# frozen_string_literal: true

module Lark
  module Demo
    # Demo 的自动部分（存于 AutoGenerated 目录），可升级
    class Automatic
      # requirements
      require_relative '../util'
      require_relative './write_entry/entry_writer'
      require_relative './setup_patch/setup_patcher'
      require_relative './update_patch/update_patcher'

      # 版本，基于版本信息进行升级
      VERSION = '0.0.1'

      # metadata 文件名
      METADATA_NAME = 'metadata.yml'

      # 自动生成的文件所在的目录名
      AUTO_DIR_NAME = 'AutoGenerated'

      # Xcode Project 中的 group name，用于存放自动生成的内容：Assembly.swift, lark_settings 等
      AUTO_GROUP_NAME = AUTO_DIR_NAME

      # gem versions
      GEM_VERSIONS = {
        'cocoapods' => '1.11.2',
        # 公司提供的 gems
        'seer-hummer-apm' => '~> 0.0.17',
        'seer-optimize' => '1.0.1.alpha.1',
        'cocoapods-remote-resolve' => '>= 0.1.2',
        # 间接依赖的、需要指定版本的 gems
        'ffi' => '1.15.5',
        'mimemagic' => '= 0.3.5',
        'xcpretty' => '0.3.1.1'
      }

      # @type name [String] 文件名|目录名
      # @type type [Symbol] :file | :directory
      Entry = Struct.new(:name, :type)

      # @type root_dir [Pathname] 根目录，AutoGenerated/ 所在目录
      # @type proj_name [String] 工程名
      # @type version [String] 版本
      attr_reader :root_dir, :proj_name, :version

      # @type [Array<Entry>]
      attr_accessor :entries

      # @type proj_name [String] 工程名
      # @type root_dir [Pathname] 根目录，AutoGenerated 所在目录
      # @type version [String] 版本
      def initialize(proj_name, root_dir, version = VERSION)
        @proj_name    = proj_name
        @root_dir     = root_dir
        @version      = version
        @entries      = []
      end

      def auto_dir
        @auto_dir ||= root_dir.join(AUTO_DIR_NAME)
      end

      def setup(**opt)
        # prepare dir
        Dir.mkdir root_dir unless root_dir.exist?
        Dir.mkdir auto_dir unless auto_dir.exist?
        # setup entries
        setup_entries
        # dump metadata
        dump_metadata
        # do patch
        SetupPatcher.new(proj, **opt).run
      end

      def update
        # remove old entries
        old = Automatic::safe_parse(root_dir)
        old&.send(:remove_all_entries) # send 调用绕过 private 限制
        # reset entries
        setup_entries
        # dump metadata
        dump_metadata
        # do patch
        UpdatePatcher.new(proj).run
      end

      # 检查是否升级，如果需要升级，返回 String；否则返回 nil
      #
      # @type root_dir [Pathname] 目录，AutoGenerated/ 所在目录
      # @return [Void]
      def self.check_update(root_dir)
        return unless old_version_str = safe_parse(root_dir)&.version

        old_version = Gem::Version.new(old_version_str)
        raw_hash = YAML.safe_load(File.read(Pathname.new(__dir__).join('resource/changelog')))
        update_versions = raw_hash.keys
                                  .map { |s| Gem::Version.new(s) }
                                  .sort
                                  .reject { |v| v <= old_version }
        return if update_versions.empty?

        prompt = ['请执行 `bundle exec lark-project demo_update` 升级 Demo 工程，将获取如下更新：']
        update_versions.each do |v|
          infos = raw_hash[v.to_s]['changed'] || []
          infos = [infos] if infos.is_a?(String)
          prompt << infos.map { |i| "  - #{i}" }
        end
        puts prompt.join"\n"
      end

      private

      def proj
        @proj ||= Xcodeproj::Project.open(@root_dir.join("#{@proj_name}.xcodeproj"))
      end

      # 生成 metadata 文件
      def dump_metadata
        File.open(auto_dir.join(METADATA_NAME), 'w') do |f|
          template = File.read(File.expand_path('./resource/metadata.yml', __dir__))
          f.write Utils.render(template, {
            :proj_name => proj_name,
            :version => VERSION,
            :entries => @entries
          })
        end
      end

      # 从目录中根据 metadata 读取构建 Automatic 对象
      #
      # @type root_dir [Pathname] 目录，AutoGenerated/ 所在目录
      def self.safe_parse(root_dir)
        begin
          parse root_dir
        rescue => e
          puts "load metadata failed, err: #{e}."
          return
        end
      end

      # 从目录中根据 metadata 读取构建 Automatic 对象
      #
      # @type root_dir [Pathname] 目录，AutoGenerated/ 所在目录
      # @return [Automatic]
      def self.parse(root_dir)
        require 'yaml'

        raise "#{root_dir} does not exist" unless root_dir.exist? && root_dir.directory?

        auto_dir = root_dir.join(AUTO_DIR_NAME)
        raise "#{auto_dir} does not exist" unless auto_dir.exist? && auto_dir.directory?

        file_name = METADATA_NAME
        file_path = auto_dir.join file_name
        raise "cannot find #{file_name} in #{auto_dir}" unless file_path.exist? && file_path.file?

        metadata_hash = YAML.safe_load(File.read(file_path))
        raise "parse #{file_name} failed" unless metadata_hash.is_a?(Hash)

        obj = Automatic.new(metadata_hash['project_name'], root_dir, metadata_hash['version'])
        # @type name [String]
        metadata_hash['entries'].each do |name|
          entry =  name.end_with?('/') ? Entry.new(name[0...-1], :directory) : Entry.new(name, :file)
          obj.entries << entry
        end
        obj
      end

      # 移除 entries
      def remove_all_entries
        require 'fileutils'

        entries.each do |entry|
          path = root_dir.join(entry.name)
          next unless path.exist?
          if entry.type == :file
            FileUtils.rm path
          else
            FileUtils.rm_rf path
          end
        end
        self.entries = []
      end

      # @param entry [Entry]
      # @param writer [Proc] call 产生 entry 内容，传入参数（target_path）
      def append_entry(entry, &writer)
        entries << entry
        writer.call auto_dir.join(entry.name)
      end

      # 生成 entries
      def setup_entries
        # @type name [String]
        new_file = lambda { |name| Entry.new(name, :file) }

        append_entry(new_file.call('BaseGemfile')) do |target_path|
          EntryWriter.write_base_gemfile(target_path, proj_name: @proj_name, gem_versions: GEM_VERSIONS)
        end
        append_entry(new_file.call('BasePodfile')) do |target_path|
          EntryWriter.write_base_podfile(target_path, proj_name: @proj_name, gem_versions: GEM_VERSIONS)
        end
        append_entry(new_file.call('changelog')) do |target_path|
          EntryWriter.write_changelog(target_path)
        end
      end
    end
  end
end
