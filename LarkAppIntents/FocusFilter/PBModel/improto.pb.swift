// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: improto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import LarkHTTP

// swiftlint:disable all

/// IM 协议报文头中cmd
public enum ServerPB_Improto_Command: LarkHTTP.Enum {
  public typealias RawValue = Int

  case ack // = 1
  case connect // = 2
  case disconnect // = 3
  case ping // = 4
  case updateUserCustomStatus // = 1103404
  case pullUserCustomStatuses // = 1103405

  public init() {
    self = .ack
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .ack
    case 2: self = .connect
    case 3: self = .disconnect
    case 4: self = .ping
    case 1_103_404: self = .updateUserCustomStatus
    case 1_103_405: self = .pullUserCustomStatuses
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .ack: return 1
    case .connect: return 2
    case .disconnect: return 3
    case .ping: return 4
    case .updateUserCustomStatus: return 1_103_404
    case .pullUserCustomStatuses: return 1_103_405
    default: break
    }

    // Can't get here, all the cases are listed in the above switches.
    // See https://github.com/apple/swift-protobuf/issues/904 for more details.
    fatalError()
  }

}

#if swift(>=4.2)

extension ServerPB_Improto_Command: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// IM 协议报文头中payload_type
public enum ServerPB_Improto_PayloadType: LarkHTTP.Enum {
  public typealias RawValue = Int
  case typeUnknown // = 0
  case pb2 // = 1
  case json // = 2

  public init() {
    self = .typeUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .typeUnknown
    case 1: self = .pb2
    case 2: self = .json
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .typeUnknown: return 0
    case .pb2: return 1
    case .json: return 2
    }
  }

}

#if swift(>=4.2)

extension ServerPB_Improto_PayloadType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct ServerPB_Improto_PipeEntity {
  // LarkHTTP.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 管子类型 user, chat, message, doc, box, calendar...
  public var type: String {
    get { return _type ?? String() }
    set { _type = newValue }
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool { return self._type != nil }
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() { self._type = nil }

  /// 管子id，chat管子对应chat_id；user类型和不识别类型不需要传id
  public var id: Int64 {
    get { return _id ?? 0 }
    set { _id = newValue }
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool { return self._id != nil }
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() { self._id = nil }

  public var unknownFields = LarkHTTP.UnknownStorage()

  public init() {}

  fileprivate var _type: String?
  fileprivate var _id: Int64?
}

/// Version Range describe a range of this format [start, end) for the semantic versioning.
/// In the version description, there are two special descriptions, -inf and +inf. Thus, a legal
/// version range may be [-inf, 1.2.13), [2.1, 3.0) or [3.4, +inf).
public struct ServerPB_Improto_VersionRange {
  // LarkHTTP.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var start: String {
    get { return _start ?? String() }
    set { _start = newValue }
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool { return self._start != nil }
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() { self._start = nil }

  public var end: String {
    get { return _end ?? String() }
    set { _end = newValue }
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool { return self._end != nil }
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() { self._end = nil }

  public var unknownFields = LarkHTTP.UnknownStorage()

  public init() {}

  fileprivate var _start: String?
  fileprivate var _end: String?
}

/// 客户端ACK的Payload
public struct ServerPB_Improto_ClientAckResponse {
  // LarkHTTP.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionType: ServerPB_Improto_ClientAckResponse.ActionType {
    get { return _actionType ?? .beforePersist }
    set { _actionType = newValue }
  }
  /// Returns true if `actionType` has been explicitly set.
  public var hasActionType: Bool { return self._actionType != nil }
  /// Clears the value of `actionType`. Subsequent reads from it will return its default value.
  public mutating func clearActionType() { self._actionType = nil }

  public var unknownFields = LarkHTTP.UnknownStorage()

  public enum ActionType: LarkHTTP.Enum {
    public typealias RawValue = Int
    case beforePersist // = 0
    case afterPersist // = 1

    public init() {
      self = .beforePersist
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .beforePersist
      case 1: self = .afterPersist
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .beforePersist: return 0
      case .afterPersist: return 1
      }
    }

  }

  public init() {}

  fileprivate var _actionType: ServerPB_Improto_ClientAckResponse.ActionType?
}

#if swift(>=4.2)

extension ServerPB_Improto_ClientAckResponse.ActionType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct ServerPB_Improto_Packet {
  // LarkHTTP.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 服务端下发（push）消息时生成的唯一包id，保证递增
  public var sid: String {
    get { return _storage._sid ?? String() }
    set { _uniqueStorage()._sid = newValue }
  }
  /// Returns true if `sid` has been explicitly set.
  public var hasSid: Bool { return _storage._sid != nil }
  /// Clears the value of `sid`. Subsequent reads from it will return its default value.
  public mutating func clearSid() { _uniqueStorage()._sid = nil }

  public var payloadType: ServerPB_Improto_PayloadType {
    get { return _storage._payloadType ?? .pb2 }
    set { _uniqueStorage()._payloadType = newValue }
  }
  /// Returns true if `payloadType` has been explicitly set.
  public var hasPayloadType: Bool { return _storage._payloadType != nil }
  /// Clears the value of `payloadType`. Subsequent reads from it will return its default value.
  public mutating func clearPayloadType() { _uniqueStorage()._payloadType = nil }

  public var cmd: ServerPB_Improto_Command {
    get { return _storage._cmd ?? .ack }
    set { _uniqueStorage()._cmd = newValue }
  }
  /// Returns true if `cmd` has been explicitly set.
  public var hasCmd: Bool { return _storage._cmd != nil }
  /// Clears the value of `cmd`. Subsequent reads from it will return its default value.
  public mutating func clearCmd() { _uniqueStorage()._cmd = nil }

  /// 仅ACK包有，表示响应状态码
  public var status: UInt32 {
    get { return _storage._status ?? 200 }
    set { _uniqueStorage()._status = newValue }
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool { return _storage._status != nil }
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() { _uniqueStorage()._status = nil }

  public var payload: Data {
    get { return _storage._payload ?? LarkHTTP.Internal.emptyData }
    set { _uniqueStorage()._payload = newValue }
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool { return _storage._payload != nil }
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() { _uniqueStorage()._payload = nil }

  /// 客户端生成的，通讯层面的，唯一包 id，用于在客户端收到服务端发送的响应包时，判断对应的请求包是哪个
  public var cid: String {
    get { return _storage._cid ?? String() }
    set { _uniqueStorage()._cid = newValue }
  }
  /// Returns true if `cid` has been explicitly set.
  public var hasCid: Bool { return _storage._cid != nil }
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  public mutating func clearCid() { _uniqueStorage()._cid = nil }

  /// 数据包所属pipe实体，只有push下发需要set，pull packet不需要set该字段
  public var pipeEntity: ServerPB_Improto_PipeEntity {
    get { return _storage._pipeEntity ?? ServerPB_Improto_PipeEntity() }
    set { _uniqueStorage()._pipeEntity = newValue }
  }
  /// Returns true if `pipeEntity` has been explicitly set.
  public var hasPipeEntity: Bool { return _storage._pipeEntity != nil }
  /// Clears the value of `pipeEntity`. Subsequent reads from it will return its default value.
  public mutating func clearPipeEntity() { _uniqueStorage()._pipeEntity = nil }

  /// 数据包可能包含的按版本划分的payloads
  public var versionPayloads: [ServerPB_Improto_Packet.VersionPayload] {
    get { return _storage._versionPayloads }
    set { _uniqueStorage()._versionPayloads = newValue }
  }

  /// pipe_entities 用于 multi pipe v2，一个 packet 可能关联多个pipe
  /// 如收到 message pipe packet，需要更新 message pipe local_sid 并联动更新 chat change list local_sid
  public var pipeEntities: [ServerPB_Improto_PipeEntity] {
    get { return _storage._pipeEntities }
    set { _uniqueStorage()._pipeEntities = newValue }
  }

  ///数据包重试等待时间，second计数
  public var waitRetryInterval: UInt32 {
    get { return _storage._waitRetryInterval ?? 0 }
    set { _uniqueStorage()._waitRetryInterval = newValue }
  }
  /// Returns true if `waitRetryInterval` has been explicitly set.
  public var hasWaitRetryInterval: Bool { return _storage._waitRetryInterval != nil }
  /// Clears the value of `waitRetryInterval`. Subsequent reads from it will return its default value.
  public mutating func clearWaitRetryInterval() { _uniqueStorage()._waitRetryInterval = nil }

  /// cmd 的 int32 表示，SDK 处理给客户端的透传 push 包时使用
  public var command: Int32 {
    get { return _storage._command ?? 0 }
    set { _uniqueStorage()._command = newValue }
  }
  /// Returns true if `command` has been explicitly set.
  public var hasCommand: Bool { return _storage._command != nil }
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  public mutating func clearCommand() { _uniqueStorage()._command = nil }

  /// 有序推送时，packet对应的cursor，保证递增。
  public var cursor: UInt64 {
    get { return _storage._cursor ?? 0 }
    set { _uniqueStorage()._cursor = newValue }
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool { return _storage._cursor != nil }
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() { _uniqueStorage()._cursor = nil }

  public var unknownFields = LarkHTTP.UnknownStorage()

  public struct VersionPayload {
    // LarkHTTP.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var versionRange: ServerPB_Improto_VersionRange {
      get { return _storage._versionRange ?? ServerPB_Improto_VersionRange() }
      set { _uniqueStorage()._versionRange = newValue }
    }
    /// Returns true if `versionRange` has been explicitly set.
    public var hasVersionRange: Bool { return _storage._versionRange != nil }
    /// Clears the value of `versionRange`. Subsequent reads from it will return its default value.
    public mutating func clearVersionRange() { _uniqueStorage()._versionRange = nil }

    public var payload: Data {
      get { return _storage._payload ?? LarkHTTP.Internal.emptyData }
      set { _uniqueStorage()._payload = newValue }
    }
    /// Returns true if `payload` has been explicitly set.
    public var hasPayload: Bool { return _storage._payload != nil }
    /// Clears the value of `payload`. Subsequent reads from it will return its default value.
    public mutating func clearPayload() { _uniqueStorage()._payload = nil }

    public var unknownFields = LarkHTTP.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "improto"

extension ServerPB_Improto_Command: LarkHTTP._ProtoNameProviding {
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .same(proto: "ACK"),
    2: .same(proto: "CONNECT"),
    3: .same(proto: "DISCONNECT"),
    4: .same(proto: "PING"),
    1_103_404: .same(proto: "UPDATE_USER_CUSTOM_STATUS"),
    1_103_405: .same(proto: "PULL_USER_CUSTOM_STATUSES"),
  ]
}

extension ServerPB_Improto_PayloadType: LarkHTTP._ProtoNameProviding {
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "PB2"),
    2: .same(proto: "JSON")
  ]
}

extension ServerPB_Improto_PipeEntity: LarkHTTP.Message, LarkHTTP._MessageImplementationBase, LarkHTTP._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PipeEntity"
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .same(proto: "type"),
    3: .same(proto: "id")
  ]

  public var isInitialized: Bool {
    if self._type == nil { return false }
    return true
  }

  public mutating func decodeMessage<D: LarkHTTP.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._type)
      case 3: try decoder.decodeSingularInt64Field(value: &self._id)
      default: break
      }
    }
  }

  public func traverse<V: LarkHTTP.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._id {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ServerPB_Improto_PipeEntity, rhs: ServerPB_Improto_PipeEntity) -> Bool {
    if lhs._type != rhs._type { return false }
    if lhs._id != rhs._id { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension ServerPB_Improto_VersionRange: LarkHTTP.Message, LarkHTTP._MessageImplementationBase, LarkHTTP._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionRange"
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end")
  ]

  public var isInitialized: Bool {
    if self._start == nil { return false }
    if self._end == nil { return false }
    return true
  }

  public mutating func decodeMessage<D: LarkHTTP.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._start)
      case 2: try decoder.decodeSingularStringField(value: &self._end)
      default: break
      }
    }
  }

  public func traverse<V: LarkHTTP.Visitor>(visitor: inout V) throws {
    if let v = self._start {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._end {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ServerPB_Improto_VersionRange, rhs: ServerPB_Improto_VersionRange) -> Bool {
    if lhs._start != rhs._start { return false }
    if lhs._end != rhs._end { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension ServerPB_Improto_ClientAckResponse: LarkHTTP.Message, LarkHTTP._MessageImplementationBase, LarkHTTP._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientAckResponse"
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .standard(proto: "action_type")
  ]

  public mutating func decodeMessage<D: LarkHTTP.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._actionType)
      default: break
      }
    }
  }

  public func traverse<V: LarkHTTP.Visitor>(visitor: inout V) throws {
    if let v = self._actionType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ServerPB_Improto_ClientAckResponse, rhs: ServerPB_Improto_ClientAckResponse) -> Bool {
    if lhs._actionType != rhs._actionType { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension ServerPB_Improto_ClientAckResponse.ActionType: LarkHTTP._ProtoNameProviding {
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    0: .same(proto: "BeforePersist"),
    1: .same(proto: "AfterPersist")
  ]
}

extension ServerPB_Improto_Packet: LarkHTTP.Message, LarkHTTP._MessageImplementationBase, LarkHTTP._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Packet"
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .same(proto: "sid"),
    2: .standard(proto: "payload_type"),
    3: .same(proto: "cmd"),
    4: .same(proto: "status"),
    5: .same(proto: "payload"),
    6: .same(proto: "cid"),
    7: .standard(proto: "pipe_entity"),
    8: .standard(proto: "version_payloads"),
    9: .standard(proto: "pipe_entities"),
    10: .standard(proto: "wait_retry_interval"),
    11: .same(proto: "command"),
    12: .same(proto: "cursor")
  ]

  fileprivate class _StorageClass {
    var _sid: String?
    var _payloadType: ServerPB_Improto_PayloadType?
    var _cmd: ServerPB_Improto_Command?
    var _status: UInt32?
    var _payload: Data?
    var _cid: String?
    var _pipeEntity: ServerPB_Improto_PipeEntity?
    var _versionPayloads: [ServerPB_Improto_Packet.VersionPayload] = []
    var _pipeEntities: [ServerPB_Improto_PipeEntity] = []
    var _waitRetryInterval: UInt32?
    var _command: Int32?
    var _cursor: UInt64?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sid = source._sid
      _payloadType = source._payloadType
      _cmd = source._cmd
      _status = source._status
      _payload = source._payload
      _cid = source._cid
      _pipeEntity = source._pipeEntity
      _versionPayloads = source._versionPayloads
      _pipeEntities = source._pipeEntities
      _waitRetryInterval = source._waitRetryInterval
      _command = source._command
      _cursor = source._cursor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._payloadType == nil { return false }
      if _storage._cmd == nil { return false }
      if let v = _storage._pipeEntity, !v.isInitialized { return false }
      if !LarkHTTP.Internal.areAllInitialized(_storage._versionPayloads) { return false }
      if !LarkHTTP.Internal.areAllInitialized(_storage._pipeEntities) { return false }
      return true
    }
  }

  public mutating func decodeMessage<D: LarkHTTP.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._sid)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._payloadType)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._cmd)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._status)
        case 5: try decoder.decodeSingularBytesField(value: &_storage._payload)
        case 6: try decoder.decodeSingularStringField(value: &_storage._cid)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._pipeEntity)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._versionPayloads)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._pipeEntities)
        case 10: try decoder.decodeSingularUInt32Field(value: &_storage._waitRetryInterval)
        case 11: try decoder.decodeSingularInt32Field(value: &_storage._command)
        case 12: try decoder.decodeSingularUInt64Field(value: &_storage._cursor)
        default: break
        }
      }
    }
  }

  public func traverse<V: LarkHTTP.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._payloadType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._cmd {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      }
      if let v = _storage._status {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._payload {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      }
      if let v = _storage._cid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._pipeEntity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._versionPayloads.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._versionPayloads, fieldNumber: 8)
      }
      if !_storage._pipeEntities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pipeEntities, fieldNumber: 9)
      }
      if let v = _storage._waitRetryInterval {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      }
      if let v = _storage._command {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._cursor {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ServerPB_Improto_Packet, rhs: ServerPB_Improto_Packet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sid != rhs_storage._sid { return false }
        if _storage._payloadType != rhs_storage._payloadType { return false }
        if _storage._cmd != rhs_storage._cmd { return false }
        if _storage._status != rhs_storage._status { return false }
        if _storage._payload != rhs_storage._payload { return false }
        if _storage._cid != rhs_storage._cid { return false }
        if _storage._pipeEntity != rhs_storage._pipeEntity { return false }
        if _storage._versionPayloads != rhs_storage._versionPayloads { return false }
        if _storage._pipeEntities != rhs_storage._pipeEntities { return false }
        if _storage._waitRetryInterval != rhs_storage._waitRetryInterval { return false }
        if _storage._command != rhs_storage._command { return false }
        if _storage._cursor != rhs_storage._cursor { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

extension ServerPB_Improto_Packet.VersionPayload: LarkHTTP.Message, LarkHTTP._MessageImplementationBase, LarkHTTP._ProtoNameProviding {
  public static let protoMessageName: String = ServerPB_Improto_Packet.protoMessageName + ".VersionPayload"
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .standard(proto: "version_range"),
    2: .same(proto: "payload")
  ]

  fileprivate class _StorageClass {
    var _versionRange: ServerPB_Improto_VersionRange?
    var _payload: Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _versionRange = source._versionRange
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._versionRange == nil { return false }
      if _storage._payload == nil { return false }
      if let v = _storage._versionRange, !v.isInitialized { return false }
      return true
    }
  }

  public mutating func decodeMessage<D: LarkHTTP.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._versionRange)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._payload)
        default: break
        }
      }
    }
  }

  public func traverse<V: LarkHTTP.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._versionRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._payload {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ServerPB_Improto_Packet.VersionPayload, rhs: ServerPB_Improto_Packet.VersionPayload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._versionRange != rhs_storage._versionRange { return false }
        if _storage._payload != rhs_storage._payload { return false }
        return true
      }
      if !storagesAreEqual { return false }
    }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}

// swiftlint:enable all
