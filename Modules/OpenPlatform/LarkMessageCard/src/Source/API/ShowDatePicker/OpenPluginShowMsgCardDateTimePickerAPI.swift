//
//  OpenPluginShowMsgCardDateTimePickerAPI.swift
//  LarkOpenApis
//
//  GENERATED BY ANYCODE on 2022/11/14 13:11:38
//

import Foundation
import LarkOpenAPIModel
import LarkOpenPluginManager
import LarkDatePickerView
import Lynx
import UniverseDesignPopover
import EENavigator
import LarkNavigator
import LarkAlertController
import CryptoKit
import LarkContainer

public enum DateType {
    case request
    case globalEvent
}

open class OpenPluginShowMsgCardDateTimePickerAPI: OpenBasePlugin {
    
    private var popover: UDPopoverTransition?
    
    enum APIName: String {
        case showMsgCardDateTimePicker
    }
    
    private func showMsgCardDateTimePicker(
        params: OpenPluginShowMsgCardDateTimePickerRequest,
        context: OpenAPIContext,
        callback: @escaping (OpenAPIBaseResponse<OpenAPIBaseResult>) -> Void) {
        context.apiTrace.info("showMsgCardDateTimePicker API call start")
        let datePickerController = DatePickerController(initialDate: params.initialDate, pickType: dateOption(pickerType: params.tag))
        datePickerController.cancel = { [weak datePickerController] in
            datePickerController?.dismiss(animated: true, completion: nil)
        }
        datePickerController.confirm = { [weak datePickerController] type, date in
            datePickerController?.dismiss(animated: true, completion: {
                guard let date = datePickerController?.currentDate else {
                    return
                }
                if let confirm = params.confirm, let title = confirm.title, let text = confirm.text {
                    let alert = LarkAlertController()
                    alert.setTitle(text: title)
                    alert.setContent(text: text)
                    alert.addSecondaryButton(text: BundleI18n.LarkMessageCard.Lark_Legacy_Cancel)
                    alert.addPrimaryButton(text: BundleI18n.LarkMessageCard.Lark_Legacy_Sure, dismissCompletion: {
                        self.doAction(context: context, params: params, date: date)
                    })
                    MsgCardAPIUtils.presentController(vc: alert, context: context)
                } else {
                    self.doAction(context: context, params: params, date: date)
                }
            })
        }
        if let lynxView = MsgCardAPIUtils.getLynxView(context: context), let datePickerView = lynxView.find(withName: params.elementID) {
            let popover = UDPopoverTransition(
                sourceView: datePickerView,
                sourceRect: MsgCardAPIUtils.sourceRectWithPadding(for: datePickerView.bounds),
                permittedArrowDirections: [.up, .down]
            )
            popover.presentStypeInCompact = .overFullScreen
            self.popover = popover
            datePickerController.transitioningDelegate = popover
        }
        datePickerController.modalPresentationStyle = .custom
        MsgCardAPIUtils.presentController(vc: datePickerController, context: context)
        callback(.success(data: nil))
        context.apiTrace.info("showMsgCardDateTimePicker API call end")
    }
    
    private func dateOption(pickerType: String?) -> DatePickerType {
        var datePickerType: DatePickerType = .onlyDate
        if pickerType == "picker_time" {
            datePickerType = .onlyeTime
        } else if pickerType == "picker_datetime" {
            datePickerType = .dateTime
        }
        return datePickerType
    }
    
    private func doAction(context: OpenAPIContext, params: OpenPluginShowMsgCardDateTimePickerRequest, date: Date) {
        context.apiTrace.info("showMsgCardDateTimePicker API: send action")
        let eventDateString = self.dateString(dateType: .globalEvent, date: date, tag: params.tag)
        var options: [String: String] = [:]
        options["timezone"] = TimeZone.current.identifier
        options["selected_option"] = self.dateString(dateType: .request, date: date, tag: params.tag)
        if let lynxView = MsgCardAPIUtils.getLynxView(context: context) {
            let dic: [String: Any] = ["elementID": params.elementID, "eventName": "ActionStart", "params": ["select_value": eventDateString]]
            lynxView.sendGlobalEvent("updateCardState", withParams: [dic])
            context.apiTrace.info("showMsgCardDateTimePicker API: send event")
        } else {
            context.apiTrace.error("showMsgCardDateTimePicker API: lynxView is nil")
        }
        if let msgContext = context.additionalInfo["msgContext"] as? MessageCardLynxContext, let bizContext = msgContext.bizContext as? MessageCardContainer.Context, let actionService = bizContext.dependency?.actionService {
            let actionContext = MessageCardActionContext(
                elementTag: params.tag,
                elementID: params.elementID,
                bizContext: msgContext.bizContext,
                actionFrom: nil
            )
            actionService.sendAction(context: actionContext, actionID: params.actionID, params: options, isMultiAction: false, updateActionState: nil, callback: nil)
        } else {
            context.apiTrace.error("showMsgCardDateTimePicker API: ActionService is nil")
        }
    }
    
    private func dateString(dateType: DateType, date: Date, tag: String) -> String {
        switch dateType {
        case .request:
            let dateFormatter = DateFormatter()
            dateFormatter.locale = Locale.current
            dateFormatter.dateFormat = "yyyy-MM-dd' 'XXXX"
            if tag == "picker_time" {
                dateFormatter.dateFormat = "HH:mm' 'XXXX"
            } else if tag == "picker_datetime" {
                dateFormatter.dateFormat = "yyyy-MM-dd HH:mm' 'XXXX"
            }
            return dateFormatter.string(from: date)
        case .globalEvent:
            let eventDateFormatter = DateFormatter()
            eventDateFormatter.locale = Locale.current
            eventDateFormatter.dateFormat = "yyyy-MM-dd"
            if tag == "picker_time" {
                eventDateFormatter.dateFormat = "HH:mm"
            } else if tag == "picker_datetime" {
                eventDateFormatter.dateFormat = "yyyy-MM-dd HH:mm"
            }
            return eventDateFormatter.string(from: date)
        }
        return ""
    }
    
    required public init(resolver: UserResolver) {
        super.init(resolver: resolver)
        registerInstanceAsyncHandler(for: APIName.showMsgCardDateTimePicker.rawValue, pluginType: Self.self, paramsType: OpenPluginShowMsgCardDateTimePickerRequest.self, resultType: OpenAPIBaseResult.self) { (this, params, context, callback) in
            
            this.showMsgCardDateTimePicker(params: params, context: context, callback: callback)
        }
    }
}
