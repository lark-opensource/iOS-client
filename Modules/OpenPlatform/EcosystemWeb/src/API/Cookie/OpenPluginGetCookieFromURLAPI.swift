//
//  OpenPluginGetCookieFromURLAPI.swift
//  LarkOpenApis
//
//  GENERATED BY ANYCODE on 2022/12/6 07:31:15
//  DO NOT MODIFY!!!
//

import Foundation
import LarkOpenAPIModel
import TTMicroApp
import LarkOpenPluginManager
import WebBrowser
import LKCommonsLogging
import LarkSetting
import LarkWebViewContainer
import LarkContainer

final class OpenPluginGetCookieFromURLAPI: OpenBasePlugin {
    //MARK: 属性
    enum APIName: String {
        case getCookieFromURL
        case removeCookieFromURL
    }
    private static let blackListDefault = [ "feishu-boe.cn",
                                     "feishu-pre.cn",
                                     "feishu.cn",
                                     "larksuite.com",
                                     "larksuite-pre.com",
                                     "larksuite-boe.com",
                                     "bytedance.com",
                                     "bytedance.net",
                                     "feishuapp.cn"]
    private var blackList: [String] {
        do {
            let config = try SettingManager.shared.setting(with: UserSettingKey.make(userKeyLiteral: "webview_cookie_manager_config"))// user:global
            if let blackList = (config["blockModifyHost"] as? [String]){
                return blackList
            }
            return Self.blackListDefault
        } catch {
            return Self.blackListDefault
        }
    }
    
    //MARK: 初始化&JSB调用
    required init(resolver: UserResolver) {
        super.init(resolver: resolver)
        registerInstanceAsyncHandler(for: APIName.getCookieFromURL.rawValue, pluginType: Self.self, paramsType: OpenPluginGetCookieFromURLRequest.self, resultType: OpenPluginGetCookieFromURLResponse.self) { (this, params, context, callback) in
            
            this.privateGetCookieFromURL(params: params, context: context, callback: callback)
        }
        
        registerInstanceAsyncHandler(for: APIName.removeCookieFromURL.rawValue, pluginType: Self.self, paramsType: OpenPluginRemoveCookieFromURLRequest.self, resultType: OpenPluginRemoveCookieFromURLResponse.self) { (this, params, context, callback) in
            
            this.privateRemoveCookieFromURL(params: params, context: context, callback: callback)
        }
    }
    
    //MARK: 搜索Cookie相关
    private func privateGetCookieFromURL(
        params: OpenPluginGetCookieFromURLRequest,
        context: OpenAPIContext,
        callback: @escaping (OpenAPIBaseResponse<OpenPluginGetCookieFromURLResponse>) -> Void) {
            context.apiTrace.info("getCookieFromURL API call start")
            p_getCookieFromURL(params: params, context: context, callback: callback)
    }
    
    public func p_getCookieFromURL(
        params: OpenPluginGetCookieFromURLRequest,
        context: OpenAPIContext,
        callback: @escaping (OpenAPIBaseResponse<OpenPluginGetCookieFromURLResponse>) -> Void) {
            guard p_checkDomainIsValid(domain: params.url) == true else {
                callback(.success(data: OpenPluginGetCookieFromURLResponse(data: [],msg: "Please check whether the domain you've entered is valid")))
                return
            }
            guard p_checkDomainIsInBlockList (domain: params.url) == false else {
                callback(.success(data: OpenPluginGetCookieFromURLResponse(data: [],msg: "You don't have the permission for the domain of \(params.url)")))
                return
            }
            
            p_searchCookieFromDomain(domain: params.url) { findItems in
                if findItems.isEmpty {
                    callback(.success(data: OpenPluginGetCookieFromURLResponse(data: [],msg: "no cookies found for the domain of \(params.url ).Please check whether the domain you've entered is right")))
                }else {
                    callback(.success(data: OpenPluginGetCookieFromURLResponse(data: findItems,msg: "success")))
                }
                context.apiTrace.info("getCookieFromURL API call end")
            }
    }

    typealias SearchResultBlock = (Array<OpenPluginGetCookieFromURLResponse.DataItem>) -> ()
    func  p_searchCookieFromDomain(domain:String, resultBlock:@escaping SearchResultBlock) {
        let searchDomain = domain
        let cookieStore = WKWebsiteDataStore.default().httpCookieStore
        
        cookieStore.getAllCookies { (cookies) in
            var findCookies = cookies.filter { (cookie)->Bool in
                let domain = cookie.domain
                return (domain == searchDomain || searchDomain.hasSuffix(domain) || domain.contains(searchDomain))
            }
            var result = findCookies.flatMap { cookie in
                let value = self.p_cookie_value_mask(value:cookie.value)
                var expire = ""
                if let date = cookie.expiresDate {
                    expire = self.p_dateToStr(date: date)
                }
                let dataItem = OpenPluginGetCookieFromURLResponse.DataItem.init(key: cookie.name, value: value, domain: cookie.domain, expires: expire, maxAge: nil, path: cookie.path, secure: cookie.isSecure as? String, httpOnly: cookie.isHTTPOnly as? String, sameSite: nil)
                return dataItem
            }
            resultBlock(result)
        }
    }
    
    //MARK: 删除cookie相关
    private func privateRemoveCookieFromURL(
        params: OpenPluginRemoveCookieFromURLRequest,
        context: OpenAPIContext,
        callback: @escaping (OpenAPIBaseResponse<OpenPluginRemoveCookieFromURLResponse>) -> Void) {
            context.apiTrace.info("removeCookieFromURL API call start")
            p_removeCookieFromURL(params: params, context: context, callback: callback)
            context.apiTrace.info("removeCookieFromURL API call end")
    }
    
    public func p_removeCookieFromURL(
        params: OpenPluginRemoveCookieFromURLRequest,
        context: OpenAPIContext,
        callback: @escaping (OpenAPIBaseResponse<OpenPluginRemoveCookieFromURLResponse>) -> Void) {
            guard let browser = context.controller as? WebBrowser else {
                let errorMsg = "apiContext.controller is not WebBrowser when call getWebDetectNetStatus api"
                let error = OpenAPIError(errno: OpenAPICommonErrno.internalError)
                    .setMonitorMessage(errorMsg)
                context.apiTrace.error(errorMsg)
                callback(.failure(error: error))
                return
            }
            guard p_checkDomainIsValid(domain: params.url) == true else {
                callback(.success(data: OpenPluginRemoveCookieFromURLResponse(msg: "Please check whether the domain you've entered is valid")))
                return
            }
            guard p_checkDomainIsInBlockList (domain: params.url) == false else {
                callback(.success(data: OpenPluginRemoveCookieFromURLResponse(msg: "You don't have the permission for the domain of \(params.url)")))
                return
            }
            p_core_removeCookieFromDomain(domain: params.url, callback: callback)
    }
    
    func  p_core_removeCookieFromDomain(domain:String, callback:@escaping (OpenAPIBaseResponse<OpenPluginRemoveCookieFromURLResponse>) -> Void) {
        let searchDomain = domain
        let httpCookieStore = WKWebsiteDataStore.default().httpCookieStore
        var hasDeleted = false
        httpCookieStore.getAllCookies { (cookies) in
            for cookie:HTTPCookie in cookies {
                let domain = cookie.domain
                if (domain == searchDomain) {
                    httpCookieStore.delete(cookie)
                    hasDeleted = true
                }
            }
            if (hasDeleted) {
                callback(.success(data: OpenPluginRemoveCookieFromURLResponse(msg: "success")))
            }else{
                callback(.success(data: OpenPluginRemoveCookieFromURLResponse(msg: "no cookies deleted.Please check whether the domain you've entered is right")))
            }
        }
    }
    
    //MARK: 其他私有方法
    func p_checkDomainIsValid(domain:String) -> Bool {
        let array = domain.split(separator: ".")
        if (array.count < 2) {
            return false
        }
        return true
    }
    
    func p_checkDomainIsInBlockList(domain:String) -> Bool {
        let array = self.blackList
        if (!self.blackList.isEmpty) {
            for unit in self.blackList {
                if (unit.contains(domain) || domain.contains(unit)) {
                    return true
                }
            }
        }
        return false
    }
    
    func p_dateToStr(date:Date) -> String {
        let date = Date()
        let df = DateFormatter.init()
        df.dateFormat = "yyyy-MM-dd HH:mm:ss"
        let dateStr = df.string(from: date)
        return dateStr
    }
    
    func p_cookie_value_mask(value:String) -> String {
        if value.isEmpty {
              return ""
          } else if value.count == 1 {
              return "*"
          } else if value.count == 2 {
              return "**"
          } else if value.count == 3 {
              let prefixIndex = String.Index(utf16Offset:1, in:value)
              let suffixIndex = String.Index(utf16Offset:2, in:value)
              let maskRange = prefixIndex ..< suffixIndex
              return value.replacingCharacters(in: maskRange, with: "*")
          } else {
              let padding = Int(floor(Double(value.count / 4)))
              let length = value.count - padding * 2
              let toIndex = String.Index(utf16Offset:padding, in:value)
              let fromIndex = String.Index(utf16Offset:padding+length, in:value)
              return String(value[..<toIndex]) + "***" + String(value[fromIndex...])
          }
      }
}
