//
//  OpenPluginDeviceJsReadContentAPI.swift
//  LarkOpenApis
//
//  GENERATED BY ANYCODE on 2023/11/7 12:19:10
//

import Foundation
import LarkOpenAPIModel
import TTMicroApp
import LarkOpenPluginManager
import LarkContainer
import WebBrowser
import ServerPB
import RxSwift
import LarkRustClient
import LKCommonsLogging

// MARK: - OpenPluginDeviceJsReadContentAPI
final class OpenPluginDeviceJsReadContentAPI: OpenBasePlugin {
    
    static let logger = Logger.ecosystemWebLog(OpenPluginDeviceJsReadContentAPI.self, category: "OpenPluginDeviceJsReadContentAPI")
    
    private let disposeBag = DisposeBag()
    
    //MARK: 初始化&JSB调用
    required init(resolver: UserResolver) {
        super.init(resolver: resolver)
        registerInstanceAsyncHandlerGadget(for: "device.js.read.content", pluginType: Self.self, paramsType: OpenPluginDeviceJsReadContentRequest.self, resultType: OpenAPIBaseResult.self) { (this, params, context, gadgetContext, callback) in
            context.apiTrace.info("device.js.read.content API call start")
            Self.logger.info("[Web MyAI ChatMode] [WebContent] getWebContent API call start")
            this.afterDeviceJsReadContent(params: params, context: context, gadgetContext: gadgetContext)
            context.apiTrace.info("device.js.read.content API call end")
            Self.logger.info("[Web MyAI ChatMode] [WebContent] getWebContent API call end")
            callback(.success(data: nil))
        }
    }
    
    func afterDeviceJsReadContent(
        params: OpenPluginDeviceJsReadContentRequest,
        context: OpenAPIContext,
        gadgetContext: GadgetAPIContext) {
            guard let browser = context.controller as? WebBrowser else {
                let errMessage = "[Web MyAI ChatMode] [WebContent] (online script) browser is nil"
                context.apiTrace.error(errMessage)
                Self.logger.error(errMessage)
                return
            }
            if let errString = params.error {
                // 读取 errString 只是为了记录执行 JS 脚本本身的报错
                // JS中会用空字符串兜底content，服务端需要上报空字符串来触发AI的失败回复
                let errMessage = "[Web MyAI ChatMode] [WebContent] (online script) getWebContent execute error \(String(describing: errString))"
                context.apiTrace.error(errMessage)
                Self.logger.error(errMessage)
            }
            guard let content = params.content else {
                let errMessage = "[Web MyAI ChatMode] [WebContent] (online script) getWebContent is nil"
                context.apiTrace.error(errMessage)
                Self.logger.info(errMessage)
                return
            }
            guard let url = params.url else {
                let errMessage = "[Web MyAI ChatMode] [WebContent] (online script) url is nil"
                context.apiTrace.error(errMessage)
                Self.logger.info(errMessage)
                return
            }
            #if DEBUG
            Self.logger.info("[Web MyAI ChatMode] [WebContent] (online script) getWebContent \(content)")
            #else
            Self.logger.info("[Web MyAI ChatMode] [WebContent] (online script) getWebContent length \(content.count)")
            #endif
            // 获得结果，发送给服务端
            browser.sendWebContentAsync(with: content, of: url,
                onSuccess: {Self.logger.info("[Web MyAI ChatMode] [WebContent] (online script) sendWebContentAsync success")},
                onError: {Self.logger.error("[Web MyAI ChatMode] [WebContent] (online script) sendWebContentAsync fail")})
        }
}
