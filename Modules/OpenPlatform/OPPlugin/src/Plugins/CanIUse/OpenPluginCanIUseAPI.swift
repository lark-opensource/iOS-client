//
//  OpenPluginCanIUseAPI.swift
//  LarkOpenApis
//
//  GENERATED BY ANYCODE on 2022/12/1 11:18:23
//  DO NOT MODIFY!!!
//

import Foundation
import LarkOpenAPIModel
import OPPluginManagerAdapter
import LarkOpenPluginManager
import LarkWebviewNativeComponent
import TTMicroApp
import LarkSetting
import LarkContainer

// MARK: - 
final class OpenPluginCanIUseAPI: OpenBasePlugin {
    
    enum APIName: String {
        case canIUse
    }
    
    enum CanIUseSchemaType: String {
        case isRenderInSameLayer
        case getVideoInfo
        
        func handler(resolver: UserResolver) -> CanIUseSchemaHandler{
            switch self {
            case .isRenderInSameLayer:
                return RenderInSameLayerSchmeaHandler()
            case .getVideoInfo:
                return GetVideoInfoSchmeaHandler(resolver: resolver)
            }
        }
    }
    
    
    func canIUse(
        params: OpenPluginCanIUseRequest,
        context: OpenAPIContext,
        gadgetContext: GadgetAPIContext) -> OpenAPIBaseResponse<OpenPluginCanIUseResponse> {
            let array = params.schema.split(separator: ".").map{String($0)}
            guard array.count > 1, let first = array.first, let schemaType = CanIUseSchemaType(rawValue: first) else {
                context.apiTrace.error("schema is not correct, \(params.schema)")
                return .success(data: .init(data: false))
            }
            let result = schemaType.handler(resolver: userResolver).handleSchema(schemaSplitArray: array, context: context, gadgetContext: gadgetContext)
            return .success(data: .init(data: result))
    }
    
    required init(resolver: UserResolver) {
        super.init(resolver: resolver)
        registerInstanceSyncHandlerGadget(for: APIName.canIUse.rawValue, pluginType: Self.self, paramsType: OpenPluginCanIUseRequest.self, resultType: OpenPluginCanIUseResponse.self) { (this, params, context, gadgetContext) -> OpenAPIBaseResponse<OpenPluginCanIUseResponse> in
            
            return this.canIUse(params: params, context: context, gadgetContext: gadgetContext)
        }
    }
}

protocol CanIUseSchemaHandler {
    func handleSchema(schemaSplitArray: [String], context: OpenAPIContext, gadgetContext: GadgetAPIContext) -> Bool
}

private final class RenderInSameLayerSchmeaHandler: CanIUseSchemaHandler {
    private static let isRenderInSameLayer = "isRenderInSameLayer"
    private static let supportRenderTypes = "supportRenderTypes"
    
    private enum Components: String, CaseIterable {
        case input
        case textarea
        case video
        case map
        case camera
    }
    
    private enum NotSameLayerType: String, CaseIterable {
        case legacy
        case native_component_overlay
        case disable
    }
    
    typealias ConfigType = [String: [String: [String: [String]]]]
    private var config: ConfigType?
    
    func handleSchema(schemaSplitArray: [String], context: OpenAPIContext, gadgetContext: GadgetAPIContext) -> Bool {
        guard let first = schemaSplitArray.first, first == Self.isRenderInSameLayer,
              let last = schemaSplitArray.last,
              let type = Components(rawValue: String(last)) else {
            context.apiTrace.error("RenderInSameLayerSchmeaHandler schema is not correct, \(schemaSplitArray)")
            return false
        }
        
        var config: ConfigType
        if let tmpConfig = self.config {
            config = tmpConfig
        } else if let task = BDPTaskManager.shared().getTaskWith(gadgetContext.uniqueID),
                  let componentConfigManager = task.componentConfigManager,
                  let tmpConfig = componentConfigManager.configMap as? ConfigType {
            config = tmpConfig
            self.config = tmpConfig
        } else {
            context.apiTrace.error("cannot find config with appID: \(gadgetContext.uniqueID.appID)")
            return false
        }
        
        guard let result = config["components"]?[type.rawValue]?[Self.supportRenderTypes] as? [String] else {
            context.apiTrace.error("cannot find config with type: \(type.rawValue), config: \(config)")
            return false
        }
        
        if result.contains(where: { element in  NotSameLayerType(rawValue: element) != nil }) {
            return false
        } else {
            return true
        }
    }
    
}

private final class GetVideoInfoSchmeaHandler: CanIUseSchemaHandler {
    
    private let userResolver: UserResolver
        
    init(resolver: UserResolver) {
        userResolver = resolver
    }
    
    func handleSchema(schemaSplitArray: [String], context: OpenAPIContext, gadgetContext: GadgetAPIContext) -> Bool {
        guard let last = schemaSplitArray.last else {
            context.apiTrace.error("GetVideoInfoSchmeaHandler schema is not correct, \(schemaSplitArray)")
            return false
        }
        if last == "isSupportNetworkURL" {
            //settings获取值
            if let uniqueID = context.uniqueID {
                return isSupportNetworkURL(uniqueId: uniqueID)
            }else {
                context.apiTrace.error("GetVideoInfoSchmeaHandler uniqueID is nil")
            }
        }
        return false
    }
    
    /// settings配置xx appID是否开启getVideoInfo支持网络url
     func isSupportNetworkURL(uniqueId: OPAppUniqueID) -> Bool {
        do {
            let config: [String: Any] = try userResolver.settings.setting(with: UserSettingKey.make(userKeyLiteral: "getVideoInfoSupportNetworkURL"))
            if let all = config["all"] as? Bool , all == true {
                return true
            }
            let appID = uniqueId.appID
            if let appIds = config["appIds"] as? [String], appIds.contains(appID) {
                return true
            }
            return false
        } catch {
            return false
        }
    }
    
}
