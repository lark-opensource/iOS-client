//
//  OpenPluginGetFilterFeatureGatingAPI.swift
//  LarkOpenApis
//
//  GENERATED BY ANYCODE on 2023/11/2 03:08:56
//

import Foundation
import LarkOpenAPIModel
import TTMicroApp
import LarkOpenPluginManager
import LarkSetting
import WebBrowser
import LarkContainer

// MARK: - OpenPluginGetFilterFeatureGatingAPI
final class OpenPluginGetFilterFeatureGatingAPI: OpenBasePlugin {

    @LazyRawSetting(key: UserSettingKey.make(userKeyLiteral: "use_new_network_api")) private var useNewNetworkAPISetting: [String: Any]?
    
    enum CalculateFGName: String {
        case downloadH5 = "calculated_fg_web_download_h5"
        case uploadH5 = "calculated_fg_web_upload_h5"
    }
    
    func getFilterFeatureGating(
        params: OpenPluginGetFilterFeatureGatingRequest,
        context: OpenAPIContext,
        getFilterExtension: OpenAPIGetFilterFGExtension,
        callback: @escaping (OpenAPIBaseResponse<OpenPluginGetFilterFeatureGatingResponse>) -> Void) {
            if let calculateFG: CalculateFGName = CalculateFGName.init(rawValue: params.fg_name) {
                self.handleCalculateFG(calculateFG: calculateFG, appId: getFilterExtension.appId(), context: context, callback: callback)
            } else {
                let error = OpenAPIError(errno: OpenAPICommonErrno.invalidParam(InvalidParamType.invalidParam(param: params.fg_name))).setMonitorMessage("fg_name is invalid")
                callback(.failure(error: error))
            }
    }
    

    func handleCalculateFG(calculateFG: CalculateFGName, appId: String?, context: OpenAPIContext, callback: @escaping (OpenAPIBaseResponse<OpenPluginGetFilterFeatureGatingResponse>) -> Void) {
        switch calculateFG {
        case .uploadH5, .downloadH5:
            callback(.success(data: OpenPluginGetFilterFeatureGatingResponse(fg_value: self.calculateH5Enable(calculateFG: calculateFG, appId: appId, context: context))))
        }
    }
    
    private func calculateH5Enable(calculateFG: CalculateFGName, appId: String?, context: OpenAPIContext) -> Bool {
        guard let appId = appId else {
            context.apiTrace.info("getFilterFeatureGating: appId is nil")
            return false
        }
        var key = "uploadH5"
        if calculateFG == .downloadH5 {
            key = "downloadH5"
        }
        context.apiTrace.info("getFilterFeatureGating API call,key:\(key)")
        guard let networkDic = self.useNewNetworkAPISetting?[key] as? [AnyHashable: Any] else {
            context.apiTrace.info("getFilterFeatureGating API:useNewNetworkAPISetting key is not find")
            return false
        }
        if let result = networkDic["forceDisable"] as? Bool, result == true {
            context.apiTrace.info("getFilterFeatureGating API: forceDisable is true")
            return false
        }
        if let result = networkDic[appId] as? Bool {
            context.apiTrace.info("getFilterFeatureGating API: appId :\(appId), result:\(result)")
            return result
        }
        if let result = networkDic["default"] as? Bool {
            context.apiTrace.info("getFilterFeatureGating API: appId :\(appId), default:\(result)")
            return result
        }
        return false
    }
    
    required init(resolver: UserResolver) {
        super.init(resolver: resolver)
        registerAsync(for: "getFilterFeatureGating", registerInfo: .init(pluginType: Self.self), extensionInfo: .init(type: OpenAPIGetFilterFGExtension.self, defaultCanBeUsed: false)) {
            Self.getFilterFeatureGating($0)
        }
    }
}
