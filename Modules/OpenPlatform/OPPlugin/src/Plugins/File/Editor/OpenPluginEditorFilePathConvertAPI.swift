//
//  OpenPluginEditorFilePathConvertAPI.swift
//  LarkOpenApis
//
//  GENERATED BY ANYCODE on 2023/6/27 08:35:09
//

import Foundation
import LarkOpenAPIModel
import OPPluginManagerAdapter
import LarkOpenPluginManager
import LarkStorage
import OPFoundation
import LarkContainer

// MARK: - OpenPluginEditorFilePathConvertAPI
final class OpenPluginEditorFilePathConvertAPI: OpenBasePlugin {
    
    enum APIName: String {
        case editorFilePathConvert
    }
    
    // 只有小程序可用
    func editorFilePathConvert(
        params: OpenPluginEditorFilePathConvertRequest,
        context: OpenAPIContext,
        gadgetContext: GadgetAPIContext,
        callback: @escaping (OpenAPIBaseResponse<OpenPluginEditorFilePathConvertResponse>) -> Void)
    {
        let common = BDPCommonManager.shared().getCommonWith(gadgetContext.uniqueID)
        
        let imageFiles: [OpenPluginEditorFilePathConvertResponse.ImagesItem] = params.images.mapToImages().compactMap { pickImage in
            // limitSize 要大一点
            guard let imageData = EditorImageUtil.dataForImage(pickImage, quality: 1, limitSize: UInt.max) else {
                return nil
            }
            // Destination AbsPath
            let fileExtension = TMACustomHelper.contentType(forImageData: imageData)
            
            let fileObj = FileObject.generateRandomTTFile(type: .temp, fileExtension: fileExtension)
            let fsContext = FileSystem.Context(uniqueId: gadgetContext.uniqueID, trace: context.apiTrace, tag: APIName.editorFilePathConvert.rawValue)
            do {
                try FileSystemCompatible.writeSystemData(imageData, to: fileObj, context: fsContext)
                return OpenPluginEditorFilePathConvertResponse.ImagesItem(
                    filePath: fileObj.rawValue,
                    width: (pickImage.image.size.width * pickImage.image.scale) / UIScreen.main.scale,
                    height: (pickImage.image.size.height * pickImage.image.scale) / UIScreen.main.scale)
            } catch let error {
                fsContext.trace.error("write systemData failed, error: \(error)")
                return nil
            }
        }
        callback(.success(data: .init(images: imageFiles)))
    }
    
    required init(resolver: UserResolver) {
        super.init(resolver: resolver)
        registerInstanceAsyncHandlerGadget(
            for: APIName.editorFilePathConvert.rawValue,
            pluginType: Self.self,
            paramsType: OpenPluginEditorFilePathConvertRequest.self,
            resultType: OpenPluginEditorFilePathConvertResponse.self) { (this, params, context, gadgetContext, callback) in
            context.apiTrace.info("\(APIName.editorFilePathConvert.rawValue) API call start")
            this.editorFilePathConvert(params: params, context: context, gadgetContext: gadgetContext, callback: callback)
            context.apiTrace.info("\(APIName.editorFilePathConvert.rawValue) API call end")
        }
    }
}

extension Array where Element == String {
    func mapToImages() -> [EditorPickImage] {
        return self.compactMap { urlString in
            if let url = URL(string: urlString),
               let data = try? NSData.lssSmartRead(from: url),
               let result = UIImage(data: data as Data) {
                return EditorPickImage(image: result, data: nil)
            }
            return nil
        }
    }
}
