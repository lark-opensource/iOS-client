//
//  RustService.generate.swift
//  LarkRustClient
//
//  Created by SolaWing on 2022/9/20.
//
// *** GENERATED BY ERB, DON'T MODIFY THIS FILE DIRECTLY ***
// erb -T- % > %:r

// swiftlint:disable all
import Foundation
import SwiftProtobuf
import RustPB
import ServerPB
import RxSwift
<%
$type = %w[Server Rust]
$option = [false, true]
class << self
  attr_accessor :cmd # %w[Server Rust]
  attr_accessor :doPacket # if packet to provide context info
  attr_accessor :msg # prefer msg than data
  def each
    $type.product($option, $option) do |v|
      @cmd, @doPacket, @msg = *v
      yield v
    end
  end
  def each_msg
    $type.product($option) do |v|
      @cmd, @doPacket, @msg = *v, true
      yield v
    end
  end

  def cmd_tip
    cmd == "Rust" ? "pushCmd" : "serverPushCmd"
  end
  def cmd_type
    cmd == "Rust" ? "Command" : "ServerCommand"
  end
  def body_type
    msg ? "R" : "Data"
  end
  def response_type
    doPacket ? "#{cmd}PushPacket<#{body_type}>" : body_type
  end
end
-%>

extension RustService {
    // MARK: Non Cancel Handler API
% each do

    /// Register <%= cmd %> push hander for specified cmd
    /// NOTE: if dispose not on the same queue of handler, will not cancel push immediately.
    ///
    /// - Parameter <%= cmd_tip %>: the cmd wait to observe
    /// - Returns: a Disposable which can use to cancel push.
    public func register<%= "<R: Message>" if msg %>(<%= cmd_tip %> cmd: <%= cmd_type %>, handler: @escaping (<%= response_type %>) -> Void) -> Disposable {
        register(<%= cmd_tip %>: cmd, onCancel: nil, handler: handler)
    }
% end

    // MARK: RxSwift Observable API
% each_msg do

    /// Get <%= cmd %> push observable for specified cmd. this observable can cancel
    /// - Parameter <%= cmd_tip %>: the cmd wait to observe
    /// - Returns: a Observable to get message or dispose to cancel push
    public func register<R: SwiftProtobuf.Message>(<%= cmd_tip %> cmd: <%= cmd_type %>) -> Observable<<%= response_type %>> {
        return Observable.create { (observer) -> Disposable in
            return self.register(
                <%= cmd_tip %>: cmd,
                onCancel: { observer.on(.error(RCError.cancel)) },
                handler: { observer.on(.next($0)) })
        }
    }
% end
}

extension PushHandlerType {
% each do

    static public func register<%= "<R: Message>" if msg %>(on service: RustService, cmd: <%= cmd_type %>, factory: @escaping () throws -> Self) -> Disposable where PushType == <%= response_type %> {
        var cache: Self?
        return service.register(<%= cmd_tip %>: cmd) { (data: PushType) in
            if let handler = make(factory: factory, store: &cache) {
                handler.process(data)
            }
        }
    }
% end
}

#if Client
extension SimpleRustClient {
    // MARK: Core Register Handler API
% each do
    public func register<%= "<R: Message>" if msg %>(<%= cmd_tip %> cmd: <%= cmd_type %>, onCancel: (() -> Void)?, handler: @escaping (<%= response_type %>) -> Void) -> Disposable {
        register(<%= cmd_tip %>: cmd, onCancel: onCancel, onSerial: Self.onSerial(packet:cache:), onHandle: handler)
    }
% end

    // MARK: serial function
    static func onSerial<T>(packet: T, cache: RustManager.Cache) throws -> (T, String) { (packet, "Data With Packet") } // server packet or rust packet, return directly
% each do
%  next if doPacket && !msg # packet and data not need to modify, return directly
    static func onSerial<%= "<R: Message>" if msg %>(packet: <%= cmd %>PushPacket<Data>, cache: RustManager.Cache) throws -> (<%= response_type %>, String) {
% if msg
%  if doPacket
        let new = try packet.map { try cache.onSerial(data: $0.body) as R }
        return (new, "\(R.protoMessageName) With Packet")
%  else
        let msg: R = try cache.onSerial(data: packet.body)
        return (msg, R.protoMessageName)
%  end
% else
        (packet.body, "Data")
% end
    }
% end
}
#endif
