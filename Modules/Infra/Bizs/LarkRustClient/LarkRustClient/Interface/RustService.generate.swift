//
//  RustService.generate.swift
//  LarkRustClient
//
//  Created by SolaWing on 2022/9/20.
//
// *** GENERATED BY ERB, DON'T MODIFY THIS FILE DIRECTLY ***
// erb -T- % > %:r

// swiftlint:disable all
import Foundation
import SwiftProtobuf
import RustPB
import ServerPB
import RxSwift

extension RustService {
    // MARK: Non Cancel Handler API

    /// Register Server push hander for specified cmd
    /// NOTE: if dispose not on the same queue of handler, will not cancel push immediately.
    ///
    /// - Parameter serverPushCmd: the cmd wait to observe
    /// - Returns: a Disposable which can use to cancel push.
    public func register(serverPushCmd cmd: ServerCommand, handler: @escaping (Data) -> Void) -> Disposable {
        register(serverPushCmd: cmd, onCancel: nil, handler: handler)
    }

    /// Register Server push hander for specified cmd
    /// NOTE: if dispose not on the same queue of handler, will not cancel push immediately.
    ///
    /// - Parameter serverPushCmd: the cmd wait to observe
    /// - Returns: a Disposable which can use to cancel push.
    public func register<R: Message>(serverPushCmd cmd: ServerCommand, handler: @escaping (R) -> Void) -> Disposable {
        register(serverPushCmd: cmd, onCancel: nil, handler: handler)
    }

    /// Register Server push hander for specified cmd
    /// NOTE: if dispose not on the same queue of handler, will not cancel push immediately.
    ///
    /// - Parameter serverPushCmd: the cmd wait to observe
    /// - Returns: a Disposable which can use to cancel push.
    public func register(serverPushCmd cmd: ServerCommand, handler: @escaping (ServerPushPacket<Data>) -> Void) -> Disposable {
        register(serverPushCmd: cmd, onCancel: nil, handler: handler)
    }

    /// Register Server push hander for specified cmd
    /// NOTE: if dispose not on the same queue of handler, will not cancel push immediately.
    ///
    /// - Parameter serverPushCmd: the cmd wait to observe
    /// - Returns: a Disposable which can use to cancel push.
    public func register<R: Message>(serverPushCmd cmd: ServerCommand, handler: @escaping (ServerPushPacket<R>) -> Void) -> Disposable {
        register(serverPushCmd: cmd, onCancel: nil, handler: handler)
    }

    /// Register Rust push hander for specified cmd
    /// NOTE: if dispose not on the same queue of handler, will not cancel push immediately.
    ///
    /// - Parameter pushCmd: the cmd wait to observe
    /// - Returns: a Disposable which can use to cancel push.
    public func register(pushCmd cmd: Command, handler: @escaping (Data) -> Void) -> Disposable {
        register(pushCmd: cmd, onCancel: nil, handler: handler)
    }

    /// Register Rust push hander for specified cmd
    /// NOTE: if dispose not on the same queue of handler, will not cancel push immediately.
    ///
    /// - Parameter pushCmd: the cmd wait to observe
    /// - Returns: a Disposable which can use to cancel push.
    public func register<R: Message>(pushCmd cmd: Command, handler: @escaping (R) -> Void) -> Disposable {
        register(pushCmd: cmd, onCancel: nil, handler: handler)
    }

    /// Register Rust push hander for specified cmd
    /// NOTE: if dispose not on the same queue of handler, will not cancel push immediately.
    ///
    /// - Parameter pushCmd: the cmd wait to observe
    /// - Returns: a Disposable which can use to cancel push.
    public func register(pushCmd cmd: Command, handler: @escaping (RustPushPacket<Data>) -> Void) -> Disposable {
        register(pushCmd: cmd, onCancel: nil, handler: handler)
    }

    /// Register Rust push hander for specified cmd
    /// NOTE: if dispose not on the same queue of handler, will not cancel push immediately.
    ///
    /// - Parameter pushCmd: the cmd wait to observe
    /// - Returns: a Disposable which can use to cancel push.
    public func register<R: Message>(pushCmd cmd: Command, handler: @escaping (RustPushPacket<R>) -> Void) -> Disposable {
        register(pushCmd: cmd, onCancel: nil, handler: handler)
    }

    // MARK: RxSwift Observable API

    /// Get Server push observable for specified cmd. this observable can cancel
    /// - Parameter serverPushCmd: the cmd wait to observe
    /// - Returns: a Observable to get message or dispose to cancel push
    public func register<R: SwiftProtobuf.Message>(serverPushCmd cmd: ServerCommand) -> Observable<R> {
        return Observable.create { (observer) -> Disposable in
            return self.register(
                serverPushCmd: cmd,
                onCancel: { observer.on(.error(RCError.cancel)) },
                handler: { observer.on(.next($0)) })
        }
    }

    /// Get Server push observable for specified cmd. this observable can cancel
    /// - Parameter serverPushCmd: the cmd wait to observe
    /// - Returns: a Observable to get message or dispose to cancel push
    public func register<R: SwiftProtobuf.Message>(serverPushCmd cmd: ServerCommand) -> Observable<ServerPushPacket<R>> {
        return Observable.create { (observer) -> Disposable in
            return self.register(
                serverPushCmd: cmd,
                onCancel: { observer.on(.error(RCError.cancel)) },
                handler: { observer.on(.next($0)) })
        }
    }

    /// Get Rust push observable for specified cmd. this observable can cancel
    /// - Parameter pushCmd: the cmd wait to observe
    /// - Returns: a Observable to get message or dispose to cancel push
    public func register<R: SwiftProtobuf.Message>(pushCmd cmd: Command) -> Observable<R> {
        return Observable.create { (observer) -> Disposable in
            return self.register(
                pushCmd: cmd,
                onCancel: { observer.on(.error(RCError.cancel)) },
                handler: { observer.on(.next($0)) })
        }
    }

    /// Get Rust push observable for specified cmd. this observable can cancel
    /// - Parameter pushCmd: the cmd wait to observe
    /// - Returns: a Observable to get message or dispose to cancel push
    public func register<R: SwiftProtobuf.Message>(pushCmd cmd: Command) -> Observable<RustPushPacket<R>> {
        return Observable.create { (observer) -> Disposable in
            return self.register(
                pushCmd: cmd,
                onCancel: { observer.on(.error(RCError.cancel)) },
                handler: { observer.on(.next($0)) })
        }
    }
}

extension PushHandlerType {

    static public func register(on service: RustService, cmd: ServerCommand, factory: @escaping () throws -> Self) -> Disposable where PushType == Data {
        var cache: Self?
        return service.register(serverPushCmd: cmd) { (data: PushType) in
            if let handler = make(factory: factory, store: &cache) {
                handler.process(data)
            }
        }
    }

    static public func register<R: Message>(on service: RustService, cmd: ServerCommand, factory: @escaping () throws -> Self) -> Disposable where PushType == R {
        var cache: Self?
        return service.register(serverPushCmd: cmd) { (data: PushType) in
            if let handler = make(factory: factory, store: &cache) {
                handler.process(data)
            }
        }
    }

    static public func register(on service: RustService, cmd: ServerCommand, factory: @escaping () throws -> Self) -> Disposable where PushType == ServerPushPacket<Data> {
        var cache: Self?
        return service.register(serverPushCmd: cmd) { (data: PushType) in
            if let handler = make(factory: factory, store: &cache) {
                handler.process(data)
            }
        }
    }

    static public func register<R: Message>(on service: RustService, cmd: ServerCommand, factory: @escaping () throws -> Self) -> Disposable where PushType == ServerPushPacket<R> {
        var cache: Self?
        return service.register(serverPushCmd: cmd) { (data: PushType) in
            if let handler = make(factory: factory, store: &cache) {
                handler.process(data)
            }
        }
    }

    static public func register(on service: RustService, cmd: Command, factory: @escaping () throws -> Self) -> Disposable where PushType == Data {
        var cache: Self?
        return service.register(pushCmd: cmd) { (data: PushType) in
            if let handler = make(factory: factory, store: &cache) {
                handler.process(data)
            }
        }
    }

    static public func register<R: Message>(on service: RustService, cmd: Command, factory: @escaping () throws -> Self) -> Disposable where PushType == R {
        var cache: Self?
        return service.register(pushCmd: cmd) { (data: PushType) in
            if let handler = make(factory: factory, store: &cache) {
                handler.process(data)
            }
        }
    }

    static public func register(on service: RustService, cmd: Command, factory: @escaping () throws -> Self) -> Disposable where PushType == RustPushPacket<Data> {
        var cache: Self?
        return service.register(pushCmd: cmd) { (data: PushType) in
            if let handler = make(factory: factory, store: &cache) {
                handler.process(data)
            }
        }
    }

    static public func register<R: Message>(on service: RustService, cmd: Command, factory: @escaping () throws -> Self) -> Disposable where PushType == RustPushPacket<R> {
        var cache: Self?
        return service.register(pushCmd: cmd) { (data: PushType) in
            if let handler = make(factory: factory, store: &cache) {
                handler.process(data)
            }
        }
    }
}

#if Client
extension SimpleRustClient {
    // MARK: Core Register Handler API
    public func register(serverPushCmd cmd: ServerCommand, onCancel: (() -> Void)?, handler: @escaping (Data) -> Void) -> Disposable {
        register(serverPushCmd: cmd, onCancel: onCancel, onSerial: Self.onSerial(packet:cache:), onHandle: handler)
    }
    public func register<R: Message>(serverPushCmd cmd: ServerCommand, onCancel: (() -> Void)?, handler: @escaping (R) -> Void) -> Disposable {
        register(serverPushCmd: cmd, onCancel: onCancel, onSerial: Self.onSerial(packet:cache:), onHandle: handler)
    }
    public func register(serverPushCmd cmd: ServerCommand, onCancel: (() -> Void)?, handler: @escaping (ServerPushPacket<Data>) -> Void) -> Disposable {
        register(serverPushCmd: cmd, onCancel: onCancel, onSerial: Self.onSerial(packet:cache:), onHandle: handler)
    }
    public func register<R: Message>(serverPushCmd cmd: ServerCommand, onCancel: (() -> Void)?, handler: @escaping (ServerPushPacket<R>) -> Void) -> Disposable {
        register(serverPushCmd: cmd, onCancel: onCancel, onSerial: Self.onSerial(packet:cache:), onHandle: handler)
    }
    public func register(pushCmd cmd: Command, onCancel: (() -> Void)?, handler: @escaping (Data) -> Void) -> Disposable {
        register(pushCmd: cmd, onCancel: onCancel, onSerial: Self.onSerial(packet:cache:), onHandle: handler)
    }
    public func register<R: Message>(pushCmd cmd: Command, onCancel: (() -> Void)?, handler: @escaping (R) -> Void) -> Disposable {
        register(pushCmd: cmd, onCancel: onCancel, onSerial: Self.onSerial(packet:cache:), onHandle: handler)
    }
    public func register(pushCmd cmd: Command, onCancel: (() -> Void)?, handler: @escaping (RustPushPacket<Data>) -> Void) -> Disposable {
        register(pushCmd: cmd, onCancel: onCancel, onSerial: Self.onSerial(packet:cache:), onHandle: handler)
    }
    public func register<R: Message>(pushCmd cmd: Command, onCancel: (() -> Void)?, handler: @escaping (RustPushPacket<R>) -> Void) -> Disposable {
        register(pushCmd: cmd, onCancel: onCancel, onSerial: Self.onSerial(packet:cache:), onHandle: handler)
    }

    // MARK: serial function
    static func onSerial<T>(packet: T, cache: RustManager.Cache) throws -> (T, String) { (packet, "Data With Packet") } // server packet or rust packet, return directly
    static func onSerial(packet: ServerPushPacket<Data>, cache: RustManager.Cache) throws -> (Data, String) {
        (packet.body, "Data")
    }
    static func onSerial<R: Message>(packet: ServerPushPacket<Data>, cache: RustManager.Cache) throws -> (R, String) {
        let msg: R = try cache.onSerial(data: packet.body)
        return (msg, R.protoMessageName)
    }
    static func onSerial<R: Message>(packet: ServerPushPacket<Data>, cache: RustManager.Cache) throws -> (ServerPushPacket<R>, String) {
        let new = try packet.map { try cache.onSerial(data: $0.body) as R }
        return (new, "\(R.protoMessageName) With Packet")
    }
    static func onSerial(packet: RustPushPacket<Data>, cache: RustManager.Cache) throws -> (Data, String) {
        (packet.body, "Data")
    }
    static func onSerial<R: Message>(packet: RustPushPacket<Data>, cache: RustManager.Cache) throws -> (R, String) {
        let msg: R = try cache.onSerial(data: packet.body)
        return (msg, R.protoMessageName)
    }
    static func onSerial<R: Message>(packet: RustPushPacket<Data>, cache: RustManager.Cache) throws -> (RustPushPacket<R>, String) {
        let new = try packet.map { try cache.onSerial(data: $0.body) as R }
        return (new, "\(R.protoMessageName) With Packet")
    }
}
#endif
