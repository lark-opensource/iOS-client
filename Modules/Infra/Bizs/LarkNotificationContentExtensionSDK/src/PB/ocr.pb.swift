// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ocr.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// swiftlint:disable all

import Foundation
import LarkHTTP

public struct Ocr_ImageOCRRequest {
  // LarkHTTP.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the LarkHTTP library for
  // methods supported on all messages.

  /// 图片内容
  public var image: Data {
    get {return _image ?? LarkHTTP.Internal.emptyData}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
//  public mutating func clearImage() {self._image = nil}

  public var unknownFields = LarkHTTP.UnknownStorage()

  public init() {}

  fileprivate var _image: Data? = nil
}

public struct Ocr_ImageOCRResponse {
  // LarkHTTP.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the LarkHTTP library for
  // methods supported on all messages.

  /// 文本行识别结果
  public var textAndRect: [Ocr_TextAndRect] = []

  public var unknownFields = LarkHTTP.UnknownStorage()

  public init() {}
}

public struct Ocr_TextAndRect {
  // LarkHTTP.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the LarkHTTP library for
  // methods supported on all messages.

  public var text: String {
    get {return _storage._text ?? String()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {_uniqueStorage()._text = nil}

  public var rect: Ocr_Rect {
    get {return _storage._rect ?? Ocr_Rect()}
    set {_uniqueStorage()._rect = newValue}
  }
  /// Returns true if `rect` has been explicitly set.
  public var hasRect: Bool {return _storage._rect != nil}
  /// Clears the value of `rect`. Subsequent reads from it will return its default value.
//  public mutating func clearRect() {_uniqueStorage()._rect = nil}

  public var unknownFields = LarkHTTP.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Ocr_Rect {
  // LarkHTTP.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the LarkHTTP library for
  // methods supported on all messages.

  public var xLt: Int32 {
    get {return _xLt ?? 0}
    set {_xLt = newValue}
  }
  /// Returns true if `xLt` has been explicitly set.
//  public var hasXLt: Bool {return self._xLt != nil}
  /// Clears the value of `xLt`. Subsequent reads from it will return its default value.
//  public mutating func clearXLt() {self._xLt = nil}

  public var yLt: Int32 {
    get {return _yLt ?? 0}
    set {_yLt = newValue}
  }
  /// Returns true if `yLt` has been explicitly set.
//  public var hasYLt: Bool {return self._yLt != nil}
  /// Clears the value of `yLt`. Subsequent reads from it will return its default value.
//  public mutating func clearYLt() {self._yLt = nil}

  public var xRt: Int32 {
    get {return _xRt ?? 0}
    set {_xRt = newValue}
  }
  /// Returns true if `xRt` has been explicitly set.
//  public var hasXRt: Bool {return self._xRt != nil}
  /// Clears the value of `xRt`. Subsequent reads from it will return its default value.
//  public mutating func clearXRt() {self._xRt = nil}

  public var yRt: Int32 {
    get {return _yRt ?? 0}
    set {_yRt = newValue}
  }
  /// Returns true if `yRt` has been explicitly set.
//  public var hasYRt: Bool {return self._yRt != nil}
  /// Clears the value of `yRt`. Subsequent reads from it will return its default value.
//  public mutating func clearYRt() {self._yRt = nil}

  public var xRb: Int32 {
    get {return _xRb ?? 0}
    set {_xRb = newValue}
  }
  /// Returns true if `xRb` has been explicitly set.
//  public var hasXRb: Bool {return self._xRb != nil}
  /// Clears the value of `xRb`. Subsequent reads from it will return its default value.
//  public mutating func clearXRb() {self._xRb = nil}

  public var yRb: Int32 {
    get {return _yRb ?? 0}
    set {_yRb = newValue}
  }
  /// Returns true if `yRb` has been explicitly set.
//  public var hasYRb: Bool {return self._yRb != nil}
  /// Clears the value of `yRb`. Subsequent reads from it will return its default value.
//  public mutating func clearYRb() {self._yRb = nil}

  public var xLb: Int32 {
    get {return _xLb ?? 0}
    set {_xLb = newValue}
  }
  /// Returns true if `xLb` has been explicitly set.
//  public var hasXLb: Bool {return self._xLb != nil}
  /// Clears the value of `xLb`. Subsequent reads from it will return its default value.
//  public mutating func clearXLb() {self._xLb = nil}

  public var yLb: Int32 {
    get {return _yLb ?? 0}
    set {_yLb = newValue}
  }
  /// Returns true if `yLb` has been explicitly set.
//  public var hasYLb: Bool {return self._yLb != nil}
  /// Clears the value of `yLb`. Subsequent reads from it will return its default value.
//  public mutating func clearYLb() {self._yLb = nil}

  public var unknownFields = LarkHTTP.UnknownStorage()

  public init() {}

  fileprivate var _xLt: Int32? = nil
  fileprivate var _yLt: Int32? = nil
  fileprivate var _xRt: Int32? = nil
  fileprivate var _yRt: Int32? = nil
  fileprivate var _xRb: Int32? = nil
  fileprivate var _yRb: Int32? = nil
  fileprivate var _xLb: Int32? = nil
  fileprivate var _yLb: Int32? = nil
}

// MARK: - Code below here is support for the LarkHTTP runtime.

fileprivate let _protobuf_package = "ocr"

extension Ocr_ImageOCRRequest: LarkHTTP.Message, LarkHTTP._MessageImplementationBase, LarkHTTP._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageOCRRequest"
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .same(proto: "image"),
  ]

  public var isInitialized: Bool {
    if self._image == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: LarkHTTP.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self._image)
      default: break
      }
    }
  }

  public func traverse<V: LarkHTTP.Visitor>(visitor: inout V) throws {
    if let v = self._image {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocr_ImageOCRRequest, rhs: Ocr_ImageOCRRequest) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocr_ImageOCRResponse: LarkHTTP.Message, LarkHTTP._MessageImplementationBase, LarkHTTP._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageOCRResponse"
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .standard(proto: "text_and_rect"),
  ]

  public var isInitialized: Bool {
    if !LarkHTTP.Internal.areAllInitialized(self.textAndRect) {return false}
    return true
  }

  public mutating func decodeMessage<D: LarkHTTP.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.textAndRect)
      default: break
      }
    }
  }

  public func traverse<V: LarkHTTP.Visitor>(visitor: inout V) throws {
    if !self.textAndRect.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.textAndRect, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocr_ImageOCRResponse, rhs: Ocr_ImageOCRResponse) -> Bool {
    if lhs.textAndRect != rhs.textAndRect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocr_TextAndRect: LarkHTTP.Message, LarkHTTP._MessageImplementationBase, LarkHTTP._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextAndRect"
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "rect"),
  ]

  fileprivate class _StorageClass {
    var _text: String? = nil
    var _rect: Ocr_Rect? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _text = source._text
      _rect = source._rect
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._text == nil {return false}
      if _storage._rect == nil {return false}
      if let v = _storage._rect, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: LarkHTTP.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._text)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._rect)
        default: break
        }
      }
    }
  }

  public func traverse<V: LarkHTTP.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._text {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._rect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocr_TextAndRect, rhs: Ocr_TextAndRect) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._text != rhs_storage._text {return false}
        if _storage._rect != rhs_storage._rect {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ocr_Rect: LarkHTTP.Message, LarkHTTP._MessageImplementationBase, LarkHTTP._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rect"
  public static let _protobuf_nameMap: LarkHTTP._NameMap = [
    1: .standard(proto: "x_lt"),
    2: .standard(proto: "y_lt"),
    3: .standard(proto: "x_rt"),
    4: .standard(proto: "y_rt"),
    5: .standard(proto: "x_rb"),
    6: .standard(proto: "y_rb"),
    7: .standard(proto: "x_lb"),
    8: .standard(proto: "y_lb"),
  ]

  public var isInitialized: Bool {
    if self._xLt == nil {return false}
    if self._yLt == nil {return false}
    if self._xRt == nil {return false}
    if self._yRt == nil {return false}
    if self._xRb == nil {return false}
    if self._yRb == nil {return false}
    if self._xLb == nil {return false}
    if self._yLb == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: LarkHTTP.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._xLt)
      case 2: try decoder.decodeSingularInt32Field(value: &self._yLt)
      case 3: try decoder.decodeSingularInt32Field(value: &self._xRt)
      case 4: try decoder.decodeSingularInt32Field(value: &self._yRt)
      case 5: try decoder.decodeSingularInt32Field(value: &self._xRb)
      case 6: try decoder.decodeSingularInt32Field(value: &self._yRb)
      case 7: try decoder.decodeSingularInt32Field(value: &self._xLb)
      case 8: try decoder.decodeSingularInt32Field(value: &self._yLb)
      default: break
      }
    }
  }

  public func traverse<V: LarkHTTP.Visitor>(visitor: inout V) throws {
    if let v = self._xLt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._yLt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._xRt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._yRt {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._xRb {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._yRb {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._xLb {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._yLb {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ocr_Rect, rhs: Ocr_Rect) -> Bool {
    if lhs._xLt != rhs._xLt {return false}
    if lhs._yLt != rhs._yLt {return false}
    if lhs._xRt != rhs._xRt {return false}
    if lhs._yRt != rhs._yRt {return false}
    if lhs._xRb != rhs._xRb {return false}
    if lhs._yRb != rhs._yRb {return false}
    if lhs._xLb != rhs._xLb {return false}
    if lhs._yLb != rhs._yLb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
// swiftlint:enable all
