// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: lark_fg.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//  Generated code. DO NOT EDIT.
//  source: lark-fg.yaml

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// feature gating interface error type 
enum LarkFg_Proto_LarkFgError: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Interface call failed due to unknown error. 
  case unknownError // = 0

  /// Interface call failed due to user validation error. 
  case userValidError // = 1

  init() {
    self = .unknownError
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownError
    case 1: self = .userValidError
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownError: return 0
    case .userValidError: return 1
    }
  }

}

#if swift(>=4.2)

extension LarkFg_Proto_LarkFgError: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Get runtime immutable feature gating after client invoke [`MakeUserOnline`] 
struct LarkFg_Proto_FuncParamsXe310569e8131bb62 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userid: String {
    get {return _userid ?? String()}
    set {_userid = newValue}
  }
  /// Returns true if `userid` has been explicitly set.
  var hasUserid: Bool {return self._userid != nil}
  /// Clears the value of `userid`. Subsequent reads from it will return its default value.
  mutating func clearUserid() {self._userid = nil}

  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userid: String? = nil
  fileprivate var _key: String? = nil
}

/// Get runtime immutable feature gating after client invoke [`MakeUserOnline`] 
struct LarkFg_Proto_FuncReturnX3dc8b8542df1cbb1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ret: Bool {
    get {return _ret ?? false}
    set {_ret = newValue}
  }
  /// Returns true if `ret` has been explicitly set.
  var hasRet: Bool {return self._ret != nil}
  /// Clears the value of `ret`. Subsequent reads from it will return its default value.
  mutating func clearRet() {self._ret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ret: Bool? = nil
}

/// Get runtime immutable feature gating after client invoke [`MakeUserOnline`] 
struct LarkFg_Proto_FuncErrorXb7613bdc761bb2dc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: LarkFg_Proto_LarkFgError {
    get {return _err ?? .unknownError}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: LarkFg_Proto_LarkFgError? = nil
}

struct LarkFg_Proto___molten_ffi_placeholder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension LarkFg_Proto_LarkFgError: @unchecked Sendable {}
extension LarkFg_Proto_FuncParamsXe310569e8131bb62: @unchecked Sendable {}
extension LarkFg_Proto_FuncReturnX3dc8b8542df1cbb1: @unchecked Sendable {}
extension LarkFg_Proto_FuncErrorXb7613bdc761bb2dc: @unchecked Sendable {}
extension LarkFg_Proto___molten_ffi_placeholder: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "lark_fg.proto"

extension LarkFg_Proto_FuncParamsXe310569e8131bb62: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".FuncParamsXe310569e8131bb62"

  public var isInitialized: Bool {
    if self._userid == nil {return false}
    if self._key == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._userid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LarkFg_Proto_FuncParamsXe310569e8131bb62, rhs: LarkFg_Proto_FuncParamsXe310569e8131bb62) -> Bool {
    if lhs._userid != rhs._userid {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LarkFg_Proto_FuncReturnX3dc8b8542df1cbb1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".FuncReturnX3dc8b8542df1cbb1"

  public var isInitialized: Bool {
    if self._ret == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._ret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ret {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LarkFg_Proto_FuncReturnX3dc8b8542df1cbb1, rhs: LarkFg_Proto_FuncReturnX3dc8b8542df1cbb1) -> Bool {
    if lhs._ret != rhs._ret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LarkFg_Proto_FuncErrorXb7613bdc761bb2dc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".FuncErrorXb7613bdc761bb2dc"

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._err {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LarkFg_Proto_FuncErrorXb7613bdc761bb2dc, rhs: LarkFg_Proto_FuncErrorXb7613bdc761bb2dc) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LarkFg_Proto___molten_ffi_placeholder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".__molten_ffi_placeholder"

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LarkFg_Proto___molten_ffi_placeholder, rhs: LarkFg_Proto___molten_ffi_placeholder) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
