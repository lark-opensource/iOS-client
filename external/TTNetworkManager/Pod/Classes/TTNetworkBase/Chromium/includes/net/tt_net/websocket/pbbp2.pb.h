// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pbbp2.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pbbp2_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pbbp2_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include "net/base/net_export.h"
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pbbp2_2eproto TTNET_IMPLEMENT_EXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TTNET_IMPLEMENT_EXPORT TableStruct_pbbp2_2eproto {
static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
PROTOBUF_SECTION_VARIABLE(protodesc_cold);
static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
PROTOBUF_SECTION_VARIABLE(protodesc_cold);
static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[2]
PROTOBUF_SECTION_VARIABLE(protodesc_cold);
static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace pbbp2 {
class Frame;
class FrameDefaultTypeInternal;
TTNET_IMPLEMENT_EXPORT extern FrameDefaultTypeInternal _Frame_default_instance_;
class Frame_ExtendedEntry;
class Frame_ExtendedEntryDefaultTypeInternal;
TTNET_IMPLEMENT_EXPORT extern Frame_ExtendedEntryDefaultTypeInternal _Frame_ExtendedEntry_default_instance_;
}  // namespace pbbp2
PROTOBUF_NAMESPACE_OPEN
template<> TTNET_IMPLEMENT_EXPORT ::pbbp2::Frame* Arena::CreateMaybeMessage<::pbbp2::Frame>(Arena*);
template<> TTNET_IMPLEMENT_EXPORT ::pbbp2::Frame_ExtendedEntry* Arena::CreateMaybeMessage<::pbbp2::Frame_ExtendedEntry>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pbbp2 {

// ===================================================================

class TTNET_IMPLEMENT_EXPORT Frame_ExtendedEntry :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pbbp2.Frame.ExtendedEntry) */ {
public:
Frame_ExtendedEntry();
virtual ~Frame_ExtendedEntry();

Frame_ExtendedEntry(const Frame_ExtendedEntry& from);
Frame_ExtendedEntry(Frame_ExtendedEntry&& from) noexcept
: Frame_ExtendedEntry() {
*this = ::std::move(from);
}

inline Frame_ExtendedEntry& operator=(const Frame_ExtendedEntry& from) {
CopyFrom(from);
return *this;
}
inline Frame_ExtendedEntry& operator=(Frame_ExtendedEntry&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const Frame_ExtendedEntry& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const Frame_ExtendedEntry* internal_default_instance() {
return reinterpret_cast<const Frame_ExtendedEntry*>(
&_Frame_ExtendedEntry_default_instance_);
}
static constexpr int kIndexInFileMessages =
0;

friend void swap(Frame_ExtendedEntry& a, Frame_ExtendedEntry& b) {
a.Swap(&b);
}
inline void Swap(Frame_ExtendedEntry* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline Frame_ExtendedEntry* New() const final {
return CreateMaybeMessage<Frame_ExtendedEntry>(nullptr);
}

Frame_ExtendedEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<Frame_ExtendedEntry>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const Frame_ExtendedEntry& from);
void MergeFrom(const Frame_ExtendedEntry& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Frame_ExtendedEntry* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "pbbp2.Frame.ExtendedEntry";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kKeyFieldNumber = 1,
kValueFieldNumber = 2,
};
// required string key = 1;
bool has_key() const;
void clear_key();
const std::string& key() const;
void set_key(const std::string& value);
void set_key(std::string&& value);
void set_key(const char* value);
void set_key(const char* value, size_t size);
std::string* mutable_key();
std::string* release_key();
void set_allocated_key(std::string* key);

// required string value = 2;
bool has_value() const;
void clear_value();
const std::string& value() const;
void set_value(const std::string& value);
void set_value(std::string&& value);
void set_value(const char* value);
void set_value(const char* value, size_t size);
std::string* mutable_value();
std::string* release_value();
void set_allocated_value(std::string* value);

// @@protoc_insertion_point(class_scope:pbbp2.Frame.ExtendedEntry)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
friend struct ::TableStruct_pbbp2_2eproto;
};
// -------------------------------------------------------------------

class TTNET_IMPLEMENT_EXPORT Frame :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:pbbp2.Frame) */ {
public:
Frame();
virtual ~Frame();

Frame(const Frame& from);
Frame(Frame&& from) noexcept
: Frame() {
*this = ::std::move(from);
}

inline Frame& operator=(const Frame& from) {
CopyFrom(from);
return *this;
}
inline Frame& operator=(Frame&& from) noexcept {
if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
if (this != &from) InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields();
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields();
}

static const Frame& default_instance();

static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
static inline const Frame* internal_default_instance() {
return reinterpret_cast<const Frame*>(
&_Frame_default_instance_);
}
static constexpr int kIndexInFileMessages =
1;

friend void swap(Frame& a, Frame& b) {
a.Swap(&b);
}
inline void Swap(Frame* other) {
if (other == this) return;
InternalSwap(other);
}

// implements Message ----------------------------------------------

inline Frame* New() const final {
return CreateMaybeMessage<Frame>(nullptr);
}

Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
return CreateMaybeMessage<Frame>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
final;
void CopyFrom(const Frame& from);
void MergeFrom(const Frame& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
#else
bool MergePartialFromCodedStream(
::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
void SerializeWithCachedSizes(
::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
void DiscardUnknownFields();
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
inline void SharedCtor();
inline void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Frame* other);
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "pbbp2.Frame";
}
private:
inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
return nullptr;
}
inline void* MaybeArenaPtr() const {
return nullptr;
}
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef Frame_ExtendedEntry ExtendedEntry;

// accessors -------------------------------------------------------

enum : int {
kHeadersFieldNumber = 5,
kPayloadEncodingFieldNumber = 6,
kPayloadTypeFieldNumber = 7,
kPayloadFieldNumber = 8,
kLogidnewFieldNumber = 9,
kSeqidFieldNumber = 1,
kLogidFieldNumber = 2,
kServiceFieldNumber = 3,
kMethodFieldNumber = 4,
};
// repeated .pbbp2.Frame.ExtendedEntry headers = 5;
int headers_size() const;
void clear_headers();
::pbbp2::Frame_ExtendedEntry* mutable_headers(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbbp2::Frame_ExtendedEntry >*
mutable_headers();
const ::pbbp2::Frame_ExtendedEntry& headers(int index) const;
::pbbp2::Frame_ExtendedEntry* add_headers();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbbp2::Frame_ExtendedEntry >&
headers() const;

// optional string payload_encoding = 6;
bool has_payload_encoding() const;
void clear_payload_encoding();
const std::string& payload_encoding() const;
void set_payload_encoding(const std::string& value);
void set_payload_encoding(std::string&& value);
void set_payload_encoding(const char* value);
void set_payload_encoding(const char* value, size_t size);
std::string* mutable_payload_encoding();
std::string* release_payload_encoding();
void set_allocated_payload_encoding(std::string* payload_encoding);

// optional string payload_type = 7;
bool has_payload_type() const;
void clear_payload_type();
const std::string& payload_type() const;
void set_payload_type(const std::string& value);
void set_payload_type(std::string&& value);
void set_payload_type(const char* value);
void set_payload_type(const char* value, size_t size);
std::string* mutable_payload_type();
std::string* release_payload_type();
void set_allocated_payload_type(std::string* payload_type);

// optional bytes payload = 8;
bool has_payload() const;
void clear_payload();
const std::string& payload() const;
void set_payload(const std::string& value);
void set_payload(std::string&& value);
void set_payload(const char* value);
void set_payload(const void* value, size_t size);
std::string* mutable_payload();
std::string* release_payload();
void set_allocated_payload(std::string* payload);

// optional string logidnew = 9;
bool has_logidnew() const;
void clear_logidnew();
const std::string& logidnew() const;
void set_logidnew(const std::string& value);
void set_logidnew(std::string&& value);
void set_logidnew(const char* value);
void set_logidnew(const char* value, size_t size);
std::string* mutable_logidnew();
std::string* release_logidnew();
void set_allocated_logidnew(std::string* logidnew);

// required uint64 seqid = 1;
bool has_seqid() const;
void clear_seqid();
::PROTOBUF_NAMESPACE_ID::uint64 seqid() const;
void set_seqid(::PROTOBUF_NAMESPACE_ID::uint64 value);

// required uint64 logid = 2;
bool has_logid() const;
void clear_logid();
::PROTOBUF_NAMESPACE_ID::uint64 logid() const;
void set_logid(::PROTOBUF_NAMESPACE_ID::uint64 value);

// required int32 service = 3;
bool has_service() const;
void clear_service();
::PROTOBUF_NAMESPACE_ID::int32 service() const;
void set_service(::PROTOBUF_NAMESPACE_ID::int32 value);

// required int32 method = 4;
bool has_method() const;
void clear_method();
::PROTOBUF_NAMESPACE_ID::int32 method() const;
void set_method(::PROTOBUF_NAMESPACE_ID::int32 value);

// @@protoc_insertion_point(class_scope:pbbp2.Frame)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbbp2::Frame_ExtendedEntry > headers_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_encoding_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_type_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logidnew_;
::PROTOBUF_NAMESPACE_ID::uint64 seqid_;
::PROTOBUF_NAMESPACE_ID::uint64 logid_;
::PROTOBUF_NAMESPACE_ID::int32 service_;
::PROTOBUF_NAMESPACE_ID::int32 method_;
friend struct ::TableStruct_pbbp2_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Frame_ExtendedEntry

// required string key = 1;
inline bool Frame_ExtendedEntry::has_key() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_ExtendedEntry::clear_key() {
key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Frame_ExtendedEntry::key() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.ExtendedEntry.key)
return key_.GetNoArena();
}
inline void Frame_ExtendedEntry::set_key(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:pbbp2.Frame.ExtendedEntry.key)
}
inline void Frame_ExtendedEntry::set_key(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
key_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:pbbp2.Frame.ExtendedEntry.key)
}
inline void Frame_ExtendedEntry::set_key(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:pbbp2.Frame.ExtendedEntry.key)
}
inline void Frame_ExtendedEntry::set_key(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:pbbp2.Frame.ExtendedEntry.key)
}
inline std::string* Frame_ExtendedEntry::mutable_key() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:pbbp2.Frame.ExtendedEntry.key)
return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Frame_ExtendedEntry::release_key() {
// @@protoc_insertion_point(field_release:pbbp2.Frame.ExtendedEntry.key)
if (!has_key()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_ExtendedEntry::set_allocated_key(std::string* key) {
if (key != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
// @@protoc_insertion_point(field_set_allocated:pbbp2.Frame.ExtendedEntry.key)
}

// required string value = 2;
inline bool Frame_ExtendedEntry::has_value() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame_ExtendedEntry::clear_value() {
value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Frame_ExtendedEntry::value() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.ExtendedEntry.value)
return value_.GetNoArena();
}
inline void Frame_ExtendedEntry::set_value(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:pbbp2.Frame.ExtendedEntry.value)
}
inline void Frame_ExtendedEntry::set_value(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:pbbp2.Frame.ExtendedEntry.value)
}
inline void Frame_ExtendedEntry::set_value(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:pbbp2.Frame.ExtendedEntry.value)
}
inline void Frame_ExtendedEntry::set_value(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:pbbp2.Frame.ExtendedEntry.value)
}
inline std::string* Frame_ExtendedEntry::mutable_value() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:pbbp2.Frame.ExtendedEntry.value)
return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Frame_ExtendedEntry::release_value() {
// @@protoc_insertion_point(field_release:pbbp2.Frame.ExtendedEntry.value)
if (!has_value()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_ExtendedEntry::set_allocated_value(std::string* value) {
if (value != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set_allocated:pbbp2.Frame.ExtendedEntry.value)
}

// -------------------------------------------------------------------

// Frame

// required uint64 seqid = 1;
inline bool Frame::has_seqid() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Frame::clear_seqid() {
seqid_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Frame::seqid() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.seqid)
return seqid_;
}
inline void Frame::set_seqid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000010u;
seqid_ = value;
// @@protoc_insertion_point(field_set:pbbp2.Frame.seqid)
}

// required uint64 logid = 2;
inline bool Frame::has_logid() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Frame::clear_logid() {
logid_ = PROTOBUF_ULONGLONG(0);
_has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Frame::logid() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.logid)
return logid_;
}
inline void Frame::set_logid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
_has_bits_[0] |= 0x00000020u;
logid_ = value;
// @@protoc_insertion_point(field_set:pbbp2.Frame.logid)
}

// required int32 service = 3;
inline bool Frame::has_service() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Frame::clear_service() {
service_ = 0;
_has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Frame::service() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.service)
return service_;
}
inline void Frame::set_service(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000040u;
service_ = value;
// @@protoc_insertion_point(field_set:pbbp2.Frame.service)
}

// required int32 method = 4;
inline bool Frame::has_method() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Frame::clear_method() {
method_ = 0;
_has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Frame::method() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.method)
return method_;
}
inline void Frame::set_method(::PROTOBUF_NAMESPACE_ID::int32 value) {
_has_bits_[0] |= 0x00000080u;
method_ = value;
// @@protoc_insertion_point(field_set:pbbp2.Frame.method)
}

// repeated .pbbp2.Frame.ExtendedEntry headers = 5;
inline int Frame::headers_size() const {
return headers_.size();
}
inline void Frame::clear_headers() {
headers_.Clear();
}
inline ::pbbp2::Frame_ExtendedEntry* Frame::mutable_headers(int index) {
// @@protoc_insertion_point(field_mutable:pbbp2.Frame.headers)
return headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbbp2::Frame_ExtendedEntry >*
Frame::mutable_headers() {
// @@protoc_insertion_point(field_mutable_list:pbbp2.Frame.headers)
return &headers_;
}
inline const ::pbbp2::Frame_ExtendedEntry& Frame::headers(int index) const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.headers)
return headers_.Get(index);
}
inline ::pbbp2::Frame_ExtendedEntry* Frame::add_headers() {
// @@protoc_insertion_point(field_add:pbbp2.Frame.headers)
return headers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbbp2::Frame_ExtendedEntry >&
Frame::headers() const {
// @@protoc_insertion_point(field_list:pbbp2.Frame.headers)
return headers_;
}

// optional string payload_encoding = 6;
inline bool Frame::has_payload_encoding() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::clear_payload_encoding() {
payload_encoding_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Frame::payload_encoding() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.payload_encoding)
return payload_encoding_.GetNoArena();
}
inline void Frame::set_payload_encoding(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
payload_encoding_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:pbbp2.Frame.payload_encoding)
}
inline void Frame::set_payload_encoding(std::string&& value) {
_has_bits_[0] |= 0x00000001u;
payload_encoding_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:pbbp2.Frame.payload_encoding)
}
inline void Frame::set_payload_encoding(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000001u;
payload_encoding_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:pbbp2.Frame.payload_encoding)
}
inline void Frame::set_payload_encoding(const char* value, size_t size) {
_has_bits_[0] |= 0x00000001u;
payload_encoding_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:pbbp2.Frame.payload_encoding)
}
inline std::string* Frame::mutable_payload_encoding() {
_has_bits_[0] |= 0x00000001u;
// @@protoc_insertion_point(field_mutable:pbbp2.Frame.payload_encoding)
return payload_encoding_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Frame::release_payload_encoding() {
// @@protoc_insertion_point(field_release:pbbp2.Frame.payload_encoding)
if (!has_payload_encoding()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
return payload_encoding_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_allocated_payload_encoding(std::string* payload_encoding) {
if (payload_encoding != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
payload_encoding_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload_encoding);
// @@protoc_insertion_point(field_set_allocated:pbbp2.Frame.payload_encoding)
}

// optional string payload_type = 7;
inline bool Frame::has_payload_type() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::clear_payload_type() {
payload_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Frame::payload_type() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.payload_type)
return payload_type_.GetNoArena();
}
inline void Frame::set_payload_type(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
payload_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:pbbp2.Frame.payload_type)
}
inline void Frame::set_payload_type(std::string&& value) {
_has_bits_[0] |= 0x00000002u;
payload_type_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:pbbp2.Frame.payload_type)
}
inline void Frame::set_payload_type(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000002u;
payload_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:pbbp2.Frame.payload_type)
}
inline void Frame::set_payload_type(const char* value, size_t size) {
_has_bits_[0] |= 0x00000002u;
payload_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:pbbp2.Frame.payload_type)
}
inline std::string* Frame::mutable_payload_type() {
_has_bits_[0] |= 0x00000002u;
// @@protoc_insertion_point(field_mutable:pbbp2.Frame.payload_type)
return payload_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Frame::release_payload_type() {
// @@protoc_insertion_point(field_release:pbbp2.Frame.payload_type)
if (!has_payload_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
return payload_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_allocated_payload_type(std::string* payload_type) {
if (payload_type != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
payload_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload_type);
// @@protoc_insertion_point(field_set_allocated:pbbp2.Frame.payload_type)
}

// optional bytes payload = 8;
inline bool Frame::has_payload() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame::clear_payload() {
payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Frame::payload() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.payload)
return payload_.GetNoArena();
}
inline void Frame::set_payload(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:pbbp2.Frame.payload)
}
inline void Frame::set_payload(std::string&& value) {
_has_bits_[0] |= 0x00000004u;
payload_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:pbbp2.Frame.payload)
}
inline void Frame::set_payload(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000004u;
payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:pbbp2.Frame.payload)
}
inline void Frame::set_payload(const void* value, size_t size) {
_has_bits_[0] |= 0x00000004u;
payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:pbbp2.Frame.payload)
}
inline std::string* Frame::mutable_payload() {
_has_bits_[0] |= 0x00000004u;
// @@protoc_insertion_point(field_mutable:pbbp2.Frame.payload)
return payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Frame::release_payload() {
// @@protoc_insertion_point(field_release:pbbp2.Frame.payload)
if (!has_payload()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
return payload_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_allocated_payload(std::string* payload) {
if (payload != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload);
// @@protoc_insertion_point(field_set_allocated:pbbp2.Frame.payload)
}

// optional string logidnew = 9;
inline bool Frame::has_logidnew() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Frame::clear_logidnew() {
logidnew_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Frame::logidnew() const {
// @@protoc_insertion_point(field_get:pbbp2.Frame.logidnew)
return logidnew_.GetNoArena();
}
inline void Frame::set_logidnew(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
logidnew_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:pbbp2.Frame.logidnew)
}
inline void Frame::set_logidnew(std::string&& value) {
_has_bits_[0] |= 0x00000008u;
logidnew_.SetNoArena(
&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
// @@protoc_insertion_point(field_set_rvalue:pbbp2.Frame.logidnew)
}
inline void Frame::set_logidnew(const char* value) {
GOOGLE_DCHECK(value != nullptr);
_has_bits_[0] |= 0x00000008u;
logidnew_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:pbbp2.Frame.logidnew)
}
inline void Frame::set_logidnew(const char* value, size_t size) {
_has_bits_[0] |= 0x00000008u;
logidnew_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:pbbp2.Frame.logidnew)
}
inline std::string* Frame::mutable_logidnew() {
_has_bits_[0] |= 0x00000008u;
// @@protoc_insertion_point(field_mutable:pbbp2.Frame.logidnew)
return logidnew_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Frame::release_logidnew() {
// @@protoc_insertion_point(field_release:pbbp2.Frame.logidnew)
if (!has_logidnew()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
return logidnew_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_allocated_logidnew(std::string* logidnew) {
if (logidnew != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
logidnew_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logidnew);
// @@protoc_insertion_point(field_set_allocated:pbbp2.Frame.logidnew)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbbp2

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pbbp2_2eproto
