// Copyright 2019 The Lynx Authors. All rights reserved.

#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

#import "JSModule.h"
#import "LynxConfig.h"
#import "LynxConfigInfo.h"
#import "LynxDynamicComponentFetcher.h"
#import "LynxExtraTiming.h"
#import "LynxGroup.h"
#import "LynxLifecycleDispatcher.h"
#import "LynxPerformance.h"
#import "LynxResourceProvider.h"
#import "LynxScrollListener.h"
#import "LynxTemplateBundle.h"
#import "LynxTemplateData.h"
#import "LynxTheme.h"
#import "LynxViewClient.h"

/**
 * This enum is used to define size measure mode of LynxView.
 * If mode is Undefined, the size will be determined by the content.
 * If mode is Exact, the size will be the size set by outside.
 * If mode is Max, the size will be determined by the content, but not exceed
 * the maximum size.
 */
typedef NS_ENUM(NSInteger, LynxViewSizeMode) {
  LynxViewSizeModeUndefined = 0,
  LynxViewSizeModeExact,
  LynxViewSizeModeMax
};

// now only support LynxThreadStrategyForRenderAllOnUI!
typedef NS_ENUM(NSInteger, LynxThreadStrategyForRender) {
  LynxThreadStrategyForRenderAllOnUI = 0,
  LynxThreadStrategyForRenderMostOnTASM = 1,
  LynxThreadStrategyForRenderPartOnLayout = 2,
  LynxThreadStrategyForRenderMultiThreads = 3,
};

@interface LynxViewBuilder : NSObject
@property(nonatomic, assign) BOOL isUIRunningMode __attribute__((deprecated(
    "try to set 'threadStrategy' variable if you want to change the thread strategy for rendering"))
);
@property(nonatomic, nullable) LynxConfig* config;
@property(nonatomic, nullable) LynxGroup* group;
@property(nonatomic, assign) BOOL enableLayoutSafepoint;
@property(nonatomic, assign) BOOL enableAutoExpose;
@property(nonatomic, assign) BOOL enableTextNonContiguousLayout;
@property(nonatomic, assign) BOOL enableLayoutOnly;
@property(nonatomic, assign) BOOL enableUIOperationQueue;
@property(nonatomic, assign) BOOL enablePendingJSTaskOnLayout;
@property(nonatomic, assign) BOOL enableJSRuntime;
@property(nonatomic, assign) BOOL enableAirStrictMode;
@property(nonatomic, assign) BOOL enableAsyncCreateRender;
@property(nonatomic, assign) BOOL enableRadonCompatible;
@property(nonatomic, assign) BOOL enableSyncFlush;
@property(nonatomic, assign) BOOL enableMultiAsyncThread;
@property(nonatomic, assign) CGRect frame;
@property(nonatomic, nullable) id<LynxDynamicComponentFetcher> fetcher;
@property(nonatomic, assign) CGFloat fontScale;

/**
 * You can set a virtual screen size to lynxview by this way.
 * Generally, you don't need to set it.The screen size of lynx is the real device size by default.
 * It will be useful for the split-window, this case, it can make some css properties based on rpx
 * shows better.
 * screenSize.width (dp)
 * screenSize.height (dp)
 */
@property(nonatomic, assign) CGSize screenSize;

/**
 * indicates lynx view can be debug or not
 * when switch enableDevtool is disabled and
 * switch enableDevtoolForDebuggableView is enabled
 */
@property(nonatomic, assign) BOOL debuggable;

/**
 * Control whether updateData can take effect before loadTemplate
 */
@property(nonatomic, assign) BOOL enablePreUpdateData;

- (void)setThreadStrategyForRender:(LynxThreadStrategyForRender)threadStrategy;
- (LynxThreadStrategyForRender)getThreadStrategyForRender;

- (void)addLynxResourceProvider:(NSString* _Nonnull)resType
                       provider:(id<LynxResourceProvider> _Nonnull)provider;

/**
 * You can use the following interface to create an alias for system fonts or registered fonts
 * (fontFamily) that can be used in Lynx style sheets. This is an instance level interface and can
 * override settings in the global interface.
 */
- (void)registerFont:(UIFont* _Nonnull)font forName:(NSString* _Nonnull)name;
- (void)registerFamilyName:(NSString* _Nonnull)fontFamilyName
             withAliasName:(NSString* _Nonnull)aliasName;

@end

@class LynxTemplateRender;
@protocol LynxBaseInspectorOwner;
@class LynxGetUIResultDarwin;
@class LynxContext;
@class LynxExtraTiming;
@protocol LynxKryptonHelper;

/**
 * A view that display content generated by lynx cli.
 */
@interface LynxView : UIView

/*!
 The URL of the resource to load。

 @see loadTemplateFromURL:
 @see loadTemplate:withURL:
 @see loadTemplateFromURL:initData:
 @see loadTemplate:withURL:initData:
 */
@property(nonatomic, readonly, nullable) NSString* url;

/*!
 If `enableAsyncDisplay` is YES, sub-nodes' contents will be drawn asynchronously.
 Set `enableAsyncDisplay` is NO if it is not wanted. Default to YES.
 */
@property(nonatomic, readwrite, assign) BOOL enableAsyncDisplay;
/*!
 If `enableTextLayerRender` is YES, all `LynxUIText` will be drawn by using `CALayer`.
 This value is set by page-config. Default is NO.
 */
@property(nonatomic, readonly) BOOL enableTextLayerRender;

/*!
 If isUIRunningMode return true, it means that the template assembler will work on ui thread
 completely including layout operation. Otherwise template assembler will work on layout thread.

 If you want LynxView behavior similar to native view such as layout children when layoutSubviews
 happens, it's better to return true to get better visual effect.

 It's better to return false if the template is too heavy so that getting better performance.
 */
@property(nonatomic, readonly) BOOL isUIRunningMode
    __attribute__((deprecated("try to set 'threadStrategyForRendering' if you want to change the "
                              "thread strategy for rendering")));

/*!
 Through this client, you can get callbacks for some key nodes in the
 running process of LynxView, such as page loading completion, etc.
 */
@property(nonatomic, weak, nullable) id<LynxViewClient> client
    __attribute__((deprecated("use xxxxFetcher instead, and use LynxViewLifecycle to "
                              "implement lifecycle methods")));

@property(nonatomic, weak, nullable) id<LynxImageFetcher> imageFetcher;
@property(nonatomic, weak, nullable) id<LynxResourceFetcher> resourceFetcher;
@property(nonatomic, weak, nullable) id<LynxScrollListener> scrollListener;

// Layout, must call invalidateIntrinsicContentSize after change layout props
// If you use view.frame to set view frame, the layout mode will all be
// specified
@property(nonatomic, assign) LynxViewSizeMode layoutWidthMode;
@property(nonatomic, assign) LynxViewSizeMode layoutHeightMode;
@property(nonatomic, assign) CGFloat preferredMaxLayoutWidth;
@property(nonatomic, assign) CGFloat preferredMaxLayoutHeight;
@property(nonatomic, assign) CGFloat preferredLayoutWidth;
@property(nonatomic, assign) CGFloat preferredLayoutHeight;

- (nonnull instancetype)init;
- (nonnull instancetype)initWithFrame:(CGRect)frame;
- (nonnull instancetype)initWithBuilderBlock:
    (void (^_Nullable)(NS_NOESCAPE LynxViewBuilder* _Nonnull))builder;
- (instancetype _Nullable)initWithoutRender;
/**
 * If @see isUIRunningMode, you can get intrinsicContentSize immediately
 * after call invalidateIntrinsicContentSize. If not you can observe
 * the change of intrinsicContentSize through @see LynxViewClient
 */
- (void)invalidateIntrinsicContentSize __attribute__((deprecated("Use `triggerLayout` instead.")));

/**
 * send global event to lepus runtime(for lynx air)
 *
 * @param name event name
 * @param params context for event
 */
- (void)triggerEventBus:(nonnull NSString*)name withParams:(nullable NSArray*)params;

- (void)triggerLayout;
- (void)syncFlush;
- (void)setEnableTextNonContiguousLayout:(BOOL)enableTextNonContiguousLayout;
- (BOOL)enableTextNonContiguousLayout;

- (void)setEnableRadonCompatible:(BOOL)enableRadonCompatible
    __attribute__((deprecated("Radon diff mode can't be close after lynx 2.3.")));

- (void)setEnableLayoutOnly:(BOOL)enableLayoutOnly;

- (void)setEnableSyncFlush:(BOOL)enableSyncFlush;

/**
 * The natural size for the Lynxview, considering the content with the
 * size and size mode of LynxView.
 *
 * @see layoutWidthMode
 * @see layoutHeightMode
 * @see preferredMaxLayoutWidth
 * @see preferredMaxLayoutHeight
 * @see preferredLayoutWidth
 * @see preferredLayoutHeight
 */
- (CGSize)intrinsicContentSize;

- (void)loadTemplateFromURL:(nonnull NSString*)url;
- (void)loadTemplate:(nonnull NSData*)tem withURL:(nonnull NSString*)url;
- (void)loadTemplateFromURL:(nonnull NSString*)url initData:(nullable LynxTemplateData*)data;
- (void)loadTemplate:(nonnull NSData*)tem
             withURL:(nonnull NSString*)url
            initData:(nullable LynxTemplateData*)data;

/**
 * Load LynxView with a pre-decoded template.js
 * Load LynxView with a pre-decoded template.js with [LynxTemplateBundle initWithTemplate], it can
 *be used for LynxTemplateBundle reuse.
 *
 *@param bundle The pre-decoded template.js with [LynxTemplateBundle initWithTemplate].
 *@param url The url of lynx template.
 *@param data The initData to be used when render first screen.
 */
- (void)loadTemplateBundle:(nonnull LynxTemplateBundle*)bundle
                   withURL:(nonnull NSString*)url
                  initData:(nullable LynxTemplateData*)data;

/**
 * Load ssr data.
 * SSR data is a kind of file format which is generated by server runtime of Lynx on server side.
 * The data represented the objects to be rendered on the page.
 * And with ssr data, the first screen will be rendered extremely fast.
 * But the ssr data doesn't contains the logic of page, the page won't be interactable if rendered
 * only with ssr data. To make the lynx view interactable, call ssrHydrate api with the page
 * template to attach the events.
 *
 * @param tem The binary ssr data
 * @param url The url of ssr data
 * @param data The data to be forwarded to the placeholders placed when rendering on server.
 */
- (void)loadSSRData:(nonnull NSData*)tem
            withURL:(nonnull NSString*)url
           initData:(nullable LynxTemplateData*)data;
- (void)loadSSRDataFromURL:(nonnull NSString*)url initData:(nullable LynxTemplateData*)data;

/**
 * Attach page logic to a LynxView rendered with loadSSRData.
 * Calling this api will make LynxView rendered with SSR data interactable and behave just like a
 * normal lynxview.
 *
 * @param tem The binary of the template
 * @param url The url of the template
 * @param data The init data of the template
 */
- (void)ssrHydrate:(nonnull NSData*)tem
           withURL:(nonnull NSString*)url
          initData:(nullable LynxTemplateData*)data;
- (void)ssrHydrateFromURL:(nonnull NSString*)url initData:(nullable LynxTemplateData*)data;

- (void)dispatchViewDidStartLoading __attribute__((deprecated("Shouldn't call it.")));
- (LynxLifecycleDispatcher* _Nullable)getLifecycleDispatcher;

/**
 * 在 updateData 被调用时，如果 Layout Safepoint
 * 是开启状态，更新数据需要主动触发一次
 * requestLayout，确保 Safepoint 的流程完整执行，防止在 updateData
 * 的过程中没有触发任何
 * requestLayout，导致相关任务如排版任务堆积在底层的 pending task
 * queue中，引发界面位置无刷新问题。
 */
- (void)requestLayoutWhenSafepointEnable;

/**
 * EXPERIMENTAL API!
 * Updating the screen size for lynxview.
 * Updating the screen size does not trigger a re-layout, You should trigger  a re-layout by
 * yourself. It will be useful for the screen size change, like screen rotation. it can make some
 * css properties based on rpx shows better. Multiple views are not supported with different
 * settings!
 * @param width(dp) screen width
 * @param height(dp) screen screen
 */
#pragma mark updateScreenMetricsWithWidth
- (void)updateScreenMetricsWithWidth:(CGFloat)width height:(CGFloat)height;
- (void)updateFontScale:(CGFloat)scale;
/**
 * Normally, updateData before loadTemplate does not take effect. If you want to cache the data
 * updated before loadTemplate and use it together when loadTemplate, please set EnablePreUpdateData
 * option in LynxViewBuilder.
 */
- (void)updateDataWithString:(nullable NSString*)data;
- (void)updateDataWithString:(nullable NSString*)data processorName:(nullable NSString*)name;
- (void)updateDataWithTemplateData:(nullable LynxTemplateData*)data;
- (void)updateDataWithTemplateData:(nullable LynxTemplateData*)data
            updateFinishedCallback:(void (^__nullable)(void))callback;
- (void)updateDataWithDictionary:(nullable NSDictionary<NSString*, id>*)data;
- (void)updateDataWithDictionary:(nullable NSDictionary<NSString*, id>*)data
                   processorName:(nullable NSString*)name;
- (void)setGlobalPropsWithTemplateData:(nonnull LynxTemplateData*)data
    __attribute__((deprecated("Use `updateGlobalPropsWithTemplateData` instead.")));
- (void)setGlobalPropsWithDictionary:(NSDictionary<NSString*, id>* _Nonnull)data
    __attribute__((deprecated("Use `updateGlobalPropsWithDictionary` instead.")));
/**
 * If data is nil or not legal data, global props will not be updated
 */
- (void)updateGlobalPropsWithTemplateData:(nonnull LynxTemplateData*)data;
- (void)updateGlobalPropsWithDictionary:(NSDictionary<NSString*, id>* _Nonnull)data;

/**
 * Clear current data and update with the given data. If you want to clear the current data only,
 * you can pass an Empty LynxTemplateData
 */
- (void)resetDataWithTemplateData:(nonnull LynxTemplateData*)data;

/**
 * Reload template with data or also with globalProps.
 */
- (void)reloadTemplateWithTemplateData:(nonnull LynxTemplateData*)data;
/**
 * @param globalProps default : nil. Global props will be reset by new nonnull globalProps. Empty
 * globalProps could overwrite the original props, but nil object will do nothing.
 */
- (void)reloadTemplateWithTemplateData:(nonnull LynxTemplateData*)data
                           globalProps:(nullable LynxTemplateData*)globalProps;

/**
 Method to accquire current LynxView card data.
 Called IN UI Thread.
 Attentions: should be called in ui thread & be called after LynxView template loaded.
 */
- (NSDictionary* _Nullable)getCurrentData;

/**
 * **EXPERIMENTAL API**
 *
 * Method to acquire current LynxView card data by Key.
 * Called IN **UI Thread**.
 *
 * Attentions: should be called after lynxview template loaded.
 * @param keys keys to be acquired.
 */
- (NSDictionary* _Nullable)getPageDataByKey:(nonnull NSArray*)keys;

- (void)onEnterForeground;
- (void)onEnterBackground;
- (void)sendGlobalEvent:(nonnull NSString*)name withParams:(nullable NSArray*)params;
- (void)sendGlobalEventToLepus:(nonnull NSString*)name withParams:(nullable NSArray*)params;

- (nullable LynxUI*)findUIByIndex:(int)index;

// prefer using `findViewWithName:` than `viewWithName:`.
// `viewWithName:` will be marked deprecated in 1.6
- (nullable UIView*)viewWithName:(nonnull NSString*)name;
- (nullable UIView*)findViewWithName:(nonnull NSString*)name;
- (nullable LynxUI*)uiWithName:(nonnull NSString*)name;
- (nullable UIView*)viewWithIdSelector:(nonnull NSString*)idSelector;
- (nullable LynxUI*)uiWithIdSelector:(nonnull NSString*)idSelector;
- (nullable NSArray<UIView*>*)viewsWithA11yID:(nonnull NSString*)a11yID;

- (nullable NSString*)cardVersion __attribute__((deprecated("Use `lynxReportInfo` instead.")));
- (nonnull LynxConfigInfo*)lynxConfigInfo;
- (nullable LynxPerformance*)forceGetPerf
    __attribute__((deprecated("Use `LynxViewLifecycle didReceivexxx` instead.")));

- (nullable JSModule*)getJSModule:(nonnull NSString*)name;
- (void)hotModuleReplace:(nonnull NSString*)message withParams:(nonnull NSDictionary*)params;

/**
 * 暂停和开启 lynxview 的 layout animation。
 */
- (void)pauseRootLayoutAnimation;
- (void)resumeRootLayoutAnimation;

- (void)addLifecycleClient:(nonnull id<LynxViewLifecycle>)lifecycleClient;

// 设置主题，自动触发刷新界面
- (void)setTheme:(nonnull LynxTheme*)theme;
// 获取当前主题设置
- (nullable LynxTheme*)theme;
// clear
- (void)clearForDestroy;

/**
 *在 cell 复用 ，prepareForReuse 时进行调用，复用成功时调用 restart。
 */
- (void)resetAnimation;
- (void)restartAnimation;

- (void)attachTemplateRender:(LynxTemplateRender* _Nullable)templateRender;

- (void)processLayout:(nonnull NSData*)tem
              withURL:(nonnull NSString*)url
             initData:(nullable LynxTemplateData*)data;

// Calculate the width and height of view but do not create ui views.
// Call the processRender func to create ui views of this page.
- (void)processLayoutWithSSRData:(nonnull NSData*)tem
                         withURL:(nonnull NSString*)url
                        initData:(nullable LynxTemplateData*)data;

- (void)processRender;

- (void)startLynxRuntime;

- (void)setNeedPendingUIOperation:(BOOL)needPendingUIOperation;
- (BOOL)isLayoutFinish;
- (float)rootWidth;
- (float)rootHeight;

- (void)initLifecycleDispatcher;
- (void)resetViewAndLayer;
- (void)detachRender;

- (void)updateViewportWithPreferredLayoutWidth:(CGFloat)preferredLayoutWidth
                         preferredLayoutHeight:(CGFloat)preferredLayoutHeight;
- (void)updateViewportWithPreferredLayoutWidth:(CGFloat)preferredLayoutWidth
                         preferredLayoutHeight:(CGFloat)preferredLayoutHeight
                                    needLayout:(BOOL)needLayout;

- (nonnull LynxContext*)getLynxContext;
- (nullable NSNumber*)getLynxRuntimeId;
- (LynxThreadStrategyForRender)getThreadStrategyForRender;

- (void)runOnTasmThread:(dispatch_block_t _Nonnull)task;

@property(nonatomic, readonly, nullable) id<LynxBaseInspectorOwner> baseInspectorOwner;

@property(nonatomic, readwrite) BOOL catchAllException;

- (void)setExtraTiming:(LynxExtraTiming* _Nonnull)timing;

- (nullable NSDictionary*)getAllTimingInfo;

- (void)setExtraTimingWithDictionary:(NSDictionary* _Nonnull)timing;

- (void)triggerTrailReport;

- (nullable id<LynxKryptonHelper>)getKryptonHelper;

/**
 * Preload dynamic components with urls.
 * If you want to improve the efficiency of the first-screen display of dynamic components, you can
 * preload them.
 */
- (void)preloadDynamicComponents:(nonnull NSArray*)urls;

@end
