// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: meego_rust.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//  Generated code. DO NOT EDIT.
//  source: meego_rust.yaml

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum MeegoRust_Proto_DataType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ofBool // = 0
  case ofInt // = 1
  case ofDouble // = 2
  case ofString // = 3

  init() {
    self = .ofBool
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ofBool
    case 1: self = .ofInt
    case 2: self = .ofDouble
    case 3: self = .ofString
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .ofBool: return 0
    case .ofInt: return 1
    case .ofDouble: return 2
    case .ofString: return 3
    }
  }

}

#if swift(>=4.2)

extension MeegoRust_Proto_DataType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// The instance of a MeegoDB created from rust-sdk side of which implementation based on squam-db. 
struct MeegoRust_Proto_MeegoDb {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var handle: Int64 {
    get {return _handle ?? 0}
    set {_handle = newValue}
  }
  /// Returns true if `handle` has been explicitly set.
  var hasHandle: Bool {return self._handle != nil}
  /// Clears the value of `handle`. Subsequent reads from it will return its default value.
  mutating func clearHandle() {self._handle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _handle: Int64? = nil
}

/// config the meego db 
struct MeegoRust_Proto_RustConfigMeegoDbParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _path: String? = nil
}

/// Open or created if not exists the meego db. 
struct MeegoRust_Proto_RustGetMeegoDbParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scope: MeegoRust_Proto_MeegoDbScope {
    get {return _scope ?? MeegoRust_Proto_MeegoDbScope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {self._scope = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scope: MeegoRust_Proto_MeegoDbScope? = nil
}

/// Open or created if not exists the meego db. 
struct MeegoRust_Proto_RustGetMeegoDbReturn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ret: MeegoRust_Proto_MeegoDb {
    get {return _ret ?? MeegoRust_Proto_MeegoDb()}
    set {_ret = newValue}
  }
  /// Returns true if `ret` has been explicitly set.
  var hasRet: Bool {return self._ret != nil}
  /// Clears the value of `ret`. Subsequent reads from it will return its default value.
  mutating func clearRet() {self._ret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ret: MeegoRust_Proto_MeegoDb? = nil
}

/// Open or created if not exists the meego db. 
struct MeegoRust_Proto_RustGetMeegoDbError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: MeegoRust_Proto_MeegoDbError {
    get {return _err ?? MeegoRust_Proto_MeegoDbError()}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: MeegoRust_Proto_MeegoDbError? = nil
}

/// Close the meego db. 
struct MeegoRust_Proto_RustCloseMeegoDbParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scope: MeegoRust_Proto_MeegoDbScope {
    get {return _scope ?? MeegoRust_Proto_MeegoDbScope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  mutating func clearScope() {self._scope = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scope: MeegoRust_Proto_MeegoDbScope? = nil
}

/// Close the meego db. 
struct MeegoRust_Proto_RustCloseMeegoDbError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: MeegoRust_Proto_MeegoDbError {
    get {return _err ?? MeegoRust_Proto_MeegoDbError()}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: MeegoRust_Proto_MeegoDbError? = nil
}

struct MeegoRust_Proto_MeegoDbScope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inner: MeegoRust_Proto_MeegoDbScope.OneOf_Inner? = nil

  var memory: Bool {
    get {
      if case .memory(let v)? = inner {return v}
      return false
    }
    set {inner = .memory(newValue)}
  }

  var global: Bool {
    get {
      if case .global(let v)? = inner {return v}
      return false
    }
    set {inner = .global(newValue)}
  }

  /// The id of user. 
  var user: String {
    get {
      if case .user(let v)? = inner {return v}
      return String()
    }
    set {inner = .user(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Inner: Equatable {
    case memory(Bool)
    case global(Bool)
    /// The id of user. 
    case user(String)

  #if !swift(>=4.1)
    static func ==(lhs: MeegoRust_Proto_MeegoDbScope.OneOf_Inner, rhs: MeegoRust_Proto_MeegoDbScope.OneOf_Inner) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.memory, .memory): return {
        guard case .memory(let l) = lhs, case .memory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.global, .global): return {
        guard case .global(let l) = lhs, case .global(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.user, .user): return {
        guard case .user(let l) = lhs, case .user(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// The error occured in MeegoDB related APIs. 
struct MeegoRust_Proto_MeegoDbError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inner: MeegoRust_Proto_MeegoDbError.OneOf_Inner? = nil

  /// The error marked as database category. 
  var database: String {
    get {
      if case .database(let v)? = inner {return v}
      return String()
    }
    set {inner = .database(newValue)}
  }

  /// The error marked as handle category. 
  var handle: String {
    get {
      if case .handle(let v)? = inner {return v}
      return String()
    }
    set {inner = .handle(newValue)}
  }

  /// The error marked as io category. 
  var io: String {
    get {
      if case .io(let v)? = inner {return v}
      return String()
    }
    set {inner = .io(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Inner: Equatable {
    /// The error marked as database category. 
    case database(String)
    /// The error marked as handle category. 
    case handle(String)
    /// The error marked as io category. 
    case io(String)

  #if !swift(>=4.1)
    static func ==(lhs: MeegoRust_Proto_MeegoDbError.OneOf_Inner, rhs: MeegoRust_Proto_MeegoDbError.OneOf_Inner) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.database, .database): return {
        guard case .database(let l) = lhs, case .database(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.handle, .handle): return {
        guard case .handle(let l) = lhs, case .handle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.io, .io): return {
        guard case .io(let l) = lhs, case .io(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct MeegoRust_Proto_DataValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inner: MeegoRust_Proto_DataValue.OneOf_Inner? = nil

  var ofBool: Bool {
    get {
      if case .ofBool(let v)? = inner {return v}
      return false
    }
    set {inner = .ofBool(newValue)}
  }

  var ofInt: Int64 {
    get {
      if case .ofInt(let v)? = inner {return v}
      return 0
    }
    set {inner = .ofInt(newValue)}
  }

  var ofDouble: Double {
    get {
      if case .ofDouble(let v)? = inner {return v}
      return 0
    }
    set {inner = .ofDouble(newValue)}
  }

  var ofString: String {
    get {
      if case .ofString(let v)? = inner {return v}
      return String()
    }
    set {inner = .ofString(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Inner: Equatable {
    case ofBool(Bool)
    case ofInt(Int64)
    case ofDouble(Double)
    case ofString(String)

  #if !swift(>=4.1)
    static func ==(lhs: MeegoRust_Proto_DataValue.OneOf_Inner, rhs: MeegoRust_Proto_DataValue.OneOf_Inner) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ofBool, .ofBool): return {
        guard case .ofBool(let l) = lhs, case .ofBool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ofInt, .ofInt): return {
        guard case .ofInt(let l) = lhs, case .ofInt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ofDouble, .ofDouble): return {
        guard case .ofDouble(let l) = lhs, case .ofDouble(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ofString, .ofString): return {
        guard case .ofString(let l) = lhs, case .ofString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// 根据 key 获取 MeegoKV 表 domain 中的 type 值 
struct MeegoRust_Proto_RustKvGetParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataType: MeegoRust_Proto_DataType {
    get {return _dataType ?? .ofBool}
    set {_dataType = newValue}
  }
  /// Returns true if `dataType` has been explicitly set.
  var hasDataType: Bool {return self._dataType != nil}
  /// Clears the value of `dataType`. Subsequent reads from it will return its default value.
  mutating func clearDataType() {self._dataType = nil}

  var db: MeegoRust_Proto_MeegoDb {
    get {return _db ?? MeegoRust_Proto_MeegoDb()}
    set {_db = newValue}
  }
  /// Returns true if `db` has been explicitly set.
  var hasDb: Bool {return self._db != nil}
  /// Clears the value of `db`. Subsequent reads from it will return its default value.
  mutating func clearDb() {self._db = nil}

  var domain: String {
    get {return _domain ?? String()}
    set {_domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  var hasDomain: Bool {return self._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  mutating func clearDomain() {self._domain = nil}

  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dataType: MeegoRust_Proto_DataType? = nil
  fileprivate var _db: MeegoRust_Proto_MeegoDb? = nil
  fileprivate var _domain: String? = nil
  fileprivate var _key: String? = nil
}

/// 根据 key 获取 MeegoKV 表 domain 中的 type 值 
struct MeegoRust_Proto_RustKvGetReturn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ret: MeegoRust_Proto_DataValue {
    get {return _ret ?? MeegoRust_Proto_DataValue()}
    set {_ret = newValue}
  }
  /// Returns true if `ret` has been explicitly set.
  var hasRet: Bool {return self._ret != nil}
  /// Clears the value of `ret`. Subsequent reads from it will return its default value.
  mutating func clearRet() {self._ret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ret: MeegoRust_Proto_DataValue? = nil
}

/// 根据 key 获取 MeegoKV 表 domain 中的 type 值 
struct MeegoRust_Proto_RustKvGetError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: MeegoRust_Proto_MeegoDbError {
    get {return _err ?? MeegoRust_Proto_MeegoDbError()}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: MeegoRust_Proto_MeegoDbError? = nil
}

/// 设置 MeegoKV 表 domain 中 key 的值为 value 
struct MeegoRust_Proto_RustKvSetParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isAsync: Bool {
    get {return _isAsync ?? false}
    set {_isAsync = newValue}
  }
  /// Returns true if `isAsync` has been explicitly set.
  var hasIsAsync: Bool {return self._isAsync != nil}
  /// Clears the value of `isAsync`. Subsequent reads from it will return its default value.
  mutating func clearIsAsync() {self._isAsync = nil}

  var db: MeegoRust_Proto_MeegoDb {
    get {return _db ?? MeegoRust_Proto_MeegoDb()}
    set {_db = newValue}
  }
  /// Returns true if `db` has been explicitly set.
  var hasDb: Bool {return self._db != nil}
  /// Clears the value of `db`. Subsequent reads from it will return its default value.
  mutating func clearDb() {self._db = nil}

  var domain: String {
    get {return _domain ?? String()}
    set {_domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  var hasDomain: Bool {return self._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  mutating func clearDomain() {self._domain = nil}

  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var value: MeegoRust_Proto_DataValue {
    get {return _value ?? MeegoRust_Proto_DataValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var expiredMillis: Int64 {
    get {return _expiredMillis ?? 0}
    set {_expiredMillis = newValue}
  }
  /// Returns true if `expiredMillis` has been explicitly set.
  var hasExpiredMillis: Bool {return self._expiredMillis != nil}
  /// Clears the value of `expiredMillis`. Subsequent reads from it will return its default value.
  mutating func clearExpiredMillis() {self._expiredMillis = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isAsync: Bool? = nil
  fileprivate var _db: MeegoRust_Proto_MeegoDb? = nil
  fileprivate var _domain: String? = nil
  fileprivate var _key: String? = nil
  fileprivate var _value: MeegoRust_Proto_DataValue? = nil
  fileprivate var _expiredMillis: Int64? = nil
}

/// 设置 MeegoKV 表 domain 中 key 的值为 value 
struct MeegoRust_Proto_RustKvSetError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: MeegoRust_Proto_MeegoDbError {
    get {return _err ?? MeegoRust_Proto_MeegoDbError()}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: MeegoRust_Proto_MeegoDbError? = nil
}

/// 添加一条用户记录 
struct MeegoRust_Proto_UserTrackAddParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var db: MeegoRust_Proto_MeegoDb {
    get {return _db ?? MeegoRust_Proto_MeegoDb()}
    set {_db = newValue}
  }
  /// Returns true if `db` has been explicitly set.
  var hasDb: Bool {return self._db != nil}
  /// Clears the value of `db`. Subsequent reads from it will return its default value.
  mutating func clearDb() {self._db = nil}

  var larkScene: Int64 {
    get {return _larkScene ?? 0}
    set {_larkScene = newValue}
  }
  /// Returns true if `larkScene` has been explicitly set.
  var hasLarkScene: Bool {return self._larkScene != nil}
  /// Clears the value of `larkScene`. Subsequent reads from it will return its default value.
  mutating func clearLarkScene() {self._larkScene = nil}

  var meegoScene: String {
    get {return _meegoScene ?? String()}
    set {_meegoScene = newValue}
  }
  /// Returns true if `meegoScene` has been explicitly set.
  var hasMeegoScene: Bool {return self._meegoScene != nil}
  /// Clears the value of `meegoScene`. Subsequent reads from it will return its default value.
  mutating func clearMeegoScene() {self._meegoScene = nil}

  var action: Int64 {
    get {return _action ?? 0}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var timestampMillis: Int64 {
    get {return _timestampMillis ?? 0}
    set {_timestampMillis = newValue}
  }
  /// Returns true if `timestampMillis` has been explicitly set.
  var hasTimestampMillis: Bool {return self._timestampMillis != nil}
  /// Clears the value of `timestampMillis`. Subsequent reads from it will return its default value.
  mutating func clearTimestampMillis() {self._timestampMillis = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _db: MeegoRust_Proto_MeegoDb? = nil
  fileprivate var _larkScene: Int64? = nil
  fileprivate var _meegoScene: String? = nil
  fileprivate var _action: Int64? = nil
  fileprivate var _timestampMillis: Int64? = nil
}

/// 添加一条用户记录 
struct MeegoRust_Proto_UserTrackAddError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: MeegoRust_Proto_MeegoDbError {
    get {return _err ?? MeegoRust_Proto_MeegoDbError()}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: MeegoRust_Proto_MeegoDbError? = nil
}

/// 获取 after_time_stamp_millis 之后的 action 总数，lark_scene 为空取全集，meego_scene 为空取全集 
struct MeegoRust_Proto_UserTrackCountParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var db: MeegoRust_Proto_MeegoDb {
    get {return _db ?? MeegoRust_Proto_MeegoDb()}
    set {_db = newValue}
  }
  /// Returns true if `db` has been explicitly set.
  var hasDb: Bool {return self._db != nil}
  /// Clears the value of `db`. Subsequent reads from it will return its default value.
  mutating func clearDb() {self._db = nil}

  var larkScene: Int64 {
    get {return _larkScene ?? 0}
    set {_larkScene = newValue}
  }
  /// Returns true if `larkScene` has been explicitly set.
  var hasLarkScene: Bool {return self._larkScene != nil}
  /// Clears the value of `larkScene`. Subsequent reads from it will return its default value.
  mutating func clearLarkScene() {self._larkScene = nil}

  var meegoScene: String {
    get {return _meegoScene ?? String()}
    set {_meegoScene = newValue}
  }
  /// Returns true if `meegoScene` has been explicitly set.
  var hasMeegoScene: Bool {return self._meegoScene != nil}
  /// Clears the value of `meegoScene`. Subsequent reads from it will return its default value.
  mutating func clearMeegoScene() {self._meegoScene = nil}

  var action: Int64 {
    get {return _action ?? 0}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var afterTimeStampMillis: Int64 {
    get {return _afterTimeStampMillis ?? 0}
    set {_afterTimeStampMillis = newValue}
  }
  /// Returns true if `afterTimeStampMillis` has been explicitly set.
  var hasAfterTimeStampMillis: Bool {return self._afterTimeStampMillis != nil}
  /// Clears the value of `afterTimeStampMillis`. Subsequent reads from it will return its default value.
  mutating func clearAfterTimeStampMillis() {self._afterTimeStampMillis = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _db: MeegoRust_Proto_MeegoDb? = nil
  fileprivate var _larkScene: Int64? = nil
  fileprivate var _meegoScene: String? = nil
  fileprivate var _action: Int64? = nil
  fileprivate var _afterTimeStampMillis: Int64? = nil
}

/// 获取 after_time_stamp_millis 之后的 action 总数，lark_scene 为空取全集，meego_scene 为空取全集 
struct MeegoRust_Proto_UserTrackCountReturn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ret: Int64 {
    get {return _ret ?? 0}
    set {_ret = newValue}
  }
  /// Returns true if `ret` has been explicitly set.
  var hasRet: Bool {return self._ret != nil}
  /// Clears the value of `ret`. Subsequent reads from it will return its default value.
  mutating func clearRet() {self._ret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ret: Int64? = nil
}

/// 获取 after_time_stamp_millis 之后的 action 总数，lark_scene 为空取全集，meego_scene 为空取全集 
struct MeegoRust_Proto_UserTrackCountError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: MeegoRust_Proto_MeegoDbError {
    get {return _err ?? MeegoRust_Proto_MeegoDbError()}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: MeegoRust_Proto_MeegoDbError? = nil
}

/// 删除 before_time_stamp_millis 之前的数据 
struct MeegoRust_Proto_UserTrackDeleteParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var db: MeegoRust_Proto_MeegoDb {
    get {return _db ?? MeegoRust_Proto_MeegoDb()}
    set {_db = newValue}
  }
  /// Returns true if `db` has been explicitly set.
  var hasDb: Bool {return self._db != nil}
  /// Clears the value of `db`. Subsequent reads from it will return its default value.
  mutating func clearDb() {self._db = nil}

  var beforeTimeStampMillis: Int64 {
    get {return _beforeTimeStampMillis ?? 0}
    set {_beforeTimeStampMillis = newValue}
  }
  /// Returns true if `beforeTimeStampMillis` has been explicitly set.
  var hasBeforeTimeStampMillis: Bool {return self._beforeTimeStampMillis != nil}
  /// Clears the value of `beforeTimeStampMillis`. Subsequent reads from it will return its default value.
  mutating func clearBeforeTimeStampMillis() {self._beforeTimeStampMillis = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _db: MeegoRust_Proto_MeegoDb? = nil
  fileprivate var _beforeTimeStampMillis: Int64? = nil
}

/// 删除 before_time_stamp_millis 之前的数据 
struct MeegoRust_Proto_UserTrackDeleteError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var err: MeegoRust_Proto_MeegoDbError {
    get {return _err ?? MeegoRust_Proto_MeegoDbError()}
    set {_err = newValue}
  }
  /// Returns true if `err` has been explicitly set.
  var hasErr: Bool {return self._err != nil}
  /// Clears the value of `err`. Subsequent reads from it will return its default value.
  mutating func clearErr() {self._err = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _err: MeegoRust_Proto_MeegoDbError? = nil
}

struct MeegoRust_Proto___molten_ffi_placeholder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension MeegoRust_Proto_DataType: @unchecked Sendable {}
extension MeegoRust_Proto_MeegoDb: @unchecked Sendable {}
extension MeegoRust_Proto_RustConfigMeegoDbParams: @unchecked Sendable {}
extension MeegoRust_Proto_RustGetMeegoDbParams: @unchecked Sendable {}
extension MeegoRust_Proto_RustGetMeegoDbReturn: @unchecked Sendable {}
extension MeegoRust_Proto_RustGetMeegoDbError: @unchecked Sendable {}
extension MeegoRust_Proto_RustCloseMeegoDbParams: @unchecked Sendable {}
extension MeegoRust_Proto_RustCloseMeegoDbError: @unchecked Sendable {}
extension MeegoRust_Proto_MeegoDbScope: @unchecked Sendable {}
extension MeegoRust_Proto_MeegoDbScope.OneOf_Inner: @unchecked Sendable {}
extension MeegoRust_Proto_MeegoDbError: @unchecked Sendable {}
extension MeegoRust_Proto_MeegoDbError.OneOf_Inner: @unchecked Sendable {}
extension MeegoRust_Proto_DataValue: @unchecked Sendable {}
extension MeegoRust_Proto_DataValue.OneOf_Inner: @unchecked Sendable {}
extension MeegoRust_Proto_RustKvGetParams: @unchecked Sendable {}
extension MeegoRust_Proto_RustKvGetReturn: @unchecked Sendable {}
extension MeegoRust_Proto_RustKvGetError: @unchecked Sendable {}
extension MeegoRust_Proto_RustKvSetParams: @unchecked Sendable {}
extension MeegoRust_Proto_RustKvSetError: @unchecked Sendable {}
extension MeegoRust_Proto_UserTrackAddParams: @unchecked Sendable {}
extension MeegoRust_Proto_UserTrackAddError: @unchecked Sendable {}
extension MeegoRust_Proto_UserTrackCountParams: @unchecked Sendable {}
extension MeegoRust_Proto_UserTrackCountReturn: @unchecked Sendable {}
extension MeegoRust_Proto_UserTrackCountError: @unchecked Sendable {}
extension MeegoRust_Proto_UserTrackDeleteParams: @unchecked Sendable {}
extension MeegoRust_Proto_UserTrackDeleteError: @unchecked Sendable {}
extension MeegoRust_Proto___molten_ffi_placeholder: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "meego_rust.proto"

extension MeegoRust_Proto_MeegoDb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".MeegoDb"

  public var isInitialized: Bool {
    if self._handle == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._handle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._handle {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_MeegoDb, rhs: MeegoRust_Proto_MeegoDb) -> Bool {
    if lhs._handle != rhs._handle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustConfigMeegoDbParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustConfigMeegoDbParams"

  public var isInitialized: Bool {
    if self._path == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustConfigMeegoDbParams, rhs: MeegoRust_Proto_RustConfigMeegoDbParams) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustGetMeegoDbParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustGetMeegoDbParams"

  public var isInitialized: Bool {
    if self._scope == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustGetMeegoDbParams, rhs: MeegoRust_Proto_RustGetMeegoDbParams) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustGetMeegoDbReturn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustGetMeegoDbReturn"

  public var isInitialized: Bool {
    if self._ret == nil {return false}
    if let v = self._ret, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ret {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustGetMeegoDbReturn, rhs: MeegoRust_Proto_RustGetMeegoDbReturn) -> Bool {
    if lhs._ret != rhs._ret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustGetMeegoDbError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustGetMeegoDbError"

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._err {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustGetMeegoDbError, rhs: MeegoRust_Proto_RustGetMeegoDbError) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustCloseMeegoDbParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustCloseMeegoDbParams"

  public var isInitialized: Bool {
    if self._scope == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustCloseMeegoDbParams, rhs: MeegoRust_Proto_RustCloseMeegoDbParams) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustCloseMeegoDbError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustCloseMeegoDbError"

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._err {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustCloseMeegoDbError, rhs: MeegoRust_Proto_RustCloseMeegoDbError) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_MeegoDbScope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".MeegoDbScope"

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .memory(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .global(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .user(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.inner {
    case .memory?: try {
      guard case .memory(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .global?: try {
      guard case .global(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .user?: try {
      guard case .user(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_MeegoDbScope, rhs: MeegoRust_Proto_MeegoDbScope) -> Bool {
    if lhs.inner != rhs.inner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_MeegoDbError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".MeegoDbError"

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .database(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .handle(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .io(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.inner {
    case .database?: try {
      guard case .database(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .handle?: try {
      guard case .handle(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .io?: try {
      guard case .io(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_MeegoDbError, rhs: MeegoRust_Proto_MeegoDbError) -> Bool {
    if lhs.inner != rhs.inner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_DataValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".DataValue"

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .ofBool(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .ofInt(v)
        }
      }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .ofDouble(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.inner != nil {try decoder.handleConflictingOneOf()}
          self.inner = .ofString(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.inner {
    case .ofBool?: try {
      guard case .ofBool(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .ofInt?: try {
      guard case .ofInt(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .ofDouble?: try {
      guard case .ofDouble(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .ofString?: try {
      guard case .ofString(let v)? = self.inner else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_DataValue, rhs: MeegoRust_Proto_DataValue) -> Bool {
    if lhs.inner != rhs.inner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustKvGetParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustKvGetParams"

  public var isInitialized: Bool {
    if self._dataType == nil {return false}
    if self._db == nil {return false}
    if self._domain == nil {return false}
    if self._key == nil {return false}
    if let v = self._db, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._dataType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._db) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._domain) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dataType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._db {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._domain {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustKvGetParams, rhs: MeegoRust_Proto_RustKvGetParams) -> Bool {
    if lhs._dataType != rhs._dataType {return false}
    if lhs._db != rhs._db {return false}
    if lhs._domain != rhs._domain {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustKvGetReturn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustKvGetReturn"

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ret {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustKvGetReturn, rhs: MeegoRust_Proto_RustKvGetReturn) -> Bool {
    if lhs._ret != rhs._ret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustKvGetError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustKvGetError"

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._err {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustKvGetError, rhs: MeegoRust_Proto_RustKvGetError) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustKvSetParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustKvSetParams"

  public var isInitialized: Bool {
    if self._isAsync == nil {return false}
    if self._db == nil {return false}
    if self._domain == nil {return false}
    if self._key == nil {return false}
    if self._value == nil {return false}
    if let v = self._db, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isAsync) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._db) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._domain) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self._expiredMillis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isAsync {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._db {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._domain {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._expiredMillis {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustKvSetParams, rhs: MeegoRust_Proto_RustKvSetParams) -> Bool {
    if lhs._isAsync != rhs._isAsync {return false}
    if lhs._db != rhs._db {return false}
    if lhs._domain != rhs._domain {return false}
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs._expiredMillis != rhs._expiredMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_RustKvSetError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".RustKvSetError"

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._err {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_RustKvSetError, rhs: MeegoRust_Proto_RustKvSetError) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_UserTrackAddParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".UserTrackAddParams"

  public var isInitialized: Bool {
    if self._db == nil {return false}
    if self._larkScene == nil {return false}
    if self._meegoScene == nil {return false}
    if self._action == nil {return false}
    if self._timestampMillis == nil {return false}
    if let v = self._db, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._db) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._larkScene) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._meegoScene) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._action) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._timestampMillis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._db {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._larkScene {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._meegoScene {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timestampMillis {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_UserTrackAddParams, rhs: MeegoRust_Proto_UserTrackAddParams) -> Bool {
    if lhs._db != rhs._db {return false}
    if lhs._larkScene != rhs._larkScene {return false}
    if lhs._meegoScene != rhs._meegoScene {return false}
    if lhs._action != rhs._action {return false}
    if lhs._timestampMillis != rhs._timestampMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_UserTrackAddError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".UserTrackAddError"

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._err {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_UserTrackAddError, rhs: MeegoRust_Proto_UserTrackAddError) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_UserTrackCountParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".UserTrackCountParams"

  public var isInitialized: Bool {
    if self._db == nil {return false}
    if self._action == nil {return false}
    if self._afterTimeStampMillis == nil {return false}
    if let v = self._db, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._db) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._larkScene) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._meegoScene) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._action) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self._afterTimeStampMillis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._db {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._larkScene {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._meegoScene {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._afterTimeStampMillis {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_UserTrackCountParams, rhs: MeegoRust_Proto_UserTrackCountParams) -> Bool {
    if lhs._db != rhs._db {return false}
    if lhs._larkScene != rhs._larkScene {return false}
    if lhs._meegoScene != rhs._meegoScene {return false}
    if lhs._action != rhs._action {return false}
    if lhs._afterTimeStampMillis != rhs._afterTimeStampMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_UserTrackCountReturn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".UserTrackCountReturn"

  public var isInitialized: Bool {
    if self._ret == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self._ret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ret {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_UserTrackCountReturn, rhs: MeegoRust_Proto_UserTrackCountReturn) -> Bool {
    if lhs._ret != rhs._ret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_UserTrackCountError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".UserTrackCountError"

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._err {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_UserTrackCountError, rhs: MeegoRust_Proto_UserTrackCountError) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_UserTrackDeleteParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".UserTrackDeleteParams"

  public var isInitialized: Bool {
    if self._db == nil {return false}
    if self._beforeTimeStampMillis == nil {return false}
    if let v = self._db, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._db) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._beforeTimeStampMillis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._db {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._beforeTimeStampMillis {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_UserTrackDeleteParams, rhs: MeegoRust_Proto_UserTrackDeleteParams) -> Bool {
    if lhs._db != rhs._db {return false}
    if lhs._beforeTimeStampMillis != rhs._beforeTimeStampMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto_UserTrackDeleteError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".UserTrackDeleteError"

  public var isInitialized: Bool {
    if self._err == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._err) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._err {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto_UserTrackDeleteError, rhs: MeegoRust_Proto_UserTrackDeleteError) -> Bool {
    if lhs._err != rhs._err {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MeegoRust_Proto___molten_ffi_placeholder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase {
  static let protoMessageName: String = _protobuf_package + ".__molten_ffi_placeholder"

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MeegoRust_Proto___molten_ffi_placeholder, rhs: MeegoRust_Proto___molten_ffi_placeholder) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
