#ifdef __cplusplus
#ifndef BACH_NAIL_SLAM_BUFFER_H
#define BACH_NAIL_SLAM_BUFFER_H

#include "Bach/Base/BachAlgorithmBuffer.h"
#include "Bach/Algorithm/AlgorithmInfo.h"
#include "Gaia/AMGPrimitiveVector.h"

NAMESPACE_BACH_BEGIN

///------------------ AR Trackers Define ----------------------------
enum class AMGTrackerPhase
{
    Added = 0, //A Tracker Added Automatically by ARKit
    Update,    //When ARKit to Ajustment its world pose
    Removed,   //A Tracker Removed Automatically by ARKit
};

enum class AMGTrackerType
{
    Unkown = 0,
    Plane, //Plane Anchor when ARKit chooses the planeDetection config
    Face,
    Image,
    Object,
    Point
};

enum class AMGTrackingState
{
    None = 0,
    Limited = 1,
    Tracking = 2
};

enum class AMGPlaneAlignment
{
    None = 0,
    HorizontalUp = 100,
    HorizontalDown = 101,
    Vertical = 200,
    NotAxisAligned = 300
};

//The Tracker Result of the Anchor generated by ARKit
class BACH_EXPORT AETrackable : public AmazingEngine::RefBase
{
public:
    AETrackable() = default;

    virtual ~AETrackable() {}

    virtual AmazingEngine::Matrix4x4f getTransform() const
    {
        return AmazingEngine::Matrix4x4f();
    }

    virtual float getOffset() const
    {
        return 0.0f;
    }

    virtual AmazingEngine::Vector3f getNormal()
    {
        return AmazingEngine::Vector3f();
    }

    virtual AMGPlaneAlignment alignment() const
    {
        return AMGPlaneAlignment::None;
    }

    virtual AmazingEngine::Vector3f getCenter() const
    {
        return AmazingEngine::Vector3f();
    }

    virtual std::vector<AmazingEngine::Vector3f>& boundary()
    {
        return mBoundary;
    }

    void setTrackId(const std::string& trackId) { mTrackId = trackId; }
    std::string getTrackId() const { return mTrackId; }

    void setTrackType(AMGTrackerType type) { mType = type; }
    AMGTrackerType getTrackType() const { return mType; }
    void setTrackPhase(AMGTrackerPhase phase) { mPhase = phase; }
    AMGTrackerPhase getTrackPhase() const { return mPhase; }
    void setTrackingState(AMGTrackingState state) { mState = state; }
    AMGTrackingState getTrackingState() const { return mState; }

    void pending(bool pending) { mPending = pending; }
    bool isPending() const { return mPending; }
    void removeOnDestroy(bool removeOnDestroy) { mRemoveOnDestroy = removeOnDestroy; }
    bool shouldRemoveOnDestroy() const { return mRemoveOnDestroy; }

protected:
    std::string mTrackId = "";
    AMGTrackerType mType = AMGTrackerType::Unkown;
    AMGTrackerPhase mPhase = AMGTrackerPhase::Added;
    AMGTrackingState mState = AMGTrackingState::None;
    bool mPending = true;
    bool mRemoveOnDestroy = true;

private:
    // only for build
    std::vector<AmazingEngine::Vector3f> mBoundary;
};

class BACH_EXPORT SlamTouchInfo : public AmazingEngine::RefBase
{
public:
    AmazingEngine::Matrix4x4f worldTransform;
    bool touchDirty = false;
    float touchX = 0.5;
    float touchY = 0.5;

    void toMap(BachMap& info) const;
    void fromMap(const BachMap& info);
};

class BACH_EXPORT SlamHitResult : public AmazingEngine::RefBase
{
public:
    int mIndex;
    std::string mTrackId;
    AmazingEngine::Matrix4x4f mLocalTransform = AmazingEngine::Matrix4x4f::identity();
    AmazingEngine::Matrix4x4f mWorldTransform = AmazingEngine::Matrix4x4f::identity();
    bool mDirty = false;
    bool mActive = false;
    bool mCastHit = false;
};

class BACH_EXPORT SlamCircle : public AmazingEngine::RefBase
{
public:
    int ID;
    float radius;
    AmazingEngine::Vector3f position;
    AmazingEngine::Vector3f normal;
    bool hasEllipse = false;

    void toMap(BachMap& info) const;
    void fromMap(const BachMap& info);
};

class BACH_EXPORT SlamVideoResult : public AmazingEngine::RefBase
{
public:
    // frames;
    int frameSize;
    AmazingEngine::Mat4Vector frameViews;
    AmazingEngine::Int32Vector frameTrackStatus;
    AmazingEngine::Int32Vector framePointSizes;
    AmazingEngine::Int32Vector frameValidPointSizes;
    AmazingEngine::FloatVector frameDepths; // new added by xiaodong, frame Idx-matting_mask depth dict
    AmazingEngine::Matrix4x4f projection;
};

class BACH_EXPORT SlamResult : public AmazingEngine::RefBase
{
public:
    bool projDirty = false;
    AmazingEngine::Matrix4x4f projection; // 平面投影矩阵
    AmazingEngine::Matrix4x4f view;       // 相机的位置
    AmazingEngine::Vector4f colorCorrection;
    bool enable = false;
    int trackStatus = -1;
    bool executed = false;
    bool hitTestAuto = false; //by ARKit
    bool planeUpdate = false;
    int sizeOfFeaturePoints = 0;
    AmazingEngine::FloatVector featurePoints; // 返回的特征点，x,y坐标顺序存储
    AmazingEngine::FloatVector depths;        // 特征点对应的深度信息
    bool withDepth = false;
    int planeDetected = 0; // 1: detected  0:otherwise
    int trackingStateReason = 0;
    std::vector<AmazingEngine::SharePtr<AETrackable>> trackables;
    std::vector<AmazingEngine::SharePtr<SlamHitResult>> hitResults;
    AmazingEngine::SharePtr<SlamTouchInfo> touchInfo;

    std::string mapData = "";                 // VPS mapData
    int fusionState = -1;                     // VPS fusion State
    void* algHandle = nullptr;                //for old GroundSeg
    AmazingEngine::Matrix4x4f planeTransform; // 平面信息的变换矩阵
    AmazingEngine::Vec3Vector hangboxDepths;  // [autohang]
    AmazingEngine::Vec2Vector cubePoints;

    float depthRangeMin = 0;
    float depthRangeMax = 0;
    int depthImageWidth = 0;
    int depthImageHeight = 0;
    AmazingEngine::UInt8Vector depthImage;

    void toMap(BachMap& info) const;
    void fromMap(const BachMap& info);
};

class BACH_EXPORT SlamBuffer : public BachBuffer
{
public:
    AmazingEngine::SharePtr<SlamResult> m_slamInfo;
    AmazingEngine::SharePtr<SlamCircle> m_slamCircle;
    AmazingEngine::SharePtr<SlamVideoResult> m_slamVideoInfo;

    void toMapBuffer(BachBuffer& buffer) const;
    void fromMapBuffer(const BachBuffer& buffer);
    SlamBuffer* _clone() const override
    {
        return nullptr;
    }
};

NAMESPACE_BACH_END
#endif

#endif