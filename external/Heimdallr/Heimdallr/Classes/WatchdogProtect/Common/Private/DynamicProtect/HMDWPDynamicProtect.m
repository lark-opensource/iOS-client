//
//  HMDWPDynamicProtect.m
//  Heimdallr
//
//  Created by chengchao.cc on 2021/8/31.
//

#import "HMDWPDynamicProtect.h"
#import "HMDSwizzle.h"
#import "HMDWatchdogProtectManager.h"
#import "HMDWPUtility.h"
#import "HMDMacro.h"
#import "NSDictionary+HMDSafe.h"
#import "pthread_extended.h"
#import <Stinger/Stinger.h>
#import <objc/objc.h>
#import "HMDStingerBlocker.h"
#import "hmd_crash_safe_tool.h"
#import "HMDALogProtocol.h"
#import "HMDWPDynamicSafeData.h"
#import "HMDDynamicCall.h"
#import "HMDWPDynamicSafeData+ThreadSynchronize.h"

static pthread_rwlock_t callbackLock = PTHREAD_RWLOCK_INITIALIZER;
static HMDWPExceptionCallback internal_exception_callback;

static void hmd_wp_dynamic_capture(HMDWPCapture * capture);

/*!@protocol HMDStingerUpdate
  @discussion 因为在 Stinger 1.1.0 版本，支持 -[id<StingerParams> preGenerateInvocationIfNeed] 方法
   我又没有办法把每个小业务给说动同步升级 Heimdallr + Stinger 版本；出此下策，望大家谅解
 */
@protocol HMDStingerUpdate <NSObject>

- (void)preGenerateInvocationIfNeed;

@end

@interface HMDWPDynamicProtect : NSObject

+ (instancetype)sharedInstance;

- (void)protectMethodsOnMainThread:(NSArray<NSString *> *)mainThreadMethodCollection
                       onAnyThread:(NSArray<NSString *> *)anyThreadMethodCollection;

@property (nonatomic, strong) NSMutableSet<NSString *>* swizzledMethodSet;

#define mainThreadOnlyNumber @(1)
#define anyThreadPossibleNumber @(0)

/*! @property protectedMethodDictionary
    @discussion the key is NSString generated by HMDValidatedMethod.methodString
                the value is NSNumber, it is @(1) if only protect on main thread, it is @(0) if not only on main thread */
@property (atomic, copy) NSDictionary<NSString *, NSNumber *> *protectedMethodDictionary;

@end

#pragma mark - Export function

extern void hmd_wp_toggle_dynamic_protection(NSArray<NSString *> *methodsOnlyMainThread,
                                             NSArray<NSString *> *methodsAnyThread,
                                             HMDWPExceptionCallback _Nullable callback) {
    int lock_rst = pthread_rwlock_wrlock(&callbackLock);
    internal_exception_callback = callback;
    if (lock_rst == 0) pthread_rwlock_unlock(&callbackLock);
    
    // 下发新配置后，及时更新
    [HMDWPDynamicProtect.sharedInstance protectMethodsOnMainThread:methodsOnlyMainThread
                                                       onAnyThread:methodsAnyThread];
}

NSSet<NSString *> *hmd_wp_dynamic_protect_method_set(void) {
    return [[NSSet alloc] initWithArray:HMDWPDynamicProtect.sharedInstance.protectedMethodDictionary.allKeys];
}

static void hmd_wp_dynamic_capture(HMDWPCapture * capture) {
    if (!capture) {
        return;
    }
    
    int lock_rst = pthread_rwlock_rdlock(&callbackLock);
    HMDWPExceptionCallback callback = internal_exception_callback;
    if (lock_rst == 0) {
        pthread_rwlock_unlock(&callbackLock);
    }
    
    if (callback) {
        callback(capture);
    }
}


#pragma mark - Implementation

@interface HMDValidatedMethod : NSObject

@property (nonatomic, readonly, copy) NSString *validatedMethodName;
@property (nonatomic, readonly, copy) NSString *classString;
@property (nonatomic, readonly, copy) NSString *selectorString;
@property (nonatomic, readonly, strong) Class clazz;
@property (nonatomic, readonly, assign) SEL selector;
@property (nonatomic, readonly, assign) BOOL isInstance;

@end

@implementation HMDValidatedMethod

- (instancetype)initWithClassString:(NSString *)classString
                     selectorString:(NSString *)selectorString
                              clazz:(Class)clazz
                           selector:(SEL)selector
                         isInstance:(BOOL)isInstance {
    self = [super init];
    if (self) {
        _classString = [classString copy];
        _selectorString = [selectorString copy];
        _isInstance = isInstance;
        _clazz = clazz;
        _selector = selector;
        _validatedMethodName = [NSString stringWithFormat:@"%@[%@ %@]", _isInstance ? @"-" : @"+", _classString, _selectorString];
    }
    return self;
}

@end

@interface HMDWPDynamicProtect()

@property (nonatomic, strong) NSMutableArray<NSMutableData *> *waitFlags;

@end

@implementation HMDWPDynamicProtect

+ (instancetype)sharedInstance
{
    static HMDWPDynamicProtect *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[HMDWPDynamicProtect alloc] init];
    });
    return instance;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        _swizzledMethodSet = [NSMutableSet set];
        _protectedMethodDictionary = [NSMutableDictionary dictionary];
        _waitFlags = [NSMutableArray array];
    }
    return self;
}

// return nil if method name is not supported
+ (HMDValidatedMethod *)validatedMethodNameString:(NSString *)methodNameString error:(NSError **)error {
    
    static NSString * const HMDWatchdogProtectErrorUserInfoDescriptionKey = @"descrption";
    
    if (HMDIsEmptyString(methodNameString)) {
        if (error) {
            *error = [NSError errorWithDomain:HMDWatchdogProtectErrorDomain
                                         code:HMDWatchdogProtectErrorCodeDynamicMethodEmpty
                                     userInfo:@{HMDWatchdogProtectErrorUserInfoDescriptionKey: @"DynamicProtect fail due to methodString is emtpy"}];
        }
        return nil;
    }
    
    NSString *method = [methodNameString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    BOOL isInstance = NO;
    if ([method hasPrefix:@"+"]) {
        isInstance = NO;
    }
    else if ([method hasPrefix:@"-"]) {
        isInstance = YES;
    }
    else {
        if (error) {
            *error = [NSError errorWithDomain:HMDWatchdogProtectErrorDomain
                                         code:HMDWatchdogProtectErrorCodeDynamicMethodInvalidPrefix
                                     userInfo:@{HMDWatchdogProtectErrorUserInfoDescriptionKey: [NSString stringWithFormat:@"DynamicProtect fail due to invalid method prefix: %@", methodNameString] ?: @""}];
        }
        return nil;
    }
    
    method = [method substringFromIndex:1];
    method = [method stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (method.length > 2 && [method hasPrefix:@"["] && [method hasSuffix:@"]"]) {
        method = [method substringWithRange:NSMakeRange(1, method.length-2)];
    }
    NSArray<NSString *> *componentsList = [method componentsSeparatedByCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if (!(componentsList && componentsList.count == 2)) {
        if (error) {
            *error = [NSError errorWithDomain:HMDWatchdogProtectErrorDomain
                                         code:HMDWatchdogProtectErrorCodeDynamicMethodInvalidFormat
                                     userInfo:@{HMDWatchdogProtectErrorUserInfoDescriptionKey: [NSString stringWithFormat:@"DynamicProtect fail due to invalid method format: %@", methodNameString] ?: @""}];
        }
        return nil;
    }
    NSString *clsString = componentsList[0];
    NSString *selString = componentsList[1];
    if (HMDIsEmptyString(clsString) || HMDIsEmptyString(selString)) {
        if (error) {
            *error = [NSError errorWithDomain:HMDWatchdogProtectErrorDomain
                                         code:HMDWatchdogProtectErrorCodeDynamicMethodInvalidClassOrSelectorName
                                     userInfo:@{HMDWatchdogProtectErrorUserInfoDescriptionKey: [NSString stringWithFormat:@"DynamicProtect fail due to invalid class/selector name: %@", methodNameString] ?: @""}];
        }
        return nil;
    }
    
    // get Class, SEL
    Class cls = NSClassFromString(clsString);
    if (cls == NULL) {
        if (error) {
            *error = [NSError errorWithDomain:HMDWatchdogProtectErrorDomain
                                         code:HMDWatchdogProtectErrorCodeDynamicMethodInvalidClass
                                     userInfo:@{HMDWatchdogProtectErrorUserInfoDescriptionKey: [NSString stringWithFormat:@"DynamicProtect fail due to no such class: %@", methodNameString] ?: @""}];
        }
        return nil;
    }
    SEL sel = NSSelectorFromString(selString);
    if ([[HMDStingerBlocker sharedInstance] hitBlockListForCls:cls selector:sel isInstance:isInstance]) {
        if (error) {
            *error = [NSError errorWithDomain:HMDWatchdogProtectErrorDomain
                                         code:HMDWatchdogProtectErrorCodeDynamicMethodBlockedSelector
                                     userInfo:@{HMDWatchdogProtectErrorUserInfoDescriptionKey: [NSString stringWithFormat:@"DynamicProtect fail due to method is blocked by Stinger: %@", methodNameString] ?: @""}];
        }
        return nil;
    }
    
    HMDValidatedMethod *validatedMethod = [[HMDValidatedMethod alloc] initWithClassString:clsString
                                                                           selectorString:selString
                                                                                    clazz:cls
                                                                                 selector:sel
                                                                               isInstance:isInstance];
    return validatedMethod;
}

- (void)protectMethodsOnMainThread:(NSArray<NSString *> *)mainThreadMethodCollection
                       onAnyThread:(NSArray<NSString *> *)anyThreadMethodCollection {
    
    if (HMDIsEmptyArray(mainThreadMethodCollection) && HMDIsEmptyArray(anyThreadMethodCollection)) {
        return;
    }
    
    NSSet<NSString *> * mainThreadSet = nil;
    NSSet<NSString *> *  anyThreadSet = nil;
    
    if(!HMDIsEmptyArray(mainThreadMethodCollection)) {
        mainThreadSet = [self protectMethods:mainThreadMethodCollection];
    }
    if(!HMDIsEmptyArray(anyThreadMethodCollection)) {
         anyThreadSet = [self protectMethods:anyThreadMethodCollection];
    }
    
    NSMutableDictionary<NSString *, NSNumber *> *protectedMethodDictionary = [NSMutableDictionary dictionary];
    
    if(mainThreadSet != nil) {
        for(NSString *eachMethodName in mainThreadSet) {
            [protectedMethodDictionary setValue:mainThreadOnlyNumber forKey:eachMethodName];
        }
    }
    if(anyThreadSet != nil) {
        for(NSString *eachMethodName in anyThreadSet) {
            [protectedMethodDictionary setValue:anyThreadPossibleNumber forKey:eachMethodName];
        }
    }
    // SO: if two method protect on both main thread and any thread, it is put on any thread, because any thread set later
    self.protectedMethodDictionary = protectedMethodDictionary;
}

/*! @method protectMethods:
    @discussion input possible protected method, return actual protected method
 */
- (NSSet<NSString *> *)protectMethods:(NSArray<NSString *> *)methodsArray {
    NSMutableSet<NSString *> *protectedMethodSet = [[NSMutableSet alloc] init];
    
    for (NSString *methodString in methodsArray) {
        
        NSError *error = nil;
        HMDValidatedMethod *validatedMethod = [[self class] validatedMethodNameString:methodString error:&error];
        if (error || !validatedMethod) {
            HMDALOG_PROTOCOL_ERROR_TAG(@"Heimdallr", @"[HMDWP] %@", error);
            continue;
        }
        
        if ([self.swizzledMethodSet containsObject:validatedMethod.validatedMethodName]) {
            HMDALOG_PROTOCOL_INFO_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect method already protected: %@", validatedMethod.validatedMethodName);
            [protectedMethodSet addObject:validatedMethod.validatedMethodName];
            continue;
        }
        
        // stinger hook
        if (validatedMethod.isInstance) {
            Method targetMethod = class_getInstanceMethod(validatedMethod.clazz, validatedMethod.selector);
            if (targetMethod != NULL) {
                const char *signature = method_getTypeEncoding(targetMethod);
                id block = [self blockWithClass:validatedMethod.clazz selector:validatedMethod.selector isInstance:validatedMethod.isInstance signature:signature methodName:validatedMethod.validatedMethodName];
                if (block) {
                    NSError *error = nil;
                    [validatedMethod.clazz st_hookInstanceMethod:validatedMethod.selector withOptions:STOptionInstead|STOptionWeakCheckSignature usingBlock:block error:&error];
                    if (error) {
                        HMDALOG_PROTOCOL_ERROR_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect fail due to Stinger error: %@ %@", methodString, error);
                        continue;
                    }
                } else {
                    HMDALOG_PROTOCOL_ERROR_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect fail due to get block error: %@ %s", methodString, signature);
                    continue;
                }
            } else {
                HMDALOG_PROTOCOL_ERROR_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect fail due to get method error: %@", methodString);
                continue;
            }
        } else {
            Method targetMethod = class_getClassMethod(validatedMethod.clazz, validatedMethod.selector);
            if (targetMethod != NULL) {
                const char *signature = method_getTypeEncoding(targetMethod);
                id block = [self blockWithClass:validatedMethod.clazz selector:validatedMethod.selector isInstance:validatedMethod.isInstance signature:signature methodName:validatedMethod.validatedMethodName];
                if (block) {
                    NSError *error = nil;
                    [validatedMethod.clazz st_hookClassMethod:validatedMethod.selector withOptions:STOptionInstead|STOptionWeakCheckSignature usingBlock:block error:&error];
                    if (error) {
                        HMDALOG_PROTOCOL_ERROR_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect fail due to Stinger error: %@ %@", methodString, error);
                        continue;
                    }
                } else {
                    HMDALOG_PROTOCOL_ERROR_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect fail due to get block error: %@ %s", methodString, signature);
                    continue;
                }
            } else {
                HMDALOG_PROTOCOL_ERROR_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect fail due to get method error: %@", methodString);
                continue;
            }
        }
        
        [self.swizzledMethodSet addObject:validatedMethod.validatedMethodName];
        [protectedMethodSet addObject:validatedMethod.validatedMethodName];
        
        HMDALOG_PROTOCOL_INFO_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect protect method success: %@", methodString);
    }
    return protectedMethodSet;
}

static inline void prepareForAsyncInvocationIfPossible(id<StingerParams> params) {
    static BOOL globalDecided = NO;       // 全局：是否已经查询 -[id<StingerParams> preGenerateInvocationIfNeed] 方法存在
    static BOOL globalRespondToSEL;       // 全局查询结果：是否 -[id<StingerParams> preGenerateInvocationIfNeed] 方法存在

    // 当前全局是否已经判断完成
    BOOL currentDecided = __atomic_load_n(&globalDecided, __ATOMIC_ACQUIRE);

    // 如果全局已经判断完成，无论如何都会返回
    if(likely(currentDecided)) {
        BOOL respondToSEL = __atomic_load_n(&globalRespondToSEL, __ATOMIC_ACQUIRE);
        if(respondToSEL) [(id<HMDStingerUpdate>)params preGenerateInvocationIfNeed];
        return; //       无论如何都会返回
    }
    
    // 当前查询结果: 是否已经升级 Stinger 版本
    BOOL currentRespondToSEL = NO;
    
    id<NSObject> convertObject = (id<NSObject>)params;
    if([convertObject respondsToSelector:@selector(preGenerateInvocationIfNeed)])
        currentRespondToSEL = YES;

    // 写入全局判断结果
    if(currentRespondToSEL)
         __atomic_store_n(&globalRespondToSEL, YES, __ATOMIC_RELEASE);
    else __atomic_store_n(&globalRespondToSEL, NO,  __ATOMIC_RELEASE);

    // 写入全局是否判断
    __atomic_store_n(&globalDecided, YES, __ATOMIC_RELEASE);
    
    // 如果当前存在相应方法，那么调用一下
    if(currentRespondToSEL) [(id<HMDStingerUpdate>)params preGenerateInvocationIfNeed];
}

static void protect_method(__unsafe_unretained Class cls, SEL sel, BOOL isInstance,
                           id<StingerParams> params,
                           HMDWPDynamicSafeData * _Nullable returnStore, size_t returnSize,
                           atomic_flag *waitFlag, NSString *methodName) {
    
    // currently protect is on
    if(internal_exception_callback != nil) {
        
        // we use @(1) mean protect on any thread, and @(0) mean protect only on main thread
        // If here it returns nil, the method we no longger protect
        NSNumber * _Nullable protectNumber = [HMDWPDynamicProtect.sharedInstance.protectedMethodDictionary objectForKey:methodName];
        
        // Something we will protect probably
        if(protectNumber != nil) {
            
            BOOL needProtectOnAnyThread = [protectNumber isEqualToNumber:anyThreadPossibleNumber];
            
            // Now we do protect it if any thread need protect or is just main thread
            if(needProtectOnAnyThread || [NSThread isMainThread]) {
                // prepare call interface for async method
                prepareForAsyncInvocationIfPossible(params);
                
                HMDALOG_PROTOCOL_INFO_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect is protecting method: %@", methodName);
                
                if (isInstance) {
                    [HMDWPUtility protectObject:cls
                                        slector:sel
                                   skippedDepth:7
                                       waitFlag:needProtectOnAnyThread?nil:waitFlag
                                   syncWaitTime:HMDWatchdogProtectManager.sharedInstance.timeoutInterval
                               exceptionTimeout:HMDWPExceptionMaxWaitTime
                              exceptionCallback:^(HMDWPCapture *capture) {
                        hmd_wp_dynamic_capture(capture);
                    }
                                   protectBlock:^{
                        DEBUG_ASSERT(returnStore != nil);
                        HMDWPCallerStatus callerStatus = returnStore.atomicInfo;
                        DEBUG_ASSERT(callerStatus < HMDWPCallerStatusImpossible);
                        if(callerStatus != HMDWPCallerStatusWaiting) return;
                        
                        void *temp = NULL;
                        if(returnSize > 0) temp = __builtin_alloca(returnSize);
                        
                        [params invokeAndGetOriginalRetValue:temp];
                        
                        if(returnSize > 0) [returnStore storeData:temp];
                    }];
                } else {
                    [HMDWPUtility protectClass:cls
                                       slector:sel
                                  skippedDepth:7
                                      waitFlag:needProtectOnAnyThread?nil:waitFlag
                                  syncWaitTime:HMDWatchdogProtectManager.sharedInstance.timeoutInterval
                              exceptionTimeout:HMDWPExceptionMaxWaitTime
                             exceptionCallback:^(HMDWPCapture *capture) {
                        hmd_wp_dynamic_capture(capture);
                    }
                                  protectBlock:^{
                        DEBUG_ASSERT(returnStore != nil);
                        HMDWPCallerStatus callerStatus = returnStore.atomicInfo;
                        DEBUG_ASSERT(callerStatus < HMDWPCallerStatusImpossible);
                        if(callerStatus != HMDWPCallerStatusWaiting) return;
                        
                        void *temp = NULL;
                        if(returnSize > 0) temp = __builtin_alloca(returnSize);
                        
                        [params invokeAndGetOriginalRetValue:temp];
                        
                        if(returnSize > 0) [returnStore storeData:temp];
                    }];
                }
                
                return;
            }
        }
    }
    
    HMDALOG_PROTOCOL_INFO_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect has given up to protect method: %@", methodName);
    
    void *temp = NULL;
    if(returnSize > 0) temp = __builtin_alloca(returnSize);
    [params invokeAndGetOriginalRetValue:temp];
    if(returnSize > 0) [returnStore storeData:temp];
}

#pragma mark - Create implementation block of hooked method

static const char *HMDDCSkipMethodEncodings(const char *_Nonnull decl);

- (id)blockWithClass:(Class)cls selector:(SEL)sel isInstance:(BOOL)isInstance signature:(const char *)signature methodName:(NSString *)methodName
{
    if (signature == NULL) {
        return nil;
    }
    
    // atomic_flag
    atomic_flag flag = ATOMIC_FLAG_INIT;
    NSMutableData *flagData = [NSMutableData dataWithBytes:&flag length:sizeof(atomic_flag)];
    [self.waitFlags addObject:flagData];
    atomic_flag *waitFlag = (atomic_flag *)flagData.mutableBytes;
    
    signature = HMDDCSkipMethodEncodings(signature);
    
    // generate block
    id block = nil;
    switch (signature[0]) {
        case _C_ID:
        {
            block = ^id(id<StingerParams> params) {
                // 创建异步数据存储对象 HMDWPDynamicSafeData
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataStoreObject];
                // CallerStatusWaiting 调用线程正在等待; 默认初始化为0; 无需额外赋值
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                // 创建异步线程;执行方法;同步等待方法执行成功返回
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(id), waitFlag, methodName);
                
                // 获取返回对象的值
                id object = [returnStore getObject];
                
                // 无论获取成功与否; 标记调用线程已经没有再继续等待
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return object;
            };
            break;
        }
        case _C_VOID:
        {
            block = ^void(id<StingerParams> params) {
                // 我们虽然不需要返回值，但是需要使用 atomicInfo 的值; 用于同步 HMDWPCallerStatusWaiting 信息
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:0];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
    
                protect_method(cls, sel, isInstance, params, returnStore, 0, waitFlag, methodName);
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                GCC_FORCE_NO_OPTIMIZATION // 增加此行可以在 Slardar 上看到 HMDWPDynamicProtect 是 _C_VOID 这里的调用
            };
            break;
        }
        case _C_CLASS:
        {
            block = ^Class(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataStoreObject];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(Class), waitFlag, methodName);
                
                Class aClass = [returnStore getObject];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return aClass;
            };
            break;
        }
        case _C_SEL:
        {
            block = ^SEL(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(SEL)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(SEL), waitFlag, methodName);
                
                SEL defaultValue = NULL;   // 首先初始化默认值
                [returnStore getDataIfPossible:&defaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return defaultValue;
            };
            break;
        }
        case _C_PTR:
        {
            block = ^void *(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(void *)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(void *), waitFlag, methodName);
                
                void *defaultValue = NULL;
                [returnStore getDataIfPossible:&defaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return defaultValue;
            };
            break;
        }
        case _C_CHARPTR:
        {
            block = ^char *(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(char *)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(char *), waitFlag, methodName);
                
                void *defaultValue = NULL;
                [returnStore getDataIfPossible:&defaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return defaultValue;
            };
            break;
        }
        case _C_CHR:
        {
            block = ^char(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(char)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(char), waitFlag, methodName);
                
                char dafaultValue = '\0';
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_UCHR:
        {
            block = ^unsigned char(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(unsigned char)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(unsigned char), waitFlag, methodName);
                
                unsigned char dafaultValue = '\0';
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_SHT:
        {
            block = ^short(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(short)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(short), waitFlag, methodName);
                
                short dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_USHT:
        {
            block = ^unsigned short(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(unsigned short)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(unsigned short), waitFlag, methodName);
                
                unsigned short dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_INT:
        {
            block = ^int(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(int)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(int), waitFlag, methodName);
                
                int dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_UINT:
        {
            block = ^unsigned int(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(unsigned int)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(unsigned int), waitFlag, methodName);
                
                unsigned int dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_LNG:
        {
            block = ^long(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(long)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(long), waitFlag, methodName);
                
                long dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_ULNG:
        {
            block = ^unsigned long(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(unsigned long)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(unsigned long), waitFlag, methodName);
                
                unsigned long dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_LNG_LNG:
        {
            block = ^long long(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(long long)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(long long), waitFlag, methodName);
                
                long long dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_ULNG_LNG:
        {
            block = ^unsigned long long(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(unsigned long long)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(unsigned long long), waitFlag, methodName);
                
                unsigned long long dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_FLT:
        {
            block = ^float(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(float)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(float), waitFlag, methodName);
                
                float dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_DBL:
        {
            block = ^double(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(double)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(double), waitFlag, methodName);
                
                double dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_BOOL:
        {
            block = ^BOOL(id<StingerParams> params) {
                HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(BOOL)];
                DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                
                protect_method(cls, sel, isInstance, params, returnStore, sizeof(BOOL), waitFlag, methodName);
                
                BOOL dafaultValue = 0;
                [returnStore getDataIfPossible:&dafaultValue];
                
                returnStore.atomicInfo = HMDWPCallerStatusContinue;
                return dafaultValue;
            };
            break;
        }
        case _C_STRUCT_B:
        {
            if (hmd_reliable_has_prefix(signature, @encode(CGPoint))) {
                block = ^CGPoint(id<StingerParams> params) {
                    HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(CGPoint)];
                    DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                    
                    protect_method(cls, sel, isInstance, params, returnStore, sizeof(CGPoint), waitFlag, methodName);
                    
                    CGPoint dafaultValue = CGPointZero;
                    [returnStore getDataIfPossible:&dafaultValue];
                    
                    returnStore.atomicInfo = HMDWPCallerStatusContinue;
                    return dafaultValue;
                };
            }
            else if (hmd_reliable_has_prefix(signature, @encode(CGSize))) {
                block = ^CGSize(id<StingerParams> params) {
                    HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(CGSize)];
                    DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                    
                    protect_method(cls, sel, isInstance, params, returnStore, sizeof(CGSize), waitFlag, methodName);
                    
                    CGSize dafaultValue = CGSizeZero;
                    [returnStore getDataIfPossible:&dafaultValue];
                    
                    returnStore.atomicInfo = HMDWPCallerStatusContinue;
                    return dafaultValue;
                };
            }
            else if (hmd_reliable_has_prefix(signature, @encode(CGRect))) {
                block = ^CGRect(id<StingerParams> params) {
                    HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(CGRect)];
                    DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                    
                    protect_method(cls, sel, isInstance, params, returnStore, sizeof(CGRect), waitFlag, methodName);
                    
                    CGRect dafaultValue = CGRectZero;
                    [returnStore getDataIfPossible:&dafaultValue];
                    
                    returnStore.atomicInfo = HMDWPCallerStatusContinue;
                    return dafaultValue;
                };
            }
            else if (hmd_reliable_has_prefix(signature, @encode(NSRange))) {
                block = ^NSRange(id<StingerParams> params) {
                    HMDWPDynamicSafeData *returnStore = [HMDWPDynamicSafeData safeDataWithSize:sizeof(NSRange)];
                    DEBUG_ASSERT(returnStore.atomicInfo == HMDWPCallerStatusWaiting);
                    
                    protect_method(cls, sel, isInstance, params, returnStore, sizeof(NSRange), waitFlag, methodName);
                    
                    NSRange dafaultValue = NSMakeRange(NSNotFound, 0);
                    [returnStore getDataIfPossible:&dafaultValue];
                    
                    returnStore.atomicInfo = HMDWPCallerStatusContinue;
                    return dafaultValue;
                };
            }
            else {
                HMDALOG_PROTOCOL_ERROR_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect get block fail due to unknown _C_STRUCT_B: %s", signature);
            }
            break;
        }
        default:
            HMDALOG_PROTOCOL_ERROR_TAG(@"Heimdallr", @"[HMDWP] DynamicProtect get block fail due to unknown signature: %s", signature);
            break;
    }
    
    return block;
}

@end

static const char *HMDDCSkipMethodEncodings(const char *_Nonnull decl) {
    static const char *qualifiersAndComments = "nNoOrRV\"";
    while (*decl != '\0' && strchr(qualifiersAndComments, *decl)) {
        if (*decl == '"') {
            decl++;
            while (*decl++ != '"');
        }
        else decl++;
    }
    return decl;
}
