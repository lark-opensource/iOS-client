/*
 * QuickJS Javascript Engine
 *
 * Copyright (c) 2017-2019 Fabrice Bellard
 * Copyright (c) 2017-2019 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
#include <assert.h>
#include <fenv.h>
#include <math.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined(_WIN32)
#if defined(_MSC_VER)
#include <BaseTsd.h>
typedef SSIZE_T ssize_t;
#endif
#include <windows.h>
#include <winsock.h>
extern "C" {
#include "quickjs-libc.h"
}
#include <memoryapi.h>
#else
#include <sys/time.h>
#endif
#include <time.h>

#include <cstdint>
#include <cstdlib>
#if defined(ANDROID) || defined(__ANDROID__)
#include <errno.h>
#include <unistd.h>
#endif

#if defined(__APPLE__)
#include <malloc/malloc.h>
#elif defined(__linux__)
#include <malloc.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif
#include "cutils.h"
#include "libregexp.h"
#include "list.h"
#ifdef MALLOC_DEBUG
#include "malloc_debug_check.h"
#endif
#include "quickjs_version.h"
#ifdef __cplusplus
}
#endif

#include "quickjs-inner.h"

#if !defined(BAZEL_TEST) && !defined(__WASI_SDK__)
#include "devtool/quickjs/interface.h"
#endif  // BAZEL_TEST

#if defined(ANDROID) || defined(__ANDROID__)
#include <android/log.h>
#include <pthread.h>
#endif

#if defined(APPLE) || defined(__APPLE__) || defined(QJS_UNITTEST)
#include <pthread.h>
#endif

#ifndef EMSCRIPTEN
#define EMSCRIPTEN
#endif

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wconversion"
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wconditional-uninitialized"
#pragma clang diagnostic ignored "-Wunreachable-code"
// <ByteDance end>
#if defined(EMSCRIPTEN)
#define DIRECT_DISPATCH 0
#else
#define DIRECT_DISPATCH 1
#endif

#if defined(__APPLE__)
#define MALLOC_OVERHEAD 0
#else
#define MALLOC_OVERHEAD 8
#endif

#if !defined(_WIN32) && !defined(__WASI_SDK__)
/* define it if printf uses the RNDN rounding mode instead of RNDNA */
#define CONFIG_PRINTF_RNDN
#endif

/* define to include Atomics.* operations which depend on the OS
   threads */
#if !defined(EMSCRIPTEN)
#define CONFIG_ATOMICS
#endif

/* dump object free */
// #define DUMP_FREE
//#define DUMP_CLOSURE

/* dump the occurence of the automatic GC */
// #define DUMP_GC
/* dump objects freed by the garbage collector */
// #define DUMP_GC_FREE

/* dump memory usage before running the garbage collector */
// #define DUMP_MEM 1
// #define DUMP_OBJECTS    /* dump objects in LEPUS_FreeContext */
//#define DUMP_ATOMS      /* dump atoms in LEPUS_FreeContext */
//#define DUMP_SHAPES     /* dump shapes in LEPUS_FreeContext */
//#define DUMP_MODULE_RESOLVE
//#define DUMP_PROMISE
//#define DUMP_READ_OBJECT

#if (defined(DUMP_LEAKS) || defined(DUMP_BYTECODE) || defined(DUMP_OBJECTS) || \
     defined(DUMP_ATOMS) || defined(DUMP_SHAPES) || defined(DUMP_GC_FREE) ||   \
     defined(DUMP_FREE)) &&                                                    \
    !defined(DUMP_QJS_VALUE)
#define DUMP_QJS_VALUE
#if defined(QJS_UNITTEST) && defined(printf)
#undef printf
#endif
#endif

/* test the GC by forcing it before each object allocation */
//#define FORCE_GC_AT_MALLOC

#ifdef CONFIG_ATOMICS
#include <errno.h>
#include <pthread.h>
#include <stdatomic.h>
#endif

// <primjs begin>
#ifdef ENABLE_PRIMJS_RUNTIME
#include "src/StubRoutines.hpp"
#include "src/global.hpp"
#endif

#if defined(ENABLE_PRIMJS_SNAPSHOT) && !defined(ENABLE_PRIMJS_RUNTIME)
static const int NUM_OF_TOS_STATES = 3;
#endif

#if defined(ENABLE_PRIMJS_SNAPSHOT) || defined(ENABLE_PRIMJS_PROFILER)
static pthread_mutex_t prim_init_mutex = PTHREAD_MUTEX_INITIALIZER;

static bool IS_PRIM_INITIALIZED = false;

#endif

#if defined(ENABLE_PRIMJS_TRACE) && PRINT_LOG_TO_FILE && \
    (defined(ANDROID) || defined(__ANDROID__))
FILE *log_f = nullptr;
#endif

// <primjs end>

/* number of typed array types */
#define LEPUS_TYPED_ARRAY_COUNT \
  (LEPUS_CLASS_FLOAT64_ARRAY - LEPUS_CLASS_UINT8C_ARRAY + 1)
/* Typed Arrays */
static uint8_t const typed_array_size_log2[LEPUS_TYPED_ARRAY_COUNT] = {
    0, 0, 0, 1, 1, 2, 2,
#ifdef CONFIG_BIGNUM
    3, 3, /* BigInt64Array, BigUint64Array */
#endif
    2, 3};

#define typed_array_size_log2(classid) \
  (typed_array_size_log2[(classid)-LEPUS_CLASS_UINT8C_ARRAY])

#define LEPUS_MAX_LOCAL_VARS 65535
#define LEPUS_STACK_SIZE_MAX 65535
#define LEPUS_STRING_LEN_MAX ((1 << 30) - 1)

struct LEPUSString {
  LEPUSRefCountHeader header; /* must come first, 32-bit */
  uint32_t len : 31;
  uint8_t is_wide_char : 1; /* 0 = 8 bits, 1 = 16 bits characters */
  /* for LEPUS_ATOM_TYPE_SYMBOL: hash = 0, atom_type = 3,
     for LEPUS_ATOM_TYPE_PRIVATE: hash = 1, atom_type = 3
     XXX: could change encoding to have one more bit in hash */
  uint32_t hash : 30;
  uint8_t atom_type : 2; /* != 0 if atom, LEPUS_ATOM_TYPE_x */
  uint32_t hash_next;    /* atom_index for LEPUS_ATOM_TYPE_SYMBOL */
#ifdef DUMP_LEAKS
  struct list_head link; /* string list */
#endif

#ifdef ENABLE_LEPUSNG
  // ByteDance add
  void *cache_;  // add to convert to lepusString
#endif
  union {
    uint8_t str8[0]; /* 8 bit strings will get an extra null terminator */
    uint16_t str16[0];
  } u;
};

QJS_STATIC int LEPUS_InitAtoms(LEPUSRuntime *rt);
QJS_STATIC LEPUSAtom __JS_NewAtomInit(LEPUSRuntime *rt, const char *str,
                                      int len, int atom_type);
QJS_STATIC void LEPUS_FreeAtomStruct(LEPUSRuntime *rt, LEPUSAtomStruct *p);
// <ByteDance begin>
#ifdef ENABLE_LEPUSNG
QJS_STATIC void LEPUS_FreeStringCache(LEPUSRuntime *rt, LEPUSString *p);
#endif
// <ByteDance end>
QJS_STATIC void free_function_bytecode(LEPUSRuntime *rt,
                                       LEPUSFunctionBytecode *b);
static LEPUSValue lepus_call_c_function(LEPUSContext *ctx,
                                        LEPUSValueConst func_obj,
                                        LEPUSValueConst this_obj, int argc,
                                        LEPUSValueConst *argv, int flags);
static LEPUSValue lepus_call_bound_function(LEPUSContext *ctx,
                                            LEPUSValueConst func_obj,
                                            LEPUSValueConst this_obj, int argc,
                                            LEPUSValueConst *argv, int flags);
QJS_STATIC LEPUSValue LEPUS_CallInternal(LEPUSContext *ctx,
                                         LEPUSValueConst func_obj,
                                         LEPUSValueConst this_obj,
                                         LEPUSValueConst new_target, int argc,
                                         LEPUSValue *argv, int flags);
QJS_STATIC LEPUSValue LEPUS_CallFree(LEPUSContext *ctx, LEPUSValue func_obj,
                                     LEPUSValueConst this_obj, int argc,
                                     LEPUSValueConst *argv);
QJS_STATIC LEPUSValue LEPUS_InvokeFree(LEPUSContext *ctx, LEPUSValue this_val,
                                       LEPUSAtom atom, int argc,
                                       LEPUSValueConst *argv);
QJS_STATIC __exception int LEPUS_ToArrayLengthFree(LEPUSContext *ctx,
                                                   uint32_t *plen,
                                                   LEPUSValue val,
                                                   BOOL is_array_ctor);
QJS_STATIC LEPUSValue LEPUS_EvalObject(LEPUSContext *ctx,
                                       LEPUSValueConst this_obj,
                                       LEPUSValueConst val, int flags,
                                       int scope_idx);
LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowInternalError(LEPUSContext *ctx, const char *fmt, ...);

// <ByteDance begin>
#if defined(DUMP_QJS_VALUE)
static __attribute__((unused)) void LEPUS_DumpAtoms(LEPUSRuntime *rt);
static __attribute__((unused)) void LEPUS_DumpString(LEPUSRuntime *rt,
                                                     const LEPUSString *p);
static __attribute__((unused)) void LEPUS_DumpStringNoPrint(
    LEPUSRuntime *rt, const LEPUSString *p, char dump_buf[]);
static __attribute__((unused)) void LEPUS_DumpObjectHeader(LEPUSRuntime *rt);
static __attribute__((unused)) void LEPUS_DumpObject(LEPUSRuntime *rt,
                                                     LEPUSObject *p);
static __attribute__((unused)) void LEPUS_DumpValueShort(LEPUSRuntime *rt,
                                                         LEPUSValueConst val);
static __attribute__((unused)) void LEPUS_DumpValueShortNoPrint(
    LEPUSRuntime *rt, LEPUSValueConst val, char dump_buf[]);
static __attribute__((unused)) void LEPUS_DumpValue(LEPUSContext *ctx,
                                                    LEPUSValueConst val);
static __attribute__((unused)) void LEPUS_PrintValue(LEPUSContext *ctx,
                                                     const char *str,
                                                     LEPUSValueConst val);
static __attribute__((unused)) void LEPUS_DumpShapes(LEPUSRuntime *rt);
#endif  // DUMP_QJS_VALUE
// <ByteDance end>

QJS_STATIC void lepus_array_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_array_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                 LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_object_data_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_object_data_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                       LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_bytecode_function_finalizer(LEPUSRuntime *rt,
                                                  LEPUSValue val);
QJS_STATIC void lepus_bytecode_function_mark(LEPUSRuntime *rt,
                                             LEPUSValueConst val,
                                             LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_bound_function_finalizer(LEPUSRuntime *rt,
                                               LEPUSValue val);
QJS_STATIC void lepus_bound_function_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                          LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_for_in_iterator_finalizer(LEPUSRuntime *rt,
                                                LEPUSValue val);
QJS_STATIC void lepus_for_in_iterator_mark(LEPUSRuntime *rt,
                                           LEPUSValueConst val,
                                           LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_regexp_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_array_buffer_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_typed_array_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_typed_array_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                       LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_proxy_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_proxy_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                 LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_map_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_map_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                               LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_map_iterator_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_map_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                        LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_array_iterator_finalizer(LEPUSRuntime *rt,
                                               LEPUSValue val);
QJS_STATIC void lepus_array_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                          LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_regexp_string_iterator_finalizer(LEPUSRuntime *rt,
                                                       LEPUSValue val);
QJS_STATIC void lepus_regexp_string_iterator_mark(LEPUSRuntime *rt,
                                                  LEPUSValueConst val,
                                                  LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_generator_finalizer(LEPUSRuntime *rt, LEPUSValue obj);
QJS_STATIC void lepus_generator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                     LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_weakref_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_finalizationRegistry_finalizer(LEPUSRuntime *rt,
                                                     LEPUSValue val);
QJS_STATIC void lepus_finalizationRegistry_mark(LEPUSRuntime *rt,
                                                LEPUSValueConst val,
                                                LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_promise_finalizer(LEPUSRuntime *rt, LEPUSValue val);
QJS_STATIC void lepus_promise_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                   LEPUS_MarkFunc *mark_func);
QJS_STATIC void lepus_promise_resolve_function_finalizer(LEPUSRuntime *rt,
                                                         LEPUSValue val);
QJS_STATIC void lepus_promise_resolve_function_mark(LEPUSRuntime *rt,
                                                    LEPUSValueConst val,
                                                    LEPUS_MarkFunc *mark_func);
QJS_STATIC LEPUSValue lepus_promise_resolve_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_val,
    int argc, LEPUSValueConst *argv, int flags);
QJS_STATIC LEPUSValue LEPUS_ToStringFree(LEPUSContext *ctx, LEPUSValue val);
QJS_STATIC int LEPUS_ToInt32Free(LEPUSContext *ctx, int32_t *pres,
                                 LEPUSValue val);
QJS_STATIC int LEPUS_ToFloat64Free(LEPUSContext *ctx, double *pres,
                                   LEPUSValue val);
QJS_STATIC int LEPUS_ToUint8ClampFree(LEPUSContext *ctx, int32_t *pres,
                                      LEPUSValue val);
QJS_STATIC LEPUSValue lepus_compile_regexp(LEPUSContext *ctx,
                                           LEPUSValueConst pattern,
                                           LEPUSValueConst flags);
QJS_STATIC void gc_decref(LEPUSRuntime *rt);
QJS_STATIC int LEPUS_NewClass1(LEPUSRuntime *rt, LEPUSClassID class_id,
                               const LEPUSClassDef *class_def, LEPUSAtom name);

typedef enum LEPUSStrictEqModeEnum {
  LEPUS_EQ_STRICT,
  LEPUS_EQ_SAME_VALUE,
  LEPUS_EQ_SAME_VALUE_ZERO,
} LEPUSStrictEqModeEnum;

QJS_STATIC BOOL lepus_strict_eq2(LEPUSContext *ctx, LEPUSValue op1,
                                 LEPUSValue op2, LEPUSStrictEqModeEnum eq_mode);
QJS_STATIC BOOL lepus_strict_eq(LEPUSContext *ctx, LEPUSValue op1,
                                LEPUSValue op2);
QJS_STATIC BOOL lepus_same_value(LEPUSContext *ctx, LEPUSValueConst op1,
                                 LEPUSValueConst op2);
QJS_STATIC BOOL lepus_same_value_zero(LEPUSContext *ctx, LEPUSValueConst op1,
                                      LEPUSValueConst op2);
QJS_STATIC LEPUSValue LEPUS_ToObjectFree(LEPUSContext *ctx, LEPUSValue val);
#ifdef CONFIG_BIGNUM
static void lepus_float_env_finalizer(LEPUSRuntime *rt, LEPUSValue val);
static LEPUSValue LEPUS_NewBigFloat(LEPUSContext *ctx, bf_t *a);
static LEPUSValue LEPUS_NewBigInt2(LEPUSContext *ctx, bf_t *a,
                                   BOOL force_bigint);
static LEPUSValue LEPUS_NewBigInt(LEPUSContext *ctx, bf_t *a);
static int LEPUS_ToBigInt64Free(LEPUSContext *ctx, int64_t *pres,
                                LEPUSValue val);
static bf_t *LEPUS_ToBigFloat(LEPUSContext *ctx, BOOL *pis_float, bf_t *buf,
                              LEPUSValueConst val);
#endif
LEPUSValue LEPUS_ThrowOutOfMemory(LEPUSContext *ctx);
QJS_STATIC LEPUSValue LEPUS_ThrowTypeErrorRevokedProxy(LEPUSContext *ctx);
QJS_STATIC LEPUSValue lepus_proxy_call(LEPUSContext *ctx,
                                       LEPUSValueConst func_obj,
                                       LEPUSValueConst this_obj, int argc,
                                       LEPUSValueConst *argv, int flags);
QJS_STATIC LEPUSValue lepus_proxy_call_constructor(LEPUSContext *ctx,
                                                   LEPUSValueConst func_obj,
                                                   LEPUSValueConst new_target,
                                                   int argc,
                                                   LEPUSValueConst *argv);
QJS_STATIC LEPUSValueConst lepus_proxy_getPrototypeOf(LEPUSContext *ctx,
                                                      LEPUSValueConst obj);
QJS_STATIC int lepus_proxy_setPrototypeOf(LEPUSContext *ctx,
                                          LEPUSValueConst obj,
                                          LEPUSValueConst proto_val,
                                          BOOL throw_flag);
QJS_STATIC int lepus_proxy_isExtensible(LEPUSContext *ctx, LEPUSValueConst obj);
QJS_STATIC int lepus_proxy_preventExtensions(LEPUSContext *ctx,
                                             LEPUSValueConst obj);
QJS_STATIC int lepus_proxy_isArray(LEPUSContext *ctx, LEPUSValueConst obj);
QJS_STATIC int LEPUS_CreateProperty(LEPUSContext *ctx, LEPUSObject *p,
                                    LEPUSAtom prop, LEPUSValueConst val,
                                    LEPUSValueConst getter,
                                    LEPUSValueConst setter, int flags);
QJS_STATIC int lepus_string_memcmp(const LEPUSString *p1, const LEPUSString *p2,
                                   int len);
QJS_STATIC void reset_weak_ref(LEPUSRuntime *rt, LEPUSObject *p);
QJS_STATIC void reset_weakref_record(LEPUSRuntime *rt, LEPUSObject *p);
QJS_STATIC void reset_fg_registry(LEPUSRuntime *rt, LEPUSObject *p);
QJS_STATIC BOOL typed_array_is_detached(LEPUSContext *ctx, LEPUSObject *p);
QJS_STATIC uint32_t typed_array_get_length(LEPUSContext *ctx, LEPUSObject *p);
QJS_STATIC LEPUSValue
LEPUS_ThrowTypeErrorDetachedArrayBuffer(LEPUSContext *ctx);
QJS_STATIC LEPUSValue lepus_generator_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_obj,
    int argc, LEPUSValueConst *argv, int flags);
QJS_STATIC void lepus_async_function_resolve_finalizer(LEPUSRuntime *rt,
                                                       LEPUSValue val);
QJS_STATIC void lepus_async_function_resolve_mark(LEPUSRuntime *rt,
                                                  LEPUSValueConst val,
                                                  LEPUS_MarkFunc *mark_func);
#ifndef NO_QUICKJS_COMPILER

// the last two parameters are needed for qjs debugger, default value: false,
// NULL
#ifdef ENABLE_QUICKJS_DEBUGGER
LEPUSValue LEPUS_EvalInternal(LEPUSContext *ctx,
#else
static LEPUSValue LEPUS_EvalInternal(
    LEPUSContext *ctx,
#endif
                              LEPUSValueConst this_obj, const char *input,
                              size_t input_len, const char *filename, int flags,
                              int scope_idx, bool debugger_eval = false,
                              LEPUSStackFrame *sf = NULL);
#endif
QJS_STATIC void lepus_free_module_def(LEPUSContext *ctx, LEPUSModuleDef *m);
QJS_STATIC void free_var_ref(LEPUSRuntime *rt, LEPUSVarRef *var_ref);
QJS_STATIC LEPUSValue lepus_new_promise_capability(LEPUSContext *ctx,
                                                   LEPUSValue *resolving_funcs,
                                                   LEPUSValueConst ctor);
QJS_STATIC __exception int perform_promise_then(
    LEPUSContext *ctx, LEPUSValueConst promise, LEPUSValueConst *resolve_reject,
    LEPUSValueConst *cap_resolving_funcs);
QJS_STATIC LEPUSValue lepus_promise_resolve(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv, int magic);
QJS_STATIC int lepus_string_compare(LEPUSContext *ctx, const LEPUSString *p1,
                                    const LEPUSString *p2);
QJS_STATIC LEPUSValue LEPUS_ToNumber(LEPUSContext *ctx, LEPUSValueConst val);
QJS_STATIC int LEPUS_NumberIsInteger(LEPUSContext *ctx, LEPUSValueConst val);
QJS_STATIC BOOL LEPUS_NumberIsNegativeOrMinusZero(LEPUSContext *ctx,
                                                  LEPUSValueConst val);
QJS_STATIC LEPUSValue LEPUS_ToNumberFree(LEPUSContext *ctx, LEPUSValue val);
QJS_STATIC int LEPUS_GetOwnPropertyInternal(LEPUSContext *ctx,
                                            LEPUSPropertyDescriptor *desc,
                                            LEPUSObject *p, LEPUSAtom prop);
QJS_STATIC void lepus_free_desc(LEPUSContext *ctx,
                                LEPUSPropertyDescriptor *desc);
QJS_STATIC void async_func_mark(LEPUSRuntime *rt, LEPUSAsyncFunctionState *s,
                                LEPUS_MarkFunc *mark_func);
QJS_STATIC void LEPUS_AddIntrinsicBasicObjects(LEPUSContext *ctx);
QJS_STATIC void lepus_free_shape(LEPUSRuntime *rt, LEPUSShape *sh);
QJS_STATIC void lepus_free_shape_null(LEPUSRuntime *rt, LEPUSShape *sh);
QJS_STATIC int lepus_shape_prepare_update(LEPUSContext *ctx, LEPUSObject *p,
                                          LEPUSShapeProperty **pprs);
QJS_STATIC int init_shape_hash(LEPUSRuntime *rt);
__exception int lepus_get_length32(LEPUSContext *ctx, uint32_t *pres,
                                   LEPUSValueConst obj);
QJS_STATIC __exception int lepus_get_length64(LEPUSContext *ctx, int64_t *pres,
                                              LEPUSValueConst obj);
QJS_STATIC void free_arg_list(LEPUSContext *ctx, LEPUSValue *tab, uint32_t len);
QJS_STATIC LEPUSValue *build_arg_list(LEPUSContext *ctx, uint32_t *plen,
                                      LEPUSValueConst array_arg);
QJS_STATIC BOOL lepus_get_fast_array(LEPUSContext *ctx, LEPUSValueConst obj,
                                     LEPUSValue **arrpp, uint32_t *countp);
QJS_STATIC LEPUSValue
LEPUS_CreateAsyncFromSyncIterator(LEPUSContext *ctx, LEPUSValueConst sync_iter);
QJS_STATIC void lepus_c_function_data_finalizer(LEPUSRuntime *rt,
                                                LEPUSValue val);
QJS_STATIC void lepus_c_function_data_mark(LEPUSRuntime *rt,
                                           LEPUSValueConst val,
                                           LEPUS_MarkFunc *mark_func);
QJS_STATIC LEPUSValue lepus_c_function_data_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_val,
    int argc, LEPUSValueConst *argv, int flags);
QJS_STATIC int lepus_module_ns_has(LEPUSContext *ctx, LEPUSValueConst obj,
                                   LEPUSAtom atom);
QJS_STATIC int lepus_proxy_get_own_property(LEPUSContext *ctx,
                                            LEPUSPropertyDescriptor *pdesc,
                                            LEPUSValueConst obj,
                                            LEPUSAtom prop);
QJS_STATIC int lepus_proxy_define_own_property(
    LEPUSContext *ctx, LEPUSValueConst obj, LEPUSAtom prop, LEPUSValueConst val,
    LEPUSValueConst getter, LEPUSValueConst setter, int flags);
QJS_STATIC int lepus_proxy_delete_property(LEPUSContext *ctx,
                                           LEPUSValueConst obj, LEPUSAtom atom);
QJS_STATIC int lepus_proxy_get_own_property_names(LEPUSContext *ctx,
                                                  LEPUSPropertyEnum **ptab,
                                                  uint32_t *plen,
                                                  LEPUSValueConst obj);
QJS_STATIC int lepus_proxy_has(LEPUSContext *ctx, LEPUSValueConst obj,
                               LEPUSAtom atom);
QJS_STATIC LEPUSValue lepus_proxy_get(LEPUSContext *ctx, LEPUSValueConst obj,
                                      LEPUSAtom atom, LEPUSValueConst receiver);
QJS_STATIC int lepus_proxy_set(LEPUSContext *ctx, LEPUSValueConst obj,
                               LEPUSAtom atom, LEPUSValueConst value,
                               LEPUSValueConst receiver, int flags);
QJS_STATIC int lepus_string_get_own_property(LEPUSContext *ctx,
                                             LEPUSPropertyDescriptor *desc,
                                             LEPUSValueConst obj,
                                             LEPUSAtom prop);
QJS_STATIC int lepus_string_define_own_property(
    LEPUSContext *ctx, LEPUSValueConst this_obj, LEPUSAtom prop,
    LEPUSValueConst val, LEPUSValueConst getter, LEPUSValueConst setter,
    int flags);
QJS_STATIC int lepus_string_delete_property(LEPUSContext *ctx,
                                            LEPUSValueConst obj,
                                            LEPUSAtom prop);
QJS_STATIC int lepus_arguments_define_own_property(
    LEPUSContext *ctx, LEPUSValueConst this_obj, LEPUSAtom prop,
    LEPUSValueConst val, LEPUSValueConst getter, LEPUSValueConst setter,
    int flags);
QJS_STATIC int lepus_string_get_own_property_names(LEPUSContext *ctx,
                                                   LEPUSPropertyEnum **ptab,
                                                   uint32_t *plen,
                                                   LEPUSValueConst obj);

static const LEPUSClassExoticMethods lepus_arguments_exotic_methods = {
    .define_own_property = lepus_arguments_define_own_property,
};
static const LEPUSClassExoticMethods lepus_string_exotic_methods = {
    .get_own_property = lepus_string_get_own_property,
    .get_own_property_names = lepus_string_get_own_property_names,
    .define_own_property = lepus_string_define_own_property,
    .delete_property = lepus_string_delete_property,
};
static const LEPUSClassExoticMethods lepus_proxy_exotic_methods = {
    .get_own_property = lepus_proxy_get_own_property,
    .define_own_property = lepus_proxy_define_own_property,
    .delete_property = lepus_proxy_delete_property,
    .get_own_property_names = lepus_proxy_get_own_property_names,
    .has_property = lepus_proxy_has,
    .get_property = lepus_proxy_get,
    .set_property = lepus_proxy_set,
};
static const LEPUSClassExoticMethods lepus_module_ns_exotic_methods = {
    .has_property = lepus_module_ns_has,
};

QJS_STATIC LEPUSValue lepus_instantiate_prototype(LEPUSContext *ctx,
                                                  LEPUSObject *p,
                                                  LEPUSAtom atom, void *opaque);
QJS_STATIC LEPUSValue lepus_module_ns_autoinit(LEPUSContext *ctx,
                                               LEPUSObject *p, LEPUSAtom atom,
                                               void *opaque);
QJS_STATIC LEPUSValue LEPUS_InstantiateFunctionListItem2(LEPUSContext *ctx,
                                                         LEPUSObject *p,
                                                         LEPUSAtom atom,
                                                         void *opaque);

static LEPUSClassID lepus_class_id_alloc = LEPUS_CLASS_INIT_COUNT;
QJS_HIDE LEPUSAtom lepus_symbol_to_atom(LEPUSContext *ctx, LEPUSValue val);
#define QJSCallBackName(V)               \
  V(run_message_loop_on_pause)           \
  V(quit_message_loop_on_pause)          \
  V(get_messages)                        \
  V(send_response)                       \
  V(send_notification)                   \
  V(free_messages)                       \
  V(debugger_exception)                  \
  V(inspector_check)                     \
  V(console_message)                     \
  V(script_parsed_ntfy)                  \
  V(console_api_called_ntfy)             \
  V(script_fail_parse_ntfy)              \
  V(debugger_paused)                     \
  V(is_devtool_on)                       \
  V(send_response_with_view_id)          \
  V(send_ntfy_with_view_id)              \
  V(script_parsed_ntfy_with_view_id)     \
  V(script_fail_parse_ntfy_with_view_id) \
  V(set_session_enable_state)            \
  V(get_session_state)                   \
  V(console_api_called_ntfy_with_rid)    \
  V(get_session_enable_state)            \
  V(get_console_stack_trace)

#define VMSDKCallBackName(V) V(print_by_alog)

#ifdef ENABLE_QUICKJS_DEBUGGER
struct LEPUSFunctionDef;
QJS_STATIC uint8_t DebuggerIsDevtoolOn(LEPUSRuntime *rt);
QJS_STATIC void LEPUS_AddIntrinsicConsole(LEPUSContext *ctx,
                                          bool is_lynx_console = false);
QJS_STATIC void DebuggerSetFunctionBytecodeScript(LEPUSContext *ctx,
                                                  struct LEPUSFunctionDef *fd,
                                                  LEPUSFunctionBytecode *b);
QJS_STATIC void InitializeDebuggerInfo(LEPUSDebuggerInfo *info);
QJS_STATIC void DebuggerInitialize(LEPUSContext *ctx);
void DebuggerFree(LEPUSContext *ctx);
void SetFixedShapeObjValue(LEPUSContext *ctx, LEPUSObject *p, uint32_t idx,
                           LEPUSValue val);
LEPUSObject *DebuggerCreateObjFromShape(LEPUSDebuggerInfo *info,
                                        LEPUSValue obj);
QJS_STATIC char *DebuggerSetScriptHash(LEPUSContext *ctx, const char *src,
                                       int32_t id);
QJS_STATIC void DebuggerParseScript(LEPUSContext *ctx, const char *input,
                                    size_t input_len,
                                    struct LEPUSFunctionDef *fd,
                                    const char *filename, int32_t end_line_num,
                                    int32_t err);
void DebuggerFreeScript(LEPUSContext *ctx, LEPUSScriptSource *script);
QJS_STATIC void FreeDebuggerScriptAndBytecodeList(LEPUSContext *ctx);
QJS_STATIC void AddFunctionBytecode(LEPUSContext *ctx, LEPUSValue obj,
                                    LEPUSFunctionBytecode **&list,
                                    uint32_t *use_size, uint32_t &total_size);
void ComputeLineCol(int64_t line_col_num, int32_t *line, int64_t *column);
void InitQJSDebugger(LEPUSContext *ctx);
void DebuggerSetPropertyStr(LEPUSContext *ctx, LEPUSValueConst this_obj,
                            const char *prop, LEPUSValue val);
#endif

LEPUS_BOOL LEPUS_IsNumber(LEPUSValueConst v) {
#ifdef CONFIG_BIGNUM
  int tag = LEPUS_VALUE_GET_TAG(v);
  return tag == LEPUS_TAG_INT || tag == LEPUS_TAG_BIG_INT ||
         tag == LEPUS_TAG_BIG_FLOAT || LEPUS_TAG_IS_FLOAT64(tag);
#else
  return LEPUS_VALUE_IS_INT(v) || LEPUS_VALUE_IS_FLOAT64(v);
#endif
}

// <bytedance begin>

void RegisterLepusType(LEPUSRuntime *rt, int32_t array_typeid,
                       int32_t table_typeid) {
#ifdef ENABLE_LEPUSNG
  rt->lepus_type_.array_typeid_ = array_typeid;
  rt->lepus_type_.table_typeid_ = table_typeid;
#endif
}

void LEPUS_RegisterNgType(LEPUSRuntime *rt, int32_t *types,
                          uint32_t input_size) {
#ifdef ENABLE_LEPUSNG
  int32_t *dst = &(rt->lepus_type_.array_typeid_),
          *end = dst + (sizeof(rt->lepus_type_) / sizeof(int32_t));

  for (uint32_t i = 0; dst < end && i < input_size; ++i, ++dst) {
    *dst = types[i];
  }
  return;
#endif
}

#ifdef ENABLE_QUICKJS_DEBUGGER
LEPUS_BOOL LEPUS_LepusRefIsArray(LEPUSRuntime *rt, LEPUSValue v) {
#else
QJS_STATIC LEPUS_BOOL LEPUS_LepusRefIsArray(LEPUSRuntime *rt, LEPUSValue v) {
#endif
#ifdef ENABLE_LEPUSNG
  if (rt && LEPUS_IsLepusRef(v)) {
    return LEPUS_GetLepusRefTag(v) == rt->lepus_type_.array_typeid_;
  }
#endif
  return FALSE;
}

#ifdef ENABLE_LEPUSNG
#ifdef ENABLE_QUICKJS_DEBUGGER
LEPUS_BOOL LEPUS_LepusRefIsTable(LEPUSRuntime *rt, LEPUSValue v) {
#else
QJS_STATIC LEPUS_BOOL LEPUS_LepusRefIsTable(LEPUSRuntime *rt, LEPUSValue v) {
#endif
  if (rt && LEPUS_IsLepusRef(v)) {
    return LEPUS_GetLepusRefTag(v) == rt->lepus_type_.table_typeid_;
  }
  return FALSE;
}
#endif

QJS_STATIC LEPUSValue LEPUSRef2Value(LEPUSContext *ctx, LEPUSValue ref) {
#ifdef ENABLE_LEPUSNG
  if (ctx && LEPUS_IsLepusRef(ref)) {
    if (!LEPUS_IsUndefined(
            ((LEPUSLepusRef *)LEPUS_VALUE_GET_PTR(ref))->lepus_val)) {
      return ((LEPUSLepusRef *)LEPUS_VALUE_GET_PTR(ref))->lepus_val;
    } else {
      if (ctx->rt->lepus_callbacks_.convert_to_object) {
        return ctx->rt->lepus_callbacks_.convert_to_object(ctx, ref);
      }
    }
  }
#endif
  return ref;
}

#ifdef ENABLE_QUICKJS_SECURITY_MODE
static uint8_t xor_encoding(LEPUSContext *ctx, uint8_t opcode) {
  uint8_t value = (uint8_t)ctx->op_transform_value;
  if (!ctx->enable_security_feature || opcode >= OP_COUNT || value > 128 ||
      value < 0)
    return opcode;
  opcode ^= value;
  return opcode;
}

static uint8_t xor_decoding(LEPUSContext *ctx, uint8_t opcode) {
  return xor_encoding(ctx, opcode);
}

void LEPUS_EnableXorTransform(LEPUSContext *ctx, uint32_t value) {
  ctx->op_transform_callback.encode_opcode = xor_encoding;
  ctx->op_transform_callback.decode_opcode = xor_decoding;
  ctx->op_transform_value = value;
}

void LEPUS_EnableSecurityFeature(LEPUSContext *ctx) {
  ctx->enable_security_feature = 1;
}
#endif

// <bytedance end>

QJS_STATIC void lepus_trigger_gc(LEPUSRuntime *rt, size_t size) {
  BOOL force_gc;
#ifdef FORCE_GC_AT_MALLOC
  force_gc = TRUE;
#else
  force_gc = ((rt->malloc_state.malloc_size + size) > rt->malloc_gc_threshold);
#endif
  if (force_gc) {
#ifdef DUMP_GC
    printf("GC: size=%" PRIu64 "\n", (uint64_t)rt->malloc_state.malloc_size);
#endif
    LEPUS_RunGC(rt);
    if (rt->use_dlmalloc) {
#if defined(__x86_64__) || defined(__aarch64__)
      rt->malloc_gc_threshold = rt->malloc_state.malloc_size << 1;
#else
      rt->malloc_gc_threshold =
          rt->malloc_state.malloc_size + (rt->malloc_state.malloc_size >> 1);
#endif
    } else {
      rt->malloc_gc_threshold =
          rt->malloc_state.malloc_size + (rt->malloc_state.malloc_size >> 1);
    }
  }
}

QJS_STATIC size_t lepus_malloc_usable_size_unknown(const void *ptr) {
  return 0;
}

void *lepus_malloc_rt(LEPUSRuntime *rt, size_t size) {
  return rt->mf.lepus_malloc(&rt->malloc_state, size);
}

void lepus_free_rt(LEPUSRuntime *rt, void *ptr) {
  rt->mf.lepus_free(&rt->malloc_state, ptr);
}

void *lepus_realloc_rt(LEPUSRuntime *rt, void *ptr, size_t size) {
  return rt->mf.lepus_realloc(&rt->malloc_state, ptr, size);
}

size_t lepus_malloc_usable_size_rt(LEPUSRuntime *rt, const void *ptr) {
  return rt->mf.lepus_malloc_usable_size(ptr);
}

void *lepus_mallocz_rt(LEPUSRuntime *rt, size_t size) {
  void *ptr;
  ptr = lepus_malloc_rt(rt, size);
  if (!ptr) return NULL;
  return memset(ptr, 0, size);
}

#ifdef CONFIG_BIGNUM
/* called by libbf */
static void *lepus_bf_realloc(void *opaque, void *ptr, size_t size) {
  LEPUSRuntime *rt = reinterpret_cast<LEPUSRuntime *>(opaque);
  return lepus_realloc_rt(rt, ptr, size);
}
#endif /* CONFIG_BIGNUM */

/* Throw out of memory in case of error */
void *lepus_malloc(LEPUSContext *ctx, size_t size) {
  void *ptr;
  ptr = lepus_malloc_rt(ctx->rt, size);
  if (unlikely(!ptr)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  return ptr;
}

/* Throw out of memory in case of error */
void *lepus_mallocz(LEPUSContext *ctx, size_t size) {
  void *ptr;
  ptr = lepus_mallocz_rt(ctx->rt, size);
  if (unlikely(!ptr)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  return ptr;
}

void lepus_free(LEPUSContext *ctx, void *ptr) { lepus_free_rt(ctx->rt, ptr); }

/* Throw out of memory in case of error */
void *lepus_realloc(LEPUSContext *ctx, void *ptr, size_t size) {
  void *ret;
  ret = lepus_realloc_rt(ctx->rt, ptr, size);
  if (unlikely(!ret && size != 0)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  return ret;
}

/* store extra allocated size in *pslack if successful */
void *lepus_realloc2(LEPUSContext *ctx, void *ptr, size_t size,
                     size_t *pslack) {
  void *ret;
  ret = lepus_realloc_rt(ctx->rt, ptr, size);
  if (unlikely(!ret && size != 0)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  if (pslack) {
    size_t new_size = ctx->rt->mf.lepus_malloc_usable_size(ret);
    *pslack = (new_size > size) ? new_size - size : 0;
  }
  return ret;
}

size_t lepus_malloc_usable_size(LEPUSContext *ctx, const void *ptr) {
  return lepus_malloc_usable_size_rt(ctx->rt, ptr);
}

/* Throw out of memory exception in case of error */
char *lepus_strndup(LEPUSContext *ctx, const char *s, size_t n) {
  char *ptr;
  ptr = static_cast<char *>(lepus_malloc(ctx, n + 1));
  if (ptr) {
    memcpy(ptr, s, n);
    ptr[n] = '\0';
  }
  return ptr;
}

char *lepus_strdup(LEPUSContext *ctx, const char *str) {
  return lepus_strndup(ctx, str, strlen(str));
}

QJS_STATIC inline void lepus_dbuf_init(LEPUSContext *ctx, DynBuf *s) {
  dbuf_init2(s, ctx->rt, (DynBufReallocFunc *)lepus_realloc_rt);
}

QJS_STATIC inline int is_digit(int c) { return c >= '0' && c <= '9'; }

typedef struct LEPUSClassShortDef {
  LEPUSAtom class_name;
  LEPUSClassFinalizer *finalizer;
  LEPUSClassGCMark *gc_mark;
} LEPUSClassShortDef;

typedef struct ReferenceRecord {
  int max_size;
  LEPUSValue *references;
  int length;
} ReferenceRecord;

typedef struct RegistryRecord {
  struct ReferenceRecord *registra;
  struct ReferenceRecord *heldvalue;
  struct ReferenceRecord *target;
  struct ReferenceRecord *token;
  struct LEPUSFinalizationRegistryEntry *entry;
  int *idx;
} RegistryRecord;

typedef struct LEPUSMapRecord {
  int ref_count; /* used during enumeration to avoid freeing the record */
  BOOL empty;    /* TRUE if the record is deleted */
  struct LEPUSMapState *map;
  struct LEPUSMapRecord *next_weak_ref;
  struct list_head link;
  struct list_head hash_link;
  LEPUSValue key;
  LEPUSValue value;
  ReferenceRecord *record;  /* LEPUS_CLASS_WeakRef */
  BOOL is_ref;              /* true when for LEPUS_CLASS_WeakRef */
  RegistryRecord *registry; /* LEPUS_CLASS_FinalizationRegistry */
} LEPUSMapRecord;

typedef struct FinalizerOpaque {
  LEPUSContext *ctx;
} FinalizerOpaque;

static LEPUSClassShortDef const lepus_std_class_def[] = {
    {LEPUS_ATOM_Object, NULL, NULL}, /* LEPUS_CLASS_OBJECT */
    {LEPUS_ATOM_Array, lepus_array_finalizer,
     lepus_array_mark},             /* LEPUS_CLASS_ARRAY */
    {LEPUS_ATOM_Error, NULL, NULL}, /* LEPUS_CLASS_ERROR */
    {LEPUS_ATOM_Number, lepus_object_data_finalizer,
     lepus_object_data_mark}, /* LEPUS_CLASS_NUMBER */
    {LEPUS_ATOM_String, lepus_object_data_finalizer,
     lepus_object_data_mark}, /* LEPUS_CLASS_STRING */
    {LEPUS_ATOM_Boolean, lepus_object_data_finalizer,
     lepus_object_data_mark}, /* LEPUS_CLASS_BOOLEAN */
    {LEPUS_ATOM_Symbol, lepus_object_data_finalizer,
     lepus_object_data_mark}, /* LEPUS_CLASS_SYMBOL */
    {LEPUS_ATOM_Arguments, lepus_array_finalizer,
     lepus_array_mark},                 /* LEPUS_CLASS_ARGUMENTS */
    {LEPUS_ATOM_Arguments, NULL, NULL}, /* LEPUS_CLASS_MAPPED_ARGUMENTS */
    {LEPUS_ATOM_Date, lepus_object_data_finalizer,
     lepus_object_data_mark},          /* LEPUS_CLASS_DATE */
    {LEPUS_ATOM_Object, NULL, NULL},   /* LEPUS_CLASS_MODULE_NS */
    {LEPUS_ATOM_Function, NULL, NULL}, /* LEPUS_CLASS_C_FUNCTION */
    {LEPUS_ATOM_Function, lepus_bytecode_function_finalizer,
     lepus_bytecode_function_mark}, /* LEPUS_CLASS_BYTECODE_FUNCTION */
    {LEPUS_ATOM_Function, lepus_bound_function_finalizer,
     lepus_bound_function_mark}, /* LEPUS_CLASS_BOUND_FUNCTION */
    {LEPUS_ATOM_Function, lepus_c_function_data_finalizer,
     lepus_c_function_data_mark}, /* LEPUS_CLASS_C_FUNCTION_DATA */
    {LEPUS_ATOM_GeneratorFunction, lepus_bytecode_function_finalizer,
     lepus_bytecode_function_mark}, /* LEPUS_CLASS_GENERATOR_FUNCTION */
    {LEPUS_ATOM_ForInIterator, lepus_for_in_iterator_finalizer,
     lepus_for_in_iterator_mark}, /* LEPUS_CLASS_FOR_IN_ITERATOR */
    {LEPUS_ATOM_RegExp, lepus_regexp_finalizer, NULL}, /* LEPUS_CLASS_REGEXP */
    {LEPUS_ATOM_ArrayBuffer, lepus_array_buffer_finalizer,
     NULL}, /* LEPUS_CLASS_ARRAY_BUFFER */
    {LEPUS_ATOM_SharedArrayBuffer, lepus_array_buffer_finalizer,
     NULL}, /* LEPUS_CLASS_SHARED_ARRAY_BUFFER */
    {LEPUS_ATOM_Uint8ClampedArray, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_UINT8C_ARRAY */
    {LEPUS_ATOM_Int8Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_INT8_ARRAY */
    {LEPUS_ATOM_Uint8Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_UINT8_ARRAY */
    {LEPUS_ATOM_Int16Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_INT16_ARRAY */
    {LEPUS_ATOM_Uint16Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_UINT16_ARRAY */
    {LEPUS_ATOM_Int32Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_INT32_ARRAY */
    {LEPUS_ATOM_Uint32Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_UINT32_ARRAY */
#ifdef CONFIG_BIGNUM
    {LEPUS_ATOM_BigInt64Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_BIG_INT64_ARRAY */
    {LEPUS_ATOM_BigUint64Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_BIG_UINT64_ARRAY */
#endif
    {LEPUS_ATOM_Float32Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_FLOAT32_ARRAY */
    {LEPUS_ATOM_Float64Array, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_FLOAT64_ARRAY */
    {LEPUS_ATOM_DataView, lepus_typed_array_finalizer,
     lepus_typed_array_mark}, /* LEPUS_CLASS_DATAVIEW */
#ifdef CONFIG_BIGNUM
    {LEPUS_ATOM_BigInt, lepus_object_data_finalizer,
     lepus_object_data_mark}, /* LEPUS_CLASS_BIG_INT */
    {LEPUS_ATOM_BigFloat, lepus_object_data_finalizer,
     lepus_object_data_mark}, /* LEPUS_CLASS_BIG_FLOAT */
    {LEPUS_ATOM_BigFloatEnv, lepus_float_env_finalizer,
     NULL}, /* LEPUS_CLASS_FLOAT_ENV */
#endif
    {LEPUS_ATOM_Map, lepus_map_finalizer, lepus_map_mark}, /* LEPUS_CLASS_MAP */
    {LEPUS_ATOM_Set, lepus_map_finalizer, lepus_map_mark}, /* LEPUS_CLASS_SET */
    {LEPUS_ATOM_WeakMap, lepus_map_finalizer,
     lepus_map_mark}, /* LEPUS_CLASS_WEAKMAP */
    {LEPUS_ATOM_WeakSet, lepus_map_finalizer,
     lepus_map_mark}, /* LEPUS_CLASS_WEAKSET */
    {LEPUS_ATOM_Map_Iterator, lepus_map_iterator_finalizer,
     lepus_map_iterator_mark}, /* LEPUS_CLASS_MAP_ITERATOR */
    {LEPUS_ATOM_Set_Iterator, lepus_map_iterator_finalizer,
     lepus_map_iterator_mark}, /* LEPUS_CLASS_SET_ITERATOR */
    {LEPUS_ATOM_Array_Iterator, lepus_array_iterator_finalizer,
     lepus_array_iterator_mark}, /* LEPUS_CLASS_ARRAY_ITERATOR */
    {LEPUS_ATOM_String_Iterator, lepus_array_iterator_finalizer,
     lepus_array_iterator_mark}, /* LEPUS_CLASS_STRING_ITERATOR */
    {LEPUS_ATOM_RegExp_String_Iterator, lepus_regexp_string_iterator_finalizer,
     lepus_regexp_string_iterator_mark}, /* LEPUS_CLASS_STRING_ITERATOR */
    {LEPUS_ATOM_Generator, lepus_generator_finalizer,
     lepus_generator_mark}, /* LEPUS_CLASS_GENERATOR */
};

QJS_STATIC int init_class_range(LEPUSRuntime *rt, LEPUSClassShortDef const *tab,
                                int start, int count) {
  LEPUSClassDef cm_s, *cm = &cm_s;
  int i, class_id;

  for (i = 0; i < count; i++) {
    class_id = i + start;
    memset(cm, 0, sizeof(*cm));
    cm->finalizer = tab[i].finalizer;
    cm->gc_mark = tab[i].gc_mark;
    if (LEPUS_NewClass1(rt, class_id, cm, tab[i].class_name) < 0) return -1;
  }
  return 0;
}

#ifdef ENABLE_PRIMJS_SNAPSHOT
QJS_STATIC bool primjs_snapshot_enabled() {
#ifdef FORCE_USE_PRIMJS
  return true;
#else
#ifdef ENABLE_MONITOR
  bool value = GetSettingsWithKey("primjs_snapshot_enable");
#if defined(ANDROID) || defined(__ANDROID__)
  LOGI("primjs_snapshot_enable: %d", value);
#endif
  return value;
#else
  return false;
#endif  // ENABLE_MONITOR
#endif  // FORCE_USE_PRIMJS
}
#endif

QJS_STATIC bool dlmalloc_enabled() {
#ifdef DLMALLOC_WINDOWS
  return false;
#endif
#ifdef ENABLE_MONITOR
  return GetSettingsWithKey("dlmalloc_enable");
#else

#ifndef DISABLE_DLMALLOC
  return true;
#else
  return false;
#endif
#endif
}
#ifdef MALLOC_DEBUG
static bool dlmalloc_debug_enabled() {
#ifdef ENABLE_MONITOR
  return GetSettingsWithKey("dlmalloc_debug_enable");
#else
  return true;
#endif
}

static bool dlmalloc_debug_protect_enabled() {
#ifdef ENABLE_MONITOR
  return GetSettingsWithKey("dlmalloc_debug_protect_enable");
#else
  return false;
#endif
}

static int dlmalloc_protect_granularity() { return 1000; }
#endif

static inline uint8_t *lepus_get_stack_pointer(void);
LEPUSRuntime *LEPUS_NewRuntime2(const LEPUSMallocFunctions *mf, void *opaque) {
  LEPUSRuntime *rt;
  LEPUSMallocState ms;

  memset(&ms, 0, sizeof(ms));
  ms.opaque = opaque;
  ms.malloc_limit = -1;
  bool dlmalloc_is_active = dlmalloc_enabled();
#ifdef ENABLE_PRIMJS_SNAPSHOT
  bool primjs_is_active = primjs_snapshot_enabled();
#endif

#ifdef ENABLE_MONITOR
#ifdef ENABLE_PRIMJS_SNAPSHOT
  const char *module_name = primjs_is_active ? MODULE_PRIMJS : MODULE_QUICK;
  MonitorEvent(module_name, DEFAULT_BIZ_NAME, "NewRuntime", "true");
#else
  MonitorEvent(MODULE_QUICK, DEFAULT_BIZ_NAME, "NewRuntime", "true");
#endif
#endif

#ifdef DLMALLOC_WINDOWS
  rt = static_cast<LEPUSRuntime *>(mf->lepus_malloc(&ms, sizeof(LEPUSRuntime)));
#else
  if (dlmalloc_is_active) {
#define SYSTEM_MALLOC malloc
    rt = static_cast<LEPUSRuntime *>(SYSTEM_MALLOC(sizeof(LEPUSRuntime)));
#ifdef MALLOC_DEBUG
    malloc_debug_initialize(dlmalloc_protect_granularity());
#endif
  } else {
    rt = static_cast<LEPUSRuntime *>(
        mf->lepus_malloc(&ms, sizeof(LEPUSRuntime)));
  }
#endif
  if (!rt) return NULL;
  memset(rt, 0, sizeof(*rt));
  rt->use_dlmalloc = dlmalloc_is_active;
#ifdef ENABLE_PRIMJS_SNAPSHOT
  rt->use_primjs = primjs_is_active;
#endif
  rt->mf = *mf;
  if (!rt->mf.lepus_malloc_usable_size) {
    /* use dummy function if none provided */
    rt->mf.lepus_malloc_usable_size = lepus_malloc_usable_size_unknown;
  }
  rt->malloc_state = ms;
  if (dlmalloc_is_active) {
    rt->malloc_state.dlmalloc_state.mflags = 1;
  }
#ifdef MALLOC_DEBUG
  rt->malloc_state.dlmalloc_state.enable_malloc_debug =
      dlmalloc_debug_enabled();
  rt->malloc_state.dlmalloc_state.enable_malloc_debug_protect =
      dlmalloc_debug_protect_enabled();
  if (rt->malloc_state.dlmalloc_state.enable_malloc_debug ||
      rt->malloc_state.dlmalloc_state.enable_malloc_debug_protect)
    assert(rt->use_dlmalloc == true);
#endif
  rt->malloc_gc_threshold = 256 * 1024;

#ifdef CONFIG_BIGNUM
  bf_context_init(&rt->bf_ctx, lepus_bf_realloc, rt);
#endif

  init_list_head(&rt->context_list);
  init_list_head(&rt->obj_list);
  // <ByteDance begin>
  init_list_head(&rt->gc_bytecode_list);
  init_list_head(&rt->gc_obj_list);
  // <ByteDance end>
#ifdef DUMP_LEAKS
  init_list_head(&rt->string_list);
#endif
  init_list_head(&rt->job_list);
  init_list_head(&rt->unhandled_rejections);

  if (LEPUS_InitAtoms(rt)) goto fail;

  /* create the object, array and function classes */
  if (init_class_range(rt, lepus_std_class_def, LEPUS_CLASS_OBJECT,
                       countof(lepus_std_class_def)) < 0)
    goto fail;
  rt->class_array[LEPUS_CLASS_ARGUMENTS].exotic =
      &lepus_arguments_exotic_methods;
  rt->class_array[LEPUS_CLASS_STRING].exotic = &lepus_string_exotic_methods;
  rt->class_array[LEPUS_CLASS_MODULE_NS].exotic =
      &lepus_module_ns_exotic_methods;

  rt->class_array[LEPUS_CLASS_C_FUNCTION].call = lepus_call_c_function;
  rt->class_array[LEPUS_CLASS_C_FUNCTION_DATA].call =
      lepus_c_function_data_call;
  rt->class_array[LEPUS_CLASS_BOUND_FUNCTION].call = lepus_call_bound_function;
  rt->class_array[LEPUS_CLASS_GENERATOR_FUNCTION].call =
      lepus_generator_function_call;
  // <bytedance begin>
#ifdef ENABLE_LEPUSNG
  rt->lepus_type_.array_typeid_ = -1;
  rt->lepus_type_.table_typeid_ = -1;
#endif
  // <bytedance end>
  if (init_shape_hash(rt)) goto fail;

#ifdef BUILD_ASYNC_STACK
  rt->current_micro_task = NULL;
#endif
  rt->stack_top = lepus_get_stack_pointer();
  rt->stack_size = LEPUS_DEFAULT_STACK_SIZE;
  rt->current_exception = LEPUS_NULL;
  return rt;
fail:
  LEPUS_FreeRuntime(rt);
  return NULL;
}

/* default memory allocation functions with memory limitation */
QJS_STATIC inline size_t lepus_def_malloc_usable_size(void *ptr) {
#if defined(__APPLE__)
  return malloc_size(ptr);
#elif defined(_WIN32)
  return _msize(ptr);
#elif defined(EMSCRIPTEN)
  return 0;
#elif defined(__linux__)
  return malloc_usable_size(ptr);
#else
  /* change this to `return 0;` if
   * compilation fails */
  return malloc_usable_size(ptr);
#endif
}

QJS_STATIC void *lepus_def_malloc(LEPUSMallocState *s, size_t size) {
  void *ptr;

  /* Do not allocate zero bytes: behavior is platform dependent */
  assert(size != 0);

  if (unlikely(s->malloc_size + size > s->malloc_limit)) return NULL;

  ptr = malloc(size);
  if (!ptr) return NULL;

  s->malloc_count++;
  s->malloc_size += lepus_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
  return ptr;
}

#ifndef DLMALLOC_WINDOWS
QJS_STATIC void *base_dlmalloc(
    LEPUSMallocState *s, size_t size,
    void *(*dlmalloc_debug)(struct malloc_state *state, size_t size),
    size_t (*dlmalloc_usable_size)(void *ptr)) {
  void *ptr;

  /* Do not allocate zero bytes: behavior is platform dependent */
  assert(size != 0);

  if (unlikely(s->malloc_size + size > s->malloc_limit)) return NULL;

  ptr = dlmalloc_debug(&s->dlmalloc_state, size);

  if (!ptr) return NULL;

  s->malloc_count++;
  s->malloc_size +=
      (uint64_t)dlmalloc_usable_size(ptr) + (uint64_t)MALLOC_OVERHEAD;
  return ptr;
}

QJS_STATIC void *lepus_def_dlmalloc(LEPUSMallocState *s, size_t size) {
  return base_dlmalloc(s, size, dlmalloc, dlmalloc_usable_size);
}
#ifdef MALLOC_DEBUG
static void *lepus_def_dlmalloc_debug(LEPUSMallocState *s, size_t size) {
  return base_dlmalloc(s, size, chk_malloc, dlmalloc_usable_size_debug);
}

static void *lepus_def_dlmalloc_debug_protect(LEPUSMallocState *s,
                                              size_t size) {
  return base_dlmalloc(s, size, chk_malloc_protect,
                       dlmalloc_usable_size_debug_protect);
}
#endif
#endif

QJS_STATIC void lepus_def_free(LEPUSMallocState *s, void *ptr) {
  if (!ptr) return;

  s->malloc_count--;
  s->malloc_size -= lepus_def_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
  free(ptr);
}

#ifndef DLMALLOC_WINDOWS
QJS_STATIC void base_dlfree(LEPUSMallocState *s, void *ptr,
                            size_t (*dlmalloc_usable_size)(void *ptr),
                            void (*free)(struct malloc_state *state,
                                         void *ptr)) {
  if (!ptr) return;
  s->malloc_count--;
  s->malloc_size -=
      (uint64_t)dlmalloc_usable_size(ptr) + (uint64_t)MALLOC_OVERHEAD;
  free(&s->dlmalloc_state, ptr);
}

QJS_STATIC void lepus_def_dlfree(LEPUSMallocState *s, void *ptr) {
  base_dlfree(s, ptr, dlmalloc_usable_size, dlfree);
}
#ifdef MALLOC_DEBUG
static void lepus_def_dlfree_debug(LEPUSMallocState *s, void *ptr) {
  base_dlfree(s, ptr, dlmalloc_usable_size_debug, chk_free);
}

static void lepus_def_dlfree_debug_protect(LEPUSMallocState *s, void *ptr) {
  base_dlfree(s, ptr, dlmalloc_usable_size_debug_protect, chk_free_protect);
}
#endif
#endif

QJS_STATIC void *lepus_def_realloc(LEPUSMallocState *s, void *ptr,
                                   size_t size) {
  size_t old_size;

  if (!ptr) {
    if (size == 0) return NULL;
    return lepus_def_malloc(s, size);
  }
  old_size = lepus_def_malloc_usable_size(ptr);
  if (size == 0) {
    s->malloc_count--;
    s->malloc_size -= old_size + MALLOC_OVERHEAD;
    free(ptr);
    return NULL;
  }
  if (s->malloc_size + size - old_size > s->malloc_limit) return NULL;

  ptr = realloc(ptr, size);
  if (!ptr) return NULL;

  s->malloc_size += lepus_def_malloc_usable_size(ptr) - old_size;
  return ptr;
}

#ifndef DLMALLOC_WINDOWS
QJS_STATIC void *base_dlrealloc(
    LEPUSMallocState *s, void *ptr, size_t size,
    void *(*dlmalloc_debug)(LEPUSMallocState *s, size_t size),
    size_t (*dlmalloc_usable_size)(void *ptr),
    void *(*realloc)(struct malloc_state *s, void *ptr, size_t size),
    void (*free)(struct malloc_state *state, void *ptr)) {
  size_t old_size;

  if (!ptr) {
    if (size == 0) return NULL;
    return dlmalloc_debug(s, size);
  }
  old_size = dlmalloc_usable_size(ptr);
  if (size == 0) {
    s->malloc_count--;
    s->malloc_size -= (uint64_t)old_size + (uint64_t)MALLOC_OVERHEAD;
    free(&s->dlmalloc_state, ptr);
    return NULL;
  }
  if (s->malloc_size + size - old_size > s->malloc_limit) return NULL;
  ptr = realloc(&s->dlmalloc_state, ptr, size);
  if (!ptr) return NULL;

  s->malloc_size += (uint64_t)dlmalloc_usable_size(ptr) - (uint64_t)old_size;
  return ptr;
}

QJS_STATIC void *lepus_def_dlrealloc(LEPUSMallocState *s, void *ptr,
                                     size_t size) {
  return base_dlrealloc(s, ptr, size, lepus_def_dlmalloc, dlmalloc_usable_size,
                        dlrealloc, dlfree);
}
#ifdef MALLOC_DEBUG
static void *lepus_def_dlrealloc_debug(LEPUSMallocState *s, void *ptr,
                                       size_t size) {
  return base_dlrealloc(s, ptr, size, lepus_def_dlmalloc_debug,
                        dlmalloc_usable_size_debug, chk_realloc, chk_free);
}

static void *lepus_def_dlrealloc_debug_protect(LEPUSMallocState *s, void *ptr,
                                               size_t size) {
  return base_dlrealloc(s, ptr, size, lepus_def_dlmalloc_debug_protect,
                        dlmalloc_usable_size_debug_protect, chk_realloc_protect,
                        chk_free_protect);
}
#endif
#endif

static const LEPUSMallocFunctions def_malloc_funcs = {
  lepus_def_malloc,
  lepus_def_free,
  lepus_def_realloc,
#if defined(__APPLE__)
  malloc_size,
#elif defined(_WIN32)
  (size_t(*)(const void *))_msize,
#elif defined(EMSCRIPTEN)
  NULL,
#elif defined(__linux__)
  (size_t(*)(const void *))malloc_usable_size,
#else
  /* change this to `NULL,` if compilation
     fails */
  malloc_usable_size,
#endif
};

#ifndef DLMALLOC_WINDOWS
static const LEPUSMallocFunctions def_dlmalloc_funcs = {
    lepus_def_dlmalloc,
    lepus_def_dlfree,
    lepus_def_dlrealloc,
    (size_t(*)(const void *))dlmalloc_usable_size,
};
#ifdef MALLOC_DEBUG
static const LEPUSMallocFunctions def_dlmalloc_debug_funcs = {
    lepus_def_dlmalloc_debug,
    lepus_def_dlfree_debug,
    lepus_def_dlrealloc_debug,
    (size_t(*)(const void *))dlmalloc_usable_size_debug,
};

static const LEPUSMallocFunctions def_dlmalloc_debug_protect_funcs = {
    lepus_def_dlmalloc_debug_protect,
    lepus_def_dlfree_debug_protect,
    lepus_def_dlrealloc_debug_protect,
    (size_t(*)(const void *))dlmalloc_usable_size_debug_protect,
};
#endif
#endif

LEPUSRuntime *LEPUS_NewRuntime(void) {
#ifdef DLMALLOC_WINDOWS
  return LEPUS_NewRuntime2(&def_malloc_funcs, NULL);
#else
  if (dlmalloc_enabled() == TRUE) {
#ifdef MALLOC_DEBUG
    if (dlmalloc_debug_enabled() == TRUE)
      return LEPUS_NewRuntime2(&def_dlmalloc_debug_funcs, NULL);
    else if (dlmalloc_debug_protect_enabled()) {
      return LEPUS_NewRuntime2(&def_dlmalloc_debug_protect_funcs, NULL);
    } else {
#endif
      return LEPUS_NewRuntime2(&def_dlmalloc_funcs, NULL);
#ifdef MALLOC_DEBUG
    }
#endif
  } else
    return LEPUS_NewRuntime2(&def_malloc_funcs, NULL);
#endif
}

void LEPUS_SetMemoryLimit(LEPUSRuntime *rt, size_t limit) {
  rt->malloc_state.malloc_limit = limit;
}

/* use -1 to disable automatic GC */
void LEPUS_SetGCThreshold(LEPUSRuntime *rt, size_t gc_threshold) {
  rt->malloc_gc_threshold = gc_threshold;
}

void LEPUS_SetInterruptHandler(LEPUSRuntime *rt, LEPUSInterruptHandler *cb,
                               void *opaque) {
  rt->interrupt_handler = cb;
  rt->interrupt_opaque = opaque;
}

void LEPUS_SetCanBlock(LEPUSRuntime *rt, BOOL can_block) {
  rt->can_block = can_block;
}

/* return 0 if OK, < 0 if exception */
int LEPUS_EnqueueJob(LEPUSContext *ctx, LEPUSJobFunc *job_func, int argc,
                     LEPUSValueConst *argv) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSJobEntry *e;
  int i;

  e = static_cast<LEPUSJobEntry *>(
      lepus_malloc(ctx, sizeof(*e) + argc * sizeof(LEPUSValue)));
  if (!e) return -1;
  e->ctx = ctx;
  e->job_func = job_func;
  e->argc = argc;
  for (i = 0; i < argc; i++) {
    e->argv[i] = LEPUS_DupValue(ctx, argv[i]);
  }
  list_add_tail(&e->link, &rt->job_list);
  return 0;
}

BOOL LEPUS_IsJobPending(LEPUSRuntime *rt) { return !list_empty(&rt->job_list); }

/* return < 0 if exception, 0 if no job pending, 1 if a job was
   executed successfully. the context of the job is stored in '*pctx' */
int LEPUS_ExecutePendingJob(LEPUSRuntime *rt, LEPUSContext **pctx) {
  LEPUSContext *ctx;
  LEPUSJobEntry *e;
  LEPUSValue res;
  int i, ret;

  if (list_empty(&rt->job_list)) {
    *pctx = NULL;
    return 0;
  }

  /* get the first pending job and execute it */
  e = list_entry(rt->job_list.next, LEPUSJobEntry, link);
  list_del(&e->link);
  ctx = e->ctx;
  res = e->job_func(e->ctx, e->argc, (LEPUSValueConst *)e->argv);
  for (i = 0; i < e->argc; i++) LEPUS_FreeValue(ctx, e->argv[i]);
  if (LEPUS_IsException(res))
    ret = -1;
  else
    ret = 1;
  LEPUS_FreeValue(ctx, res);
  lepus_free(ctx, e);
  *pctx = ctx;
  return ret;
}

QJS_STATIC inline uint32_t atom_get_free(const LEPUSAtomStruct *p) {
  return (uintptr_t)p >> 1;
}

QJS_STATIC inline BOOL atom_is_free(const LEPUSAtomStruct *p) {
  return (uintptr_t)p & 1;
}

QJS_STATIC inline LEPUSAtomStruct *atom_set_free(uint32_t v) {
  return (LEPUSAtomStruct *)(((uintptr_t)v << 1) | 1);
}

/* Note: the string contents are uninitialized */
QJS_STATIC LEPUSString *lepus_alloc_string_rt(LEPUSRuntime *rt, int max_len,
                                              int is_wide_char) {
  LEPUSString *str;
  str = static_cast<LEPUSString *>(lepus_malloc_rt(
      rt, sizeof(LEPUSString) + (max_len << is_wide_char) + 1 - is_wide_char));
  if (unlikely(!str)) return NULL;
  str->header.ref_count = 1;
  str->is_wide_char = is_wide_char;
  str->len = max_len;
  str->atom_type = 0;
  str->hash = 0;      /* optional but costless */
  str->hash_next = 0; /* optional */
#ifdef DUMP_LEAKS
  list_add_tail(&str->link, &rt->string_list);
#endif

#ifdef ENABLE_LEPUSNG
  // <ByteDance begin>
  str->cache_ = NULL;
  // <ByteDance end>
#endif
  return str;
}

QJS_STATIC LEPUSString *lepus_alloc_string(LEPUSContext *ctx, int max_len,
                                           int is_wide_char) {
  LEPUSString *p;
  p = lepus_alloc_string_rt(ctx->rt, max_len, is_wide_char);
  if (unlikely(!p)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return NULL;
  }
  return p;
}

/* same as LEPUS_FreeValueRT() but faster */
QJS_STATIC inline void lepus_free_string(LEPUSRuntime *rt, LEPUSString *str) {
  if (--str->header.ref_count <= 0) {
    if (str->atom_type) {
      LEPUS_FreeAtomStruct(rt, str);
    } else {
#ifdef DUMP_LEAKS
      list_del(&str->link);
#endif

#ifdef ENABLE_LEPUSNG
      // <ByteDance begin>
      LEPUS_FreeStringCache(rt, str);
      // <ByteDance end>
#endif
      lepus_free_rt(rt, str);
    }
  }
}

void LEPUS_SetRuntimeInfo(LEPUSRuntime *rt, const char *s) {
  if (rt) {
    rt->rt_info = s;
#ifdef ENABLE_MONITOR
#ifdef ENABLE_PRIMJS_SNAPSHOT
    const char *module_name = rt->use_primjs ? MODULE_PRIMJS : MODULE_QUICK;
    MonitorEvent(module_name, s, "SetRuntimeInfo", "true");
#else
    MonitorEvent(MODULE_QUICK, s, "SetRuntimeInfo", "true");
#endif
#endif
  }
}

void LEPUS_FreeRuntime(LEPUSRuntime *rt) {
  struct list_head *el, *el1;
  int i;

  LEPUS_FreeValueRT(rt, rt->current_exception);

  list_for_each_safe(el, el1, &rt->context_list) {
    LEPUSContext *ctx = list_entry(el, LEPUSContext, link);
    LEPUS_FreeContext(ctx);
  }

  list_for_each_safe(el, el1, &rt->job_list) {
    LEPUSJobEntry *e = list_entry(el, LEPUSJobEntry, link);
    for (i = 0; i < e->argc; i++) LEPUS_FreeValueRT(rt, e->argv[i]);
    lepus_free_rt(rt, e);
  }
  init_list_head(&rt->job_list);

  list_for_each_safe(el, el1, &rt->unhandled_rejections) {
    LEPUSUnhandledRejectionEntry *e =
        list_entry(el, LEPUSUnhandledRejectionEntry, link);
    LEPUS_FreeValueRT(rt, e->error);
    lepus_free_rt(rt, e);
  }
  init_list_head(&rt->unhandled_rejections);

  LEPUS_RunGC(rt);

#ifdef ENABLE_LEPUSNG
  // In LepusNG, the gc is performed twice to eliminate mem leak
  if (rt->rt_info && !strcmp(rt->rt_info, "Lynx_LepusNG")) {
    LEPUS_RunGC(rt);
  }
#endif

#ifdef DUMP_LEAKS
  int exists_leak = 0;
  /* leaking objects */
  {
    BOOL header_done;
    LEPUSObject *p;
    int count;
    printf("DUMP_LEAKS: dump leaks...\n");

    /* remove the internal refcounts to display only the object
       referenced externally */
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      p->gc_header.mark = 0;
    }
    gc_decref(rt);

    count = 0;
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      if (p->header.ref_count != 0) {
        count++;
      }
    }

    header_done = FALSE;
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      if (p->header.ref_count != 0) {
        if (!header_done) {
          printf("DUMP_LEAKS: Object leaks: %d\n", count);
          LEPUS_DumpObjectHeader(rt);
          header_done = TRUE;
        }
        LEPUS_DumpObject(rt, p);
        exists_leak++;
      }
    }

    count = 0;
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      if (p->header.ref_count == 0) {
        count++;
        exists_leak++;
      }
    }
    if (count != 0) {
      printf("DUMP_LEAKS: Secondary object leaks: %d\n", count);
    }
  }

  // assert(list_empty(&rt->obj_list));
#else
  if (!list_empty(&rt->obj_list)) {
    printf("LEPUS_FreeRuntime obj_list leak...\n");
  }
#endif

  /* free the classes */
  for (i = 0; i < rt->class_count; i++) {
    LEPUSClass *cl = &rt->class_array[i];
    if (cl->class_id != 0) {
      LEPUS_FreeAtomRT(rt, cl->class_name);
    }
  }
  lepus_free_rt(rt, rt->class_array);

#ifdef CONFIG_BIGNUM
  bf_context_end(&rt->bf_ctx);
#endif

#ifdef DUMP_LEAKS
  /* only the atoms defined in LEPUS_InitAtoms() should be left */
  {
    BOOL header_done = FALSE;
    char dump_buf[4096], fmt_buf[1024];
#define write(...) \
  snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), strcat(dump_buf, fmt_buf);

    for (i = 0; i < rt->atom_size; i++) {
      LEPUSAtomStruct *p = rt->atom_array[i];
      if (!atom_is_free(p) /* && p->str*/) {
        if (i >= LEPUS_ATOM_END || p->header.ref_count != 1) {
          if (!header_done) {
            header_done = TRUE;
            if (rt->rt_info) {
              printf("DUMP_LEAKS: %s:1: atom leakage:", rt->rt_info);
            } else {
              printf("DUMP_LEAKS: Atom leaks:\n");
              printf("DUMP_LEAKS:     %6s %6s %s\n", "ID", "REFCNT", "NAME");
            }
          }
          dump_buf[0] = '\0';
          exists_leak++;
          if (rt->rt_info) {
            write(" ");
          } else {
            write("    %6u %6u ", i, p->header.ref_count);
          }
          switch (p->atom_type) {
            case LEPUS_ATOM_TYPE_STRING:
              LEPUS_DumpStringNoPrint(rt, p, dump_buf);
              break;
            case LEPUS_ATOM_TYPE_GLOBAL_SYMBOL:
              write("Symbol.for(");
              LEPUS_DumpStringNoPrint(rt, p, dump_buf);
              write(")");
              break;
            case LEPUS_ATOM_TYPE_SYMBOL:
              if (p->hash == LEPUS_ATOM_HASH_SYMBOL) {
                write("Symbol(");
                LEPUS_DumpStringNoPrint(rt, p, dump_buf);
                write(")");
              } else {
                write("Private(");
                LEPUS_DumpStringNoPrint(rt, p, dump_buf);
                write(")");
              }
              break;
          }
          if (rt->rt_info) {
            write(":%u", p->header.ref_count);
          } else {
            write("\n");
          }
          printf("DUMP_LEAKS: %s", dump_buf);
        }
      }
    }
#undef write
#ifndef DEBUG_MEMORY
    if (rt->rt_info && header_done) printf("\n");
#endif
  }
#endif

  /* free the atoms */
  for (i = 0; i < rt->atom_size; i++) {
    LEPUSAtomStruct *p = rt->atom_array[i];
    if (!atom_is_free(p)) {
#ifdef DUMP_LEAKS
      list_del(&p->link);
#endif
// bytedance begin
#ifdef ENABLE_LEPUSNG
      LEPUS_FreeStringCache(rt, p);
#endif
      // bytedanend
      lepus_free_rt(rt, p);
    }
  }
  lepus_free_rt(rt, rt->atom_array);
  lepus_free_rt(rt, rt->atom_hash);
  lepus_free_rt(rt, rt->shape_hash);
#ifdef DUMP_LEAKS
  if (!list_empty(&rt->string_list)) {
    char dump_buf[4096], fmt_buf[1024];
#define write(...) \
  snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), strcat(dump_buf, fmt_buf);
    if (rt->rt_info) {
      printf("DUMP_LEAKS: %s:1: string leakage:", rt->rt_info);
    } else {
      printf("DUMP_LEAKS: String leaks:\n");
      printf("DUMP_LEAKS:     %6s %s\n", "REFCNT", "VALUE");
    }
    list_for_each_safe(el, el1, &rt->string_list) {
      exists_leak++;
      dump_buf[0] = '\0';
      LEPUSString *str = list_entry(el, LEPUSString, link);
      if (rt->rt_info) {
        write(" ");
      } else {
        write("    %6u ", str->header.ref_count);
      }
      LEPUS_DumpStringNoPrint(rt, str, dump_buf);
      if (rt->rt_info) {
        write(":%u", str->header.ref_count);
      } else {
        write("\n");
      }
      list_del(&str->link);
      lepus_free_rt(rt, str);
      printf("DUMP_LEAKS: %s", dump_buf);
    }
    if (rt->rt_info) write("\n");
#undef write
  }
  {
    LEPUSMallocState *s = &rt->malloc_state;
    if (s->malloc_count > 1) {
      if (rt->rt_info) printf("DUMP_LEAKS: %s:1: ", rt->rt_info);
      printf("DUMP_LEAKS: Memory leak: %" PRIu64 " bytes lost in %" PRIu64
             " block%s\n",
             (uint64_t)(s->malloc_size - sizeof(LEPUSRuntime)),
             (uint64_t)(s->malloc_count - 1), &"s"[s->malloc_count == 2]);
    }
  }
#endif

  {
    LEPUSMallocState ms = rt->malloc_state;
    if (rt->use_dlmalloc == TRUE) {
#ifdef MALLOC_DEBUG
      if (ms.dlmalloc_state.enable_malloc_debug == 1 ||
          ms.dlmalloc_state.enable_malloc_debug_protect == 1)
        malloc_debug_finalize(&ms.dlmalloc_state);
#endif
#ifndef DLMALLOC_WINDOWS
      destroy_dlmalloc_instance(&ms.dlmalloc_state);
#define SYSTEM_FREE free
      SYSTEM_FREE(rt);
#undef SYSTEM_FREE
#endif
    } else {
      rt->mf.lepus_free(&ms, rt);
    }
  }

#ifdef DEBUG_MEMORY
  if (exists_leak > 255) {
#ifdef __ANDROID__
    __android_log_print(ANDROID_LOG_FATAL, "LYNX",
                        "DUMP_LEAKS: Memory_leak_detected!");
#else
    printf("DUMP_LEAKS: Memory_leak_detected!\n");
#endif
    (*(int *)(0xfffffff))++;
    abort();
  }
#endif
}
#define malloc(s) malloc_is_forbidden(s)
#define free(p) free_is_forbidden(p)
#define realloc(p, s) realloc_is_forbidden(p, s)

QJS_STATIC void get_backtrace(LEPUSContext *ctx, DynBuf *dbuf,
                              BOOL is_debug_mode, LEPUSValueConst error_obj,
                              const uint8_t *cur_pc, int backtrace_flags);

#if defined(EMSCRIPTEN)
#if defined(ANDROID) || defined(__ANDROID__) || defined(APPLE) || \
    defined(__APPLE__) || defined(QJS_UNITTEST) || defined(_WIN32)
QJS_STATIC inline uintptr_t get_thread_stack_limit() {
#if defined(_WIN32)
  MEMORY_BASIC_INFORMATION mem;
  VirtualQuery(&mem, &mem, sizeof mem);
  return (uintptr_t)(mem.AllocationBase) + (52 * 1024);
#else
  uintptr_t stack_limit = 0;
  void *stack;
  size_t stack_size;
  pthread_attr_t attr;
  pthread_t tid = pthread_self();
#if defined(QJS_UNITTEST)
#if defined(APPLE) || defined(__APPLE__)
  stack = pthread_get_stackaddr_np(tid);
  stack_size = pthread_get_stacksize_np(tid);
  stack_limit = reinterpret_cast<uintptr_t>(stack) - stack_size +
                (128 * 1024);  // reserve 128k
#else
  pthread_getattr_np(tid, &attr);
  pthread_attr_getstack(&attr, &stack, &stack_size);
  stack_limit =
      reinterpret_cast<uintptr_t>(stack) + (128 * 1024);  // reserve 128k
#endif
#elif defined(ANDROID) || defined(__ANDROID__)
  pthread_getattr_np(tid, &attr);
  pthread_attr_getstack(&attr, &stack, &stack_size);
  stack_limit =
      reinterpret_cast<uintptr_t>(stack) + (52 * 1024);  // reserve 52k
#elif defined(APPLE) || defined(__APPLE__)
  // stack_base
  stack = pthread_get_stackaddr_np(tid);
  stack_size = pthread_get_stacksize_np(tid);
  stack_limit = reinterpret_cast<uintptr_t>(stack) - stack_size +
                (52 * 1024);  // reserve 52k
#endif
  pthread_attr_destroy(&attr);
  return stack_limit;
#endif
}

QJS_STATIC __attribute__((unused)) inline void lepus_print_stack(
    LEPUSContext *ctx) {
  DynBuf dbuf;
  lepus_dbuf_init(ctx, &dbuf);
  get_backtrace(ctx, &dbuf, FALSE, LEPUS_NULL, NULL, 0);
  char *stack = reinterpret_cast<char *>(dbuf.buf);
  if (!stack) {
    return;
  }
#if defined(ANDROID) || defined(__ANDROID__)
  size_t len = strlen(stack);
  size_t chunkCount = len / 1000;
  size_t index = 0;
  char ch;
  for (size_t i = 0; i < chunkCount; i++) {
    index = (i + 1) * 1000 - 1;
    ch = stack[index];
    stack[index] = '\0';
    if (i == 0) {
      __android_log_print(ANDROID_LOG_ERROR, "VMSDK", "%s", stack);
      stack[index] = ch;
    } else {
      __android_log_print(ANDROID_LOG_ERROR, "VMSDK", "%s",
                          stack + i * 1000 - 1);
      stack[index] = ch;
    }
  }
  if (index == 0) {
    __android_log_print(ANDROID_LOG_ERROR, "VMSDK", "%s",
                        stack + chunkCount * 1000);
  } else {
    __android_log_print(ANDROID_LOG_ERROR, "VMSDK", "%s",
                        stack + chunkCount * 1000 - 1);
  }
#elif defined(APPLE) || defined(__APPLE__) || defined(_WIN32)
  fprintf(stderr, "==== stack overflow ====\n%s\n", stack);
#endif
  if (ctx->rt->vmsdk_callbacks_.print_by_alog) {
    ctx->rt->vmsdk_callbacks_.print_by_alog(stack);
  }
  dbuf_free(&dbuf);
}

QJS_STATIC inline uint8_t *lepus_get_stack_pointer(void) {
  return static_cast<uint8_t *>(__builtin_frame_address(0));
}

BOOL lepus_check_stack_overflow(LEPUSContext *ctx, size_t alloca_size) {
  static __thread uintptr_t stack_limit = 0;
  BOOL stack_overflow = FALSE;
  if (stack_limit == 0) {
    stack_limit =
        reinterpret_cast<uintptr_t>(lepus_get_stack_pointer()) - 400 * 1024;
  } else {
    stack_overflow =
        reinterpret_cast<uintptr_t>(lepus_get_stack_pointer()) - alloca_size <
        stack_limit;
    if (stack_overflow) {
      stack_limit = reinterpret_cast<uintptr_t>(get_thread_stack_limit());
      stack_overflow =
          reinterpret_cast<uintptr_t>(lepus_get_stack_pointer()) - alloca_size <
          stack_limit;
    }
  }
  return stack_overflow;
  // only print stack when stack overflow
  // lepus_print_stack(ctx);
  // return FALSE;
}
#else
/* currently no stack limitation */
static inline uint8_t *lepus_get_stack_pointer(void) { return NULL; }
BOOL lepus_check_stack_overflow(LEPUSContext *ctx, size_t alloca_size) {
  return FALSE;
}
#endif
#else
/* Note: OS and CPU dependent */
static inline uint8_t *lepus_get_stack_pointer(void) {
  return __builtin_frame_address(0);
}

static inline BOOL lepus_check_stack_overflow(LEPUSContext *ctx,
                                              size_t alloca_size) {
  size_t size;
  size = ctx->rt->stack_top - lepus_get_stack_pointer();
  return unlikely((size + alloca_size) > ctx->rt->stack_size);
}
#endif

LEPUSValue LEPUS_ThrowOutOfMemory(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  if (!rt->in_out_of_memory) {
    rt->in_out_of_memory = TRUE;
    LEPUS_ThrowInternalError(ctx, "out of memory");
    rt->in_out_of_memory = FALSE;
  }
  return LEPUS_EXCEPTION;
}

// <Bytedance begin>
void LEPUS_SetVirtualStackSize(LEPUSContext *ctx, uint32_t stack_size) {
#ifdef OS_IOS
  if (ctx->stack_pos != 0) {
    return;
  }
  ctx->rt->stack_size = stack_size;
  ctx->stack = static_cast<uint8_t *>(
      lepus_realloc(ctx, ctx->stack, ctx->rt->stack_size));

  if (ctx->stack == NULL) {
    ctx->rt->stack_size = 0;
  }
#endif
}
// <Bytedance end>
// <primjs begin>
void PrimInit(LEPUSContext *ctx);
// <primjs end>
LEPUSContext *LEPUS_NewContextRaw(LEPUSRuntime *rt) {
#if defined(ENABLE_PRIMJS_TRACE) && PRINT_LOG_TO_FILE && \
    (defined(ANDROID) || defined(__ANDROID__))
  pthread_mutex_lock(&prim_init_mutex);
  if (!log_f) {
    chdir("/data/local/tmp/");
    log_f = fopen("log.txt", "w");
    if (!log_f) {
      LOGE("open fail errno = %d reason = %s \n", errno, strerror(errno));
      abort();
    }
    LOGI("\nlogging to /data/local/tmp/log.txt! ---------\n\n");
  }
  pthread_mutex_unlock(&prim_init_mutex);
#endif
  LEPUSContext *ctx;
  int i;

  ctx = static_cast<LEPUSContext *>(lepus_mallocz_rt(rt, sizeof(LEPUSContext)));
  if (!ctx) return NULL;
  ctx->class_proto = static_cast<LEPUSValue *>(
      lepus_malloc_rt(rt, sizeof(ctx->class_proto[0]) * rt->class_count));
  if (!ctx->class_proto) {
    lepus_free_rt(rt, ctx);
    return NULL;
  }
  ctx->rt = rt;
#ifndef DLMALLOC_WINDOWS
  if (rt->use_dlmalloc == TRUE)
    ctx->dlmalloc_state = &rt->malloc_state.dlmalloc_state;
  else
    ctx->dlmalloc_state = NULL;
#endif

  list_add_tail(&ctx->link, &rt->context_list);
#ifdef CONFIG_BIGNUM
  ctx->bf_ctx = &rt->bf_ctx;
  ctx->fp_env.prec = 53;
  ctx->fp_env.flags = bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL;
#endif
  for (i = 0; i < rt->class_count; i++) ctx->class_proto[i] = LEPUS_NULL;
  ctx->regexp_ctor = LEPUS_NULL;
  ctx->promise_ctor = LEPUS_NULL;
  ctx->no_lepus_strict_mode = FALSE;
  init_list_head(&ctx->loaded_modules);
  init_list_head(&ctx->finalization_registries);
  LEPUS_AddIntrinsicBasicObjects(ctx);
  // <Bytedance begin>
#ifdef OS_IOS
  ctx->stack =
      static_cast<uint8_t *>(lepus_malloc(ctx, DEFAULT_VIRTUAL_STACK_SIZE));
  if (ctx->stack == NULL) {
    ctx->stack =
        static_cast<uint8_t *>(lepus_malloc(ctx, FALLBACK_VIRTUAL_STACK_SIZE));
    if (ctx->stack) {
      ctx->rt->stack_size = FALLBACK_VIRTUAL_STACK_SIZE;
    } else {
      ctx->rt->stack_size = 0;
    }
  } else {
    ctx->rt->stack_size = DEFAULT_VIRTUAL_STACK_SIZE;
  }
#endif
  // ctx->stack_pos = 0;
  ctx->next_function_id = 1;   // for lepusNG sourcemap, need to start from 1
  ctx->debuginfo_outside = 2;  // 2: uninitialize, 1: true, 0: false
  ctx->lynx_target_sdk_version = "";
  // <Bytedance end>

#ifdef ENABLE_QUICKJS_SECURITY_MODE
  ctx->op_transform_callback.encode_opcode = NULL;
  ctx->op_transform_callback.decode_opcode = NULL;
  ctx->enable_security_feature = 0;
#endif
  // <primjs begin>
#ifdef ENABLE_PRIMJS_SNAPSHOT
  if (ctx->rt->use_primjs) {
    PRIM_LOG("Use snapshot!\n");
  } else {
    PRIM_LOG("Use raw Quickjs!\n");
  }
#else
  PRIM_LOG("Use raw Quickjs!\n");
#endif
#if defined(ENABLE_PRIMJS_SNAPSHOT) || defined(ENABLE_PRIMJS_PROFILER)
  pthread_mutex_lock(&prim_init_mutex);
#if defined(ENABLE_PRIMJS_RUNTIME)
  if (!IS_PRIM_INITIALIZED) {
#endif
    PrimInit(ctx);
#if defined(ENABLE_PRIMJS_RUNTIME)
    PRIM_LOG("Prim Initialized success!\n");
    IS_PRIM_INITIALIZED = true;
  }
#endif
  pthread_mutex_unlock(&prim_init_mutex);
#endif
  // <primjs end>
  return ctx;
}

QJS_STATIC void LEPUS_AddIntrinsicWeakRef(LEPUSContext *ctx);
QJS_STATIC void LEPUS_AddIntrinsicFinalizationRegistry(LEPUSContext *ctx);

LEPUSContext *LEPUS_NewContext(LEPUSRuntime *rt) {
  LEPUSContext *ctx;

  ctx = LEPUS_NewContextRaw(rt);
  if (!ctx) return NULL;

  LEPUS_AddIntrinsicBaseObjects(ctx);
  LEPUS_AddIntrinsicDate(ctx);
  LEPUS_AddIntrinsicEval(ctx);
  LEPUS_AddIntrinsicStringNormalize(ctx);
  LEPUS_AddIntrinsicRegExp(ctx);
  LEPUS_AddIntrinsicJSON(ctx);
  LEPUS_AddIntrinsicProxy(ctx);
  LEPUS_AddIntrinsicMapSet(ctx);
  LEPUS_AddIntrinsicTypedArrays(ctx);
  LEPUS_AddIntrinsicPromise(ctx);
  LEPUS_AddIntrinsicWeakRef(ctx);
  LEPUS_AddIntrinsicFinalizationRegistry(ctx);
#ifdef ENABLE_QUICKJS_DEBUGGER
  ctx->debugger_info = NULL;
  ctx->debugger_parse_script = 0;
  ctx->is_profiler_ctx = 0;
  if (DebuggerIsDevtoolOn(rt)) {
    InitQJSDebugger(ctx);
    ctx->debugger_mode = 1;
    LEPUS_AddIntrinsicConsole(ctx);
  } else {
    ctx->debugger_mode = 0;
  }
#endif

  return ctx;
}

void *LEPUS_GetContextOpaque(LEPUSContext *ctx) { return ctx->user_opaque; }

void LEPUS_SetContextOpaque(LEPUSContext *ctx, void *opaque) {
  ctx->user_opaque = opaque;
}

/* set the new value and free the old value after (freeing the value
   can reallocate the object data) */
QJS_STATIC inline void set_value(LEPUSContext *ctx, LEPUSValue *pval,
                                 LEPUSValue new_val) {
  LEPUSValue old_val;
  old_val = *pval;
  *pval = new_val;
  LEPUS_FreeValue(ctx, old_val);
}

void LEPUS_SetClassProto(LEPUSContext *ctx, LEPUSClassID class_id,
                         LEPUSValue obj) {
  LEPUSRuntime *rt = ctx->rt;
  assert(class_id < rt->class_count);
  set_value(ctx, &ctx->class_proto[class_id], obj);
}

LEPUSValue LEPUS_GetClassProto(LEPUSContext *ctx, LEPUSClassID class_id) {
  LEPUSRuntime *rt = ctx->rt;
  assert(class_id < rt->class_count);
  return LEPUS_DupValue(ctx, ctx->class_proto[class_id]);
}

typedef enum LEPUSFreeModuleEnum {
  LEPUS_FREE_MODULE_ALL,
  LEPUS_FREE_MODULE_NOT_RESOLVED,
  LEPUS_FREE_MODULE_NOT_EVALUATED,
} LEPUSFreeModuleEnum;

/* XXX: would be more efficient with separate module lists */
QJS_STATIC void lepus_free_modules(LEPUSContext *ctx,
                                   LEPUSFreeModuleEnum flag) {
  struct list_head *el, *el1;
  list_for_each_safe(el, el1, &ctx->loaded_modules) {
    LEPUSModuleDef *m = list_entry(el, LEPUSModuleDef, link);
    if (flag == LEPUS_FREE_MODULE_ALL ||
        (flag == LEPUS_FREE_MODULE_NOT_RESOLVED && !m->resolved) ||
        (flag == LEPUS_FREE_MODULE_NOT_EVALUATED && !m->evaluated)) {
      lepus_free_module_def(ctx, m);
    }
  }
}
void LEPUS_FreeContextRegistry(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  struct list_head *el, *el1;
  LEPUSFinalizationRegistryEntry *p;
  list_for_each_safe(el, el1, &ctx->finalization_registries) {
    p = list_entry(el, LEPUSFinalizationRegistryEntry, link);
    if (p && p->obj && p->obj->first_weak_ref &&
        p->obj->first_weak_ref->registry) {
      LEPUSObject *obj = p->obj;
      reset_fg_registry(rt, obj);
      if (!(obj->first_weak_ref->map || obj->first_weak_ref->is_ref)) {
        lepus_free_rt(ctx->rt, obj->first_weak_ref);
        obj->first_weak_ref = NULL;
      }
    } else {
      list_del(el);
      lepus_free(ctx, p);
    }
  }
}

void LEPUS_FreeContext(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  int i;

#ifdef DUMP_ATOMS
  LEPUS_DumpAtoms(ctx->rt);
#endif
#ifdef DUMP_SHAPES
  LEPUS_DumpShapes(ctx->rt);
#endif

#ifdef ENABLE_QUICKJS_DEBUGGER
  if (ctx->debugger_mode || ctx->debugger_parse_script ||
      ctx->is_profiler_ctx) {
    FreeDebuggerScriptAndBytecodeList(ctx);
  }
#endif

  struct list_head *el, *el1;
  LEPUS_FreeContextRegistry(ctx);
  lepus_free_modules(ctx, LEPUS_FREE_MODULE_ALL);

  LEPUS_FreeValue(ctx, ctx->global_obj);
  LEPUS_FreeValue(ctx, ctx->global_var_obj);

  LEPUS_FreeValue(ctx, ctx->throw_type_error);
  LEPUS_FreeValue(ctx, ctx->eval_obj);

  LEPUS_FreeValue(ctx, ctx->array_proto_values);
  for (i = 0; i < LEPUS_NATIVE_ERROR_COUNT; i++) {
    LEPUS_FreeValue(ctx, ctx->native_error_proto[i]);
  }
  for (i = 0; i < rt->class_count; i++) {
    LEPUS_FreeValue(ctx, ctx->class_proto[i]);
  }
  lepus_free_rt(rt, ctx->class_proto);
  LEPUS_FreeValue(ctx, ctx->iterator_proto);
  LEPUS_FreeValue(ctx, ctx->async_iterator_proto);
  LEPUS_FreeValue(ctx, ctx->promise_ctor);
  LEPUS_FreeValue(ctx, ctx->regexp_ctor);
  LEPUS_FreeValue(ctx, ctx->function_ctor);
  LEPUS_FreeValue(ctx, ctx->function_proto);
  // <Bytedance begin>
#ifdef OS_IOS
  lepus_free(ctx, ctx->stack);
#endif
  // <Bytedance end>

  lepus_free_shape_null(ctx->rt, ctx->array_shape);

  list_del(&ctx->link);

// for quickjs debugger
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (ctx->debugger_mode || ctx->debugger_parse_script ||
      ctx->is_profiler_ctx) {
    DebuggerFree(ctx);
  }
#endif

  lepus_free_rt(ctx->rt, ctx);

#ifdef DUMP_MEM
  {
    LEPUSMemoryUsage stats;
    LEPUS_ComputeMemoryUsage(rt, &stats);
    LEPUS_DumpMemoryUsage(stdout, &stats, rt);
  }
#endif

#ifdef DUMP_OBJECTS
  LEPUS_RunGC(rt);
  {
    struct list_head *el;
    LEPUSObject *p;
    printf("LEPUSObjects: {\n");
    LEPUS_DumpObjectHeader(rt);
    list_for_each(el, &rt->obj_list) {
      p = list_entry(el, LEPUSObject, link);
      LEPUS_DumpObject(rt, p);
    }
    printf("}\n");
  }
#endif
}

LEPUSRuntime *LEPUS_GetRuntime(LEPUSContext *ctx) { return ctx->rt; }

void LEPUS_SetMaxStackSize(LEPUSContext *ctx, size_t stack_size) {
  ctx->rt->stack_size = stack_size;
}

QJS_STATIC inline BOOL is_strict_mode(LEPUSContext *ctx) {
  LEPUSStackFrame *sf = ctx->rt->current_stack_frame;
  return (sf && (sf->lepus_mode & LEPUS_MODE_STRICT));
}

#ifdef CONFIG_BIGNUM
static inline BOOL is_bignum_mode(LEPUSContext *ctx) {
  LEPUSStackFrame *sf = ctx->rt->current_stack_frame;
  return (sf && (sf->lepus_mode & LEPUS_MODE_BIGINT));
}
#endif

LEPUSValue LEPUS_NewInt64(LEPUSContext *ctx, int64_t v) {
  if (v == (int32_t)v) {
    return LEPUS_NewInt32(ctx, v);
  } else {
#ifdef CONFIG_BIGNUM
    if (is_bignum_mode(ctx)) {
      bf_t a_s, *a = &a_s;
      bf_init(ctx->bf_ctx, a);
      bf_set_si(a, v);
      return LEPUS_NewBigInt(ctx, a);
    } else
#endif
    {
      return __JS_NewFloat64(ctx, (double)v);
    }
  }
}

QJS_STATIC force_inline LEPUSValue LEPUS_NewUint32(LEPUSContext *ctx,
                                                   uint32_t val) {
#ifdef CONFIG_BIGNUM
  return LEPUS_NewInt64(ctx, val);
#else
  LEPUSValue v;
  if (val <= 0x7fffffff) {
    v = LEPUS_MKVAL(LEPUS_TAG_INT, static_cast<int32_t>(val));
  } else {
    v = __JS_NewFloat64(ctx, val);
  }
  return v;
#endif
}

/* LEPUSAtom support */

QJS_STATIC inline BOOL __JS_AtomIsConst(LEPUSAtom v) {
#if defined(DUMP_LEAKS) && DUMP_LEAKS > 1
  return (int32_t)v <= 0;
#else
  return (int32_t)v < LEPUS_ATOM_END;
#endif
}

QJS_STATIC inline BOOL __JS_AtomIsTaggedInt(LEPUSAtom v) {
  return (v & LEPUS_ATOM_TAG_INT) != 0;
}

QJS_STATIC inline LEPUSAtom __JS_AtomFromUInt32(uint32_t v) {
  return v | LEPUS_ATOM_TAG_INT;
}

QJS_STATIC inline uint32_t __JS_AtomToUInt32(LEPUSAtom atom) {
  return atom & ~LEPUS_ATOM_TAG_INT;
}

QJS_STATIC inline int is_num(int c) { return c >= '0' && c <= '9'; }

/* return TRUE if the string is a number n with 0 <= n <= 2^32-1 */
QJS_STATIC inline BOOL is_num_string(uint32_t *pval, const LEPUSString *p) {
  uint32_t n;
  uint64_t n64;
  int c, i, len;

  len = p->len;
  if (len == 0 || len > 10) return FALSE;
  if (p->is_wide_char)
    c = p->u.str16[0];
  else
    c = p->u.str8[0];
  if (is_num(c)) {
    if (c == '0') {
      if (len != 1) return FALSE;
      n = 0;
    } else {
      n = c - '0';
      for (i = 1; i < len; i++) {
        if (p->is_wide_char)
          c = p->u.str16[i];
        else
          c = p->u.str8[i];
        if (!is_num(c)) return FALSE;
        n64 = (uint64_t)n * 10 + (c - '0');
        if ((n64 >> 32) != 0) return FALSE;
        n = n64;
      }
    }
    *pval = n;
    return TRUE;
  } else {
    return FALSE;
  }
}

/* XXX: could use faster version ? */
QJS_STATIC inline uint32_t hash_string8(const uint8_t *str, size_t len,
                                        uint32_t h) {
  size_t i;

  for (i = 0; i < len; i++) h = h * 263 + str[i];
  return h;
}

QJS_STATIC inline uint32_t hash_string16(const uint16_t *str, size_t len,
                                         uint32_t h) {
  size_t i;

  for (i = 0; i < len; i++) h = h * 263 + str[i];
  return h;
}

QJS_STATIC uint32_t hash_string(const LEPUSString *str, uint32_t h) {
  if (str->is_wide_char)
    h = hash_string16(str->u.str16, str->len, h);
  else
    h = hash_string8(str->u.str8, str->len, h);
  return h;
}

// <ByteDance begin>
#if defined(DUMP_QJS_VALUE)
static __attribute__((unused)) void LEPUS_DumpStringNoPrint(
    LEPUSRuntime *rt, const LEPUSString *p, char dump_buf[]) {
  int i, c, sep;
  char fmt_buf[1024];

#define write(...) \
  snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), strcat(dump_buf, fmt_buf);
  if (p == NULL) {
    write("<null>");
    return;
  }
  write("%d", p->header.ref_count);
  sep = (p->header.ref_count == 1) ? '\"' : '\'';
  write("%c", sep);
  for (i = 0; i < p->len; i++) {
    if (p->is_wide_char)
      c = p->u.str16[i];
    else
      c = p->u.str8[i];
    if (c == sep || c == '\\') {
      write("%c", '\\');
      write("%c", c);
    } else if (c >= ' ' && c <= 126) {
      write("%c", c);
    } else if (c == '\n') {
      write("%c", '\\');
      write("%c", 'n');
    } else {
      write("\\u%04x", c);
    }
  }
  write("%c", sep);

#undef write
}

static __attribute__((unused)) void LEPUS_DumpString(LEPUSRuntime *rt,
                                                     const LEPUSString *p) {
  char dump_buf[4096];
  dump_buf[0] = '\0';
  LEPUS_DumpStringNoPrint(rt, p, dump_buf);
  printf("%s", dump_buf);
}

static __attribute__((unused)) void LEPUS_DumpAtoms(LEPUSRuntime *rt) {
  LEPUSAtomStruct *p;
  int h, i;
  /* This only dumps hashed atoms, not LEPUS_ATOM_TYPE_SYMBOL atoms */
  printf("LEPUSAtom count=%d size=%d hash_size=%d:\n", rt->atom_count,
         rt->atom_size, rt->atom_hash_size);
  printf("LEPUSAtom hash table: {\n");
  for (i = 0; i < rt->atom_hash_size; i++) {
    h = rt->atom_hash[i];
    if (h) {
      printf("  %d:", i);
      while (h) {
        p = rt->atom_array[h];
        printf(" ");
        LEPUS_DumpString(rt, p);
        h = p->hash_next;
      }
      printf("\n");
    }
  }
  printf("}\n");
  printf("LEPUSAtom table: {\n");
  for (i = 0; i < rt->atom_size; i++) {
    p = rt->atom_array[i];
    if (!atom_is_free(p)) {
      printf("  %d: { %d %08x ", i, p->atom_type, p->hash);
      if (!(p->len == 0 && p->is_wide_char != 0)) LEPUS_DumpString(rt, p);
      printf(" %d }\n", p->hash_next);
    }
  }
  printf("}\n");
}
#endif  // DUMP_QJS_VALUE
// <ByteDance end>

QJS_STATIC int LEPUS_ResizeAtomHash(LEPUSRuntime *rt, int new_hash_size) {
  LEPUSAtomStruct *p;
  uint32_t new_hash_mask, h, i, hash_next1, j, *new_hash;

  assert((new_hash_size & (new_hash_size - 1)) == 0); /* power of two */
  new_hash_mask = new_hash_size - 1;
  new_hash = static_cast<uint32_t *>(
      lepus_mallocz_rt(rt, sizeof(rt->atom_hash[0]) * new_hash_size));
  if (!new_hash) return -1;
  for (i = 0; i < rt->atom_hash_size; i++) {
    h = rt->atom_hash[i];
    while (h != 0) {
      p = rt->atom_array[h];
      hash_next1 = p->hash_next;
      /* add in new hash table */
      j = p->hash & new_hash_mask;
      p->hash_next = new_hash[j];
      new_hash[j] = h;
      h = hash_next1;
    }
  }
  lepus_free_rt(rt, rt->atom_hash);
  rt->atom_hash = new_hash;
  rt->atom_hash_size = new_hash_size;
  rt->atom_count_resize = LEPUS_ATOM_COUNT_RESIZE(new_hash_size);
  //    LEPUS_DumpAtoms(rt);
  return 0;
}

QJS_STATIC int LEPUS_InitAtoms(LEPUSRuntime *rt) {
  int i, len, atom_type;
  const char *p;

  rt->atom_hash_size = 0;
  rt->atom_hash = NULL;
  rt->atom_count = 0;
  rt->atom_size = 0;
  rt->atom_free_index = 0;
  if (LEPUS_ResizeAtomHash(rt,
                           256)) /* there are at least 195 predefined atoms */
    return -1;

  p = lepus_atom_init;
  for (i = 1; i < LEPUS_ATOM_END; i++) {
    if (i == LEPUS_ATOM_Private_brand)
      atom_type = LEPUS_ATOM_TYPE_PRIVATE;
    else if (i >= LEPUS_ATOM_Symbol_toPrimitive)
      atom_type = LEPUS_ATOM_TYPE_SYMBOL;
    else
      atom_type = LEPUS_ATOM_TYPE_STRING;
    len = strlen(p);
    if (__JS_NewAtomInit(rt, p, len, atom_type) == LEPUS_ATOM_NULL) return -1;
    p = p + len + 1;
  }
  return 0;
}

QJS_STATIC LEPUSAtom LEPUS_DupAtomRT(LEPUSRuntime *rt, LEPUSAtom v) {
  LEPUSAtomStruct *p;

  if (!__JS_AtomIsConst(v)) {
    p = rt->atom_array[v];
    p->header.ref_count++;
  }
  return v;
}

LEPUSAtom LEPUS_DupAtom(LEPUSContext *ctx, LEPUSAtom v) {
  LEPUSRuntime *rt;
  LEPUSAtomStruct *p;

  if (!__JS_AtomIsConst(v)) {
    rt = ctx->rt;
    p = rt->atom_array[v];
    p->header.ref_count++;
  }
  return v;
}

QJS_STATIC LEPUSAtomKindEnum LEPUS_AtomGetKind(LEPUSContext *ctx, LEPUSAtom v) {
  LEPUSRuntime *rt;
  LEPUSAtomStruct *p;

  rt = ctx->rt;
  if (__JS_AtomIsTaggedInt(v)) return LEPUS_ATOM_KIND_STRING;
  p = rt->atom_array[v];
  switch (p->atom_type) {
    case LEPUS_ATOM_TYPE_STRING:
      return LEPUS_ATOM_KIND_STRING;
    case LEPUS_ATOM_TYPE_GLOBAL_SYMBOL:
      return LEPUS_ATOM_KIND_SYMBOL;
    case LEPUS_ATOM_TYPE_SYMBOL:
      switch (p->hash) {
        case LEPUS_ATOM_HASH_SYMBOL:
          return LEPUS_ATOM_KIND_SYMBOL;
        case LEPUS_ATOM_HASH_PRIVATE:
          return LEPUS_ATOM_KIND_PRIVATE;
        default:
          abort();
      }
    default:
      abort();
  }
}

QJS_STATIC BOOL LEPUS_AtomIsString(LEPUSContext *ctx, LEPUSAtom v) {
  return LEPUS_AtomGetKind(ctx, v) == LEPUS_ATOM_KIND_STRING;
}

QJS_STATIC LEPUSAtom lepus_get_atom_index(LEPUSRuntime *rt,
                                          LEPUSAtomStruct *p) {
  uint32_t i = p->hash_next; /* atom_index */
  if (p->atom_type != LEPUS_ATOM_TYPE_SYMBOL) {
    LEPUSAtomStruct *p1;

    i = rt->atom_hash[p->hash & (rt->atom_hash_size - 1)];
    p1 = rt->atom_array[i];
    while (p1 != p) {
      assert(i != 0);
      i = p1->hash_next;
      p1 = rt->atom_array[i];
    }
  }
  return i;
}

/* string case (internal). Return LEPUS_ATOM_NULL if error. 'str' is
   freed. */
QJS_STATIC LEPUSAtom __JS_NewAtom(LEPUSRuntime *rt, LEPUSString *str,
                                  int atom_type) {
  uint32_t h, h1, i;
  LEPUSAtomStruct *p;
  int len;

#if 0
    printf("__JS_NewAtom: ");  LEPUS_DumpString(rt, str); printf("\n");
#endif
  if (atom_type < LEPUS_ATOM_TYPE_SYMBOL) {
    /* str is not NULL */
    if (str->atom_type == atom_type) {
      /* str is the atom, return its index */
      i = lepus_get_atom_index(rt, str);
      /* reduce string refcount and increase atom's unless constant */
      if (__JS_AtomIsConst(i)) str->header.ref_count--;
      return i;
    }
    /* try and locate an already registered atom */
    len = str->len;
    h = hash_string(str, atom_type);
    h &= LEPUS_ATOM_HASH_MASK;
    h1 = h & (rt->atom_hash_size - 1);
    i = rt->atom_hash[h1];
    while (i != 0) {
      p = rt->atom_array[i];
      if (p->hash == h && p->atom_type == atom_type && p->len == len &&
          lepus_string_memcmp(p, str, len) == 0) {
        if (!__JS_AtomIsConst(i)) p->header.ref_count++;
        goto done;
      }
      i = p->hash_next;
    }
  } else {
    h1 = 0; /* avoid warning */
    if (atom_type == LEPUS_ATOM_TYPE_SYMBOL) {
      h = LEPUS_ATOM_HASH_SYMBOL;
    } else {
      h = LEPUS_ATOM_HASH_PRIVATE;
      atom_type = LEPUS_ATOM_TYPE_SYMBOL;
    }
  }

  if (rt->atom_free_index == 0) {
    /* allow new atom entries */
    uint32_t new_size, start;
    LEPUSAtomStruct **new_array;

    /* alloc new with size progression 3/2:
       4 6 9 13 19 28 42 63 94 141 211 316 474 711 1066 1599 2398 3597 5395 8092
       preallocating space for predefined atoms (at least 195).
     */
    new_size = max_int(211, rt->atom_size * 3 / 2);
    if (new_size > LEPUS_ATOM_MAX) goto fail;
    /* XXX: should use realloc2 to use slack space */
    new_array = static_cast<LEPUSAtomStruct **>(
        lepus_realloc_rt(rt, rt->atom_array, sizeof(*new_array) * new_size));
    if (!new_array) goto fail;
    /* Note: the atom 0 is not used */
    start = rt->atom_size;
    if (start == 0) {
      /* LEPUS_ATOM_NULL entry */
      p = static_cast<LEPUSAtomStruct *>(
          lepus_mallocz_rt(rt, sizeof(LEPUSAtomStruct)));
      if (!p) {
        lepus_free_rt(rt, new_array);
        goto fail;
      }
      p->header.ref_count = 1; /* not refcounted */
      p->atom_type = LEPUS_ATOM_TYPE_SYMBOL;
#ifdef DUMP_LEAKS
      list_add_tail(&p->link, &rt->string_list);
#endif
      new_array[0] = p;
      rt->atom_count++;
      start = 1;
    }
    rt->atom_size = new_size;
    rt->atom_array = new_array;
    rt->atom_free_index = start;
    for (i = start; i < new_size; i++) {
      uint32_t next;
      if (i == (new_size - 1))
        next = 0;
      else
        next = i + 1;
      rt->atom_array[i] = atom_set_free(next);
    }
  }

  if (str) {
    if (str->atom_type == 0) {
      p = str;
      p->atom_type = atom_type;
    } else {
      p = static_cast<LEPUSAtomStruct *>(lepus_mallocz_rt(
          rt, sizeof(LEPUSString) + (str->len << str->is_wide_char) + 1 -
                  str->is_wide_char));
      if (unlikely(!p)) goto fail;
      p->header.ref_count = 1;
      p->is_wide_char = str->is_wide_char;
      p->len = str->len;
#ifdef DUMP_LEAKS
      list_add_tail(&p->link, &rt->string_list);
#endif
      memcpy(p->u.str8, str->u.str8,
             (str->len << str->is_wide_char) + 1 - str->is_wide_char);
      lepus_free_string(rt, str);
    }
  } else {
    p = static_cast<LEPUSAtomStruct *>(
        lepus_mallocz_rt(rt, sizeof(LEPUSAtomStruct))); /* empty wide string */
    if (!p) return LEPUS_ATOM_NULL;
    p->header.ref_count = 1;
    p->is_wide_char = 1; /* Hack to represent NULL as a LEPUSString */
    p->len = 0;
#ifdef DUMP_LEAKS
    list_add_tail(&p->link, &rt->string_list);
#endif
  }

  /* use an already free entry */
  i = rt->atom_free_index;
  rt->atom_free_index = atom_get_free(rt->atom_array[i]);
  rt->atom_array[i] = p;

  p->hash = h;
  p->hash_next = i; /* atom_index */
  p->atom_type = atom_type;

  rt->atom_count++;

  if (atom_type != LEPUS_ATOM_TYPE_SYMBOL) {
    p->hash_next = rt->atom_hash[h1];
    rt->atom_hash[h1] = i;
    if (unlikely(rt->atom_count >= rt->atom_count_resize))
      LEPUS_ResizeAtomHash(rt, rt->atom_hash_size * 2);
  }

  //    LEPUS_DumpAtoms(rt);
  return i;

fail:
  i = LEPUS_ATOM_NULL;
done:
  if (str) lepus_free_string(rt, str);
  return i;
}

/* only works with zero terminated 8 bit strings */
QJS_STATIC LEPUSAtom __JS_NewAtomInit(LEPUSRuntime *rt, const char *str,
                                      int len, int atom_type) {
  LEPUSString *p;
  p = lepus_alloc_string_rt(rt, len, 0);
  if (!p) return LEPUS_ATOM_NULL;
  memcpy(p->u.str8, str, len);
  p->u.str8[len] = '\0';
  return __JS_NewAtom(rt, p, atom_type);
}

QJS_STATIC LEPUSAtom __JS_FindAtom(LEPUSRuntime *rt, const char *str,
                                   size_t len, int atom_type) {
  uint32_t h, h1, i;
  LEPUSAtomStruct *p;

  h = hash_string8((const uint8_t *)str, len, LEPUS_ATOM_TYPE_STRING);
  h &= LEPUS_ATOM_HASH_MASK;
  h1 = h & (rt->atom_hash_size - 1);
  i = rt->atom_hash[h1];
  while (i != 0) {
    p = rt->atom_array[i];
    if (p->hash == h && p->atom_type == LEPUS_ATOM_TYPE_STRING &&
        p->len == len && p->is_wide_char == 0 &&
        memcmp(p->u.str8, str, len) == 0) {
      if (!__JS_AtomIsConst(i)) p->header.ref_count++;
      return i;
    }
    i = p->hash_next;
  }
  return LEPUS_ATOM_NULL;
}

QJS_STATIC void LEPUS_FreeAtomStruct(LEPUSRuntime *rt, LEPUSAtomStruct *p) {
#if 0 /* LEPUS_ATOM_NULL is not refcounted: __JS_AtomIsConst() includes 0 */
    if (unlikely(i == LEPUS_ATOM_NULL)) {
        p->header.ref_count = INT32_MAX / 2;
        return;
    }
#endif
  uint32_t i = p->hash_next; /* atom_index */
  if (p->atom_type != LEPUS_ATOM_TYPE_SYMBOL) {
    LEPUSAtomStruct *p0, *p1;
    uint32_t h0;

    h0 = p->hash & (rt->atom_hash_size - 1);
    i = rt->atom_hash[h0];
    p1 = rt->atom_array[i];
    if (p1 == p) {
      rt->atom_hash[h0] = p1->hash_next;
    } else {
      for (;;) {
        assert(i != 0);
        p0 = p1;
        i = p1->hash_next;
        p1 = rt->atom_array[i];
        if (p1 == p) {
          p0->hash_next = p1->hash_next;
          break;
        }
      }
    }
  }
  /* insert in free atom list */
  rt->atom_array[i] = atom_set_free(rt->atom_free_index);
  rt->atom_free_index = i;
  /* free the string structure */
#ifdef DUMP_LEAKS
  list_del(&p->link);
#endif
  // bytedance begin
#ifdef ENABLE_LEPUSNG
  LEPUS_FreeStringCache(rt, p);
#endif
  // bytedance end
  lepus_free_rt(rt, p);
  rt->atom_count--;
  assert(rt->atom_count >= 0);
}

QJS_STATIC void __JS_FreeAtom(LEPUSRuntime *rt, uint32_t i) {
  LEPUSAtomStruct *p;

  p = rt->atom_array[i];
  if (--p->header.ref_count > 0) return;
  LEPUS_FreeAtomStruct(rt, p);
}

/* Warning: 'p' is freed */
QJS_STATIC LEPUSAtom LEPUS_NewAtomStr(LEPUSContext *ctx, LEPUSString *p) {
  LEPUSRuntime *rt = ctx->rt;
  uint32_t n;
  if (is_num_string(&n, p)) {
    if (n <= LEPUS_ATOM_MAX_INT) {
      lepus_free_string(rt, p);
      return __JS_AtomFromUInt32(n);
    }
  }
  /* XXX: should generate an exception */
  return __JS_NewAtom(rt, p, LEPUS_ATOM_TYPE_STRING);
}

#ifdef OS_IOS
static BOOL lepus_check_virtual_sp_overflow(LEPUSContext *ctx, size_t size) {
  if (ctx->stack_pos + size > ctx->rt->stack_size) {
    return TRUE;
  }
  return FALSE;
}

static BOOL lepus_check_virtual_outofmemory(LEPUSContext *ctx, size_t size) {
  if (ctx->stack == NULL) {
    return TRUE;
  }
  return FALSE;
}

static LEPUSValue *lepus_get_virtual_sp(LEPUSContext *ctx) {
  return (LEPUSValue *)(ctx->stack + ctx->stack_pos);
}

static void lepus_push_virtual_sp(LEPUSContext *ctx, size_t size) {
  ctx->stack_pos += size;
}

static void lepus_pop_virtual_sp(LEPUSContext *ctx, size_t size) {
  ctx->stack_pos -= size;
}
#endif

LEPUSAtom LEPUS_NewAtomLen(LEPUSContext *ctx, const char *str, size_t len) {
  LEPUSValue val;

  if (len == 0 || !is_digit(*str)) {
    LEPUSAtom atom = __JS_FindAtom(ctx->rt, str, len, LEPUS_ATOM_TYPE_STRING);
    if (atom) return atom;
  }
  val = LEPUS_NewStringLen(ctx, str, len);
  if (LEPUS_IsException(val)) return LEPUS_ATOM_NULL;
  return LEPUS_NewAtomStr(ctx, LEPUS_VALUE_GET_STRING(val));
}

LEPUSAtom LEPUS_NewAtom(LEPUSContext *ctx, const char *str) {
  return LEPUS_NewAtomLen(ctx, str, strlen(str));
}

LEPUSAtom LEPUS_NewAtomUInt32(LEPUSContext *ctx, uint32_t n) {
  if (n <= LEPUS_ATOM_MAX_INT) {
    return __JS_AtomFromUInt32(n);
  } else {
    char buf[11];
    LEPUSValue val;
    snprintf(buf, sizeof(buf), "%u", n);
    val = LEPUS_NewString(ctx, buf);
    if (LEPUS_IsException(val)) return LEPUS_ATOM_NULL;
    return __JS_NewAtom(ctx->rt, LEPUS_VALUE_GET_STRING(val),
                        LEPUS_ATOM_TYPE_STRING);
  }
}

QJS_STATIC LEPUSAtom LEPUS_NewAtomInt64(LEPUSContext *ctx, int64_t n) {
  if ((uint64_t)n <= LEPUS_ATOM_MAX_INT) {
    return __JS_AtomFromUInt32((uint32_t)n);
  } else {
    char buf[24];
    LEPUSValue val;
    snprintf(buf, sizeof(buf), "%" PRId64, n);
    val = LEPUS_NewString(ctx, buf);
    if (LEPUS_IsException(val)) return LEPUS_ATOM_NULL;
    return __JS_NewAtom(ctx->rt, LEPUS_VALUE_GET_STRING(val),
                        LEPUS_ATOM_TYPE_STRING);
  }
}

/* 'p' is freed */
QJS_STATIC LEPUSValue LEPUS_NewSymbol(LEPUSContext *ctx, LEPUSString *p,
                                      int atom_type) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSAtom atom;
  atom = __JS_NewAtom(rt, p, atom_type);
  if (atom == LEPUS_ATOM_NULL) return LEPUS_ThrowOutOfMemory(ctx);
  return LEPUS_MKPTR(LEPUS_TAG_SYMBOL, rt->atom_array[atom]);
}

/* descr must be a non-numeric string atom */
LEPUSValue LEPUS_NewSymbolFromAtom(LEPUSContext *ctx, LEPUSAtom descr,
                                   int atom_type) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSString *p;

  assert(!__JS_AtomIsTaggedInt(descr));
  assert(descr < rt->atom_size);
  p = rt->atom_array[descr];
  LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
  return LEPUS_NewSymbol(ctx, p, atom_type);
}

#define ATOM_GET_STR_BUF_SIZE 64

/* Should only be used for debug. */
QJS_STATIC const char *LEPUS_AtomGetStrRT(LEPUSRuntime *rt, char *buf,
                                          int buf_size, LEPUSAtom atom) {
  if (__JS_AtomIsTaggedInt(atom)) {
    snprintf(buf, buf_size, "%u", __JS_AtomToUInt32(atom));
  } else {
    LEPUSAtomStruct *p;
    assert(atom < rt->atom_size);
    if (atom == LEPUS_ATOM_NULL) {
      snprintf(buf, buf_size, "<null>");
    } else {
      int i, c;
      char *q;
      LEPUSString *str;

      q = buf;
      p = rt->atom_array[atom];
      assert(!atom_is_free(p));
      str = p;
      if (str) {
        if (!str->is_wide_char) {
          /* special case ASCII strings */
          c = 0;
          for (i = 0; i < str->len; i++) {
            c |= str->u.str8[i];
          }
          if (c < 0x80) return (const char *)str->u.str8;
        }
        for (i = 0; i < str->len; i++) {
          if (str->is_wide_char)
            c = str->u.str16[i];
          else
            c = str->u.str8[i];
          if ((q - buf) >= buf_size - UTF8_CHAR_LEN_MAX) break;
          if (c < 128) {
            *q++ = c;
          } else {
            q += unicode_to_utf8((uint8_t *)q, c);
          }
        }
      }
      *q = '\0';
    }
  }
  return buf;
}

QJS_STATIC const char *LEPUS_AtomGetStr(LEPUSContext *ctx, char *buf,
                                        int buf_size, LEPUSAtom atom) {
  return LEPUS_AtomGetStrRT(ctx->rt, buf, buf_size, atom);
}

LEPUSValue __JS_AtomToValue(LEPUSContext *ctx, LEPUSAtom atom,
                            BOOL force_string) {
  char buf[ATOM_GET_STR_BUF_SIZE];

  if (__JS_AtomIsTaggedInt(atom)) {
    snprintf(buf, sizeof(buf), "%u", __JS_AtomToUInt32(atom));
    return LEPUS_NewString(ctx, buf);
  } else {
    LEPUSRuntime *rt = ctx->rt;
    LEPUSAtomStruct *p;
    assert(atom < rt->atom_size);
    p = rt->atom_array[atom];
    if (p->atom_type == LEPUS_ATOM_TYPE_STRING) {
      goto ret_string;
    } else if (force_string) {
      if (p->len == 0 && p->is_wide_char != 0) {
        /* no description string */
        p = rt->atom_array[LEPUS_ATOM_empty_string];
      }
    ret_string:
      return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
    } else {
      return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_SYMBOL, p));
    }
  }
}

LEPUSValue LEPUS_AtomToValue(LEPUSContext *ctx, LEPUSAtom atom) {
  return __JS_AtomToValue(ctx, atom, FALSE);
}

LEPUSValue LEPUS_AtomToString(LEPUSContext *ctx, LEPUSAtom atom) {
  return __JS_AtomToValue(ctx, atom, TRUE);
}

/* return TRUE if the atom is an array index (i.e. 0 <= index <=
   2^32-2 and return its value */
QJS_STATIC BOOL LEPUS_AtomIsArrayIndex(LEPUSContext *ctx, uint32_t *pval,
                                       LEPUSAtom atom) {
  if (__JS_AtomIsTaggedInt(atom)) {
    *pval = __JS_AtomToUInt32(atom);
    return TRUE;
  } else {
    LEPUSRuntime *rt = ctx->rt;
    LEPUSAtomStruct *p;
    uint32_t val;

    assert(atom < rt->atom_size);
    p = rt->atom_array[atom];
    if (p->atom_type == LEPUS_ATOM_TYPE_STRING && is_num_string(&val, p) &&
        val != -1) {
      *pval = val;
      return TRUE;
    } else {
      *pval = 0;
      return FALSE;
    }
  }
}

/* This test must be fast if atom is not a numeric index (e.g. a
   method name). Return LEPUS_UNDEFINED if not a numeric
   index. LEPUS_EXCEPTION can also be returned. */
QJS_STATIC LEPUSValue LEPUS_AtomIsNumericIndex1(LEPUSContext *ctx,
                                                LEPUSAtom atom) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSAtomStruct *p1;
  LEPUSString *p;
  int c, len, ret;
  LEPUSValue num, str;

  if (__JS_AtomIsTaggedInt(atom))
    return LEPUS_NewInt32(ctx, __JS_AtomToUInt32(atom));
  assert(atom < rt->atom_size);
  p1 = rt->atom_array[atom];
  if (p1->atom_type != LEPUS_ATOM_TYPE_STRING) return LEPUS_UNDEFINED;
  p = p1;
  len = p->len;
  if (p->is_wide_char) {
    const uint16_t *r = p->u.str16, *r_end = p->u.str16 + len;
    if (r >= r_end) return LEPUS_UNDEFINED;
    c = *r;
    if (c == '-') {
      if (r >= r_end) return LEPUS_UNDEFINED;
      r++;
      c = *r;
      /* -0 case is specific */
      if (c == '0' && len == 2) goto minus_zero;
    }
    /* XXX: should test NaN, but the tests do not check it */
    if (!is_num(c)) {
      /* XXX: String should be normalized, therefore 8-bit only */
      const uint16_t nfinity16[7] = {'n', 'f', 'i', 'n', 'i', 't', 'y'};
      if (!(c == 'I' && (r_end - r) == 8 &&
            !memcmp(r + 1, nfinity16, sizeof(nfinity16))))
        return LEPUS_UNDEFINED;
    }
  } else {
    const uint8_t *r, *r_end;
    r = p->u.str8;
    r_end = p->u.str8 + len;
    if (r >= r_end) return LEPUS_UNDEFINED;
    c = *r;
    if (c == '-') {
      if (r >= r_end) return LEPUS_UNDEFINED;
      r++;
      c = *r;
      /* -0 case is specific */
      if (c == '0' && len == 2) {
      minus_zero:
        return __JS_NewFloat64(ctx, -0.0);
      }
    }
    if (!is_num(c)) {
      if (!(c == 'I' && (r_end - r) == 8 && !memcmp(r + 1, "nfinity", 7)))
        return LEPUS_UNDEFINED;
    }
  }
  /* XXX: bignum: would be better to only accept integer to avoid
     relying on current floating point precision */
  /* this is ECMA CanonicalNumericIndexString primitive */
  num = LEPUS_ToNumber(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
  if (LEPUS_IsException(num)) return num;
  str = LEPUS_ToString(ctx, num);
  if (LEPUS_IsException(str)) {
    LEPUS_FreeValue(ctx, num);
    return str;
  }
  ret = lepus_string_compare(ctx, p, LEPUS_VALUE_GET_STRING(str));
  LEPUS_FreeValue(ctx, str);
  if (ret == 0) {
    return num;
  } else {
    LEPUS_FreeValue(ctx, num);
    return LEPUS_UNDEFINED;
  }
}

/* return -1 if exception or TRUE/FALSE */
QJS_STATIC int LEPUS_AtomIsNumericIndex(LEPUSContext *ctx, LEPUSAtom atom) {
  LEPUSValue num;
  num = LEPUS_AtomIsNumericIndex1(ctx, atom);
  if (likely(LEPUS_IsUndefined(num))) return FALSE;
  if (LEPUS_IsException(num)) return -1;
  LEPUS_FreeValue(ctx, num);
  return TRUE;
}

void LEPUS_FreeAtom(LEPUSContext *ctx, LEPUSAtom v) {
  if (!__JS_AtomIsConst(v)) __JS_FreeAtom(ctx->rt, v);
}

void LEPUS_FreeAtomRT(LEPUSRuntime *rt, LEPUSAtom v) {
  if (!__JS_AtomIsConst(v)) __JS_FreeAtom(rt, v);
}

/* return TRUE if 'v' is a symbol with a string description */
QJS_STATIC BOOL LEPUS_AtomSymbolHasDescription(LEPUSContext *ctx, LEPUSAtom v) {
  LEPUSRuntime *rt;
  LEPUSAtomStruct *p;

  rt = ctx->rt;
  if (__JS_AtomIsTaggedInt(v)) return FALSE;
  p = rt->atom_array[v];
  return (((p->atom_type == LEPUS_ATOM_TYPE_SYMBOL &&
            p->hash == LEPUS_ATOM_HASH_SYMBOL) ||
           p->atom_type == LEPUS_ATOM_TYPE_GLOBAL_SYMBOL) &&
          !(p->len == 0 && p->is_wide_char != 0));
}

QJS_STATIC __attribute__((unused)) void print_atom(LEPUSContext *ctx,
                                                   LEPUSAtom atom) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  const char *p;
  int i;

  /* XXX: should handle embedded null characters */
  /* XXX: should move encoding code to LEPUS_AtomGetStr */
  p = LEPUS_AtomGetStr(ctx, buf, sizeof(buf), atom);
  for (i = 0; p[i]; i++) {
    int c = (unsigned char)p[i];
    if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
          (c == '_' || c == '$') || (c >= '0' && c <= '9' && i > 0)))
      break;
  }
  if (i > 0 && p[i] == '\0') {
    printf("%s", p);
  } else {
    printf("%c", '"');
    printf("%.*s", i, p);
    for (; p[i]; i++) {
      int c = (unsigned char)p[i];
      if (c == '\"' || c == '\\') {
        printf("%c", '\\');
        printf("%c", c);
      } else if (c >= ' ' && c <= 126) {
        printf("%c", c);
      } else if (c == '\n') {
        printf("%c", '\\');
        printf("%c", 'n');
      } else {
        printf("\\u%04x", c);
      }
    }
    printf("%c", '\"');
  }
}

/* free with LEPUS_FreeCString() */
const char *LEPUS_AtomToCString(LEPUSContext *ctx, LEPUSAtom atom) {
  LEPUSValue str;
  const char *cstr;

  str = LEPUS_AtomToString(ctx, atom);
  if (LEPUS_IsException(str)) return NULL;
  cstr = LEPUS_ToCString(ctx, str);
  LEPUS_FreeValue(ctx, str);
  return cstr;
}

#ifndef NO_QUICKJS_COMPILER
/* return a string atom containing name concatenated with str1 */
QJS_STATIC LEPUSAtom lepus_atom_concat_str(LEPUSContext *ctx, LEPUSAtom name,
                                           const char *str1) {
  LEPUSValue str;
  LEPUSAtom atom;
  const char *cstr;
  char *cstr2;
  size_t len, len1;

  str = LEPUS_AtomToString(ctx, name);
  if (LEPUS_IsException(str)) return LEPUS_ATOM_NULL;
  cstr = LEPUS_ToCStringLen(ctx, &len, str);
  if (!cstr) goto fail;
  len1 = strlen(str1);
  cstr2 = static_cast<char *>(lepus_malloc(ctx, len + len1 + 1));
  if (!cstr2) goto fail;
  memcpy(cstr2, cstr, len);
  memcpy(cstr2 + len, str1, len1);
  cstr2[len + len1] = '\0';
  atom = LEPUS_NewAtomLen(ctx, cstr2, len + len1);
  lepus_free(ctx, cstr2);
  LEPUS_FreeCString(ctx, cstr);
  LEPUS_FreeValue(ctx, str);
  return atom;
fail:
  LEPUS_FreeCString(ctx, cstr);
  LEPUS_FreeValue(ctx, str);
  return LEPUS_ATOM_NULL;
}
#endif

#ifndef NO_QUICKJS_COMPILER
QJS_STATIC LEPUSAtom lepus_atom_concat_num(LEPUSContext *ctx, LEPUSAtom name,
                                           uint32_t n) {
  char buf[16];
  snprintf(buf, sizeof(buf), "%u", n);
  return lepus_atom_concat_str(ctx, name, buf);
}
#endif
QJS_STATIC inline BOOL LEPUS_IsEmptyString(LEPUSValueConst v) {
  return LEPUS_VALUE_IS_STRING(v) && LEPUS_VALUE_GET_STRING(v)->len == 0;
}

/* LEPUSClass support */

/* a new class ID is allocated if *pclass_id != 0 */
LEPUSClassID LEPUS_NewClassID(LEPUSClassID *pclass_id) {
  LEPUSClassID class_id;
  /* XXX: make it thread safe */
  class_id = *pclass_id;
  if (class_id == 0) {
    class_id = lepus_class_id_alloc++;
    *pclass_id = class_id;
  }
  return class_id;
}

BOOL LEPUS_IsRegisteredClass(LEPUSRuntime *rt, LEPUSClassID class_id) {
  return (class_id < rt->class_count &&
          rt->class_array[class_id].class_id != 0);
}

/* create a new object internal class. Return -1 if error, 0 if
   OK. The finalizer can be NULL if none is needed. */
QJS_STATIC int LEPUS_NewClass1(LEPUSRuntime *rt, LEPUSClassID class_id,
                               const LEPUSClassDef *class_def, LEPUSAtom name) {
  int new_size, i;
  LEPUSClass *cl, *new_class_array;
  struct list_head *el;

  if (class_id < rt->class_count && rt->class_array[class_id].class_id != 0)
    return -1;

  if (class_id >= rt->class_count) {
    new_size = max_int(LEPUS_CLASS_INIT_COUNT,
                       max_int(class_id + 1, rt->class_count * 3 / 2));

    /* reallocate the context class prototype array, if any */
    list_for_each(el, &rt->context_list) {
      LEPUSContext *ctx = list_entry(el, LEPUSContext, link);
      LEPUSValue *new_tab;
      new_tab = static_cast<LEPUSValue *>(lepus_realloc_rt(
          rt, ctx->class_proto, sizeof(ctx->class_proto[0]) * new_size));
      if (!new_tab) return -1;
      for (i = rt->class_count; i < new_size; i++) new_tab[i] = LEPUS_NULL;
      ctx->class_proto = new_tab;
    }
    /* reallocate the class array */
    new_class_array = static_cast<LEPUSClass *>(
        lepus_realloc_rt(rt, rt->class_array, sizeof(LEPUSClass) * new_size));
    if (!new_class_array) return -1;
    memset(new_class_array + rt->class_count, 0,
           (new_size - rt->class_count) * sizeof(LEPUSClass));
    rt->class_array = new_class_array;
    rt->class_count = new_size;
  }
  cl = &rt->class_array[class_id];
  cl->class_id = class_id;
  cl->class_name = LEPUS_DupAtomRT(rt, name);
  cl->finalizer = class_def->finalizer;
  cl->gc_mark = class_def->gc_mark;
  cl->call = class_def->call;
  cl->exotic = class_def->exotic;
  return 0;
}

int LEPUS_NewClass(LEPUSRuntime *rt, LEPUSClassID class_id,
                   const LEPUSClassDef *class_def) {
  int ret, len;
  LEPUSAtom name;

  len = strlen(class_def->class_name);
  name = __JS_FindAtom(rt, class_def->class_name, len, LEPUS_ATOM_TYPE_STRING);
  if (name == LEPUS_ATOM_NULL) {
    name = __JS_NewAtomInit(rt, class_def->class_name, len,
                            LEPUS_ATOM_TYPE_STRING);
    if (name == LEPUS_ATOM_NULL) return -1;
  }
  ret = LEPUS_NewClass1(rt, class_id, class_def, name);
  LEPUS_FreeAtomRT(rt, name);
  return ret;
}

QJS_STATIC LEPUSValue lepus_new_string8(LEPUSContext *ctx, const uint8_t *buf,
                                        int len) {
  LEPUSString *str;

  if (len <= 0) {
    return LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string);
  }
  str = lepus_alloc_string(ctx, len, 0);
  if (!str) return LEPUS_EXCEPTION;
  memcpy(str->u.str8, buf, len);
  str->u.str8[len] = '\0';
  return LEPUS_MKPTR(LEPUS_TAG_STRING, str);
}

QJS_STATIC LEPUSValue lepus_new_string16(LEPUSContext *ctx, const uint16_t *buf,
                                         int len) {
  LEPUSString *str;
  str = lepus_alloc_string(ctx, len, 1);
  if (!str) return LEPUS_EXCEPTION;
  memcpy(str->u.str16, buf, len * 2);
  return LEPUS_MKPTR(LEPUS_TAG_STRING, str);
}

QJS_STATIC LEPUSValue lepus_new_string_char(LEPUSContext *ctx, uint16_t c) {
  if (c < 0x100) {
    uint8_t ch8 = c;
    return lepus_new_string8(ctx, &ch8, 1);
  } else {
    uint16_t ch16 = c;
    return lepus_new_string16(ctx, &ch16, 1);
  }
}

QJS_STATIC LEPUSValue lepus_sub_string(LEPUSContext *ctx, LEPUSString *p,
                                       int start, int end) {
  int len = end - start;
  if (start == 0 && end == p->len) {
    return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
  }
  if (p->is_wide_char && len > 0) {
    LEPUSString *str;
    int i;
    uint16_t c = 0;
    for (i = start; i < end; i++) {
      c |= p->u.str16[i];
    }
    if (c > 0xFF) return lepus_new_string16(ctx, p->u.str16 + start, len);

    str = lepus_alloc_string(ctx, len, 0);
    if (!str) return LEPUS_EXCEPTION;
    for (i = 0; i < len; i++) {
      str->u.str8[i] = p->u.str16[start + i];
    }
    str->u.str8[len] = '\0';
    return LEPUS_MKPTR(LEPUS_TAG_STRING, str);
  } else {
    return lepus_new_string8(ctx, p->u.str8 + start, len);
  }
}

typedef struct StringBuffer {
  LEPUSContext *ctx;
  LEPUSString *str;
  int len;
  int size;
  int is_wide_char;
  int error_status;
} StringBuffer;

/* It is valid to call string_buffer_end() and all string_buffer functions even
   if string_buffer_init() or another string_buffer function returns an error.
   If the error_status is set, string_buffer_end() returns LEPUS_EXCEPTION.
 */
QJS_STATIC int string_buffer_init2(LEPUSContext *ctx, StringBuffer *s, int size,
                                   int is_wide) {
  s->ctx = ctx;
  s->size = size;
  s->len = 0;
  s->is_wide_char = is_wide;
  s->error_status = 0;
  s->str = lepus_alloc_string(ctx, size, is_wide);
  if (unlikely(!s->str)) {
    s->size = 0;
    return s->error_status = -1;
  }
#ifdef DUMP_LEAKS
  /* the StringBuffer may reallocate the LEPUSString, only link it at the end */
  list_del(&s->str->link);
#endif
  return 0;
}

QJS_STATIC inline int string_buffer_init(LEPUSContext *ctx, StringBuffer *s,
                                         int size) {
  return string_buffer_init2(ctx, s, size, 0);
}

QJS_STATIC void string_buffer_free(StringBuffer *s) {
  lepus_free(s->ctx, s->str);
  s->str = NULL;
}

QJS_STATIC int string_buffer_set_error(StringBuffer *s) {
  lepus_free(s->ctx, s->str);
  s->str = NULL;
  s->size = 0;
  s->len = 0;
  return s->error_status = -1;
}

QJS_STATIC no_inline int string_buffer_widen(StringBuffer *s, int size) {
  LEPUSString *str;
  size_t slack;
  int i;

  if (s->error_status) return -1;

  str = static_cast<LEPUSString *>(lepus_realloc2(
      s->ctx, s->str, sizeof(LEPUSString) + (size << 1), &slack));
  if (!str) return string_buffer_set_error(s);
  size += slack >> 1;
  for (i = s->len; i-- > 0;) {
    str->u.str16[i] = str->u.str8[i];
  }
  s->is_wide_char = 1;
  s->size = size;
  s->str = str;
  return 0;
}

QJS_STATIC no_inline int string_buffer_realloc(StringBuffer *s, int new_len,
                                               int c) {
  LEPUSString *new_str;
  int new_size;
  size_t new_size_bytes, slack;

  if (s->error_status) return -1;

  if (new_len > LEPUS_STRING_LEN_MAX) {
    LEPUS_ThrowInternalError(s->ctx, "string too long");
    return string_buffer_set_error(s);
  }
  new_size = min_int(max_int(new_len, s->size * 3 / 2), LEPUS_STRING_LEN_MAX);
  if (!s->is_wide_char && c >= 0x100) {
    return string_buffer_widen(s, new_size);
  }
  new_size_bytes =
      sizeof(LEPUSString) + (new_size << s->is_wide_char) + 1 - s->is_wide_char;
  new_str = static_cast<LEPUSString *>(
      lepus_realloc2(s->ctx, s->str, new_size_bytes, &slack));
  if (!new_str) return string_buffer_set_error(s);
  new_size =
      min_int(new_size + (slack >> s->is_wide_char), LEPUS_STRING_LEN_MAX);
  s->size = new_size;
  s->str = new_str;
  return 0;
}

QJS_STATIC no_inline int string_buffer_putc_slow(StringBuffer *s, uint32_t c) {
  if (unlikely(s->len >= s->size)) {
    if (string_buffer_realloc(s, s->len + 1, c)) return -1;
  }
  if (s->is_wide_char) {
    s->str->u.str16[s->len++] = c;
  } else if (c < 0x100) {
    s->str->u.str8[s->len++] = c;
  } else {
    if (string_buffer_widen(s, s->size)) return -1;
    s->str->u.str16[s->len++] = c;
  }
  return 0;
}

/* 0 <= c <= 0xff */
QJS_STATIC int string_buffer_putc8(StringBuffer *s, uint32_t c) {
  if (unlikely(s->len >= s->size)) {
    if (string_buffer_realloc(s, s->len + 1, c)) return -1;
  }
  if (s->is_wide_char) {
    s->str->u.str16[s->len++] = c;
  } else {
    s->str->u.str8[s->len++] = c;
  }
  return 0;
}

/* 0 <= c <= 0xffff */
QJS_STATIC int string_buffer_putc16(StringBuffer *s, uint32_t c) {
  if (likely(s->len < s->size)) {
    if (s->is_wide_char) {
      s->str->u.str16[s->len++] = c;
      return 0;
    } else if (c < 0x100) {
      s->str->u.str8[s->len++] = c;
      return 0;
    }
  }
  return string_buffer_putc_slow(s, c);
}

/* 0 <= c <= 0x10ffff */
QJS_STATIC int string_buffer_putc(StringBuffer *s, uint32_t c) {
  if (unlikely(c >= 0x10000)) {
    /* surrogate pair */
    c -= 0x10000;
    if (string_buffer_putc16(s, (c >> 10) + 0xd800)) return -1;
    c = (c & 0x3ff) + 0xdc00;
  }
  return string_buffer_putc16(s, c);
}

QJS_STATIC int string_get(const LEPUSString *p, int idx) {
  return p->is_wide_char ? p->u.str16[idx] : p->u.str8[idx];
}

QJS_STATIC int string_getc(const LEPUSString *p, int *pidx) {
  int idx, c, c1;
  idx = *pidx;
  if (p->is_wide_char) {
    c = p->u.str16[idx++];
    if (c >= 0xd800 && c < 0xdc00 && idx < p->len) {
      c1 = p->u.str16[idx];
      if (c1 >= 0xdc00 && c1 < 0xe000) {
        c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
        idx++;
      }
    }
  } else {
    c = p->u.str8[idx++];
  }
  *pidx = idx;
  return c;
}

QJS_STATIC int string_buffer_write8(StringBuffer *s, const uint8_t *p,
                                    int len) {
  int i;

  if (s->len + len > s->size) {
    if (string_buffer_realloc(s, s->len + len, 0)) return -1;
  }
  if (s->is_wide_char) {
    for (i = 0; i < len; i++) {
      s->str->u.str16[s->len + i] = p[i];
    }
    s->len += len;
  } else {
    memcpy(&s->str->u.str8[s->len], p, len);
    s->len += len;
  }
  return 0;
}

QJS_STATIC int string_buffer_write16(StringBuffer *s, const uint16_t *p,
                                     int len) {
  int c = 0, i;

  for (i = 0; i < len; i++) {
    c |= p[i];
  }
  if (s->len + len > s->size) {
    if (string_buffer_realloc(s, s->len + len, c)) return -1;
  } else if (!s->is_wide_char && c >= 0x100) {
    if (string_buffer_widen(s, s->size)) return -1;
  }
  if (s->is_wide_char) {
    memcpy(&s->str->u.str16[s->len], p, len << 1);
    s->len += len;
  } else {
    for (i = 0; i < len; i++) {
      s->str->u.str8[s->len + i] = p[i];
    }
    s->len += len;
  }
  return 0;
}

/* appending an ASCII string */
QJS_STATIC int string_buffer_puts8(StringBuffer *s, const char *str) {
  return string_buffer_write8(s, (const uint8_t *)str, strlen(str));
}

QJS_STATIC int string_buffer_concat(StringBuffer *s, const LEPUSString *p,
                                    uint32_t from, uint32_t to) {
  if (to <= from) return 0;
  if (p->is_wide_char)
    return string_buffer_write16(s, p->u.str16 + from, to - from);
  else
    return string_buffer_write8(s, p->u.str8 + from, to - from);
}

QJS_STATIC int string_buffer_concat_value(StringBuffer *s, LEPUSValueConst v) {
  LEPUSString *p;
  LEPUSValue v1;
  int res;

  if (s->error_status) {
    /* prevent exception overload */
    return -1;
  }
  if (unlikely(!LEPUS_VALUE_IS_STRING(v))) {
    v1 = LEPUS_ToString(s->ctx, v);
    if (LEPUS_IsException(v1)) return string_buffer_set_error(s);
    p = LEPUS_VALUE_GET_STRING(v1);
    res = string_buffer_concat(s, p, 0, p->len);
    LEPUS_FreeValue(s->ctx, v1);
    return res;
  }
  p = LEPUS_VALUE_GET_STRING(v);
  return string_buffer_concat(s, p, 0, p->len);
}

QJS_STATIC int string_buffer_concat_value_free(StringBuffer *s, LEPUSValue v) {
  LEPUSString *p;
  int res;

  if (s->error_status) {
    /* prevent exception overload */
    LEPUS_FreeValue(s->ctx, v);
    return -1;
  }
  if (unlikely(!LEPUS_VALUE_IS_STRING(v))) {
    v = LEPUS_ToStringFree(s->ctx, v);
    if (LEPUS_IsException(v)) return string_buffer_set_error(s);
  }
  p = LEPUS_VALUE_GET_STRING(v);
  res = string_buffer_concat(s, p, 0, p->len);
  LEPUS_FreeValue(s->ctx, v);
  return res;
}

QJS_STATIC int string_buffer_fill(StringBuffer *s, int c, int count) {
  /* XXX: optimize */
  if (s->len + count > s->size) {
    if (string_buffer_realloc(s, s->len + count, c)) return -1;
  }
  while (count-- > 0) {
    if (string_buffer_putc16(s, c)) return -1;
  }
  return 0;
}

QJS_STATIC LEPUSValue string_buffer_end(StringBuffer *s) {
  LEPUSString *str;
  str = s->str;
  if (s->error_status) return LEPUS_EXCEPTION;
  if (s->len == 0) {
    lepus_free(s->ctx, str);
    s->str = NULL;
    return LEPUS_AtomToString(s->ctx, LEPUS_ATOM_empty_string);
  }
  if (s->len < s->size) {
    /* smaller size so lepus_realloc should not fail, but OK if it does */
    /* XXX: should add some slack to avoid unnecessary calls */
    /* XXX: might need to use malloc+free to ensure smaller size */
    str = static_cast<LEPUSString *>(
        lepus_realloc_rt(s->ctx->rt, str,
                         sizeof(LEPUSString) + (s->len << s->is_wide_char) + 1 -
                             s->is_wide_char));
    if (str == NULL) str = s->str;
    s->str = str;
  }
  if (!s->is_wide_char) str->u.str8[s->len] = 0;
#ifdef DUMP_LEAKS
  list_add_tail(&str->link, &s->ctx->rt->string_list);
#endif
  str->is_wide_char = s->is_wide_char;
  str->len = s->len;
  s->str = NULL;
  return LEPUS_MKPTR(LEPUS_TAG_STRING, str);
}

/* create a string from a UTF-8 buffer */
LEPUSValue LEPUS_NewStringLen(LEPUSContext *ctx, const char *buf,
                              size_t buf_len) {
  const uint8_t *p, *p_end, *p_start, *p_next;
  uint32_t c;
  StringBuffer b_s, *b = &b_s;
  size_t len1;

  p_start = (const uint8_t *)buf;
  p_end = p_start + buf_len;
  p = p_start;
  while (p < p_end && *p < 128) p++;
  len1 = p - p_start;
  if (len1 > LEPUS_STRING_LEN_MAX)
    return LEPUS_ThrowInternalError(ctx, "string too long");
  if (p == p_end) {
    /* ASCII string */
    return lepus_new_string8(ctx, (const uint8_t *)buf, buf_len);
  } else {
    if (string_buffer_init(ctx, b, buf_len)) goto fail;
    string_buffer_write8(b, p_start, len1);
    while (p < p_end) {
      if (*p < 128) {
        string_buffer_putc8(b, *p++);
      } else {
        /* parse utf-8 sequence, return 0xFFFFFFFF for error */
        c = unicode_from_utf8(p, p_end - p, &p_next);
        if (c < 0x10000) {
          p = p_next;
        } else if (c <= 0x10FFFF) {
          p = p_next;
          /* surrogate pair */
          c -= 0x10000;
          string_buffer_putc16(b, (c >> 10) + 0xd800);
          c = (c & 0x3ff) + 0xdc00;
        } else {
          /* invalid char */
          c = 0xfffd;
          /* skip the invalid chars */
          /* XXX: seems incorrect. Why not just use c = *p++; ? */
          while (p < p_end && (*p >= 0x80 && *p < 0xc0)) p++;
          if (p < p_end) {
            p++;
            while (p < p_end && (*p >= 0x80 && *p < 0xc0)) p++;
          }
        }
        string_buffer_putc16(b, c);
      }
    }
  }
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue LEPUS_ConcatString3(LEPUSContext *ctx, const char *str1,
                                          LEPUSValue str2, const char *str3) {
  StringBuffer b_s, *b = &b_s;
  int len1, len3;
  LEPUSString *p;

  if (unlikely(!LEPUS_VALUE_IS_STRING(str2))) {
    str2 = LEPUS_ToStringFree(ctx, str2);
    if (LEPUS_IsException(str2)) goto fail;
  }
  p = LEPUS_VALUE_GET_STRING(str2);
  len1 = strlen(str1);
  len3 = strlen(str3);

  if (string_buffer_init2(ctx, b, len1 + p->len + len3, p->is_wide_char))
    goto fail;

  string_buffer_write8(b, (const uint8_t *)str1, len1);
  string_buffer_concat(b, p, 0, p->len);
  string_buffer_write8(b, (const uint8_t *)str3, len3);

  LEPUS_FreeValue(ctx, str2);
  return string_buffer_end(b);

fail:
  LEPUS_FreeValue(ctx, str2);
  return LEPUS_EXCEPTION;
}

LEPUSValue LEPUS_NewString(LEPUSContext *ctx, const char *str) {
  return LEPUS_NewStringLen(ctx, str, strlen(str));
}

LEPUSValue LEPUS_NewAtomString(LEPUSContext *ctx, const char *str) {
  LEPUSAtom atom = LEPUS_NewAtom(ctx, str);
  if (atom == LEPUS_ATOM_NULL) return LEPUS_EXCEPTION;
  LEPUSValue val = LEPUS_AtomToString(ctx, atom);
  LEPUS_FreeAtom(ctx, atom);
  return val;
}

/* return (NULL, 0) if exception. */
/* return pointer into a LEPUSString with a live ref_count */
/* cesu8 determines if non-BMP1 codepoints are encoded as 1 or 2 utf-8 sequences
 */
const char *LEPUS_ToCStringLen2(LEPUSContext *ctx, size_t *plen,
                                LEPUSValueConst val1, BOOL cesu8) {
  LEPUSValue val;
  LEPUSString *str, *str_new;
  int pos, len, c, c1;
  uint8_t *q;

  if (!LEPUS_VALUE_IS_STRING(val1)) {
    val = LEPUS_ToString(ctx, val1);
    if (LEPUS_IsException(val)) goto fail;
  } else {
    val = LEPUS_DupValue(ctx, val1);
  }

  str = LEPUS_VALUE_GET_STRING(val);
  len = str->len;
  if (!str->is_wide_char) {
    const uint8_t *src = str->u.str8;
    int count;

    /* count the number of non-ASCII characters */
    /* Scanning the whole string is required for ASCII strings,
       and computing the number of non-ASCII bytes is less expensive
       than testing each byte, hence this method is faster for ASCII
       strings, which is the most common case.
     */
    count = 0;
    for (pos = 0; pos < len; pos++) {
      count += src[pos] >> 7;
    }
    if (count == 0) {
      if (plen) *plen = len;
      return (const char *)src;
    }
    str_new = lepus_alloc_string(ctx, len + count, 0);
    if (!str_new) goto fail;
    q = str_new->u.str8;
    for (pos = 0; pos < len; pos++) {
      c = src[pos];
      if (c < 0x80) {
        *q++ = c;
      } else {
        *q++ = (c >> 6) | 0xc0;
        *q++ = (c & 0x3f) | 0x80;
      }
    }
  } else {
    const uint16_t *src = str->u.str16;
    /* Allocate 3 bytes per 16 bit code point. Surrogate pairs may
       produce 4 bytes but use 2 code points.
     */
    str_new = lepus_alloc_string(ctx, len * 3, 0);
    if (!str_new) goto fail;
    q = str_new->u.str8;
    pos = 0;
    while (pos < len) {
      c = src[pos++];
      if (c < 0x80) {
        *q++ = c;
      } else {
        if (c >= 0xd800 && c < 0xdc00) {
          if (pos < len && !cesu8) {
            c1 = src[pos];
            if (c1 >= 0xdc00 && c1 < 0xe000) {
              pos++;
              /* surrogate pair */
              c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
            } else {
              /* Keep unmatched surrogate code points */
              /* c = 0xfffd; */ /* error */
            }
          } else {
            /* Keep unmatched surrogate code points */
            /* c = 0xfffd; */ /* error */
          }
        }
        q += unicode_to_utf8(q, c);
      }
    }
  }

  *q = '\0';
  str_new->len = q - str_new->u.str8;
  LEPUS_FreeValue(ctx, val);
  if (plen) *plen = str_new->len;
  return (const char *)str_new->u.str8;
fail:
  if (plen) *plen = 0;
  return NULL;
}

void LEPUS_FreeCString(LEPUSContext *ctx, const char *ptr) {
  LEPUSString *p;
  if (!ptr) return;
  /* purposely removing constness */
  p = (LEPUSString *)(void *)(ptr - offsetof(LEPUSString, u));
  LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
}

QJS_STATIC int memcmp16_8(const uint16_t *src1, const uint8_t *src2, int len) {
  int c, i;
  for (i = 0; i < len; i++) {
    c = src1[i] - src2[i];
    if (c != 0) return c;
  }
  return 0;
}

QJS_STATIC int memcmp16(const uint16_t *src1, const uint16_t *src2, int len) {
  int c, i;
  for (i = 0; i < len; i++) {
    c = src1[i] - src2[i];
    if (c != 0) return c;
  }
  return 0;
}

QJS_STATIC int lepus_string_memcmp(const LEPUSString *p1, const LEPUSString *p2,
                                   int len) {
  int res;

  if (likely(!p1->is_wide_char)) {
    if (likely(!p2->is_wide_char))
      res = memcmp(p1->u.str8, p2->u.str8, len);
    else
      res = -memcmp16_8(p2->u.str16, p1->u.str8, len);
  } else {
    if (!p2->is_wide_char)
      res = memcmp16_8(p1->u.str16, p2->u.str8, len);
    else
      res = memcmp16(p1->u.str16, p2->u.str16, len);
  }
  return res;
}

/* return < 0, 0 or > 0 */
QJS_STATIC int lepus_string_compare(LEPUSContext *ctx, const LEPUSString *p1,
                                    const LEPUSString *p2) {
  int res, len;
  len = min_int(p1->len, p2->len);
  res = lepus_string_memcmp(p1, p2, len);
  if (res == 0) {
    if (p1->len == p2->len)
      res = 0;
    else if (p1->len < p2->len)
      res = -1;
    else
      res = 1;
  }
  return res;
}

QJS_STATIC void copy_str16(uint16_t *dst, const LEPUSString *p, int offset,
                           int len) {
  if (p->is_wide_char) {
    memcpy(dst, p->u.str16 + offset, len * 2);
  } else {
    const uint8_t *src1 = p->u.str8 + offset;
    int i;

    for (i = 0; i < len; i++) dst[i] = src1[i];
  }
}

QJS_STATIC LEPUSValue LEPUS_ConcatString1(LEPUSContext *ctx,
                                          const LEPUSString *p1,
                                          const LEPUSString *p2) {
  LEPUSString *p;
  uint32_t len;
  int is_wide_char;

  len = p1->len + p2->len;
  if (len > LEPUS_STRING_LEN_MAX)
    return LEPUS_ThrowInternalError(ctx, "string too long");
  is_wide_char = p1->is_wide_char | p2->is_wide_char;
  p = lepus_alloc_string(ctx, len, is_wide_char);
  if (!p) return LEPUS_EXCEPTION;
  if (!is_wide_char) {
    memcpy(p->u.str8, p1->u.str8, p1->len);
    memcpy(p->u.str8 + p1->len, p2->u.str8, p2->len);
    p->u.str8[len] = '\0';
  } else {
    copy_str16(p->u.str16, p1, 0, p1->len);
    copy_str16(p->u.str16 + p1->len, p2, 0, p2->len);
  }
  return LEPUS_MKPTR(LEPUS_TAG_STRING, p);
}

/* op1 and op2 are converted to strings. For convience, op1 or op2 =
   LEPUS_EXCEPTION are accepted and return LEPUS_EXCEPTION.  */
LEPUSValue LEPUS_ConcatString(LEPUSContext *ctx, LEPUSValue op1,
                              LEPUSValue op2) {
  LEPUSValue ret;
  LEPUSString *p1, *p2;

  if (unlikely(!LEPUS_VALUE_IS_STRING(op1))) {
    op1 = LEPUS_ToStringFree(ctx, op1);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      return LEPUS_EXCEPTION;
    }
  }
  if (unlikely(!LEPUS_VALUE_IS_STRING(op2))) {
    op2 = LEPUS_ToStringFree(ctx, op2);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      return LEPUS_EXCEPTION;
    }
  }
  p1 = LEPUS_VALUE_GET_STRING(op1);
  p2 = LEPUS_VALUE_GET_STRING(op2);

  /* XXX: could also check if p1 is empty */
  if (p2->len == 0) {
    goto ret_op1;
  }
  if (p1->header.ref_count == 1 && p1->is_wide_char == p2->is_wide_char &&
      ctx->rt->mf.lepus_malloc_usable_size(p1) >=
          sizeof(*p1) + ((p1->len + p2->len) << p2->is_wide_char) + 1 -
              p1->is_wide_char) {
    /* Concatenate in place in available space at the end of p1 */
    if (p1->is_wide_char) {
      memcpy(p1->u.str16 + p1->len, p2->u.str16, p2->len << 1);
      p1->len += p2->len;
    } else {
      memcpy(p1->u.str8 + p1->len, p2->u.str8, p2->len);
      p1->len += p2->len;
      p1->u.str8[p1->len] = '\0';
    }
  ret_op1:
    LEPUS_FreeValue(ctx, op2);
    return op1;
  }
  ret = LEPUS_ConcatString1(ctx, p1, p2);
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return ret;
}

/* Shape support */

QJS_STATIC inline size_t get_shape_size(size_t hash_size, size_t prop_size) {
  return hash_size * sizeof(uint32_t) + sizeof(LEPUSShape) +
         prop_size * sizeof(LEPUSShapeProperty);
}

QJS_STATIC inline LEPUSShape *get_shape_from_alloc(void *sh_alloc,
                                                   size_t hash_size) {
  return (LEPUSShape *)(void *)((uint32_t *)sh_alloc + hash_size);
}

QJS_STATIC inline void *get_alloc_from_shape(LEPUSShape *sh) {
  return sh->prop_hash_end - ((intptr_t)sh->prop_hash_mask + 1);
}

// <primjs begin>
#ifdef ENABLE_PRIMJS_IC
QJS_STATIC inline uint32_t *prop_hash_end(LEPUSShape *sh) {
  return (uint32_t *)sh;
}
#endif
// <primjs end>

QJS_STATIC inline LEPUSShapeProperty *get_shape_prop(LEPUSShape *sh) {
  return sh->prop;
}

QJS_STATIC int init_shape_hash(LEPUSRuntime *rt) {
  rt->shape_hash_bits = 4; /* 16 shapes */
  rt->shape_hash_size = 1 << rt->shape_hash_bits;
  rt->shape_hash_count = 0;
  rt->shape_hash = static_cast<LEPUSShape **>(
      lepus_mallocz_rt(rt, sizeof(rt->shape_hash[0]) * rt->shape_hash_size));
  if (!rt->shape_hash) return -1;
  return 0;
}

/* same magic hash multiplier as the Linux kernel */
QJS_STATIC uint32_t shape_hash(uint32_t h, uint32_t val) {
  return (h + val) * 0x9e370001;
}

/* truncate the shape hash to 'hash_bits' bits */
QJS_STATIC uint32_t get_shape_hash(uint32_t h, int hash_bits) {
  return h >> (32 - hash_bits);
}

QJS_STATIC uint32_t shape_initial_hash(LEPUSObject *proto) {
  uint32_t h;
  h = shape_hash(1, (uintptr_t)proto);
  if (sizeof(proto) > 4) h = shape_hash(h, (uint64_t)(uintptr_t)proto >> 32);
  return h;
}

QJS_STATIC int resize_shape_hash(LEPUSRuntime *rt, int new_shape_hash_bits) {
  int new_shape_hash_size, i;
  uint32_t h;
  LEPUSShape **new_shape_hash, *sh, *sh_next;

  new_shape_hash_size = 1 << new_shape_hash_bits;
  new_shape_hash = static_cast<LEPUSShape **>(
      lepus_mallocz_rt(rt, sizeof(rt->shape_hash[0]) * new_shape_hash_size));
  if (!new_shape_hash) return -1;
  for (i = 0; i < rt->shape_hash_size; i++) {
    for (sh = rt->shape_hash[i]; sh != NULL; sh = sh_next) {
      sh_next = sh->shape_hash_next;
      h = get_shape_hash(sh->hash, new_shape_hash_bits);
      sh->shape_hash_next = new_shape_hash[h];
      new_shape_hash[h] = sh;
    }
  }
  lepus_free_rt(rt, rt->shape_hash);
  rt->shape_hash_bits = new_shape_hash_bits;
  rt->shape_hash_size = new_shape_hash_size;
  rt->shape_hash = new_shape_hash;
  return 0;
}

QJS_STATIC void lepus_shape_hash_link(LEPUSRuntime *rt, LEPUSShape *sh) {
  uint32_t h;
  h = get_shape_hash(sh->hash, rt->shape_hash_bits);
  sh->shape_hash_next = rt->shape_hash[h];
  rt->shape_hash[h] = sh;
  rt->shape_hash_count++;
}

QJS_STATIC void lepus_shape_hash_unlink(LEPUSRuntime *rt, LEPUSShape *sh) {
  uint32_t h;
  LEPUSShape **psh;

  h = get_shape_hash(sh->hash, rt->shape_hash_bits);
  psh = &rt->shape_hash[h];
  while (*psh != sh) {
    if (*psh == nullptr) return;
    psh = &(*psh)->shape_hash_next;
  }
  *psh = sh->shape_hash_next;
  rt->shape_hash_count--;
}

/* create a new empty shape with prototype 'proto' */
QJS_STATIC no_inline LEPUSShape *lepus_new_shape2(LEPUSContext *ctx,
                                                  LEPUSObject *proto,
                                                  int hash_size,
                                                  int prop_size) {
  LEPUSRuntime *rt = ctx->rt;
  void *sh_alloc;
  LEPUSShape *sh;

  /* resize the shape hash table if necessary */
  if (2 * (rt->shape_hash_count + 1) > rt->shape_hash_size) {
    resize_shape_hash(rt, rt->shape_hash_bits + 1);
  }

  sh_alloc = lepus_malloc(ctx, get_shape_size(hash_size, prop_size));
  if (!sh_alloc) return NULL;
  sh = get_shape_from_alloc(sh_alloc, hash_size);
  sh->header.ref_count = 1;
  sh->gc_header.mark = 0;
  if (proto) LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, proto));
  sh->proto = proto;
  memset(sh->prop_hash_end - hash_size, 0,
         sizeof(sh->prop_hash_end[0]) * hash_size);
  sh->prop_hash_mask = hash_size - 1;
  sh->prop_count = 0;
  sh->prop_size = prop_size;

  /* insert in the hash table */
  sh->hash = shape_initial_hash(proto);
  sh->is_hashed = TRUE;
  sh->has_small_array_index = FALSE;
  lepus_shape_hash_link(ctx->rt, sh);
  return sh;
}

QJS_STATIC LEPUSShape *lepus_new_shape(LEPUSContext *ctx, LEPUSObject *proto) {
  return lepus_new_shape2(ctx, proto, LEPUS_PROP_INITIAL_HASH_SIZE,
                          LEPUS_PROP_INITIAL_SIZE);
}

/* The shape is cloned. The new shape is not inserted in the shape
   hash table */
QJS_STATIC LEPUSShape *lepus_clone_shape(LEPUSContext *ctx, LEPUSShape *sh1) {
  LEPUSShape *sh;
  void *sh_alloc, *sh_alloc1;
  size_t size;
  LEPUSShapeProperty *pr;
  uint32_t i, hash_size;

  hash_size = sh1->prop_hash_mask + 1;
  size = get_shape_size(hash_size, sh1->prop_size);
  sh_alloc = lepus_malloc(ctx, size);
  if (!sh_alloc) return NULL;
  sh_alloc1 = get_alloc_from_shape(sh1);
  memcpy(sh_alloc, sh_alloc1, size);
  sh = get_shape_from_alloc(sh_alloc, hash_size);
  sh->header.ref_count = 1;
  sh->gc_header.mark = 0;
  sh->is_hashed = FALSE;
  if (sh->proto) {
    LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, sh->proto));
  }
  for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
    LEPUS_DupAtom(ctx, pr->atom);
  }
  return sh;
}

#ifdef ENABLE_QUICKJS_DEBUGGER
LEPUSShape *lepus_dup_shape(LEPUSShape *sh) {
#else
static LEPUSShape *lepus_dup_shape(LEPUSShape *sh) {
#endif
  sh->header.ref_count++;
  return sh;
}

QJS_STATIC void lepus_free_shape0(LEPUSRuntime *rt, LEPUSShape *sh) {
  uint32_t i;
  LEPUSShapeProperty *pr;
  if (sh->header.ref_count < 0) {
    return;
  }

  assert(sh->header.ref_count == 0);
  if (sh->is_hashed) lepus_shape_hash_unlink(rt, sh);
  if (sh->proto != NULL) {
    LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, sh->proto));
  }
  pr = get_shape_prop(sh);
  for (i = 0; i < sh->prop_count; i++) {
    LEPUS_FreeAtomRT(rt, pr->atom);
    pr++;
  }
  lepus_free_rt(rt, get_alloc_from_shape(sh));
}

QJS_STATIC void lepus_free_shape(LEPUSRuntime *rt, LEPUSShape *sh) {
  if (unlikely(--sh->header.ref_count <= 0)) {
    lepus_free_shape0(rt, sh);
  }
}

QJS_STATIC void lepus_free_shape_null(LEPUSRuntime *rt, LEPUSShape *sh) {
  if (sh) lepus_free_shape(rt, sh);
}

/* make space to hold at least 'count' properties */
QJS_STATIC no_inline int resize_properties(LEPUSContext *ctx, LEPUSShape **psh,
                                           LEPUSObject *p, uint32_t count) {
  LEPUSShape *sh;
  uint32_t new_size, new_hash_size, new_hash_mask, i;
  LEPUSShapeProperty *pr;
  void *sh_alloc;
  intptr_t h;

  sh = *psh;
  new_size = max_int(count, sh->prop_size * 3 / 2);
  /* Reallocate prop array first to avoid crash or size inconsistency
     in case of memory allocation failure */
  if (p) {
    LEPUSProperty *new_prop;
    new_prop = static_cast<LEPUSProperty *>(
        lepus_realloc(ctx, p->prop, sizeof(new_prop[0]) * new_size));
    if (unlikely(!new_prop)) return -1;
    p->prop = new_prop;
  }
  new_hash_size = sh->prop_hash_mask + 1;
  while (new_hash_size < new_size) new_hash_size = 2 * new_hash_size;
  if (new_hash_size != (sh->prop_hash_mask + 1)) {
    LEPUSShape *old_sh;
    /* resize the hash table and the properties */
    old_sh = sh;
    sh_alloc = lepus_malloc(ctx, get_shape_size(new_hash_size, new_size));
    if (!sh_alloc) return -1;
    sh = get_shape_from_alloc(sh_alloc, new_hash_size);
    /* copy all the fields and the properties */
    memcpy(sh, old_sh,
           sizeof(LEPUSShape) + sizeof(sh->prop[0]) * old_sh->prop_count);
    new_hash_mask = new_hash_size - 1;
    sh->prop_hash_mask = new_hash_mask;
    memset(sh->prop_hash_end - new_hash_size, 0,
           sizeof(sh->prop_hash_end[0]) * new_hash_size);
    for (i = 0, pr = sh->prop; i < sh->prop_count; i++, pr++) {
      if (pr->atom != LEPUS_ATOM_NULL) {
        h = ((uintptr_t)pr->atom & new_hash_mask);
        pr->hash_next = sh->prop_hash_end[-h - 1];
        sh->prop_hash_end[-h - 1] = i + 1;
      }
    }
    lepus_free(ctx, get_alloc_from_shape(old_sh));
  } else {
    /* only resize the properties */
    sh_alloc = lepus_realloc(ctx, get_alloc_from_shape(sh),
                             get_shape_size(new_hash_size, new_size));
    if (unlikely(!sh_alloc)) {
      return -1;
    }
    sh = get_shape_from_alloc(sh_alloc, new_hash_size);
  }
  *psh = sh;
  sh->prop_size = new_size;
  return 0;
}

QJS_STATIC int add_shape_property(LEPUSContext *ctx, LEPUSShape **psh,
                                  LEPUSObject *p, LEPUSAtom atom,
                                  int prop_flags) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSShape *sh = *psh;
  LEPUSShapeProperty *pr, *prop;
  uint32_t hash_mask, new_shape_hash = 0;
  intptr_t h;

  /* update the shape hash */
  if (sh->is_hashed) {
    lepus_shape_hash_unlink(rt, sh);
    new_shape_hash = shape_hash(shape_hash(sh->hash, atom), prop_flags);
  }

  if (unlikely(sh->prop_count >= sh->prop_size)) {
    if (resize_properties(ctx, psh, p, sh->prop_count + 1)) {
      /* in case of error, reinsert in the hash table.
         sh is still valid if resize_properties() failed */
      if (sh->is_hashed) lepus_shape_hash_link(rt, sh);
      return -1;
    }
    sh = *psh;
  }
  if (sh->is_hashed) {
    sh->hash = new_shape_hash;
    lepus_shape_hash_link(rt, sh);
  }
  /* Initialize the new shape property.
     The object property at p->prop[sh->prop_count] is uninitialized */
  prop = get_shape_prop(sh);
  pr = &prop[sh->prop_count++];
  pr->atom = LEPUS_DupAtom(ctx, atom);
  pr->flags = prop_flags;
  sh->has_small_array_index |= __JS_AtomIsTaggedInt(atom);
  /* add in hash table */
  hash_mask = sh->prop_hash_mask;
  h = atom & hash_mask;
  pr->hash_next = sh->prop_hash_end[-h - 1];
  sh->prop_hash_end[-h - 1] = sh->prop_count;
  return 0;
}

/* find a hashed empty shape matching the prototype. Return NULL if
   not found */
QJS_STATIC LEPUSShape *find_hashed_shape_proto(LEPUSRuntime *rt,
                                               LEPUSObject *proto) {
  LEPUSShape *sh1;
  uint32_t h, h1;

  h = shape_initial_hash(proto);
  h1 = get_shape_hash(h, rt->shape_hash_bits);
  for (sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {
    if (sh1->hash == h && sh1->proto == proto && sh1->prop_count == 0) {
      return sh1;
    }
  }
  return NULL;
}

/* find a hashed shape matching sh + (prop, prop_flags). Return NULL if
   not found */
QJS_STATIC LEPUSShape *find_hashed_shape_prop(LEPUSRuntime *rt, LEPUSShape *sh,
                                              LEPUSAtom atom, int prop_flags) {
  LEPUSShape *sh1;
  uint32_t h, h1, i, n;

  h = sh->hash;
  h = shape_hash(h, atom);
  h = shape_hash(h, prop_flags);
  h1 = get_shape_hash(h, rt->shape_hash_bits);
  for (sh1 = rt->shape_hash[h1]; sh1 != NULL; sh1 = sh1->shape_hash_next) {
    /* we test the hash first so that the rest is done only if the
       shapes really match */
    if (sh1->hash == h && sh1->proto == sh->proto &&
        sh1->prop_count == ((n = sh->prop_count) + 1)) {
      for (i = 0; i < n; i++) {
        if (unlikely(sh1->prop[i].atom != sh->prop[i].atom) ||
            unlikely(sh1->prop[i].flags != sh->prop[i].flags))
          goto next;
      }
      if (unlikely(sh1->prop[n].atom != atom) ||
          unlikely(sh1->prop[n].flags != prop_flags))
        goto next;
      return sh1;
    }
  next:;
  }
  return NULL;
}

QJS_STATIC __attribute__((unused)) void LEPUS_DumpShape(LEPUSRuntime *rt, int i,
                                                        LEPUSShape *sh) {
  char atom_buf[ATOM_GET_STR_BUF_SIZE];
  int j;

  /* XXX: should output readable class prototype */
  printf("%5d %3d%c %14p %5d %5d", i, sh->header.ref_count, " *"[sh->is_hashed],
         (void *)sh -> proto, sh -> prop_size, sh -> prop_count);
  for (j = 0; j < sh->prop_count; j++) {
    printf(" %s", LEPUS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf),
                                     sh->prop[j].atom));
  }
  printf("\n");
}

QJS_STATIC __attribute__((unused)) void LEPUS_DumpShapes(LEPUSRuntime *rt) {
  int i;
  LEPUSShape *sh;
  struct list_head *el;
  LEPUSObject *p;

  printf("LEPUSShapes: {\n");
  printf("%5s %4s %14s %5s %5s %s\n", "SLOT", "REFS", "PROTO", "SIZE", "COUNT",
         "PROPS");
  for (i = 0; i < rt->shape_hash_size; i++) {
    for (sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {
      LEPUS_DumpShape(rt, i, sh);
      assert(sh->is_hashed);
    }
  }
  /* dump non-hashed shapes */
  list_for_each(el, &rt->obj_list) {
    p = list_entry(el, LEPUSObject, link);
    if (!p->shape->is_hashed) {
      LEPUS_DumpShape(rt, -1, p->shape);
    }
  }
  printf("}\n");
}

#ifdef ENABLE_QUICKJS_DEBUGGER
LEPUSValue LEPUS_NewObjectFromShape(LEPUSContext *ctx, LEPUSShape *sh,
#else
static LEPUSValue LEPUS_NewObjectFromShape(LEPUSContext *ctx, LEPUSShape *sh,
#endif
                                    LEPUSClassID class_id) {
  LEPUSObject *p;

  lepus_trigger_gc(ctx->rt, sizeof(LEPUSObject));
  p = static_cast<LEPUSObject *>(lepus_malloc(ctx, sizeof(LEPUSObject)));
  if (unlikely(!p)) goto fail;
  p->header.ref_count = 1;
  p->gc_header.mark = 0;
  p->class_id = class_id;
  p->extensible = TRUE;
  p->free_mark = 0;
  p->is_exotic = 0;
  p->fast_array = 0;
  p->is_constructor = 0;
  p->is_uncatchable_error = 0;
  p->is_class = 0;
  p->tmp_mark = 0;
  p->first_weak_ref = NULL;
  p->u.opaque = NULL;
  p->shape = sh;
  p->prop = static_cast<LEPUSProperty *>(
      lepus_malloc(ctx, sizeof(LEPUSProperty) * sh->prop_size));
  if (unlikely(!p->prop)) {
    lepus_free(ctx, p);
  fail:
    lepus_free_shape(ctx->rt, sh);
    return LEPUS_EXCEPTION;
  }

  switch (class_id) {
    case LEPUS_CLASS_OBJECT:
      break;
    case LEPUS_CLASS_ARRAY: {
      LEPUSProperty *pr;
      p->is_exotic = 1;
      p->fast_array = 1;
      p->u.array.u.values = NULL;
      p->u.array.count = 0;
      p->u.array.u1.size = 0;
      /* the length property is always the first one */
      if (likely(sh == ctx->array_shape)) {
        pr = &p->prop[0];
      } else {
        /* only used for the first array */
        /* cannot fail */
        pr = add_property(ctx, p, LEPUS_ATOM_length,
                          LEPUS_PROP_WRITABLE | LEPUS_PROP_LENGTH);
      }
      pr->u.value = LEPUS_NewInt32(ctx, 0);
    } break;
    case LEPUS_CLASS_C_FUNCTION:
      p->prop[0].u.value = LEPUS_UNDEFINED;
      break;
    case LEPUS_CLASS_ARGUMENTS:
    case LEPUS_CLASS_UINT8C_ARRAY ... LEPUS_CLASS_FLOAT64_ARRAY:
      p->is_exotic = 1;
      p->fast_array = 1;
      p->u.array.u.ptr = NULL;
      p->u.array.count = 0;
      break;
    case LEPUS_CLASS_DATAVIEW:
      p->u.array.u.ptr = NULL;
      p->u.array.count = 0;
      break;
    case LEPUS_CLASS_NUMBER:
    case LEPUS_CLASS_STRING:
    case LEPUS_CLASS_BOOLEAN:
    case LEPUS_CLASS_SYMBOL:
    case LEPUS_CLASS_DATE:
#ifdef CONFIG_BIGNUM
    case LEPUS_CLASS_BIG_INT:
    case LEPUS_CLASS_BIG_FLOAT:
#endif
      p->u.object_data = LEPUS_UNDEFINED;
      goto set_exotic;
    case LEPUS_CLASS_REGEXP:
      p->u.regexp.pattern = NULL;
      p->u.regexp.bytecode = NULL;
      goto set_exotic;
    default:
    set_exotic:
      if (ctx->rt->class_array[class_id].exotic) {
        p->is_exotic = 1;
      }
      break;
  }
  list_add_tail(&p->link, &ctx->rt->obj_list);
  return LEPUS_MKPTR(LEPUS_TAG_OBJECT, p);
}

QJS_STATIC LEPUSObject *get_proto_obj(LEPUSValueConst proto_val) {
  if (LEPUS_VALUE_IS_NOT_OBJECT(proto_val))
    return NULL;
  else
    return LEPUS_VALUE_GET_OBJ(proto_val);
}

/* WARNING: proto must be an object or LEPUS_NULL */
LEPUSValue LEPUS_NewObjectProtoClass(LEPUSContext *ctx,
                                     LEPUSValueConst proto_val,
                                     LEPUSClassID class_id) {
  LEPUSShape *sh;
  LEPUSObject *proto;

  proto = get_proto_obj(proto_val);
  sh = find_hashed_shape_proto(ctx->rt, proto);
  if (likely(sh)) {
    sh = lepus_dup_shape(sh);
  } else {
    sh = lepus_new_shape(ctx, proto);
    if (!sh) return LEPUS_EXCEPTION;
  }
  return LEPUS_NewObjectFromShape(ctx, sh, class_id);
}

#if 0
static LEPUSValue LEPUS_GetObjectData(LEPUSContext *ctx, LEPUSValueConst obj)
{
    LEPUSObject *p;

    if (LEPUS_VALUE_IS_OBJECT(obj)) {
        p = LEPUS_VALUE_GET_OBJ(obj);
        switch(p->class_id) {
        case LEPUS_CLASS_NUMBER:
        case LEPUS_CLASS_STRING:
        case LEPUS_CLASS_BOOLEAN:
        case LEPUS_CLASS_SYMBOL:
        case LEPUS_CLASS_DATE:
#ifdef CONFIG_BIGNUM
        case LEPUS_CLASS_BIG_INT:
        case LEPUS_CLASS_BIG_FLOAT:
#endif
            return LEPUS_DupValue(ctx, p->u.object_data);
        }
    }
    return LEPUS_UNDEFINED;
}
#endif

QJS_STATIC int LEPUS_SetObjectData(LEPUSContext *ctx, LEPUSValueConst obj,
                                   LEPUSValue val) {
  LEPUSObject *p;

  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    p = LEPUS_VALUE_GET_OBJ(obj);
    switch (p->class_id) {
      case LEPUS_CLASS_NUMBER:
      case LEPUS_CLASS_STRING:
      case LEPUS_CLASS_BOOLEAN:
      case LEPUS_CLASS_SYMBOL:
      case LEPUS_CLASS_DATE:
#ifdef CONFIG_BIGNUM
      case LEPUS_CLASS_BIG_INT:
      case LEPUS_CLASS_BIG_FLOAT:
#endif
        LEPUS_FreeValue(ctx, p->u.object_data);
        p->u.object_data = val;
        return 0;
    }
  }
  LEPUS_FreeValue(ctx, val);
  if (!LEPUS_IsException(obj)) LEPUS_ThrowTypeError(ctx, "invalid object type");
  return -1;
}

LEPUSValue LEPUS_NewObjectClass(LEPUSContext *ctx, int class_id) {
  return LEPUS_NewObjectProtoClass(ctx, ctx->class_proto[class_id], class_id);
}

LEPUSValue LEPUS_NewObjectProto(LEPUSContext *ctx, LEPUSValueConst proto) {
  return LEPUS_NewObjectProtoClass(ctx, proto, LEPUS_CLASS_OBJECT);
}

LEPUSValue PRIM_JS_NewArray(LEPUSContext *ctx) {
  return LEPUS_NewObjectFromShape(ctx, lepus_dup_shape(ctx->array_shape),
                                  LEPUS_CLASS_ARRAY);
}

LEPUSValue LEPUS_NewArray(LEPUSContext *ctx) {
  return LEPUS_NewObjectFromShape(ctx, lepus_dup_shape(ctx->array_shape),
                                  LEPUS_CLASS_ARRAY);
}

// <primjs begin>
LEPUSValue PRIM_JS_NewObject(LEPUSContext *ctx) {
  /* inline LEPUS_NewObjectClass(ctx, LEPUS_CLASS_OBJECT); */
  return LEPUS_NewObjectProtoClass(ctx, ctx->class_proto[LEPUS_CLASS_OBJECT],
                                   LEPUS_CLASS_OBJECT);
}
// <primjs end>

LEPUSValue LEPUS_NewObject(LEPUSContext *ctx) {
  /* inline LEPUS_NewObjectClass(ctx, LEPUS_CLASS_OBJECT); */
  return LEPUS_NewObjectProtoClass(ctx, ctx->class_proto[LEPUS_CLASS_OBJECT],
                                   LEPUS_CLASS_OBJECT);
}

QJS_STATIC void lepus_function_set_properties(LEPUSContext *ctx,
                                              LEPUSValueConst func_obj,
                                              LEPUSAtom name, int len) {
  /* ES6 feature non compatible with ES5.1: length is configurable */
  LEPUS_DefinePropertyValue(ctx, func_obj, LEPUS_ATOM_length,
                            LEPUS_NewInt32(ctx, len), LEPUS_PROP_CONFIGURABLE);
  LEPUS_DefinePropertyValue(ctx, func_obj, LEPUS_ATOM_name,
                            LEPUS_AtomToString(ctx, name),
                            LEPUS_PROP_CONFIGURABLE);
}

BOOL lepus_class_has_bytecode(LEPUSClassID class_id) {
  return (class_id == LEPUS_CLASS_BYTECODE_FUNCTION ||
          class_id == LEPUS_CLASS_GENERATOR_FUNCTION ||
          class_id == LEPUS_CLASS_ASYNC_FUNCTION ||
          class_id == LEPUS_CLASS_ASYNC_GENERATOR_FUNCTION);
}

/* return NULL without exception if not a function or no bytecode */
QJS_HIDE LEPUSFunctionBytecode *LEPUS_GetFunctionBytecode(LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return NULL;
  p = LEPUS_VALUE_GET_OBJ(val);
  if (!lepus_class_has_bytecode(p->class_id)) return NULL;
  return p->u.func.function_bytecode;
}

void lepus_method_set_home_object(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                  LEPUSValueConst home_obj) {
  LEPUSObject *p, *p1;
  LEPUSFunctionBytecode *b;

  if (LEPUS_VALUE_IS_NOT_OBJECT(func_obj)) return;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  if (!lepus_class_has_bytecode(p->class_id)) return;
  b = p->u.func.function_bytecode;
  if (b->need_home_object) {
    p1 = p->u.func.home_object;
    if (p1) {
      LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1));
    }
    if (LEPUS_VALUE_IS_OBJECT(home_obj))
      p1 = LEPUS_VALUE_GET_OBJ(LEPUS_DupValue(ctx, home_obj));
    else
      p1 = NULL;
    p->u.func.home_object = p1;
  }
}

QJS_STATIC LEPUSValue lepus_get_function_name(LEPUSContext *ctx,
                                              LEPUSAtom name) {
  LEPUSValue name_str;

  name_str = LEPUS_AtomToString(ctx, name);
  if (LEPUS_AtomSymbolHasDescription(ctx, name)) {
    name_str = LEPUS_ConcatString3(ctx, "[", name_str, "]");
  }
  return name_str;
}

/* Modify the name of a method according to the atom and
   'flags'. 'flags' is a bitmask of LEPUS_PROP_HAS_GET and
   LEPUS_PROP_HAS_SET. Also set the home object of the method.
   Return < 0 if exception. */
int lepus_method_set_properties(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                LEPUSAtom name, int flags,
                                LEPUSValueConst home_obj) {
  LEPUSValue name_str;

  name_str = lepus_get_function_name(ctx, name);
  if (flags & LEPUS_PROP_HAS_GET) {
    name_str = LEPUS_ConcatString3(ctx, "get ", name_str, "");
  } else if (flags & LEPUS_PROP_HAS_SET) {
    name_str = LEPUS_ConcatString3(ctx, "set ", name_str, "");
  }
  if (LEPUS_IsException(name_str)) return -1;
  if (LEPUS_DefinePropertyValue(ctx, func_obj, LEPUS_ATOM_name, name_str,
                                LEPUS_PROP_CONFIGURABLE) < 0)
    return -1;
  lepus_method_set_home_object(ctx, func_obj, home_obj);
  return 0;
}

/* Note: at least 'length' arguments will be readable in 'argv' */
QJS_STATIC LEPUSValue LEPUS_NewCFunction3(LEPUSContext *ctx,
                                          LEPUSCFunction *func,
                                          const char *name, int length,
                                          LEPUSCFunctionEnum cproto, int magic,
                                          LEPUSValueConst proto_val) {
  LEPUSValue func_obj;
  LEPUSObject *p;
  LEPUSAtom name_atom;

  func_obj = LEPUS_NewObjectProtoClass(ctx, proto_val, LEPUS_CLASS_C_FUNCTION);
  if (LEPUS_IsException(func_obj)) return func_obj;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->u.cfunc.c_function.generic = func;
  p->u.cfunc.length = length;
  p->u.cfunc.cproto = cproto;
  p->u.cfunc.magic = magic;
  p->is_constructor = (cproto == LEPUS_CFUNC_constructor ||
                       cproto == LEPUS_CFUNC_constructor_magic ||
                       cproto == LEPUS_CFUNC_constructor_or_func ||
                       cproto == LEPUS_CFUNC_constructor_or_func_magic);
  if (!name) {
    name = "";
  }
  name_atom = LEPUS_NewAtom(ctx, name);
  lepus_function_set_properties(ctx, func_obj, name_atom, length);
  LEPUS_FreeAtom(ctx, name_atom);
  return func_obj;
}

/* Note: at least 'length' arguments will be readable in 'argv' */
LEPUSValue LEPUS_NewCFunction2(LEPUSContext *ctx, LEPUSCFunction *func,
                               const char *name, int length,
                               LEPUSCFunctionEnum cproto, int magic) {
  return LEPUS_NewCFunction3(ctx, func, name, length, cproto, magic,
                             ctx->function_proto);
}

typedef struct LEPUSCFunctionDataRecord {
  LEPUSCFunctionData *func;
  uint8_t length;
  uint8_t data_len;
  uint16_t magic;
  LEPUSValue data[0];
} LEPUSCFunctionDataRecord;

QJS_STATIC void lepus_c_function_data_finalizer(LEPUSRuntime *rt,
                                                LEPUSValue val) {
  LEPUSCFunctionDataRecord *s = static_cast<LEPUSCFunctionDataRecord *>(
      LEPUS_GetOpaque(val, LEPUS_CLASS_C_FUNCTION_DATA));
  int i;

  if (s) {
    for (i = 0; i < s->data_len; i++) {
      LEPUS_FreeValueRT(rt, s->data[i]);
    }
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void lepus_c_function_data_mark(LEPUSRuntime *rt,
                                           LEPUSValueConst val,
                                           LEPUS_MarkFunc *mark_func) {
  LEPUSCFunctionDataRecord *s = static_cast<LEPUSCFunctionDataRecord *>(
      LEPUS_GetOpaque(val, LEPUS_CLASS_C_FUNCTION_DATA));
  int i;

  if (s) {
    for (i = 0; i < s->data_len; i++) {
      LEPUS_MarkValue(rt, s->data[i], mark_func);
    }
  }
}

LEPUSValue LEPUS_ThrowStackOverflow(LEPUSContext *ctx) {
  return LEPUS_ThrowInternalError(ctx, "stack overflow");
}

QJS_STATIC LEPUSValue lepus_c_function_data_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_val,
    int argc, LEPUSValueConst *argv, int flags) {
  LEPUSCFunctionDataRecord *s = static_cast<LEPUSCFunctionDataRecord *>(
      LEPUS_GetOpaque(func_obj, LEPUS_CLASS_C_FUNCTION_DATA));
  LEPUSValueConst *arg_buf;
  int i;

  // <ByteDance begin>
#ifdef OS_IOS
  size_t arg_size = 0;
  LEPUSValue ret;
#endif
  /* XXX: could add the function on the stack for debug */
  if (unlikely(argc < s->length)) {
#ifdef OS_IOS
    arg_size = sizeof(arg_buf[0]) * s->length;
    if (lepus_check_virtual_outofmemory(ctx, arg_size)) {
      return LEPUS_ThrowOutOfMemory(ctx);
    }
    if (lepus_check_virtual_sp_overflow(ctx, arg_size)) {
      return LEPUS_ThrowStackOverflow(ctx);
    }

    arg_buf = lepus_get_virtual_sp(ctx);
    lepus_push_virtual_sp(ctx, arg_size);
#elif !defined(OS_WIN)
    arg_buf = static_cast<LEPUSValue *>(alloca(sizeof(arg_buf[0]) * s->length));
#else
                                        arg_buf = static_cast<LEPUSValue *>(
                                            _alloca(sizeof(arg_buf[0]) *
                                                    s->length));
#endif
    for (i = 0; i < argc; i++) arg_buf[i] = argv[i];
    for (i = argc; i < s->length; i++) arg_buf[i] = LEPUS_UNDEFINED;
  } else {
    arg_buf = argv;
  }
#ifdef OS_IOS
  ret = s->func(ctx, this_val, argc, arg_buf, s->magic, s->data);
  lepus_pop_virtual_sp(ctx, arg_size);
  return ret;
#else
  return s->func(ctx, this_val, argc, arg_buf, s->magic, s->data);
#endif
  // <ByteDance end>
}

LEPUSValue LEPUS_NewCFunctionData(LEPUSContext *ctx, LEPUSCFunctionData *func,
                                  int length, int magic, int data_len,
                                  LEPUSValueConst *data) {
  LEPUSCFunctionDataRecord *s;
  LEPUSValue func_obj;
  int i;

  func_obj = LEPUS_NewObjectProtoClass(ctx, ctx->function_proto,
                                       LEPUS_CLASS_C_FUNCTION_DATA);
  if (LEPUS_IsException(func_obj)) return func_obj;
  s = static_cast<LEPUSCFunctionDataRecord *>(
      lepus_malloc(ctx, sizeof(*s) + data_len * sizeof(LEPUSValue)));
  if (!s) {
    LEPUS_FreeValue(ctx, func_obj);
    return LEPUS_EXCEPTION;
  }
  s->func = func;
  s->length = length;
  s->data_len = data_len;
  s->magic = magic;
  for (i = 0; i < data_len; i++) s->data[i] = LEPUS_DupValue(ctx, data[i]);
  LEPUS_SetOpaque(func_obj, s);
  lepus_function_set_properties(ctx, func_obj, LEPUS_ATOM_empty_string, length);
  return func_obj;
}

QJS_STATIC void free_property(LEPUSRuntime *rt, LEPUSProperty *pr,
                              int prop_flags) {
  if (unlikely(prop_flags & LEPUS_PROP_TMASK)) {
    if ((prop_flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
      if (pr->u.getset.getter)
        LEPUS_FreeValueRT(rt,
                          LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
      if (pr->u.getset.setter)
        LEPUS_FreeValueRT(rt,
                          LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
    } else if ((prop_flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
      free_var_ref(rt, pr->u.var_ref);
    } else if ((prop_flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
    }
  } else {
    LEPUS_FreeValueRT(rt, pr->u.value);
  }
}

QJS_STATIC force_inline LEPUSShapeProperty *find_own_property1(LEPUSObject *p,
                                                               LEPUSAtom atom) {
  LEPUSShape *sh;
  LEPUSShapeProperty *pr, *prop;
  intptr_t h;
  sh = p->shape;
  h = (uintptr_t)atom & sh->prop_hash_mask;
  h = sh->prop_hash_end[-h - 1];
  prop = get_shape_prop(sh);
  while (h) {
    pr = &prop[h - 1];
    if (likely(pr->atom == atom)) {
      return pr;
    }
    h = pr->hash_next;
  }
  return NULL;
}
// <primjs begin>
#ifdef ENABLE_PRIMJS_IC
QJS_STATIC force_inline LEPUSShapeProperty *find_own_property_with_ic(
    LEPUSProperty **ppr, LEPUSObject *p, LEPUSAtom atom, intptr_t *offset) {
  LEPUSShape *sh;
  LEPUSShapeProperty *pr, *prop;
  intptr_t h;
  sh = p->shape;
  h = (uintptr_t)atom & sh->prop_hash_mask;
  h = prop_hash_end(sh)[-h - 1];
  prop = get_shape_prop(sh);
  while (h) {
    pr = &prop[h - 1];
    if (likely(pr->atom == atom)) {
      *ppr = &p->prop[h - 1];
      *offset = (h - 1);
      /* the compiler should be able to assume that pr != NULL here */
      return pr;
    }
    h = pr->hash_next;
  }
  *ppr = NULL;
  return NULL;
}
#endif
// <primjs end>

#ifdef QJS_UNITTEST
LEPUSShapeProperty *find_own_property(
#else
QJS_STATIC force_inline LEPUSShapeProperty *find_own_property(
#endif
    LEPUSProperty **ppr, LEPUSObject *p, LEPUSAtom atom) {
  LEPUSShape *sh;
  LEPUSShapeProperty *pr, *prop;
  intptr_t h;
  sh = p->shape;
  h = (uintptr_t)atom & sh->prop_hash_mask;
  h = sh->prop_hash_end[-h - 1];
  prop = get_shape_prop(sh);
  while (h) {
    pr = &prop[h - 1];
    if (likely(pr->atom == atom)) {
      *ppr = &p->prop[h - 1];
      /* the compiler should be able to assume that pr != NULL here */
      return pr;
    }
    h = pr->hash_next;
  }
  *ppr = NULL;
  return NULL;
}

/* indicate that the object may be part of a function prototype cycle */
QJS_STATIC void set_cycle_flag(LEPUSContext *ctx, LEPUSValueConst obj) {}

QJS_STATIC void free_var_ref(LEPUSRuntime *rt, LEPUSVarRef *var_ref) {
  if (var_ref) {
    assert(var_ref->header.ref_count > 0);
    if (--var_ref->header.ref_count == 0) {
      if (var_ref->link.prev != NULL) {
        list_del(&var_ref->link); /* still on the stack */
      } else {
        LEPUS_FreeValueRT(rt, var_ref->value);
      }
      lepus_free_rt(rt, var_ref);
    }
  }
}

QJS_STATIC void lepus_array_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  int i;

  for (i = 0; i < p->u.array.count; i++) {
    LEPUS_FreeValueRT(rt, p->u.array.u.values[i]);
  }
  lepus_free_rt(rt, p->u.array.u.values);
}

QJS_STATIC void lepus_array_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                 LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  int i;

  for (i = 0; i < p->u.array.count; i++) {
    LEPUS_MarkValue(rt, p->u.array.u.values[i], mark_func);
  }
}

QJS_STATIC void lepus_object_data_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUS_FreeValueRT(rt, p->u.object_data);
  p->u.object_data = LEPUS_UNDEFINED;
}

QJS_STATIC void lepus_object_data_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                       LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUS_MarkValue(rt, p->u.object_data, mark_func);
}

QJS_STATIC void lepus_bytecode_function_finalizer(LEPUSRuntime *rt,
                                                  LEPUSValue val) {
  LEPUSObject *p1, *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSFunctionBytecode *b;
  LEPUSVarRef **var_refs;
  int i;

  p1 = p->u.func.home_object;
  if (p1) {
    LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1));
  }
  b = p->u.func.function_bytecode;
  if (b) {
    var_refs = p->u.func.var_refs;
    if (var_refs) {
      for (i = 0; i < b->closure_var_count; i++) free_var_ref(rt, var_refs[i]);
      lepus_free_rt(rt, var_refs);
    }
    LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b));
  }
}

QJS_STATIC void lepus_bytecode_function_mark(LEPUSRuntime *rt,
                                             LEPUSValueConst val,
                                             LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSVarRef **var_refs = p->u.func.var_refs;
  LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
  int i;

  if (p->u.func.home_object) {
    LEPUS_MarkValue(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p->u.func.home_object),
                    mark_func);
  }
  if (b) {
    if (var_refs) {
      for (i = 0; i < b->closure_var_count; i++) {
        LEPUSVarRef *var_ref = var_refs[i];
        if (var_ref) {
          LEPUS_MarkValue(rt, LEPUS_MKPTR(LEPUS_TAG_VAR_REF, var_ref),
                          mark_func);
        }
      }
    }
    /* must mark the function bytecode because template objects may be
       part of a cycle */
    LEPUS_MarkValue(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b), mark_func);
  }
}

QJS_STATIC void lepus_bound_function_finalizer(LEPUSRuntime *rt,
                                               LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSBoundFunction *bf = p->u.bound_function;
  int i;

  LEPUS_FreeValueRT(rt, bf->func_obj);
  LEPUS_FreeValueRT(rt, bf->this_val);
  for (i = 0; i < bf->argc; i++) {
    LEPUS_FreeValueRT(rt, bf->argv[i]);
  }
  lepus_free_rt(rt, bf);
}

QJS_STATIC void lepus_bound_function_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                          LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSBoundFunction *bf = p->u.bound_function;
  int i;

  LEPUS_MarkValue(rt, bf->func_obj, mark_func);
  LEPUS_MarkValue(rt, bf->this_val, mark_func);
  for (i = 0; i < bf->argc; i++) LEPUS_MarkValue(rt, bf->argv[i], mark_func);
}

QJS_STATIC void lepus_for_in_iterator_finalizer(LEPUSRuntime *rt,
                                                LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSForInIterator *it = p->u.for_in_iterator;
  LEPUS_FreeValueRT(rt, it->obj);
  lepus_free_rt(rt, it);
}

QJS_STATIC void lepus_for_in_iterator_mark(LEPUSRuntime *rt,
                                           LEPUSValueConst val,
                                           LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSForInIterator *it = p->u.for_in_iterator;
  LEPUS_MarkValue(rt, it->obj, mark_func);
}

QJS_STATIC void free_object_struct(LEPUSRuntime *rt, LEPUSObject *p) {
  int i;
  LEPUSClassFinalizer *finalizer;
  LEPUSShape *sh;
  LEPUSShapeProperty *pr;

  if (p->class_id != LEPUS_CLASS_WeakRef) {
    /* free all the fields */
    sh = p->shape;
    if (sh == NULL) {
      return;
    }
    pr = get_shape_prop(sh);
    for (i = 0; i < sh->prop_count; i++) {
      free_property(rt, &p->prop[i], pr->flags);
      pr++;
    }
    lepus_free_rt(rt, p->prop);
    lepus_free_shape(rt, sh);

    /* fail safe */
    p->shape = NULL;
    p->prop = NULL;
  }

  if (unlikely(p->first_weak_ref)) {
    if (p->first_weak_ref->registry) {
      reset_fg_registry(rt, p);  // FinalizationRegistry
      if (!(p->first_weak_ref->is_ref || p->first_weak_ref->map)) {
        lepus_free_rt(rt, p->first_weak_ref);
        p->first_weak_ref = NULL;
        goto finalize;
      }
    }
    if (p->first_weak_ref->is_ref) {
      reset_weakref_record(rt, p);  // WeakRef
    } else if (p->first_weak_ref->map) {
      reset_weak_ref(rt, p);  // MapSet
    }
    p->first_weak_ref = NULL;
  }

finalize:
  finalizer = rt->class_array[p->class_id].finalizer;
  if (finalizer) (*finalizer)(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));

  /* fail safe */
  p->class_id = 0;
  p->u.opaque = NULL;
  p->u.func.var_refs = NULL;
  p->u.func.home_object = NULL;
}

QJS_STATIC void free_object2(LEPUSRuntime *rt, LEPUSObject *p) {
  if (p->free_mark) {
    /* already freed (happen when freeing cycles) */
    return;
  }
  /* indicate that the object is being freed */
  p->free_mark = 1;

  free_object_struct(rt, p);

  /* remove from the global object list */
  list_del(&p->link);
  if (rt->in_gc_sweep) {
    list_add_tail(&p->link, &rt->free_obj_list);
  } else {
    lepus_free_rt(rt, p);
  }
}

QJS_STATIC void free_object(LEPUSRuntime *rt, LEPUSObject *p) {
  assert(p->header.ref_count == 0);
  if (!rt->in_gc_sweep) free_object2(rt, p);
}

#ifdef ENABLE_LEPUSNG
QJS_STATIC void LEPUSRefFinalizer(LEPUSRuntime *rt, LEPUSValue val) {
  auto &lepus_val =
      reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(val))->lepus_val;
  if (!LEPUS_IsUndefined(lepus_val)) {
    auto *lepus_val_p = LEPUS_VALUE_GET_OBJ(lepus_val);
    if (lepus_val_p->header.ref_count == 1) {
      lepus_val = LEPUS_UNDEFINED;
    }
  }
  rt->in_gc_sweep = FALSE;
  rt->lepus_callbacks_.free_value(rt, val);
  rt->in_gc_sweep = TRUE;
}
#endif

/* called with the ref_count of 'v' reaches zero. */
void __JS_FreeValueRT(LEPUSRuntime *rt, LEPUSValue v) {
  int64_t tag = LEPUS_VALUE_GET_TAG(v);

#ifdef DUMP_FREE
  {
    printf("Freeing ");
    if (tag == LEPUS_TAG_OBJECT) {
      LEPUS_DumpObject(rt, LEPUS_VALUE_GET_OBJ(v));
    } else {
      LEPUS_DumpValueShort(rt, v);
      printf("\n");
    }
  }
#endif

  switch (tag) {
    case LEPUS_TAG_STRING: {
      LEPUSString *p = LEPUS_VALUE_GET_STRING(v);
      if (p->atom_type) {
        LEPUS_FreeAtomStruct(rt, p);
      } else {
#ifdef DUMP_LEAKS
        list_del(&p->link);
#endif

#ifdef ENABLE_LEPUSNG
        // <ByteDance begin>
        LEPUS_FreeStringCache(rt, p);
        // <ByteDance end>
#endif
        lepus_free_rt(rt, p);
      }
    } break;
    case LEPUS_TAG_OBJECT:
      free_object(rt, LEPUS_VALUE_GET_OBJ(v));
      break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      free_function_bytecode(
          rt, static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(v)));
      break;
    case LEPUS_TAG_SHAPE:
    case LEPUS_TAG_ASYNC_FUNCTION:
    case LEPUS_TAG_VAR_REF:
    case LEPUS_TAG_MODULE:
      abort(); /* never freed here */
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *bf =
          reinterpret_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(v));
      bf_delete(&bf->num);
      lepus_free_rt(rt, bf);
    } break;
#else
#ifdef ENABLE_LEPUSNG
    // <ByteDance begin>
    case LEPUS_TAG_BIG_FLOAT:
    case LEPUS_TAG_BIG_INT: {
      LEPUSBigFloat *bf = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(v));
      lepus_free_rt(rt, bf);
      break;
    }
    case LEPUS_TAG_LEPUS_REF: {
      if (rt->lepus_callbacks_.free_value) {
        if (rt->in_gc_sweep) {
          LEPUSRefFinalizer(rt, v);
          break;
        }
        rt->lepus_callbacks_.free_value(rt, v);
      }
      break;
    }
    // <ByteDance end>
#endif
#endif
    case LEPUS_TAG_SYMBOL: {
      LEPUSAtomStruct *p =
          static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(v));
      LEPUS_FreeAtomStruct(rt, p);
    } break;
    default:
#if defined(__aarch64__) && !defined(OS_WIN)
      printf("__JS_FreeValue: unknown tag=%p\n", (void *)tag);
#else
      printf("__JS_FreeValue: unknown tag=%" PRId64 "\n", tag);
#endif
      abort();
  }
}

void __JS_FreeValue(LEPUSContext *ctx, LEPUSValue v) {
  __JS_FreeValueRT(ctx->rt, v);
}

void LEPUS_FreeValue(LEPUSContext *ctx, LEPUSValue v) {
  if (LEPUS_VALUE_HAS_REF_COUNT(v)) {
    LEPUSRefCountHeader *p = (LEPUSRefCountHeader *)LEPUS_VALUE_GET_PTR(v);
    if (--p->ref_count <= 0) {
      __JS_FreeValue(ctx, v);
    }
  }
}

void LEPUS_FreeValueRT(LEPUSRuntime *rt, LEPUSValue v) {
  if (LEPUS_VALUE_HAS_REF_COUNT(v)) {
    LEPUSRefCountHeader *p = (LEPUSRefCountHeader *)LEPUS_VALUE_GET_PTR(v);
    if (--p->ref_count <= 0) {
      __JS_FreeValueRT(rt, v);
    }
  }
}
/* garbage collection */

QJS_STATIC BOOL has_children(LEPUSValueConst val) {
  switch (LEPUS_VALUE_GET_TAG(val)) {
    case LEPUS_TAG_VAR_REF:
    case LEPUS_TAG_OBJECT:
    case LEPUS_TAG_FUNCTION_BYTECODE:
    case LEPUS_TAG_ASYNC_FUNCTION:
    case LEPUS_TAG_SHAPE:
    case LEPUS_TAG_LEPUS_REF:
      return TRUE;
    default:
      return FALSE;
  }
}

void LEPUS_MarkValue(LEPUSRuntime *rt, LEPUSValueConst val,
                     LEPUS_MarkFunc *mark_func) {
  if (LEPUS_VALUE_HAS_REF_COUNT(val) && has_children(val)) {
    mark_func(rt, val);
  }
}

QJS_STATIC void mark_children(LEPUSRuntime *rt, LEPUSValueConst val,
                              LEPUS_MarkFunc *mark_func) {
  // <ByteDance begin>
  rt->c_stack_depth++;
  // <ByteDance end>
  switch (LEPUS_VALUE_GET_TAG(val)) {
#ifdef ENABLE_LEPUSNG
    // ByteDance begin
    case LEPUS_TAG_LEPUS_REF: {
      LEPUSLepusRef *pref = (LEPUSLepusRef *)(LEPUS_VALUE_GET_PTR(val));
      if (!LEPUS_IsUndefined(pref->lepus_val)) {
        mark_func(rt, pref->lepus_val);
      }
      break;
    }
    // ByteDance end
#endif
    case LEPUS_TAG_OBJECT: {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
      LEPUSShapeProperty *prs;
      LEPUSShape *sh;
      int i;
      sh = p->shape;
      mark_func(rt, LEPUS_MKPTR(LEPUS_TAG_SHAPE, sh));
      /* mark all the fields */
      prs = get_shape_prop(sh);
      if (p->class_id != LEPUS_CLASS_WeakRef) {
        if (sh == nullptr) return;
        for (i = 0; i < sh->prop_count; i++) {
          LEPUSProperty *pr = &p->prop[i];
          if (prs->atom != LEPUS_ATOM_NULL) {
            if (prs->flags & LEPUS_PROP_TMASK) {
              if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
                if (pr->u.getset.getter)
                  mark_func(rt,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
                if (pr->u.getset.setter)
                  mark_func(rt,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
              } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
                LEPUS_MarkValue(rt,
                                LEPUS_MKPTR(LEPUS_TAG_VAR_REF, pr->u.var_ref),
                                mark_func);
              } else if ((prs->flags & LEPUS_PROP_TMASK) ==
                         LEPUS_PROP_AUTOINIT) {
                /* nothing to do */
              }
            } else {
              LEPUS_MarkValue(rt, pr->u.value, mark_func);
            }
          }
          prs++;
        }
      }
      if (p->class_id != LEPUS_CLASS_OBJECT) {
        LEPUSClassGCMark *gc_mark;
        gc_mark = rt->class_array[p->class_id].gc_mark;
        if (gc_mark) gc_mark(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), mark_func);
      }
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      /* the template objects can be part of a cycle */
      {
        LEPUSFunctionBytecode *b =
            static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(val));
        int i;
        for (i = 0; i < b->cpool_count; i++) {
          LEPUS_MarkValue(rt, b->cpool[i], mark_func);
        }
      }
      break;
    case LEPUS_TAG_VAR_REF: {
      LEPUSVarRef *var_ref =
          static_cast<LEPUSVarRef *>(LEPUS_VALUE_GET_PTR(val));
      /* the refcount of stack values is not incremented, hence
         the test */
      if (var_ref->link.prev == NULL) {
        LEPUS_MarkValue(rt, *var_ref->pvalue, mark_func);
      }
    } break;
    case LEPUS_TAG_ASYNC_FUNCTION: {
      LEPUSAsyncFunctionData *s =
          static_cast<LEPUSAsyncFunctionData *>(LEPUS_VALUE_GET_PTR(val));
      if (s->is_active) async_func_mark(rt, &s->func_state, mark_func);
      LEPUS_MarkValue(rt, s->resolving_funcs[0], mark_func);
      LEPUS_MarkValue(rt, s->resolving_funcs[1], mark_func);
    } break;
    case LEPUS_TAG_SHAPE: {
      LEPUSShape *sh = static_cast<LEPUSShape *>(LEPUS_VALUE_GET_PTR(val));
      if (sh->proto != NULL) {
        mark_func(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, sh->proto));
      }
    } break;
    default:
      /* no children */
      break;
  }
  // <ByteDance begin>
  rt->c_stack_depth--;
  // <ByteDance end>
}

#if 0
/* not useful until realms are supported */
static void mark_context(LEPUSRuntime *rt, LEPUSContext *ctx)
{
    int i;
    struct list_head *el;

    list_for_each(el, &ctx->loaded_modules) {
        LEPUSModuleDef *m = list_entry(el, LEPUSModuleDef, link);
        LEPUS_MarkValue(rt, m->module_ns);
        LEPUS_MarkValue(rt, m->func_obj);
    }

    LEPUS_MarkValue(rt, ctx->current_exception);

    for(i = 0; i < rt->class_count; i++)
        LEPUS_MarkValue(rt, ctx->class_proto[i]);
    LEPUS_MarkValue(rt, ctx->regexp_ctor);
    LEPUS_MarkValue(rt, ctx->function_ctor);
    LEPUS_MarkValue(rt, ctx->function_proto);
    LEPUS_MarkValue(rt, ctx->iterator_proto);
    LEPUS_MarkValue(rt, ctx->async_iterator_proto);
    LEPUS_MarkValue(rt, ctx->array_proto_values);

    for(i = 0; i < LEPUS_NATIVE_ERROR_COUNT; i++)
        LEPUS_MarkValue(rt, ctx->native_error_proto[i]);

    LEPUS_MarkValue(rt, ctx->throw_type_error);
    LEPUS_MarkValue(rt, ctx->global_obj);
    LEPUS_MarkValue(rt, ctx->global_var_obj);
}
#endif

/* 1 = possible member of a cycle
   2 = member of a cycle
*/

QJS_STATIC void gc_decref_mark(LEPUSRuntime *rt, LEPUSValueConst obj);

//#define DUMP_GC_DECREF

#ifdef DUMP_GC_DECREF
static int decref_indent;
#endif

QJS_STATIC void gc_decref_child(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));

#ifdef DUMP_LEAKS
#ifdef DUMP_GC_DECREF
  {
    int i;
    for (i = 0; i < decref_indent; i++) printf("  ");
    if (LEPUS_IsObject(obj)) {
      LEPUS_DumpObject(rt, p);
    } else {
      LEPUS_DumpValueShort(rt, obj);
      printf("\n");
    }
  }
#endif
  if (p->header.ref_count <= 0) {
    printf("%p: invalid refcount (%d)\n", p, p->header.ref_count);
    if (LEPUS_IsObject(obj)) {
      LEPUS_DumpObject(rt, p);
    } else {
      LEPUS_DumpValueShort(rt, obj);
    }
  }
#endif
  assert(p->header.ref_count > 0);
  p->header.ref_count--;

  // <bytedance begin>
  if (LEPUS_IsLepusRef(obj)) {
    // should mark lepus_val
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (LEPUS_IsUndefined(lepus_val) || p->header.ref_count > 0) {
      return;
    }
    p = LEPUS_VALUE_GET_OBJ(lepus_val);
    assert(p->header.ref_count > 0);
    p->header.ref_count--;
    obj = lepus_val;
  }
  // <bytedance end>
  gc_decref_mark(rt, obj);
}
// <ByteDance begin>
#define MAX_CSTACK_DEPTH 32
#define GC_LINK_MASK 0xF0
#define GC_mark_MASK 0x0F
#define GC_IN_LINK 0x10
QJS_STATIC BOOL insert_to_cache_list(LEPUSRuntime *rt,
                                     struct list_head *bytecode_list,
                                     struct list_head *obj_list,
                                     LEPUSValueConst obj) {
  if (rt->c_stack_depth > MAX_CSTACK_DEPTH) {
    if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(obj)) {
      LEPUSFunctionBytecode *b =
          static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(obj));
      if ((b->gc_header.mark & GC_LINK_MASK) == 0) {
        b->gc_header.mark |= GC_IN_LINK;
        list_add_tail(&b->gc_link, bytecode_list);
      }
      return TRUE;
    }
    if (LEPUS_VALUE_IS_OBJECT(obj)) {
      LEPUSObject *b = LEPUS_VALUE_GET_OBJ(obj);
      if ((b->gc_header.mark & GC_LINK_MASK) == 0) {
        b->gc_header.mark |= GC_IN_LINK;
        if (rt->el_next == &b->link) rt->el_next = rt->el_next->next;
        list_del(&b->link);
        list_add_tail(&b->link, obj_list);
      }
      return TRUE;
    }
  }
  return FALSE;
}
// <ByteDance end>
QJS_STATIC void gc_decref_mark(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  // <ByteDance begin>
  if ((p->gc_header.mark & GC_mark_MASK) == 0) {
    if (insert_to_cache_list(rt, &rt->gc_bytecode_list, &rt->gc_obj_list,
                             obj) == TRUE)
      return;
    // <ByteDance end>
    p->gc_header.mark = 1;
#ifdef DUMP_GC_DECREF
    decref_indent++;
#endif
    mark_children(rt, obj, gc_decref_child);
#ifdef DUMP_GC_DECREF
    decref_indent--;
#endif
  }
}

QJS_STATIC void gc_decref(LEPUSRuntime *rt) {
  struct list_head *el;
  LEPUSObject *p;

  list_for_each(el, &rt->obj_list) {
    p = list_entry(el, LEPUSObject, link);
    gc_decref_mark(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  }
// <ByteDance begin>
gc_decref_label:
  while (!list_empty(&rt->gc_bytecode_list)) {
    LEPUSFunctionBytecode *b =
        list_entry(rt->gc_bytecode_list.next, LEPUSFunctionBytecode, gc_link);
    list_del(&b->gc_link);
    gc_decref_mark(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b));
    b->gc_header.mark &= GC_mark_MASK;
  }

  while (!list_empty(&rt->gc_obj_list)) {
    LEPUSObject *b = list_entry(rt->gc_obj_list.next, LEPUSObject, link);
    list_del(&b->link);
    list_add_tail(&b->link, &rt->obj_list);
    gc_decref_mark(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, b));
    b->gc_header.mark &= GC_mark_MASK;
  }
  if (!list_empty(&rt->gc_bytecode_list)) goto gc_decref_label;
  // <ByteDance end>
}

QJS_STATIC void gc_scan_incref(LEPUSRuntime *rt, LEPUSValueConst obj, BOOL);

QJS_STATIC void gc_scan_incref_child(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  p->header.ref_count++;
  // <ByteDance begin>
  if (LEPUS_IsLepusRef(obj)) {
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (p->header.ref_count > 1 || LEPUS_IsUndefined(lepus_val)) {
      return;
    }

    obj = lepus_val;
    p = LEPUS_VALUE_GET_OBJ(obj);
    p->header.ref_count++;
  }
  if ((p->gc_header.mark & GC_mark_MASK) != 0) {
    // <ByteDance end>
    gc_scan_incref(rt, obj, TRUE);
  }
}

QJS_STATIC void gc_scan_incref(LEPUSRuntime *rt, LEPUSValueConst obj,
                               BOOL insert_cache) {
  // <ByteDance begin>
  if (insert_cache == TRUE &&
      insert_to_cache_list(rt, &rt->gc_bytecode_list, &rt->gc_obj_list, obj) ==
          TRUE)
    return;
  // <ByteDance end>

  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (!p) return;
  if (LEPUS_IsObject(obj)) {
    // <ByteDance begin>
    uint8_t v = p->gc_header.mark & GC_LINK_MASK;
    if (v == GC_IN_LINK) return;
    // <ByteDance end>
    /* remove the tmp_obj_list and update the next object to
       explore */
    if (rt->el_next == &p->link) rt->el_next = rt->el_next->next;
    /* add to rt->obj_list */
    list_del(&p->link);
    list_add_tail(&p->link, &rt->obj_list);
    // <ByteDance begin>
  } else if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(obj)) {
    LEPUSFunctionBytecode *b =
        static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(obj));
    uint8_t v = b->gc_header.mark & GC_LINK_MASK;
    if (v == GC_IN_LINK) return;
  }
  p->gc_header.mark = 0; /* not freed */
  // <ByteDance end>
  mark_children(rt, obj, gc_scan_incref_child);
}

QJS_STATIC void gc_scan_obj(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  // <ByteDance begin>
  if ((p->gc_header.mark & GC_mark_MASK) == 1 && p->header.ref_count > 0) {
    // <ByteDance end>
    gc_scan_incref(rt, obj, TRUE);
  }
}
// <ByteDance begin>
QJS_STATIC void gc_scan_obj_set_mark2(LEPUSRuntime *rt, LEPUSValueConst obj) {
  if (LEPUS_IsLepusRef(obj)) {
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (LEPUS_IsUndefined(lepus_val)) return;
    obj = lepus_val;
  }

  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (!p || ((uintptr_t)p & 0x1) == 1) return;
  if ((p->gc_header.mark & GC_mark_MASK) == 1) {
    if (p->header.ref_count > 0) {
      gc_scan_incref(rt, obj, FALSE);
    } else {
      p->gc_header.mark = 2;
      if (insert_to_cache_list(rt, &rt->gc_bytecode_list, &rt->gc_obj_list,
                               obj) == TRUE)
        return;
      mark_children(rt, obj, gc_scan_obj_set_mark2);
    }
  }
}
// <ByteDance end>

QJS_STATIC void gc_scan_obj2(LEPUSRuntime *rt, LEPUSValueConst obj);

QJS_STATIC void gc_scan_incref_child2(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (!p || ((uintptr_t)p & 0x1) == 1) return;
  p->header.ref_count++;
  if (LEPUS_IsLepusRef(obj)) {
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (p->header.ref_count > 1 || LEPUS_IsUndefined(lepus_val)) {
      return;
    }
    obj = lepus_val;
    p = LEPUS_VALUE_GET_OBJ(obj);
    p->header.ref_count++;
  }
  gc_scan_obj2(rt, obj);
}

QJS_STATIC void gc_scan_obj2(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (!p || ((uintptr_t)p & 0x1) == 1) return;
  // <ByteDance begin>
  if ((p->gc_header.mark & GC_mark_MASK) == 2) {
    // <ByteDance end>
    p->gc_header.mark = 3;
    // <ByteDance begin>
    if (insert_to_cache_list(rt, &rt->gc_bytecode_list, &rt->gc_obj_list,
                             obj) == TRUE)
      return;
    // <ByteDance end>
    mark_children(rt, obj, gc_scan_incref_child2);
  }
}
// <ByteDance begin>
QJS_STATIC void traverse_bytecode(LEPUSRuntime *rt, struct list_head *list,
                                  LEPUS_MarkFunc *mark_func) {
  while (!list_empty(list)) {
    LEPUSFunctionBytecode *b =
        list_entry(list->next, LEPUSFunctionBytecode, gc_link);
    list_del(&b->gc_link);
    b->gc_header.mark &= GC_mark_MASK;
    mark_children(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b), mark_func);
  }
}
QJS_STATIC void remove_gc_list(LEPUSObject *p, LEPUSRuntime *rt) {
  list_del(&p->link);
  list_add_tail(&p->link, &rt->tmp_obj_list);
  p->gc_header.mark &= GC_mark_MASK;
}
QJS_STATIC void traverse_object(LEPUSRuntime *rt, struct list_head *list,
                                LEPUS_MarkFunc *mark_func) {
  while (!list_empty(list)) {
    LEPUSObject *p = list_entry(list->next, LEPUSObject, link);
    remove_gc_list(p, rt);
    mark_children(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), mark_func);
  }
}

QJS_STATIC void traverse_incref_list(LEPUSRuntime *rt) {
  while (!list_empty(&rt->gc_bytecode_list)) {
    LEPUSFunctionBytecode *b =
        list_entry(rt->gc_bytecode_list.next, LEPUSFunctionBytecode, gc_link);
    list_del(&b->gc_link);
    b->gc_header.mark &= GC_mark_MASK;
    gc_scan_incref(rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b), TRUE);
  }

  while (!list_empty(&rt->gc_obj_list)) {
    LEPUSObject *p = list_entry(rt->gc_obj_list.next, LEPUSObject, link);
    remove_gc_list(p, rt);
    gc_scan_incref(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), TRUE);
  }
}
// <ByteDance end>
QJS_STATIC void gc_scan(LEPUSRuntime *rt) {
  struct list_head *el;
  LEPUSObject *p;

  /* move obj_list to tmp_obj_list */
  list_add(&rt->tmp_obj_list, &rt->obj_list);
  list_del(&rt->obj_list);
  init_list_head(&rt->obj_list);

  /* keep the objects with a refcount > 0 and their children. After
     this pass, obj_list contains the objects to be deleted. Their
     mark is 2. */
  for (el = rt->tmp_obj_list.next; el != &rt->tmp_obj_list; el = rt->el_next) {
    rt->el_next = el->next; /* may be modified by gc_scan_obj() */
    p = list_entry(el, LEPUSObject, link);
    gc_scan_obj(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  }
// <ByteDance begin>
gc_scan_incref_label:
  traverse_incref_list(rt);
  if (!list_empty(&rt->gc_bytecode_list)) goto gc_scan_incref_label;

  for (el = rt->tmp_obj_list.next; el != &rt->tmp_obj_list; el = rt->el_next) {
    rt->el_next = el->next; /* may be modified by gc_scan_obj() */
    p = list_entry(el, LEPUSObject, link);
    gc_scan_obj_set_mark2(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  }

gc_scan_obj_set_mark2_label:
  traverse_bytecode(rt, &rt->gc_bytecode_list, gc_scan_obj_set_mark2);
  traverse_object(rt, &rt->gc_obj_list, gc_scan_obj_set_mark2);
  if (!list_empty(&rt->gc_bytecode_list)) goto gc_scan_obj_set_mark2_label;

  /* restore the refcount of the objects to be deleted. After this
     pass, their mark is 3 */
  list_for_each(el, &rt->tmp_obj_list) {
    p = list_entry(el, LEPUSObject, link);
    gc_scan_obj2(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  }

gc_scan_incref_child2_label:
  traverse_bytecode(rt, &rt->gc_bytecode_list, gc_scan_incref_child2);
  traverse_object(rt, &rt->gc_obj_list, gc_scan_incref_child2);
  if (!list_empty(&rt->gc_bytecode_list)) goto gc_scan_incref_child2_label;
  // <ByteDance end>
}

QJS_STATIC void gc_free_cycles(LEPUSRuntime *rt) {
  struct list_head *el, *el1;
  LEPUSObject *p;
#ifdef DUMP_GC_FREE
  BOOL header_done = FALSE;
#endif
  init_list_head(&rt->free_obj_list);
  rt->in_gc_sweep = TRUE;
  list_for_each_safe(el, el1, &rt->tmp_obj_list) {
    p = list_entry(el, LEPUSObject, link);
    assert(p->gc_header.mark == 3);
#ifdef DUMP_GC_FREE
    if (!header_done) {
      printf("Freeing cycles:\n");
      LEPUS_DumpObjectHeader(rt);
      header_done = TRUE;
    }
    LEPUS_DumpObject(rt, p);
#endif
    free_object2(rt, p);
  }
  rt->in_gc_sweep = FALSE;

  /* free all the object structures */
  list_for_each_safe(el, el1, &rt->free_obj_list) {
    p = list_entry(el, LEPUSObject, link);
    lepus_free_rt(rt, p);
  }
}

void LEPUS_RunGC(LEPUSRuntime *rt) {
  /* decrement the reference of the children of each object. mark =
     1 after this pass. */
  // <ByteDance begin>
  rt->c_stack_depth = 0;
  // <ByteDance end>
  gc_decref(rt);

  /* keep the GC objects with a non zero refcount and their childs */
  gc_scan(rt);

  /* free the GC objects in a cycle */
  gc_free_cycles(rt);
}

/* Return true during the GC sweep phase (can be useful inside in finalizer) */
BOOL LEPUS_IsInGCSweep(LEPUSRuntime *rt) { return rt->in_gc_sweep; }

/* Return false if not an object or if the object has already been
   freed (zombie objects are visible in finalizers when freeing
   cycles). */
BOOL LEPUS_IsLiveObject(LEPUSRuntime *rt, LEPUSValueConst obj) {
  LEPUSObject *p;
  if (!LEPUS_IsObject(obj)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  return !p->free_mark;
}

/* Compute memory used by various object types */
/* XXX: poor man's approach to handling multiply referenced objects */
typedef struct LEPUSMemoryUsage_helper {
  double memory_used_count;
  double str_count;
  double str_size;
  double lepus_func_count;
  double lepus_func_size;
  double lepus_func_code_size;
  double lepus_func_pc2line_count;
  double lepus_func_pc2line_size;
} LEPUSMemoryUsage_helper;

#if LYNX_SIMPLIFY
QJS_STATIC void compute_value_size(LEPUSValueConst val,
                                   LEPUSMemoryUsage_helper *hp);

QJS_STATIC void compute_jsstring_size(LEPUSString *str,
                                      LEPUSMemoryUsage_helper *hp) {
  if (!str->atom_type) { /* atoms are handled separately */
    double s_ref_count = str->header.ref_count;
    hp->str_count += 1 / s_ref_count;
    hp->str_size += ((sizeof(*str) + (str->len << str->is_wide_char) + 1 -
                      str->is_wide_char) /
                     s_ref_count);
  }
}

QJS_STATIC void compute_bytecode_size(LEPUSFunctionBytecode *b,
                                      LEPUSMemoryUsage_helper *hp) {
  int memory_used_count, lepus_func_size, i;
  double ref_count = b->header.ref_count;

  memory_used_count = 0;
  lepus_func_size = offsetof(LEPUSFunctionBytecode, debug);
  if (b->vardefs) {
    lepus_func_size += (b->arg_count + b->var_count) * sizeof(*b->vardefs);
  }
  if (b->cpool) {
    lepus_func_size += b->cpool_count * sizeof(*b->cpool);
    for (i = 0; i < b->cpool_count; i++) {
      LEPUSValueConst val = b->cpool[i];
      compute_value_size(val, hp);
    }
  }
  if (b->closure_var) {
    lepus_func_size += b->closure_var_count * sizeof(*b->closure_var);
  }
  if (!b->read_only_bytecode && b->byte_code_buf) {
    hp->lepus_func_code_size += b->byte_code_len / ref_count;
  }
  if (b->has_debug) {
    lepus_func_size += sizeof(*b) - offsetof(LEPUSFunctionBytecode, debug);
    if (b->debug.source) {
      memory_used_count++;
      lepus_func_size += b->debug.source_len + 1;
    }
    if (b->debug.pc2line_len) {
      memory_used_count++;
      hp->lepus_func_pc2line_count += 1 / ref_count;
      hp->lepus_func_pc2line_size += b->debug.pc2line_len / ref_count;
    }
  }
  hp->lepus_func_size += lepus_func_size / ref_count;
  hp->lepus_func_count += 1 / ref_count;
  hp->memory_used_count += memory_used_count / ref_count;
}

QJS_STATIC void compute_value_size(LEPUSValueConst val,
                                   LEPUSMemoryUsage_helper *hp) {
  switch (LEPUS_VALUE_GET_TAG(val)) {
    case LEPUS_TAG_STRING:
      compute_jsstring_size(LEPUS_VALUE_GET_STRING(val), hp);
      break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      compute_bytecode_size(
          static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(val)), hp);
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT:
      /* should track LEPUSBigFloat usage */
      break;
#endif
  }
}

void LEPUS_ComputeMemoryUsage(LEPUSRuntime *rt, LEPUSMemoryUsage *s) {
  struct list_head *el, *el1;
  int i;
  LEPUSMemoryUsage_helper mem = {0}, *hp = &mem;

  memset(s, 0, sizeof(*s));
  s->malloc_count = rt->malloc_state.malloc_count;
  s->malloc_size = rt->malloc_state.malloc_size;
  s->malloc_limit = rt->malloc_state.malloc_limit;

  s->memory_used_count = 2; /* rt + rt->class_array */
  s->memory_used_size =
      sizeof(LEPUSRuntime) + sizeof(LEPUSValue) * rt->class_count;

  list_for_each(el, &rt->context_list) {
    LEPUSContext *ctx = list_entry(el, LEPUSContext, link);
    LEPUSShape *sh = ctx->array_shape;
    s->memory_used_count += 2; /* ctx + ctx->class_proto */
    s->memory_used_size +=
        sizeof(LEPUSContext) + sizeof(LEPUSValue) * rt->class_count;
    s->binary_object_count += ctx->binary_object_count;
    s->binary_object_size += ctx->binary_object_size;

    /* the hashed shapes are counted separately */
    if (sh && !sh->is_hashed) {
      int hash_size = sh->prop_hash_mask + 1;
      s->shape_count++;
      s->shape_size += get_shape_size(hash_size, sh->prop_size);
    }
    list_for_each(el1, &ctx->loaded_modules) {
      LEPUSModuleDef *m = list_entry(el1, LEPUSModuleDef, link);
      s->memory_used_count += 1;
      s->memory_used_size += sizeof(*m);
      if (m->req_module_entries) {
        s->memory_used_count += 1;
        s->memory_used_size +=
            m->req_module_entries_count * sizeof(*m->req_module_entries);
      }
      if (m->export_entries) {
        s->memory_used_count += 1;
        s->memory_used_size +=
            m->export_entries_count * sizeof(*m->export_entries);
        for (i = 0; i < m->export_entries_count; i++) {
          LEPUSExportEntry *me = &m->export_entries[i];
          if (me->export_type == LEPUS_EXPORT_TYPE_LOCAL &&
              me->u.local.var_ref) {
            /* potential multiple count */
            s->memory_used_count += 1;
            compute_value_size(me->u.local.var_ref->value, hp);
          }
        }
      }
      if (m->star_export_entries) {
        s->memory_used_count += 1;
        s->memory_used_size +=
            m->star_export_entries_count * sizeof(*m->star_export_entries);
      }
      if (m->import_entries) {
        s->memory_used_count += 1;
        s->memory_used_size +=
            m->import_entries_count * sizeof(*m->import_entries);
      }
      compute_value_size(m->module_ns, hp);
      compute_value_size(m->func_obj, hp);
    }
  }
  list_for_each(el, &rt->obj_list) {
    LEPUSObject *p = list_entry(el, LEPUSObject, link);
    LEPUSShape *sh = p->shape;
    LEPUSShapeProperty *prs;
    s->obj_count++;
    if (p->prop) {
      s->memory_used_count++;
      s->prop_size += sh->prop_size * sizeof(*p->prop);
      s->prop_count += sh->prop_count;
      prs = get_shape_prop(sh);
      for (i = 0; i < sh->prop_count; i++) {
        LEPUSProperty *pr = &p->prop[i];
        if (prs->atom != LEPUS_ATOM_NULL && !(prs->flags & LEPUS_PROP_TMASK)) {
          compute_value_size(pr->u.value, hp);
        }
        prs++;
      }
    }
    /* the hashed shapes are counted separately */
    if (!sh->is_hashed) {
      int hash_size = sh->prop_hash_mask + 1;
      s->shape_count++;
      s->shape_size += get_shape_size(hash_size, sh->prop_size);
    }

    switch (p->class_id) {
      case LEPUS_CLASS_ARRAY:     /* u.array | length */
      case LEPUS_CLASS_ARGUMENTS: /* u.array | length */
        s->array_count++;
        if (p->fast_array) {
          s->fast_array_count++;
          if (p->u.array.u.values) {
            s->memory_used_count++;
            s->memory_used_size +=
                p->u.array.count * sizeof(*p->u.array.u.values);
            s->fast_array_elements += p->u.array.count;
            for (i = 0; i < p->u.array.count; i++) {
              compute_value_size(p->u.array.u.values[i], hp);
            }
          }
        }
        break;
      case LEPUS_CLASS_NUMBER:  /* u.object_data */
      case LEPUS_CLASS_STRING:  /* u.object_data */
      case LEPUS_CLASS_BOOLEAN: /* u.object_data */
      case LEPUS_CLASS_SYMBOL:  /* u.object_data */
      case LEPUS_CLASS_DATE:    /* u.object_data */
#ifdef CONFIG_BIGNUM
      case LEPUS_CLASS_BIG_INT:   /* u.object_data */
      case LEPUS_CLASS_BIG_FLOAT: /* u.object_data */
#endif
        compute_value_size(p->u.object_data, hp);
        break;
      case LEPUS_CLASS_C_FUNCTION: /* u.cfunc */
        s->c_func_count++;
        break;
      case LEPUS_CLASS_BYTECODE_FUNCTION: /* u.func */
      {
        LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
        LEPUSVarRef **var_refs = p->u.func.var_refs;
        /* home_object: object will be accounted for in list scan */
        if (var_refs) {
          s->memory_used_count++;
          s->lepus_func_size += b->closure_var_count * sizeof(*var_refs);
          for (i = 0; i < b->closure_var_count; i++) {
            if (var_refs[i]) {
              double ref_count = var_refs[i]->header.ref_count;
              s->memory_used_count += 1 / ref_count;
              s->lepus_func_size += sizeof(*var_refs[i]) / ref_count;
              /* handle non object closed values */
              if (var_refs[i]->pvalue == &var_refs[i]->value) {
                /* potential multiple count */
                compute_value_size(var_refs[i]->value, hp);
              }
            }
          }
        }
        compute_bytecode_size(b, hp);
      } break;
      case LEPUS_CLASS_BOUND_FUNCTION: /* u.bound_function */
      {
        LEPUSBoundFunction *bf = p->u.bound_function;
        /* func_obj and this_val are objects */
        for (i = 0; i < bf->argc; i++) {
          compute_value_size(bf->argv[i], hp);
        }
        s->memory_used_count += 1;
        s->memory_used_size += sizeof(*bf) + bf->argc * sizeof(*bf->argv);
      } break;
      case LEPUS_CLASS_C_FUNCTION_DATA: /* u.c_function_data_record */
      {
        LEPUSCFunctionDataRecord *fd = p->u.c_function_data_record;
        if (fd) {
          for (i = 0; i < fd->data_len; i++) {
            compute_value_size(fd->data[i], hp);
          }
          s->memory_used_count += 1;
          s->memory_used_size += sizeof(*fd) + fd->data_len * sizeof(*fd->data);
        }
      } break;
      case LEPUS_CLASS_REGEXP: /* u.regexp */
        compute_jsstring_size(p->u.regexp.pattern, hp);
        compute_jsstring_size(p->u.regexp.bytecode, hp);
        break;

      case LEPUS_CLASS_FOR_IN_ITERATOR: /* u.for_in_iterator */
      {
        LEPUSForInIterator *it = p->u.for_in_iterator;
        if (it) {
          compute_value_size(it->obj, hp);
          s->memory_used_count += 1;
          s->memory_used_size += sizeof(*it);
        }
      } break;
      case LEPUS_CLASS_ARRAY_BUFFER:        /* u.array_buffer */
      case LEPUS_CLASS_SHARED_ARRAY_BUFFER: /* u.array_buffer */
      {
        LEPUSArrayBuffer *abuf = p->u.array_buffer;
        if (abuf) {
          s->memory_used_count += 1;
          s->memory_used_size += sizeof(*abuf);
          if (abuf->data) {
            s->memory_used_count += 1;
            s->memory_used_size += abuf->byte_length;
          }
        }
      } break;
      case LEPUS_CLASS_GENERATOR:    /* u.generator_data */
      case LEPUS_CLASS_UINT8C_ARRAY: /* u.typed_array / u.array */
      case LEPUS_CLASS_INT8_ARRAY:   /* u.typed_array / u.array */
      case LEPUS_CLASS_UINT8_ARRAY:  /* u.typed_array / u.array */
      case LEPUS_CLASS_INT16_ARRAY:  /* u.typed_array / u.array */
      case LEPUS_CLASS_UINT16_ARRAY: /* u.typed_array / u.array */
      case LEPUS_CLASS_INT32_ARRAY:  /* u.typed_array / u.array */
      case LEPUS_CLASS_UINT32_ARRAY: /* u.typed_array / u.array */
#ifdef CONFIG_BIGNUM
      case LEPUS_CLASS_BIG_INT64_ARRAY:  /* u.typed_array / u.array */
      case LEPUS_CLASS_BIG_UINT64_ARRAY: /* u.typed_array / u.array */
#endif
      case LEPUS_CLASS_FLOAT32_ARRAY: /* u.typed_array / u.array */
      case LEPUS_CLASS_FLOAT64_ARRAY: /* u.typed_array / u.array */
      case LEPUS_CLASS_DATAVIEW:      /* u.typed_array */
#ifdef CONFIG_BIGNUM
      case LEPUS_CLASS_FLOAT_ENV: /* u.float_env */
#endif
      case LEPUS_CLASS_MAP:                      /* u.map_state */
      case LEPUS_CLASS_SET:                      /* u.map_state */
      case LEPUS_CLASS_WEAKMAP:                  /* u.map_state */
      case LEPUS_CLASS_WEAKSET:                  /* u.map_state */
      case LEPUS_CLASS_MAP_ITERATOR:             /* u.map_iterator_data */
      case LEPUS_CLASS_SET_ITERATOR:             /* u.map_iterator_data */
      case LEPUS_CLASS_ARRAY_ITERATOR:           /* u.array_iterator_data */
      case LEPUS_CLASS_STRING_ITERATOR:          /* u.array_iterator_data */
      case LEPUS_CLASS_PROXY:                    /* u.proxy_data */
      case LEPUS_CLASS_PROMISE:                  /* u.promise_data */
      case LEPUS_CLASS_PROMISE_RESOLVE_FUNCTION: /* u.promise_function_data */
      case LEPUS_CLASS_PROMISE_REJECT_FUNCTION:  /* u.promise_function_data */
      case LEPUS_CLASS_ASYNC_FUNCTION_RESOLVE:   /* u.async_function_data */
      case LEPUS_CLASS_ASYNC_FUNCTION_REJECT:    /* u.async_function_data */
      case LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR: /* u.async_from_sync_iterator_data
                                                  */
      case LEPUS_CLASS_ASYNC_GENERATOR:          /* u.async_generator_data */
                                                 /* TODO */
      default:
        /* XXX: class definition should have an opaque block size */
        if (p->u.opaque) {
          s->memory_used_count += 1;
        }
        break;
    }
  }
  s->obj_size += s->obj_count * sizeof(LEPUSObject);

  /* hashed shapes */
  s->memory_used_count++; /* rt->shape_hash */
  s->memory_used_size += sizeof(rt->shape_hash[0]) * rt->shape_hash_size;
  for (i = 0; i < rt->shape_hash_size; i++) {
    LEPUSShape *sh;
    for (sh = rt->shape_hash[i]; sh != NULL; sh = sh->shape_hash_next) {
      int hash_size = sh->prop_hash_mask + 1;
      s->shape_count++;
      s->shape_size += get_shape_size(hash_size, sh->prop_size);
    }
  }

  /* atoms */
  s->memory_used_count += 2; /* rt->atom_array, rt->atom_hash */
  s->atom_count = rt->atom_count;
  s->atom_size = sizeof(rt->atom_array[0]) * rt->atom_size +
                 sizeof(rt->atom_hash[0]) * rt->atom_hash_size;
  for (i = 0; i < rt->atom_size; i++) {
    LEPUSAtomStruct *p = rt->atom_array[i];
    if (!atom_is_free(p)) {
      s->atom_size +=
          (sizeof(*p) + (p->len << p->is_wide_char) + 1 - p->is_wide_char);
    }
  }
  s->str_count = round(mem.str_count);
  s->str_size = round(mem.str_size);
  s->lepus_func_count = round(mem.lepus_func_count);
  s->lepus_func_size = round(mem.lepus_func_size);
  s->lepus_func_code_size = round(mem.lepus_func_code_size);
  s->lepus_func_pc2line_count = round(mem.lepus_func_pc2line_count);
  s->lepus_func_pc2line_size = round(mem.lepus_func_pc2line_size);

  s->memory_used_count += round(mem.memory_used_count) + s->atom_count +
                          s->str_count + s->obj_count + s->shape_count +
                          s->lepus_func_count + s->lepus_func_pc2line_count;
  s->memory_used_size += s->atom_size + s->str_size + s->obj_size +
                         s->prop_size + s->shape_size + s->lepus_func_size +
                         s->lepus_func_code_size + s->lepus_func_pc2line_size;
}

void LEPUS_DumpMemoryUsage(FILE *fp, const LEPUSMemoryUsage *s,
                           LEPUSRuntime *rt) {
  fprintf(fp,
          "QuickJS memory usage -- "
#ifdef CONFIG_BIGNUM
          "BigNum "
#endif
          " %d-bit, malloc limit: %" PRId64 "\n\n",
          (int)sizeof(void *) * 8, (int64_t)(ssize_t)s->malloc_limit);
#if 1
  if (rt) {
    static const struct {
      const char *name;
      size_t size;
    } object_types[] = {
        {"LEPUSRuntime", sizeof(LEPUSRuntime)},
        {"LEPUSContext", sizeof(LEPUSContext)},
        {"LEPUSObject", sizeof(LEPUSObject)},
        {"LEPUSString", sizeof(LEPUSString)},
        {"LEPUSFunctionBytecode", sizeof(LEPUSFunctionBytecode)},
    };
    int i, usage_size_ok = 0;
    for (i = 0; i < countof(object_types); i++) {
      unsigned int size = object_types[i].size;
      void *p = lepus_malloc_rt(rt, size);
      if (p) {
        unsigned int size1 = lepus_malloc_usable_size_rt(rt, p);
        if (size1 >= size) {
          usage_size_ok = 1;
          fprintf(fp, "  %3u + %-2u  %s\n", size, size1 - size,
                  object_types[i].name);
        }
        lepus_free_rt(rt, p);
      }
    }
    if (!usage_size_ok) {
      fprintf(fp, "  malloc_usable_size unavailable\n");
    }
    {
      int obj_classes[LEPUS_CLASS_INIT_COUNT + 1] = {0};
      int class_id;
      struct list_head *el;
      list_for_each(el, &rt->obj_list) {
        LEPUSObject *p = list_entry(el, LEPUSObject, link);
        obj_classes[min_uint32(p->class_id, LEPUS_CLASS_INIT_COUNT)]++;
      }
      fprintf(fp,
              "\n"
              "LEPUSObject classes\n");
      if (obj_classes[0])
        fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[0], 0, "none");
      for (class_id = 1; class_id < LEPUS_CLASS_INIT_COUNT; class_id++) {
        if (obj_classes[class_id]) {
          char buf[ATOM_GET_STR_BUF_SIZE];
          fprintf(
              fp, "  %5d  %2.0d %s\n", obj_classes[class_id], class_id,
              LEPUS_AtomGetStrRT(rt, buf, sizeof(buf),
                                 lepus_std_class_def[class_id - 1].class_name));
        }
      }
      if (obj_classes[LEPUS_CLASS_INIT_COUNT])
        fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[LEPUS_CLASS_INIT_COUNT], 0,
                "other");
    }
    fprintf(fp, "\n");
  }
#endif
  fprintf(fp, "%-20s %8s %8s\n", "NAME", "COUNT", "SIZE");

  if (s->malloc_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per block)\n",
            "memory allocated", s->malloc_count, s->malloc_size,
            (double)s->malloc_size / s->malloc_count);
    fprintf(fp,
            "%-20s %8" PRId64 " %8" PRId64
            "  (%d overhead, %0.1f average slack)\n",
            "memory used", s->memory_used_count, s->memory_used_size,
            MALLOC_OVERHEAD,
            ((double)(s->malloc_size - s->memory_used_size) /
             s->memory_used_count));
  }
  if (s->atom_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per atom)\n", "atoms",
            s->atom_count, s->atom_size, (double)s->atom_size / s->atom_count);
  }
  if (s->str_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per string)\n",
            "strings", s->str_count, s->str_size,
            (double)s->str_size / s->str_count);
  }
  if (s->obj_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per object)\n",
            "objects", s->obj_count, s->obj_size,
            (double)s->obj_size / s->obj_count);
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per object)\n",
            "  properties", s->prop_count, s->prop_size,
            (double)s->prop_count / s->obj_count);
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per shape)\n",
            "  shapes", s->shape_count, s->shape_size,
            (double)s->shape_size / s->shape_count);
  }
  if (s->lepus_func_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "\n", "bytecode functions",
            s->lepus_func_count, s->lepus_func_size);
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per function)\n",
            "  bytecode", s->lepus_func_count, s->lepus_func_code_size,
            (double)s->lepus_func_code_size / s->lepus_func_count);
    if (s->lepus_func_pc2line_count) {
      fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per function)\n",
              "  pc2line", s->lepus_func_pc2line_count,
              s->lepus_func_pc2line_size,
              (double)s->lepus_func_pc2line_size / s->lepus_func_pc2line_count);
    }
  }
  if (s->c_func_count) {
    fprintf(fp, "%-20s %8" PRId64 "\n", "C functions", s->c_func_count);
  }
  if (s->array_count) {
    fprintf(fp, "%-20s %8" PRId64 "\n", "arrays", s->array_count);
    if (s->fast_array_count) {
      fprintf(fp, "%-20s %8" PRId64 "\n", "  fast arrays", s->fast_array_count);
      fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "  (%0.1f per fast array)\n",
              "  elements", s->fast_array_elements,
              s->fast_array_elements * (int)sizeof(LEPUSValue),
              (double)s->fast_array_elements / s->fast_array_count);
    }
  }
  if (s->binary_object_count) {
    fprintf(fp, "%-20s %8" PRId64 " %8" PRId64 "\n", "binary objects",
            s->binary_object_count, s->binary_object_size);
  }
}

#endif

LEPUSValue LEPUS_GetGlobalObject(LEPUSContext *ctx) {
  return LEPUS_DupValue(ctx, ctx->global_obj);
}

/* WARNING: obj is freed */
LEPUSValue LEPUS_Throw(LEPUSContext *ctx, LEPUSValue obj) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUS_FreeValue(ctx, rt->current_exception);
  rt->current_exception = obj;
  rt->exception_needs_backtrace = LEPUS_IsError(ctx, obj);
  if (LEPUS_IsObject(rt->current_exception) &&
      find_own_property1(LEPUS_VALUE_GET_OBJ(rt->current_exception),
                         LEPUS_ATOM_stack))
    rt->exception_needs_backtrace = FALSE;
  return LEPUS_EXCEPTION;
}

/* return the pending exception (cannot be called twice). */
LEPUSValue LEPUS_GetException(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSValue val;
  val = rt->current_exception;
  rt->current_exception = LEPUS_NULL;
  rt->exception_needs_backtrace = FALSE;
  return val;
}
#ifndef NO_QUICKJS_COMPILER
QJS_STATIC void dbuf_put_leb128(DynBuf *s, uint32_t v) {
  uint32_t a;
  for (;;) {
    a = v & 0x7f;
    v >>= 7;
    if (v != 0) {
      dbuf_putc(s, a | 0x80);
    } else {
      dbuf_putc(s, a);
      break;
    }
  }
}

QJS_STATIC void dbuf_put_sleb128(DynBuf *s, int32_t v1) {
  uint32_t v = v1;
  dbuf_put_leb128(s, (2 * v) ^ -(v >> 31));
}

// <ByteDance begin>
QJS_STATIC void dbuf_put_leb128_u64(DynBuf *s, uint64_t v) {
  uint64_t a;
  for (;;) {
    a = v & 0x7f;
    v >>= 7;
    if (v != 0) {
      dbuf_putc(s, a | 0x80);
    } else {
      dbuf_putc(s, a);
      break;
    }
  }
}

QJS_STATIC void dbuf_put_sleb128_u64(DynBuf *s, int64_t v1) {
  uint64_t v = v1;
  dbuf_put_leb128_u64(s, (2 * v) ^ -(v >> 63));
}
// <ByteDance begin>
#endif

QJS_STATIC int get_leb128(uint32_t *pval, const uint8_t *buf,
                          const uint8_t *buf_end) {
  const uint8_t *ptr = buf;
  uint32_t v, a, i;
  v = 0;
  for (i = 0; i < 5; i++) {
    if (unlikely(ptr >= buf_end)) break;
    a = *ptr++;
    v |= (a & 0x7f) << (i * 7);
    if (!(a & 0x80)) {
      *pval = v;
      return ptr - buf;
    }
  }
  *pval = 0;
  return -1;
}

QJS_STATIC int get_sleb128(int32_t *pval, const uint8_t *buf,
                           const uint8_t *buf_end) {
  int ret;
  uint32_t val;
  ret = get_leb128(&val, buf, buf_end);
  if (ret < 0) {
    *pval = 0;
    return -1;
  }
  *pval = (val >> 1) ^ -(val & 1);
  return ret;
}

// <ByteDance begin>
int get_leb128_u64(uint64_t *pval, const uint8_t *buf, const uint8_t *buf_end) {
  const uint8_t *ptr = buf;
  uint64_t v, a, i;
  v = 0;
  for (i = 0; i < 10; i++) {
    if (unlikely(ptr >= buf_end)) break;
    a = *ptr++;
    v |= (a & 0x7f) << (i * 7);
    if (!(a & 0x80)) {
      *pval = v;
      return ptr - buf;
    }
  }
  *pval = 0;
  return -1;
}

int get_sleb128_u64(int64_t *pval, const uint8_t *buf, const uint8_t *buf_end) {
  int ret;
  uint64_t val;
  ret = get_leb128_u64(&val, buf, buf_end);
  if (ret < 0) {
    *pval = 0;
    return -1;
  }
  *pval = (val >> 1) ^ -(val & 1);
  return ret;
}
// <ByteDance end>

/* <ByteDance begin> */ int64_t /* <ByteDance end> */ find_line_num(
    LEPUSContext *ctx, LEPUSFunctionBytecode *b, uint32_t pc_value) {
  const uint8_t *p_end, *p;
  // <ByteDance begin>
  int ret, pc;
  int64_t v, line_num, new_line_num;
  // <ByteDance end>

  unsigned int op;

  if (!b->has_debug || !b->debug.pc2line_buf) {
    /* function was stripped */
    return -1;
  }

  p = b->debug.pc2line_buf;
  p_end = p + b->debug.pc2line_len;
  pc = 0;
  line_num = b->debug.line_num;
  while (p < p_end) {
    op = *p++;
    if (op == 0) {
      // <ByteDance begin>
      uint64_t val;
      ret = get_leb128_u64(&val, p, p_end);
      // <ByteDance end>
      if (ret < 0) goto fail;
      pc += val;
      p += ret;
      // <ByteDance begin>
      ret = get_sleb128_u64(&v, p, p_end);
      // <ByteDance end>
      if (ret < 0) {
      fail:
        /* should never happen */
        return b->debug.line_num;
      }
      p += ret;
      new_line_num = line_num + v;
    } else {
      op -= PC2LINE_OP_FIRST;
      pc += (op / PC2LINE_RANGE);
      new_line_num = line_num + (op % PC2LINE_RANGE) + PC2LINE_BASE;
    }
    if (pc_value < pc) return line_num;
    line_num = new_line_num;
  }
  return line_num;
}

/* in order to avoid executing arbitrary code during the stack trace
   generation, we only look at simple 'name' properties containing a
   string. */
const char *get_func_name(LEPUSContext *ctx, LEPUSValueConst func) {
  LEPUSProperty *pr;
  LEPUSShapeProperty *prs;
  LEPUSValueConst val;

  if (LEPUS_VALUE_IS_NOT_OBJECT(func)) return NULL;
  prs = find_own_property(&pr, LEPUS_VALUE_GET_OBJ(func), LEPUS_ATOM_name);
  if (!prs) return NULL;
  if ((prs->flags & LEPUS_PROP_TMASK) != LEPUS_PROP_NORMAL) return NULL;
  val = pr->u.value;
  if (!LEPUS_VALUE_IS_STRING(val)) return NULL;
  return LEPUS_ToCString(ctx, val);
}

#ifdef BUILD_ASYNC_STACK
QJS_STATIC void build_async_backtrace(LEPUSContext *ctx, const uint8_t *cur_pc,
                                      DynBuf *dbuf, BOOL is_debug_mode,
                                      LEPUSValueConst error_obj);
#endif

QJS_STATIC void build_backtrace_frame(LEPUSContext *ctx, LEPUSStackFrame *sf,
                                      DynBuf *dbuf, const uint8_t *cur_pc,
                                      BOOL is_async, BOOL is_debug_mode,
                                      LEPUSValueConst error_obj) {
  LEPUSValue str;
  const char *func_name_str;
  const char *str1;
  LEPUSObject *p;

  func_name_str = get_func_name(ctx, sf->cur_func);
  if (!func_name_str || func_name_str[0] == '\0')
    str1 = "<anonymous>";
  else
    str1 = func_name_str;
  if (is_async)
    dbuf_printf(dbuf, "    at (async)%s", str1);
  else
    dbuf_printf(dbuf, "    at %s", str1);
  LEPUS_FreeCString(ctx, func_name_str);

  p = LEPUS_VALUE_GET_OBJ(sf->cur_func);
  if (p && lepus_class_has_bytecode(p->class_id)) {
    LEPUSFunctionBytecode *b;
    char atom_buf[ATOM_GET_STR_BUF_SIZE];
    // <ByteDance begin>
    int64_t line_num1;
    // <ByteDance end>
    b = p->u.func.function_bytecode;
    if (b->has_debug) {
      if (sf == ctx->rt->current_stack_frame) {
        if (!cur_pc) {
          line_num1 = b->debug.line_num;
        } else {
          line_num1 = find_line_num(ctx, b, cur_pc - b->byte_code_buf - 1);
        }
#ifdef ENABLE_QUICKJS_DEBUGGER
        // get exception line number
        if (is_debug_mode) {
          LEPUS_DefinePropertyValue(
              ctx, error_obj, LEPUS_ATOM_lineNumber,
              LEPUS_NewInt64(ctx, line_num1),
              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
        }
#endif
      } else {
        line_num1 = find_line_num(ctx, b, sf->cur_pc - b->byte_code_buf - 1);
      }
      dbuf_printf(
          dbuf, " (%s",
          LEPUS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->debug.filename));
      if (ctx->debuginfo_outside != 1 || ctx->debugger_mode) {
        // output actual line and column number
        if (line_num1 != -1) {
          // <ByteDance begin>
          int type = line_num1 >> LINE_COLUMN_TYPE_SHIFT;
          if (type == 1) {
            int line =
                line_num1 & (((uint64_t)1 << LINE_NUMBER_BITS_COUNT) - 1);
            uint64_t column =
                ((line_num1 ^ ((uint64_t)1 << 62)) >> LINE_NUMBER_BITS_COUNT);
            dbuf_printf(dbuf, ":%d:%" PRIu64, line, column);
          } else if (type == 0) {
            int line =
                line_num1 & (((uint64_t)1 << OLD_LINE_NUMBER_BITS_COUNT) - 1);
            int column = line_num1 >> OLD_LINE_NUMBER_BITS_COUNT;
            dbuf_printf(dbuf, ":%d:%d", line, column);
          } else {
            dbuf_printf(dbuf, ":-1:-1");
          }
          // <ByteDance end>
        } else {
          dbuf_printf(dbuf, ":-1:-1");
        }
      } else {
        // output function id and pc index for lynx redbox
        // To be consistent with lepus, delete '()'
        dbuf_printf(dbuf, ":%" PRIu32, b->function_id);
        if (sf == ctx->rt->current_stack_frame) {
          dbuf_printf(dbuf, ":%" PRIu32,
                      (uint32_t)(cur_pc - b->byte_code_buf - 1));
        } else {
          dbuf_printf(dbuf, ":%" PRIu32,
                      (uint32_t)(sf->cur_pc - b->byte_code_buf - 1));
        }
      }
      dbuf_putc(dbuf, ')');
    }
  } else {
    dbuf_printf(dbuf, " (native)");
  }
  dbuf_putc(dbuf, '\n');
}

#define LEPUS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL (1 << 0)

/* if filename != NULL, an additional level is added with the filename
   and line number information (used for parse error). If 'pc' !=
   NULL, it is used as the cur_pc value for the current stack frame */
void build_backtrace(
    LEPUSContext *ctx, LEPUSValueConst error_obj, const char *filename,
    /* <ByteDance begin> */ int64_t line_num, /* <ByteDance end> */
    const uint8_t *cur_pc, int backtrace_flags, uint8_t is_parse_error) {
  BOOL is_debug_mode = FALSE;
#ifdef ENABLE_QUICKJS_DEBUGGER
  is_debug_mode = ctx->debugger_mode;
#endif

  LEPUSStackFrame *sf;
  LEPUSValue str;
  DynBuf dbuf;

  ctx->rt->exception_needs_backtrace = FALSE;
  lepus_dbuf_init(ctx, &dbuf);
  if (filename) {
    dbuf_printf(&dbuf, "    at %s", filename);
    if (line_num != -1) {
      // <ByteDance begin>
      int type = line_num >> LINE_COLUMN_TYPE_SHIFT;
      if (type == 1) {
        // 64 bit line&col
        int line = line_num & (((uint64_t)1 << LINE_NUMBER_BITS_COUNT) - 1);
        uint64_t column =
            ((line_num ^ ((uint64_t)1 << 62)) >> LINE_NUMBER_BITS_COUNT);
        dbuf_printf(&dbuf, ":%d:%" PRIu64, line, column);
      } else if (type == 0) {
        // 32 bit line&col
        int line = line_num & (((uint64_t)1 << OLD_LINE_NUMBER_BITS_COUNT) - 1);
        int column = line_num >> OLD_LINE_NUMBER_BITS_COUNT;
        dbuf_printf(&dbuf, ":%d:%d", line, column);
      } else {
        dbuf_printf(&dbuf, ":-1:-1");
      }
      // <ByteDance end>
    } else {
      dbuf_printf(&dbuf, ":-1:-1");
    }
    dbuf_putc(&dbuf, '\n');
    str = LEPUS_NewString(ctx, filename);
    LEPUS_DefinePropertyValue(ctx, error_obj, LEPUS_ATOM_fileName, str,
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    LEPUS_DefinePropertyValue(ctx, error_obj, LEPUS_ATOM_lineNumber,
                              LEPUS_NewInt32(ctx, line_num),
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  }

  get_backtrace(ctx, &dbuf, is_debug_mode, error_obj, cur_pc, backtrace_flags);
#ifdef BUILD_ASYNC_STACK
  build_async_backtrace(ctx, cur_pc, &dbuf, is_debug_mode, error_obj);
#endif
  dbuf_putc(&dbuf, '\0');
  if (dbuf_error(&dbuf))
    str = LEPUS_NULL;
  else
    str = LEPUS_NewString(ctx, (char *)dbuf.buf);
  dbuf_free(&dbuf);
  LEPUS_DefinePropertyValue(ctx, error_obj, LEPUS_ATOM_stack, str,
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);

  // <bytedance begin>
// if there is an exception, debugger set system paused if necessary
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (is_debug_mode && !is_parse_error &&
      ctx->rt->debugger_callbacks_.debugger_exception) {
    ctx->rt->debugger_callbacks_.debugger_exception(ctx);
  }
#endif
  // <bytedance end>
}

QJS_STATIC void get_backtrace(LEPUSContext *ctx, DynBuf *dbuf,
                              BOOL is_debug_mode, LEPUSValueConst error_obj,
                              const uint8_t *cur_pc, int backtrace_flags) {
  LEPUSStackFrame *sf;
  const char *func_name_str;
  const char *str1;
  LEPUSObject *p;

  for (sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
    if (backtrace_flags & LEPUS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL) {
      backtrace_flags &= ~LEPUS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL;
      continue;
    }
    build_backtrace_frame(ctx, sf, dbuf, cur_pc, FALSE, is_debug_mode,
                          error_obj);
  }
}

LEPUSValue LEPUS_NewError(LEPUSContext *ctx) {
  return LEPUS_NewObjectClass(ctx, LEPUS_CLASS_ERROR);
}

QJS_STATIC LEPUSValue LEPUS_ThrowError(LEPUSContext *ctx,
                                       LEPUSErrorEnum error_num,
                                       const char *fmt, va_list ap) {
  char buf[256];
  LEPUSValue obj, ret;

  vsnprintf(buf, sizeof(buf), fmt, ap);
  obj = LEPUS_NewObjectProtoClass(ctx, ctx->native_error_proto[error_num],
                                  LEPUS_CLASS_ERROR);
  if (unlikely(LEPUS_IsException(obj))) {
    /* out of memory: throw LEPUS_NULL to avoid recursing */
    obj = LEPUS_NULL;
  } else {
    LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_message,
                              LEPUS_NewString(ctx, buf),
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  }
  ret = LEPUS_Throw(ctx, obj);
  return ret;
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowSyntaxError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = LEPUS_ThrowError(ctx, LEPUS_SYNTAX_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowTypeError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = LEPUS_ThrowError(ctx, LEPUS_TYPE_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

QJS_STATIC int __attribute__((format(printf, 3, 4)))
LEPUS_ThrowTypeErrorOrFalse(LEPUSContext *ctx, int flags, const char *fmt,
                            ...) {
  va_list ap;

  if ((flags & LEPUS_PROP_THROW) ||
      ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
    va_start(ap, fmt);
    LEPUS_ThrowError(ctx, LEPUS_TYPE_ERROR, fmt, ap);
    va_end(ap);
    return -1;
  } else {
    return FALSE;
  }
}

#ifdef LYNX_DEV
/* never use it directly */
QJS_STATIC LEPUSValue __attribute__((format(printf, 3, 4)))
__JS_ThrowTypeErrorAtom(LEPUSContext *ctx, LEPUSAtom atom, const char *fmt,
                        ...) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return LEPUS_ThrowTypeError(ctx, fmt,
                              LEPUS_AtomGetStr(ctx, buf, sizeof(buf), atom));
}

/* never use it directly */
QJS_STATIC LEPUSValue __attribute__((format(printf, 3, 4)))
__JS_ThrowSyntaxErrorAtom(LEPUSContext *ctx, LEPUSAtom atom, const char *fmt,
                          ...) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return LEPUS_ThrowSyntaxError(ctx, fmt,
                                LEPUS_AtomGetStr(ctx, buf, sizeof(buf), atom));
}

/* %s is replaced by 'atom'. The macro is used so that gcc can check
    the format string. */
#define LEPUS_ThrowTypeErrorAtom(ctx, fmt, atom) \
  __JS_ThrowTypeErrorAtom(ctx, atom, fmt, "")
#define LEPUS_ThrowSyntaxErrorAtom(ctx, fmt, atom) \
  __JS_ThrowSyntaxErrorAtom(ctx, atom, fmt, "")
#endif

int LEPUS_ThrowTypeErrorReadOnly(LEPUSContext *ctx, int flags, LEPUSAtom atom) {
  if ((flags & LEPUS_PROP_THROW) ||
      ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
#ifdef LYNX_DEV
    LEPUS_ThrowTypeErrorAtom(ctx, "'%s' is read-only", atom);
#endif
    return -1;
  } else {
    return FALSE;
  }
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowReferenceError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = LEPUS_ThrowError(ctx, LEPUS_REFERENCE_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowRangeError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = LEPUS_ThrowError(ctx, LEPUS_RANGE_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

LEPUSValue __attribute__((format(printf, 2, 3)))
LEPUS_ThrowInternalError(LEPUSContext *ctx, const char *fmt, ...) {
  LEPUSValue val;
  va_list ap;

  va_start(ap, fmt);
  val = LEPUS_ThrowError(ctx, LEPUS_INTERNAL_ERROR, fmt, ap);
  va_end(ap);
  return val;
}

LEPUSValue LEPUS_ThrowTypeErrorNotAnObject(LEPUSContext *ctx) {
  return LEPUS_ThrowTypeError(ctx, "not an object");
}

QJS_STATIC LEPUSValue LEPUS_ThrowTypeErrorNotASymbol(LEPUSContext *ctx) {
  return LEPUS_ThrowTypeError(ctx, "not a symbol");
}

LEPUSValue LEPUS_ThrowReferenceErrorNotDefined(LEPUSContext *ctx,
                                               LEPUSAtom name) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return LEPUS_ThrowReferenceError(
      ctx, "%s is not defined", LEPUS_AtomGetStr(ctx, buf, sizeof(buf), name));
}

LEPUSValue LEPUS_ThrowReferenceErrorUninitialized(LEPUSContext *ctx,
                                                  LEPUSAtom name) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return LEPUS_ThrowReferenceError(
      ctx, "%s is not initialized",
      name == LEPUS_ATOM_NULL ? "lexical variable"
                              : LEPUS_AtomGetStr(ctx, buf, sizeof(buf), name));
}

QJS_STATIC LEPUSValue LEPUS_ThrowTypeErrorInvalidClass(LEPUSContext *ctx,
                                                       int class_id) {
  LEPUSRuntime *rt = ctx->rt;
  char buf[ATOM_GET_STR_BUF_SIZE];
  LEPUSAtom name;
  name = rt->class_array[class_id].class_name;
#ifdef LYNX_DEV
  return LEPUS_ThrowTypeErrorAtom(ctx, "%s object expected", name);
#else
  return LEPUS_UNDEFINED;
#endif
}

/* return -1 (exception) or TRUE/FALSE */
int LEPUS_SetPrototypeInternal(LEPUSContext *ctx, LEPUSValueConst obj,
                               LEPUSValueConst proto_val, BOOL throw_flag) {
  LEPUSObject *proto, *p, *p1;
  LEPUSShape *sh;

  if (throw_flag) {
    if (LEPUS_VALUE_IS_NULL(obj) || LEPUS_VALUE_IS_UNDEFINED(obj)) goto not_obj;
  } else {
    if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) goto not_obj;
  }
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (LEPUS_VALUE_IS_NOT_OBJECT(proto_val)) {
    if (!LEPUS_VALUE_IS_NULL(proto_val)) {
    not_obj:
      LEPUS_ThrowTypeErrorNotAnObject(ctx);
      return -1;
    }
    proto = NULL;
  } else {
    proto = LEPUS_VALUE_GET_OBJ(proto_val);
  }

  if (throw_flag && LEPUS_VALUE_IS_NOT_OBJECT(obj)) return TRUE;

  if (unlikely(p->class_id == LEPUS_CLASS_PROXY))
    return lepus_proxy_setPrototypeOf(ctx, obj, proto_val, throw_flag);
  sh = p->shape;
  if (sh->proto == proto) return TRUE;
  if (!p->extensible) {
    if (throw_flag) {
      LEPUS_ThrowTypeError(ctx, "object is not extensible");
      return -1;
    } else {
      return FALSE;
    }
  }
  if (proto) {
    /* check if there is a cycle */
    p1 = proto;
    do {
      if (p1 == p) {
        if (throw_flag) {
          LEPUS_ThrowTypeError(ctx, "circular prototype chain");
          return -1;
        } else {
          return FALSE;
        }
      }
      /* Note: for Proxy objects, proto is NULL */
      p1 = p1->shape->proto;
    } while (p1 != NULL);
    LEPUS_DupValue(ctx, proto_val);
  }

  if (lepus_shape_prepare_update(ctx, p, NULL)) return -1;
  sh = p->shape;
  if (sh->proto) LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, sh->proto));
  sh->proto = proto;
  return TRUE;
}

/* return -1 (exception) or TRUE/FALSE */
int LEPUS_SetPrototype(LEPUSContext *ctx, LEPUSValueConst obj,
                       LEPUSValueConst proto_val) {
  return LEPUS_SetPrototypeInternal(ctx, obj, proto_val, TRUE);
}

/* Return an Object, LEPUS_NULL or LEPUS_EXCEPTION in case of Proxy object. */
LEPUSValueConst LEPUS_GetPrototype(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;

  switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
      val = ctx->class_proto[LEPUS_CLASS_BIG_INT];
      break;
    case LEPUS_TAG_INT:
      if (is_bignum_mode(ctx)) {
        val = ctx->class_proto[LEPUS_CLASS_BIG_INT];
      } else {
        val = ctx->class_proto[LEPUS_CLASS_NUMBER];
      }
      break;
    case LEPUS_TAG_FLOAT64:
      val = ctx->class_proto[LEPUS_CLASS_NUMBER];
      break;
    case LEPUS_TAG_BIG_FLOAT:
      val = ctx->class_proto[LEPUS_CLASS_BIG_FLOAT];
      break;
#else
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64:
      val = ctx->class_proto[LEPUS_CLASS_NUMBER];
      break;
#endif
    case LEPUS_TAG_BOOL:
      val = ctx->class_proto[LEPUS_CLASS_BOOLEAN];
      break;
    case LEPUS_TAG_STRING:
      val = ctx->class_proto[LEPUS_CLASS_STRING];
      break;
    case LEPUS_TAG_SYMBOL:
      val = ctx->class_proto[LEPUS_CLASS_SYMBOL];
      break;
    case LEPUS_TAG_OBJECT:
      p = LEPUS_VALUE_GET_OBJ(val);
      if (unlikely(p->class_id == LEPUS_CLASS_PROXY)) {
        val = lepus_proxy_getPrototypeOf(ctx, val);
      } else {
        p = p->shape->proto;
        if (!p)
          val = LEPUS_NULL;
        else {
          val = LEPUS_MKPTR(LEPUS_TAG_OBJECT, p);
        }
      }
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
    default:
      val = LEPUS_NULL;
      break;
  }
  return val;
}

/* return TRUE, FALSE or (-1) in case of exception */
QJS_STATIC int LEPUS_OrdinaryIsInstanceOf(LEPUSContext *ctx,
                                          LEPUSValueConst val,
                                          LEPUSValueConst obj) {
  LEPUSValue obj_proto;
  LEPUSObject *proto;
  const LEPUSObject *p, *proto1;
  BOOL ret;

  if (!LEPUS_IsFunction(ctx, obj)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (p->class_id == LEPUS_CLASS_BOUND_FUNCTION) {
    LEPUSBoundFunction *s = p->u.bound_function;
    return LEPUS_IsInstanceOf(ctx, val, s->func_obj);
  }

  /* Only explicitly boxed values are instances of constructors */
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  ret = FALSE;
  obj_proto = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_prototype);
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj_proto)) {
    if (!LEPUS_IsException(obj_proto))
      LEPUS_ThrowTypeError(ctx,
                           "operand 'prototype' property is not an object");
    ret = -1;
    goto done;
  }
  proto = LEPUS_VALUE_GET_OBJ(obj_proto);
  p = LEPUS_VALUE_GET_OBJ(val);
  for (;;) {
    proto1 = p->shape->proto;
    if (!proto1) {
      if (p->class_id == LEPUS_CLASS_PROXY) {
        LEPUSValueConst proto_val;
        proto_val = LEPUS_GetPrototype(
            ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, (LEPUSObject *)p));
        if (LEPUS_IsException(proto_val)) {
          ret = -1;
          goto done;
        }
        proto1 = LEPUS_VALUE_GET_OBJ(proto_val);
        if (!proto1) break;
      } else {
        break;
      }
    }
    p = proto1;
    if (proto == p) {
      ret = TRUE;
      break;
    }
  }
done:
  LEPUS_FreeValue(ctx, obj_proto);
  return ret;
}

/* return TRUE, FALSE or (-1) in case of exception */
int LEPUS_IsInstanceOf(LEPUSContext *ctx, LEPUSValueConst val,
                       LEPUSValueConst obj) {
  LEPUSValue method;
  // <bytedance begin>
  obj = LEPUSRef2Value(ctx, obj);
  // <bytedance end>

  if (!LEPUS_IsObject(obj)) goto fail;
  method = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_Symbol_hasInstance);
  if (LEPUS_IsException(method)) return -1;
  if (!LEPUS_IsNull(method) && !LEPUS_IsUndefined(method)) {
    LEPUSValue ret;
    ret = LEPUS_CallFree(ctx, method, obj, 1, &val);
    return LEPUS_ToBoolFree(ctx, ret);
  }

  /* legacy case */
  if (!LEPUS_IsFunction(ctx, obj)) {
  fail:
    LEPUS_ThrowTypeError(ctx, "invalid 'instanceof' right operand");
    return -1;
  }
  return LEPUS_OrdinaryIsInstanceOf(ctx, val, obj);
}

#ifdef QJS_UNITTEST
LEPUSValue GetLEPUSPropertyValue(LEPUSProperty *pr) {
  if (pr) {
    return pr->u.value;
  }
  return LEPUS_MKVAL(LEPUS_TAG_NULL, 0);
}

uint32_t GetLEPUSShapePropertyFlags(LEPUSShapeProperty *prs) {
  if (prs) {
    return prs->flags;
  }
  return 0;
}
#endif

/* return the value associated to the autoinit property or an exception */
typedef LEPUSValue LEPUSAutoInitFunc(LEPUSContext *ctx, LEPUSObject *p,
                                     LEPUSAtom atom, void *opaque);

QJS_STATIC int LEPUS_AutoInitProperty(LEPUSContext *ctx, LEPUSObject *p,
                                      LEPUSAtom prop, LEPUSProperty *pr,
                                      LEPUSShapeProperty *prs) {
  LEPUSValue val;
  LEPUSAutoInitFunc *func;

  if (lepus_shape_prepare_update(ctx, p, &prs)) return -1;
  func = pr->u.init.init_func;
  /* 'func' shall not modify the object properties 'pr' */
  val = func(ctx, p, prop, pr->u.init.opaque);
  prs->flags &= ~LEPUS_PROP_TMASK;
  pr->u.value = LEPUS_UNDEFINED;
  if (LEPUS_IsException(val)) return -1;
  pr->u.value = val;
  return 0;
}

LEPUSValue LEPUS_GetPropertyInternal(LEPUSContext *ctx, LEPUSValueConst obj,
                                     LEPUSAtom prop, LEPUSValueConst this_obj,
                                     BOOL throw_ref_error) {
  return LEPUS_GetPropertyInternalImpl(ctx, obj, prop, this_obj,
                                       throw_ref_error, NULL);
}

LEPUSValue LEPUS_GetPropertyInternalImpl(LEPUSContext *ctx, LEPUSValueConst obj,
                                         LEPUSAtom prop,
                                         LEPUSValueConst this_obj,
                                         BOOL throw_ref_error,
                                         TypeGetFeedBack *feedback) {
#ifndef ENABLE_PRIMJS_IC
  assert(feedback == nullptr);
#endif

#ifdef ENABLE_PRIMJS_IC
  LEPUSObject *o;
#endif
  LEPUSObject *p;
  LEPUSProperty *pr;
  LEPUSShapeProperty *prs;
  int64_t tag;
  char buf[ATOM_GET_STR_BUF_SIZE];

  tag = LEPUS_VALUE_GET_TAG(obj);
// <ByteDance begin>
#ifdef ENABLE_LEPUSNG
  if (tag == LEPUS_TAG_LEPUS_REF) {
    if (ctx->rt->lepus_callbacks_.get_property) {
      int idx = -1;
      if (__JS_AtomIsTaggedInt(prop)) {
        idx = __JS_AtomToUInt32(prop);
      }
      LEPUSValue ret =
          ctx->rt->lepus_callbacks_.get_property(ctx, obj, prop, idx);

      if (!LEPUS_IsUninitialized(ret)) return ret;

      // is not find? convert the obj and try to find in prototype
      obj = ctx->rt->lepus_callbacks_.convert_to_object(ctx, obj);
    }
    tag = LEPUS_VALUE_GET_TAG(obj);
  }
#endif
  // <ByteDance end>

  if (unlikely(tag != LEPUS_TAG_OBJECT)) {
    switch (tag) {
      case LEPUS_TAG_NULL:
#ifdef LYNX_DEV
        // <ByteDance begin>
        // if not in the strict mode, read properties from null will return null
        if (ctx->no_lepus_strict_mode) {
          return LEPUS_NULL;
        } else {
          return LEPUS_ThrowTypeErrorAtom(
              ctx, "cannot read property '%s' of null", prop);
        }
        // <ByteDance end>
#endif
      case LEPUS_TAG_UNDEFINED:
#ifdef LYNX_DEV
        if (ctx->no_lepus_strict_mode) {
          return LEPUS_NULL;
        } else {
          return LEPUS_ThrowTypeErrorAtom(
              ctx, "cannot read property '%s' of undefined", prop);
        }
#endif
      case LEPUS_TAG_EXCEPTION:
        return LEPUS_EXCEPTION;
      case LEPUS_TAG_STRING: {
        LEPUSString *p1 = LEPUS_VALUE_GET_STRING(obj);
        if (__JS_AtomIsTaggedInt(prop)) {
          uint32_t idx, ch;
          idx = __JS_AtomToUInt32(prop);
          if (idx < p1->len) {
            if (p1->is_wide_char)
              ch = p1->u.str16[idx];
            else
              ch = p1->u.str8[idx];
            return lepus_new_string_char(ctx, ch);
          }
        } else if (prop == LEPUS_ATOM_length) {
          return LEPUS_NewInt32(ctx, p1->len);
        }
      } break;
      // <bytedance begin>
#ifdef ENABLE_LEPUSNG
      case LEPUS_TAG_BIG_INT:
        return LEPUS_UNDEFINED;
#endif
        // <bytedance end>
      default:
        break;
    }
    /* cannot raise an exception */
    p = LEPUS_VALUE_GET_OBJ(LEPUS_GetPrototype(ctx, obj));
    if (!p) return LEPUS_UNDEFINED;
  } else {
    p = LEPUS_VALUE_GET_OBJ(obj);
  }

#ifdef ENABLE_PRIMJS_IC
  uint32_t proto_depth = 0;
  o = p;
  intptr_t offset = 0;
#endif

  for (;;) {
#ifdef ENABLE_PRIMJS_IC
    prs = find_own_property_with_ic(&pr, p, prop, &offset);
#else
    prs = find_own_property(&pr, p, prop);
#endif
    if (prs) {
      /* found */
      if (unlikely(prs->flags & LEPUS_PROP_TMASK)) {
        if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
          if (unlikely(!pr->u.getset.getter)) {
            return LEPUS_UNDEFINED;
          } else {
            LEPUSValue func =
                LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter);
            /* Note: the field could be removed in the getter */
            func = LEPUS_DupValue(ctx, func);
            return LEPUS_CallFree(ctx, func, this_obj, 0, NULL);
          }
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          LEPUSValue val = *pr->u.var_ref->pvalue;
          if (unlikely(LEPUS_IsUninitialized(val)))
            return LEPUS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
          return LEPUS_DupValue(ctx, val);
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
          /* Instantiate property and retry */
          if (LEPUS_AutoInitProperty(ctx, p, prop, pr, prs))
            return LEPUS_EXCEPTION;
          continue;
        }
      } else {
#ifdef ENABLE_PRIMJS_IC
        if (feedback && o->shape->is_hashed) {
          if (proto_depth == 0) {
            lepus_free_shape_null(ctx->rt, feedback->shape);
            feedback->shape = lepus_dup_shape(o->shape);
            lepus_free_shape_null(ctx->rt, feedback->proto_shape);
            feedback->proto_shape = NULL;
            feedback->offset = offset;
          }  // if proto add proto_shape
          else if (proto_depth == 1 && p->shape->is_hashed) {
            lepus_free_shape_null(ctx->rt, feedback->shape);
            feedback->shape = lepus_dup_shape(o->shape);
            lepus_free_shape_null(ctx->rt, feedback->proto_shape);
            feedback->proto_shape = lepus_dup_shape(p->shape);
            feedback->offset = offset;
          }
        }
#endif
        return LEPUS_DupValue(ctx, pr->u.value);
      }
    }
    if (unlikely(p->is_exotic)) {
      /* exotic behaviors */
      if (p->fast_array) {
        if (__JS_AtomIsTaggedInt(prop)) {
          uint32_t idx = __JS_AtomToUInt32(prop);
          if (idx < p->u.array.count) {
            /* we avoid duplicating the code */
            return LEPUS_GetPropertyUint32(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), idx);
          } else if (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
                     p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
            goto typed_array_oob;
          }
        } else if (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
                   p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
          int ret;
          ret = LEPUS_AtomIsNumericIndex(ctx, prop);
          if (ret != 0) {
            if (ret < 0) return LEPUS_EXCEPTION;
          typed_array_oob:
            /* when array is detached, return undefined */
            return LEPUS_UNDEFINED;
          }
        }
      } else {
        const LEPUSClassExoticMethods *em =
            ctx->rt->class_array[p->class_id].exotic;
        if (em) {
          if (em->get_property) {
            /* XXX: should pass throw_ref_error */
            return em->get_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), prop,
                                    this_obj);
          }
          if (em->get_own_property) {
            LEPUSPropertyDescriptor desc;
            int ret;

            ret = em->get_own_property(ctx, &desc,
                                       LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), prop);
            if (ret < 0) return LEPUS_EXCEPTION;
            if (ret) {
              if (desc.flags & LEPUS_PROP_GETSET) {
                LEPUS_FreeValue(ctx, desc.setter);
                return LEPUS_CallFree(ctx, desc.getter, this_obj, 0, NULL);
              } else {
                return desc.value;
              }
            }
          }
        }
      }
    }
    p = p->shape->proto;
#ifdef ENABLE_PRIMJS_IC
    proto_depth++;
#endif
    if (!p) break;
  }
  if (unlikely(throw_ref_error)) {
    return LEPUS_ThrowReferenceErrorNotDefined(ctx, prop);
  } else {
    return LEPUS_UNDEFINED;
  }
}
// <primjs begin>
#ifdef ENABLE_PRIMJS_IC
LEPUSValue LEPUS_GetPropertyWithIC(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                   LEPUSAtom prop,
                                   TypeGetFeedBack *feedback_vec) {
  PRIM_LOG("primjs get_field %s, this_obj: %p\n",
           LEPUS_AtomToCString(ctx, prop), this_obj.ptr);

  TypeGetFeedBack *feedback = NULL;
  if (LEPUS_VALUE_IS_OBJECT(this_obj)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_obj);
    for (int i = 0; i < DEFAULT_FEEDBACK_SIZE; i++) {
      feedback = &feedback_vec[i];
      if (!feedback->shape) {
        break;
      }
      if (feedback->shape == p->shape) {
        if (!feedback->proto_shape) {
          LEPUSProperty *pr = &p->prop[feedback->offset];
          return LEPUS_DupValue(ctx, pr->u.value);
        } else {
          /* Special Situation
          Lookup first as prototype
          a.__proto__ = {'b':1}
          a.b = 2
          Should invalidate inline cache */
          LEPUSProperty *pr = &p->shape->proto->prop[feedback->offset];
          return LEPUS_DupValue(ctx, pr->u.value);
        }
      }
    }
  }
  return LEPUS_GetPropertyInternalImpl(ctx, this_obj, prop, this_obj, 0,
                                       feedback);
}
#endif
// <primjs end>

QJS_STATIC LEPUSValue LEPUS_ThrowTypeErrorPrivateNotFound(LEPUSContext *ctx,
                                                          LEPUSAtom atom) {
#ifdef LYNX_DEV
  return LEPUS_ThrowTypeErrorAtom(
      ctx, "private class field '%s' does not exist", atom);
#else
  return LEPUS_UNDEFINED;
#endif
}

/* Private fields can be added even on non extensible objects or
   Proxies */
int LEPUS_DefinePrivateField(LEPUSContext *ctx, LEPUSValueConst obj,
                             LEPUSValueConst name, LEPUSValue val) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  LEPUSAtom prop;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) {
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    goto fail;
  }
  /* safety check */
  if (unlikely(!LEPUS_VALUE_IS_SYMBOL(name))) {
    LEPUS_ThrowTypeErrorNotASymbol(ctx);
    goto fail;
  }
  prop = lepus_symbol_to_atom(ctx, (LEPUSValue)name);
  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property(&pr, p, prop);
  if (prs) {
#ifdef LYNX_DEV
    LEPUS_ThrowTypeErrorAtom(ctx, "private class field '%s' already exists",
                             prop);
#endif
    goto fail;
  }
  pr = add_property(ctx, p, prop, LEPUS_PROP_C_W_E);
  if (unlikely(!pr)) {
  fail:
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  pr->u.value = val;
  return 0;
}

LEPUSValue LEPUS_GetPrivateField(LEPUSContext *ctx, LEPUSValueConst obj,
                                 LEPUSValueConst name) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  LEPUSAtom prop;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj)))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  /* safety check */
  if (unlikely(!LEPUS_VALUE_IS_SYMBOL(name)))
    return LEPUS_ThrowTypeErrorNotASymbol(ctx);
  prop = lepus_symbol_to_atom(ctx, (LEPUSValue)name);
  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property(&pr, p, prop);
  if (!prs) {
    LEPUS_ThrowTypeErrorPrivateNotFound(ctx, prop);
    return LEPUS_EXCEPTION;
  }
  return LEPUS_DupValue(ctx, pr->u.value);
}

int LEPUS_SetPrivateField(LEPUSContext *ctx, LEPUSValueConst obj,
                          LEPUSValueConst name, LEPUSValue val) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  LEPUSAtom prop;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) {
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    goto fail;
  }
  /* safety check */
  if (unlikely(!LEPUS_VALUE_IS_SYMBOL(name))) {
    LEPUS_ThrowTypeErrorNotASymbol(ctx);
    goto fail;
  }
  prop = lepus_symbol_to_atom(ctx, (LEPUSValue)name);
  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property(&pr, p, prop);
  if (!prs) {
    LEPUS_ThrowTypeErrorPrivateNotFound(ctx, prop);
  fail:
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  set_value(ctx, &pr->u.value, val);
  return 0;
}

int LEPUS_AddBrand(LEPUSContext *ctx, LEPUSValueConst obj,
                   LEPUSValueConst home_obj) {
  LEPUSObject *p, *p1;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  LEPUSValue brand;
  LEPUSAtom brand_atom;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(home_obj))) {
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  p = LEPUS_VALUE_GET_OBJ(home_obj);
  prs = find_own_property(&pr, p, LEPUS_ATOM_Private_brand);
  if (!prs) {
    brand =
        LEPUS_NewSymbolFromAtom(ctx, LEPUS_ATOM_brand, LEPUS_ATOM_TYPE_PRIVATE);
    if (LEPUS_IsException(brand)) return -1;
    /* if the brand is not present, add it */
    pr = add_property(ctx, p, LEPUS_ATOM_Private_brand, LEPUS_PROP_C_W_E);
    if (!pr) {
      LEPUS_FreeValue(ctx, brand);
      return -1;
    }
    pr->u.value = LEPUS_DupValue(ctx, brand);
  } else {
    brand = LEPUS_DupValue(ctx, pr->u.value);
  }
  brand_atom = lepus_symbol_to_atom(ctx, brand);

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) {
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    LEPUS_FreeAtom(ctx, brand_atom);
    return -1;
  }
  p1 = LEPUS_VALUE_GET_OBJ(obj);
  pr = add_property(ctx, p1, brand_atom, LEPUS_PROP_C_W_E);
  LEPUS_FreeAtom(ctx, brand_atom);
  if (!pr) return -1;
  pr->u.value = LEPUS_UNDEFINED;
  return 0;
}

int LEPUS_CheckBrand(LEPUSContext *ctx, LEPUSValueConst obj,
                     LEPUSValueConst func) {
  LEPUSObject *p, *p1, *home_obj;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  LEPUSValueConst brand;

  /* get the home object of 'func' */
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(func))) {
  not_obj:
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  p1 = LEPUS_VALUE_GET_OBJ(func);
  if (!lepus_class_has_bytecode(p1->class_id)) goto not_obj;
  home_obj = p1->u.func.home_object;
  if (!home_obj) goto not_obj;
  prs = find_own_property(&pr, home_obj, LEPUS_ATOM_Private_brand);
  if (!prs) {
    LEPUS_ThrowTypeError(ctx, "expecting <brand> private field");
    return -1;
  }
  brand = pr->u.value;
  /* safety check */
  if (unlikely(!LEPUS_VALUE_IS_SYMBOL(brand))) goto not_obj;

  /* get the brand array of 'obj' */
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) goto not_obj;
  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property(&pr, p, lepus_symbol_to_atom(ctx, (LEPUSValue)brand));
  if (!prs) {
    LEPUS_ThrowTypeError(ctx, "invalid brand on object");
    return -1;
  }
  return 0;
}

QJS_STATIC int num_keys_cmp(const void *p1, const void *p2, void *opaque) {
  LEPUSContext *ctx = static_cast<LEPUSContext *>(opaque);
  LEPUSAtom atom1 = ((const LEPUSPropertyEnum *)p1)->atom;
  LEPUSAtom atom2 = ((const LEPUSPropertyEnum *)p2)->atom;
  uint32_t v1, v2;
  BOOL atom1_is_integer, atom2_is_integer;

  atom1_is_integer = LEPUS_AtomIsArrayIndex(ctx, &v1, atom1);
  atom2_is_integer = LEPUS_AtomIsArrayIndex(ctx, &v2, atom2);
  assert(atom1_is_integer && atom2_is_integer);
  if (v1 < v2)
    return -1;
  else if (v1 == v2)
    return 0;
  else
    return 1;
}

QJS_STATIC void lepus_free_prop_enum(LEPUSContext *ctx, LEPUSPropertyEnum *tab,
                                     uint32_t len) {
  uint32_t i;
  if (tab) {
    for (i = 0; i < len; i++) LEPUS_FreeAtom(ctx, tab[i].atom);
    lepus_free(ctx, tab);
  }
}

/* return < 0 in case if exception, 0 if OK. ptab and its atoms must
   be freed by the user. */
QJS_STATIC int __exception
LEPUS_GetOwnPropertyNamesInternal(LEPUSContext *ctx, LEPUSPropertyEnum **ptab,
                                  uint32_t *plen, LEPUSObject *p, int flags) {
  int i, j;
  LEPUSShape *sh;
  LEPUSShapeProperty *prs;
  LEPUSPropertyEnum *tab_atom, *tab_exotic;
  LEPUSAtom atom;
  uint32_t num_keys_count, str_keys_count, sym_keys_count, atom_count;
  uint32_t num_index, str_index, sym_index, exotic_count;
  BOOL is_enumerable, num_sorted;
  uint32_t num_key;
  LEPUSAtomKindEnum kind;

  /* clear pointer for consistency in case of failure */
  *ptab = NULL;
  *plen = 0;

  /* compute the number of returned properties */
  num_keys_count = 0;
  str_keys_count = 0;
  sym_keys_count = 0;
  exotic_count = 0;
  tab_exotic = NULL;
  sh = p->shape;
  for (i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
    atom = prs->atom;
    if (atom != LEPUS_ATOM_NULL) {
      is_enumerable = ((prs->flags & LEPUS_PROP_ENUMERABLE) != 0);
      kind = LEPUS_AtomGetKind(ctx, atom);
      if ((!(flags & LEPUS_GPN_ENUM_ONLY) || is_enumerable) &&
          ((flags >> kind) & 1) != 0) {
        /* need to raise an exception in case of the module
           name space (implicit GetOwnProperty) */
        if (unlikely((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) &&
            (flags & (LEPUS_GPN_SET_ENUM | LEPUS_GPN_ENUM_ONLY))) {
          LEPUSVarRef *var_ref = p->prop[i].u.var_ref;
          if (unlikely(LEPUS_IsUninitialized(*var_ref->pvalue))) {
            LEPUS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
            return -1;
          }
        }
        if (LEPUS_AtomIsArrayIndex(ctx, &num_key, atom)) {
          num_keys_count++;
        } else if (kind == LEPUS_ATOM_KIND_STRING) {
          str_keys_count++;
        } else {
          sym_keys_count++;
        }
      }
    }
  }

  if (p->is_exotic) {
    if (p->fast_array) {
      /* the implicit GetOwnProperty raises an exception if the
         typed array is detached */
      if ((flags & (LEPUS_GPN_SET_ENUM | LEPUS_GPN_ENUM_ONLY)) &&
          (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
           p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) &&
          typed_array_is_detached(ctx, p) &&
          typed_array_get_length(ctx, p) != 0) {
        LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        return -1;
      }
      num_keys_count += p->u.array.count;
    } else {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->get_own_property_names) {
        if (em->get_own_property_names(ctx, &tab_exotic, &exotic_count,
                                       LEPUS_MKPTR(LEPUS_TAG_OBJECT, p)))
          return -1;
        for (i = 0; i < exotic_count; i++) {
          atom = tab_exotic[i].atom;
          kind = LEPUS_AtomGetKind(ctx, atom);
          if (((flags >> kind) & 1) != 0) {
            is_enumerable = FALSE;
            if (flags & (LEPUS_GPN_SET_ENUM | LEPUS_GPN_ENUM_ONLY)) {
              LEPUSPropertyDescriptor desc;
              int res;
              /* set the "is_enumerable" field if necessary */
              res = LEPUS_GetOwnPropertyInternal(ctx, &desc, p, atom);
              if (res < 0) {
                lepus_free_prop_enum(ctx, tab_exotic, exotic_count);
                return -1;
              }
              if (res) {
                is_enumerable = ((desc.flags & LEPUS_PROP_ENUMERABLE) != 0);
                lepus_free_desc(ctx, &desc);
              }
              tab_exotic[i].is_enumerable = is_enumerable;
            }
            if (!(flags & LEPUS_GPN_ENUM_ONLY) || is_enumerable) {
              if (LEPUS_AtomIsArrayIndex(ctx, &num_key, atom)) {
                num_keys_count++;
              } else if (kind == LEPUS_ATOM_KIND_STRING) {
                str_keys_count++;
              } else {
                sym_keys_count++;
              }
            }
          }
        }
      }
    }
  }

  /* fill them */

  atom_count = num_keys_count + str_keys_count + sym_keys_count;
  /* avoid allocating 0 bytes */
  tab_atom = static_cast<LEPUSPropertyEnum *>(
      lepus_malloc(ctx, sizeof(tab_atom[0]) * max_int(atom_count, 1)));
  if (!tab_atom) {
    lepus_free_prop_enum(ctx, tab_exotic, exotic_count);
    return -1;
  }

  num_index = 0;
  str_index = num_keys_count;
  sym_index = str_index + str_keys_count;

  num_sorted = TRUE;
  sh = p->shape;
  for (i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
    atom = prs->atom;
    if (atom != LEPUS_ATOM_NULL) {
      is_enumerable = ((prs->flags & LEPUS_PROP_ENUMERABLE) != 0);
      kind = LEPUS_AtomGetKind(ctx, atom);
      if ((!(flags & LEPUS_GPN_ENUM_ONLY) || is_enumerable) &&
          ((flags >> kind) & 1) != 0) {
        if (LEPUS_AtomIsArrayIndex(ctx, &num_key, atom)) {
          j = num_index++;
          num_sorted = FALSE;
        } else if (kind == LEPUS_ATOM_KIND_STRING) {
          j = str_index++;
        } else {
          j = sym_index++;
        }
        tab_atom[j].atom = LEPUS_DupAtom(ctx, atom);
        tab_atom[j].is_enumerable = is_enumerable;
      }
    }
  }

  if (p->is_exotic) {
    if (p->fast_array) {
      for (i = 0; i < p->u.array.count; i++) {
        tab_atom[num_index].atom = __JS_AtomFromUInt32(i);
        if (tab_atom[num_index].atom == LEPUS_ATOM_NULL) {
          lepus_free_prop_enum(ctx, tab_exotic, exotic_count);
          lepus_free_prop_enum(ctx, tab_atom, num_index);
          return -1;
        }
        tab_atom[num_index].is_enumerable = TRUE;
        num_index++;
      }
    }
    if (exotic_count > 0) {
      for (i = 0; i < exotic_count; i++) {
        atom = tab_exotic[i].atom;
        is_enumerable = tab_exotic[i].is_enumerable;
        kind = LEPUS_AtomGetKind(ctx, atom);
        if ((!(flags & LEPUS_GPN_ENUM_ONLY) || is_enumerable) &&
            ((flags >> kind) & 1) != 0) {
          if (LEPUS_AtomIsArrayIndex(ctx, &num_key, atom)) {
            j = num_index++;
            num_sorted = FALSE;
          } else if (kind == LEPUS_ATOM_KIND_STRING) {
            j = str_index++;
          } else {
            j = sym_index++;
          }
          tab_atom[j].atom = atom;
          tab_atom[j].is_enumerable = is_enumerable;
        } else {
          LEPUS_FreeAtom(ctx, atom);
        }
      }
    }
    lepus_free(ctx, tab_exotic);
  }

  assert(num_index == num_keys_count);
  assert(str_index == num_keys_count + str_keys_count);
  assert(sym_index == atom_count);

  if (num_keys_count != 0 && !num_sorted) {
    rqsort(tab_atom, num_keys_count, sizeof(tab_atom[0]), num_keys_cmp, ctx);
  }
  *ptab = tab_atom;
  *plen = atom_count;
  return 0;
}

int LEPUS_GetOwnPropertyNames(LEPUSContext *ctx, LEPUSPropertyEnum **ptab,
                              uint32_t *plen, LEPUSValueConst obj, int flags) {
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  return LEPUS_GetOwnPropertyNamesInternal(ctx, ptab, plen,
                                           LEPUS_VALUE_GET_OBJ(obj), flags);
}

/* Return -1 if exception,
   FALSE if the property does not exist, TRUE if it exists. If TRUE is
   returned, the property descriptor 'desc' is filled present. */
QJS_STATIC int LEPUS_GetOwnPropertyInternal(LEPUSContext *ctx,
                                            LEPUSPropertyDescriptor *desc,
                                            LEPUSObject *p, LEPUSAtom prop) {
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;

retry:
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    if (desc) {
      desc->flags = prs->flags & LEPUS_PROP_C_W_E;
      desc->getter = LEPUS_UNDEFINED;
      desc->setter = LEPUS_UNDEFINED;
      desc->value = LEPUS_UNDEFINED;
      if (unlikely(prs->flags & LEPUS_PROP_TMASK)) {
        if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
          desc->flags |= LEPUS_PROP_GETSET;
          if (pr->u.getset.getter)
            desc->getter = LEPUS_DupValue(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
          if (pr->u.getset.setter)
            desc->setter = LEPUS_DupValue(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          LEPUSValue val = *pr->u.var_ref->pvalue;
          if (unlikely(LEPUS_IsUninitialized(val))) {
            LEPUS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
            return -1;
          }
          desc->value = LEPUS_DupValue(ctx, val);
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
          /* Instantiate property and retry */
          if (LEPUS_AutoInitProperty(ctx, p, prop, pr, prs)) return -1;
          goto retry;
        }
      } else {
        desc->value = LEPUS_DupValue(ctx, pr->u.value);
      }
    } else {
      /* for consistency, send the exception even if desc is NULL */
      if (unlikely((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF)) {
        if (unlikely(LEPUS_IsUninitialized(*pr->u.var_ref->pvalue))) {
          LEPUS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
          return -1;
        }
      } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
        /* nothing to do: delay instantiation until actual value and/or
         * attributes are read */
      }
    }
    return TRUE;
  }
  if (p->is_exotic) {
    if (p->fast_array) {
      /* specific case for fast arrays */
      if (__JS_AtomIsTaggedInt(prop)) {
        uint32_t idx;
        idx = __JS_AtomToUInt32(prop);
        if (idx < p->u.array.count) {
          if (desc) {
            desc->flags = LEPUS_PROP_WRITABLE | LEPUS_PROP_ENUMERABLE;
            if (p->class_id == LEPUS_CLASS_ARRAY ||
                p->class_id == LEPUS_CLASS_ARGUMENTS)
              desc->flags |= LEPUS_PROP_CONFIGURABLE;
            desc->getter = LEPUS_UNDEFINED;
            desc->setter = LEPUS_UNDEFINED;
            desc->value = LEPUS_GetPropertyUint32(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), idx);
          }
          return TRUE;
        }
      }
      /* 10.4.5.9: If IsDetachedBuffer(O.[[ViewedArrayBuffer]]) is true, return
       * false.*/
      // if (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
      //     p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
      //   int ret;
      //   ret = LEPUS_AtomIsNumericIndex(ctx, prop);
      //   if (ret != 0) {
      //     if (ret < 0) return -1;
      //     if (typed_array_is_detached(ctx, p)) {
      //       LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
      //       return -1;
      //     }
      //   }
      // }
    } else {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->get_own_property) {
        return em->get_own_property(ctx, desc, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p),
                                    prop);
      }
    }
  }
  return FALSE;
}

int LEPUS_GetOwnProperty(LEPUSContext *ctx, LEPUSPropertyDescriptor *desc,
                         LEPUSValueConst obj, LEPUSAtom prop) {
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  return LEPUS_GetOwnPropertyInternal(ctx, desc, LEPUS_VALUE_GET_OBJ(obj),
                                      prop);
}

/* return -1 if exception (Proxy object only) or TRUE/FALSE */
int LEPUS_IsExtensible(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSObject *p;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (unlikely(p->class_id == LEPUS_CLASS_PROXY))
    return lepus_proxy_isExtensible(ctx, obj);
  else
    return p->extensible;
}

/* return -1 if exception (Proxy object only) or TRUE/FALSE */
int LEPUS_PreventExtensions(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSObject *p;

  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (unlikely(p->class_id == LEPUS_CLASS_PROXY))
    return lepus_proxy_preventExtensions(ctx, obj);
  p->extensible = FALSE;
  return TRUE;
}

/* return -1 if exception otherwise TRUE or FALSE */
int LEPUS_HasProperty(LEPUSContext *ctx, LEPUSValueConst obj, LEPUSAtom prop) {
  LEPUSObject *p;
  int ret;
  // <bytedance begin>
  obj = LEPUSRef2Value(ctx, obj);
  // <bytedance end>
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(obj))) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(obj);
  for (;;) {
    if (p->is_exotic) {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->has_property)
        return em->has_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), prop);
    }
    ret = LEPUS_GetOwnPropertyInternal(ctx, NULL, p, prop);
    if (ret != 0) return ret;
    if (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
        p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
      ret = LEPUS_AtomIsNumericIndex(ctx, prop);
      if (ret != 0) {
        if (ret < 0) return -1;
        /* the detached array test was done in
           LEPUS_GetOwnPropertyInternal() */
        return FALSE;
      }
    }
    p = p->shape->proto;
    if (!p) break;
  }
  return FALSE;
}

/* val must be a symbol */
QJS_HIDE LEPUSAtom lepus_symbol_to_atom(LEPUSContext *ctx, LEPUSValue val) {
  LEPUSAtomStruct *p = static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
  return lepus_get_atom_index(ctx->rt, p);
}

/* return LEPUS_ATOM_NULL in case of exception */
LEPUSAtom lepus_value_to_atom(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSAtom atom;
  if (LEPUS_VALUE_IS_INT(val) &&
      (uint32_t)LEPUS_VALUE_GET_INT(val) <= LEPUS_ATOM_MAX_INT) {
    /* fast path for integer values */
    atom = __JS_AtomFromUInt32(LEPUS_VALUE_GET_INT(val));
  } else if (LEPUS_VALUE_IS_SYMBOL(val)) {
    LEPUSAtomStruct *p =
        static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
    atom = LEPUS_DupAtom(ctx, lepus_get_atom_index(ctx->rt, p));
  } else {
    LEPUSValue str;
    str = LEPUS_ToPropertyKey(ctx, val);
    if (LEPUS_IsException(str)) return LEPUS_ATOM_NULL;
    if (LEPUS_VALUE_IS_SYMBOL(str)) {
      atom = lepus_symbol_to_atom(ctx, str);
    } else {
      atom = LEPUS_NewAtomStr(ctx, LEPUS_VALUE_GET_STRING(str));
    }
  }
  return atom;
}

LEPUSValue LEPUS_GetPropertyValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                  LEPUSValue prop) {
  LEPUSAtom atom;
  LEPUSValue ret;

  if (likely(LEPUS_VALUE_IS_OBJECT(this_obj) && LEPUS_VALUE_IS_INT(prop))) {
    LEPUSObject *p;
    uint32_t idx, len;
    /* fast path for array access */
    p = LEPUS_VALUE_GET_OBJ(this_obj);
    idx = LEPUS_VALUE_GET_INT(prop);
    len = (uint32_t)p->u.array.count;
    if (unlikely(idx >= len)) goto slow_path;
    switch (p->class_id) {
      case LEPUS_CLASS_ARRAY:
      case LEPUS_CLASS_ARGUMENTS:
        return LEPUS_DupValue(ctx, p->u.array.u.values[idx]);
      case LEPUS_CLASS_INT8_ARRAY:
        return LEPUS_NewInt32(ctx, p->u.array.u.int8_ptr[idx]);
      case LEPUS_CLASS_UINT8C_ARRAY:
      case LEPUS_CLASS_UINT8_ARRAY:
        return LEPUS_NewInt32(ctx, p->u.array.u.uint8_ptr[idx]);
      case LEPUS_CLASS_INT16_ARRAY:
        return LEPUS_NewInt32(ctx, p->u.array.u.int16_ptr[idx]);
      case LEPUS_CLASS_UINT16_ARRAY:
        return LEPUS_NewInt32(ctx, p->u.array.u.uint16_ptr[idx]);
      case LEPUS_CLASS_INT32_ARRAY:
        return LEPUS_NewInt32(ctx, p->u.array.u.int32_ptr[idx]);
      case LEPUS_CLASS_UINT32_ARRAY:
        return LEPUS_NewUint32(ctx, p->u.array.u.uint32_ptr[idx]);
#ifdef CONFIG_BIGNUM
      case LEPUS_CLASS_BIG_INT64_ARRAY:
        return LEPUS_NewBigInt64(ctx, p->u.array.u.int64_ptr[idx]);
      case LEPUS_CLASS_BIG_UINT64_ARRAY:
        return LEPUS_NewBigUint64(ctx, p->u.array.u.uint64_ptr[idx]);
#endif
      case LEPUS_CLASS_FLOAT32_ARRAY:
        return __JS_NewFloat64(ctx, p->u.array.u.float_ptr[idx]);
      case LEPUS_CLASS_FLOAT64_ARRAY:
        return __JS_NewFloat64(ctx, p->u.array.u.double_ptr[idx]);
      default:
        goto slow_path;
    }
  } else {
  slow_path:
    atom = lepus_value_to_atom(ctx, prop);
    LEPUS_FreeValue(ctx, prop);
    if (unlikely(atom == LEPUS_ATOM_NULL)) return LEPUS_EXCEPTION;
    ret = LEPUS_GetProperty(ctx, this_obj, atom);
    LEPUS_FreeAtom(ctx, atom);
    return ret;
  }
}

LEPUSValue LEPUS_GetPropertyUint32(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                   uint32_t idx) {
  return LEPUS_GetPropertyValue(ctx, this_obj, LEPUS_NewUint32(ctx, idx));
}

/* Check if an object has a generalized numeric property. Return value:
   -1 for exception,
   TRUE if property exists, stored into *pval,
   FALSE if proprty does not exist.
 */
QJS_STATIC int LEPUS_TryGetPropertyInt64(LEPUSContext *ctx, LEPUSValueConst obj,
                                         int64_t idx, LEPUSValue *pval) {
  LEPUSValue val = LEPUS_UNDEFINED;
  LEPUSAtom prop;
  int present;

  if (likely((uint64_t)idx <= LEPUS_ATOM_MAX_INT)) {
    /* fast path */
    present = LEPUS_HasProperty(ctx, obj, __JS_AtomFromUInt32(idx));
    if (present > 0) {
      val = LEPUS_GetPropertyValue(ctx, obj, LEPUS_NewInt32(ctx, idx));
      if (unlikely(LEPUS_IsException(val))) present = -1;
    }
  } else {
    prop = LEPUS_NewAtomInt64(ctx, idx);
    present = -1;
    if (likely(prop != LEPUS_ATOM_NULL)) {
      present = LEPUS_HasProperty(ctx, obj, prop);
      if (present > 0) {
        val = LEPUS_GetProperty(ctx, obj, prop);
        if (unlikely(LEPUS_IsException(val))) present = -1;
      }
      LEPUS_FreeAtom(ctx, prop);
    }
  }
  *pval = val;
  return present;
}

QJS_STATIC LEPUSValue LEPUS_GetPropertyInt64(LEPUSContext *ctx,
                                             LEPUSValueConst obj, int64_t idx) {
  LEPUSAtom prop;
  LEPUSValue val;

  if ((uint64_t)idx <= INT32_MAX) {
    /* fast path for fast arrays */
    return LEPUS_GetPropertyValue(ctx, obj, LEPUS_NewInt32(ctx, idx));
  }
  prop = LEPUS_NewAtomInt64(ctx, idx);
  if (prop == LEPUS_ATOM_NULL) return LEPUS_EXCEPTION;

  val = LEPUS_GetProperty(ctx, obj, prop);
  LEPUS_FreeAtom(ctx, prop);
  return val;
}

LEPUSValue LEPUS_GetPropertyStr(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                const char *prop) {
  LEPUSAtom atom;
  LEPUSValue ret;
  atom = LEPUS_NewAtom(ctx, prop);
  ret = LEPUS_GetProperty(ctx, this_obj, atom);
  LEPUS_FreeAtom(ctx, atom);
  return ret;
}

// <primjs begin>
/*
    Attention: LEPUSTypeSetFeedBack will ref LEPUSShape
    Need Free in lepus_free_function_bytecode
*/
#ifdef ENABLE_PRIMJS_IC
static LEPUSProperty *add_property_with_ic(LEPUSContext *ctx, LEPUSObject *p,
                                           LEPUSAtom prop, int prop_flags,
                                           TypeSetFeedBack *feedback) {
  LEPUSShape *sh, *new_sh;

  sh = p->shape;

  lepus_free_shape_null(ctx->rt, feedback->old_shape);
  feedback->old_shape = lepus_dup_shape(p->shape);

  if (sh->is_hashed) {
    /* try to find an existing shape */
    new_sh = find_hashed_shape_prop(ctx->rt, sh, prop, prop_flags);
    if (new_sh) {
      /* matching shape found: use it */
      /*  the property array may need to be resized */
      if (new_sh->prop_size != sh->prop_size) {
        LEPUSProperty *new_prop;
        new_prop = (LEPUSProperty *)lepus_realloc(
            ctx, p->prop, sizeof(p->prop[0]) * new_sh->prop_size);
        if (!new_prop) return NULL;
        p->prop = new_prop;
      }
      p->shape = lepus_dup_shape(new_sh);
      lepus_free_shape(ctx->rt, sh);

      lepus_free_shape_null(ctx->rt, feedback->new_shape);
      feedback->new_shape = lepus_dup_shape(new_sh);
      feedback->offset = new_sh->prop_count - 1;
      feedback->length = 0;

      return &p->prop[new_sh->prop_count - 1];
    } else {
      /* if the shape is shared, clone it */
      new_sh = lepus_clone_shape(ctx, sh);
      if (!new_sh) return NULL;
      /* hash the cloned shape */
      new_sh->is_hashed = TRUE;
      lepus_shape_hash_link(ctx->rt, new_sh);
      lepus_free_shape(ctx->rt, p->shape);

      p->shape = new_sh;
    }
  }
  assert(p->shape->header.ref_count == 1);
  if (add_shape_property(ctx, &p->shape, p, prop, prop_flags)) {
    return NULL;
  }
  feedback->offset = p->shape->prop_count - 1;

  lepus_free_shape_null(ctx->rt, feedback->new_shape);
  feedback->new_shape = lepus_dup_shape(p->shape);
  feedback->length = 0;

  return &p->prop[p->shape->prop_count - 1];
}
#endif
// <primjs end>

/* Note: the property value is not initialized. Return NULL if memory
   error. */
LEPUSProperty *add_property(LEPUSContext *ctx, LEPUSObject *p, LEPUSAtom prop,
                            int prop_flags) {
  LEPUSShape *sh, *new_sh;

  sh = p->shape;
  if (sh->is_hashed) {
    /* try to find an existing shape */
    new_sh = find_hashed_shape_prop(ctx->rt, sh, prop, prop_flags);
    if (new_sh) {
      /* matching shape found: use it */
      /*  the property array may need to be resized */
      if (new_sh->prop_size != sh->prop_size) {
        LEPUSProperty *new_prop;
        new_prop = static_cast<LEPUSProperty *>(lepus_realloc(
            ctx, p->prop, sizeof(p->prop[0]) * new_sh->prop_size));
        if (!new_prop) return NULL;
        p->prop = new_prop;
      }
      p->shape = lepus_dup_shape(new_sh);
      lepus_free_shape(ctx->rt, sh);
      return &p->prop[new_sh->prop_count - 1];
    } else if (sh->header.ref_count != 1) {
      /* if the shape is shared, clone it */
      new_sh = lepus_clone_shape(ctx, sh);
      if (!new_sh) return NULL;
      /* hash the cloned shape */
      new_sh->is_hashed = TRUE;
      lepus_shape_hash_link(ctx->rt, new_sh);
      lepus_free_shape(ctx->rt, p->shape);
      p->shape = new_sh;
    }
  }
  assert(p->shape->header.ref_count == 1);
  if (add_shape_property(ctx, &p->shape, p, prop, prop_flags)) return NULL;
  return &p->prop[p->shape->prop_count - 1];
}

/* can be called on Array or Arguments objects. return < 0 if
   memory alloc error. */
QJS_STATIC no_inline __exception int convert_fast_array_to_array(
    LEPUSContext *ctx, LEPUSObject *p) {
  LEPUSProperty *pr;
  LEPUSShape *sh;
  LEPUSValue *tab;
  uint32_t i, len, new_count;

  if (lepus_shape_prepare_update(ctx, p, NULL)) return -1;
  len = p->u.array.count;
  /* resize the properties once to simplify the error handling */
  sh = p->shape;
  new_count = sh->prop_count + len;
  if (new_count > sh->prop_size) {
    if (resize_properties(ctx, &p->shape, p, new_count)) return -1;
  }

  tab = p->u.array.u.values;
  for (i = 0; i < len; i++) {
    /* add_property cannot fail here but
       __JS_AtomFromUInt32(i) fails for i > INT32_MAX */
    pr = add_property(ctx, p, __JS_AtomFromUInt32(i), LEPUS_PROP_C_W_E);
    pr->u.value = *tab++;
  }
  lepus_free(ctx, p->u.array.u.values);
  p->u.array.count = 0;
  p->u.array.u.values = NULL; /* fail safe */
  p->u.array.u1.size = 0;
  p->fast_array = 0;
  return 0;
}

QJS_STATIC int delete_property(LEPUSContext *ctx, LEPUSObject *p,
                               LEPUSAtom atom) {
  LEPUSShape *sh;
  LEPUSShapeProperty *pr, *lpr, *prop;
  LEPUSProperty *pr1;
  uint32_t lpr_idx;
  intptr_t h, h1;

redo:
  sh = p->shape;
  h1 = atom & sh->prop_hash_mask;
  h = sh->prop_hash_end[-h1 - 1];
  prop = get_shape_prop(sh);
  lpr = NULL;
  lpr_idx = 0; /* prevent warning */
  while (h != 0) {
    pr = &prop[h - 1];
    if (likely(pr->atom == atom)) {
      /* found ! */
      if (!(pr->flags & LEPUS_PROP_CONFIGURABLE)) return FALSE;
      /* realloc the shape if needed */
      if (lpr) lpr_idx = lpr - get_shape_prop(sh);
      if (lepus_shape_prepare_update(ctx, p, &pr)) return -1;
      sh = p->shape;
      /* remove property */
      if (lpr) {
        lpr = get_shape_prop(sh) + lpr_idx;
        lpr->hash_next = pr->hash_next;
      } else {
        sh->prop_hash_end[-h1 - 1] = pr->hash_next;
      }
      /* free the entry */
      pr1 = &p->prop[h - 1];
      free_property(ctx->rt, pr1, pr->flags);
      LEPUS_FreeAtom(ctx, pr->atom);
      /* put default values */
      pr->flags = 0;
      pr->atom = LEPUS_ATOM_NULL;
      pr1->u.value = LEPUS_UNDEFINED;
      return TRUE;
    }
    lpr = pr;
    h = pr->hash_next;
  }

  if (p->is_exotic) {
    if (p->fast_array) {
      uint32_t idx;
      if (LEPUS_AtomIsArrayIndex(ctx, &idx, atom) && idx < p->u.array.count) {
        if (p->class_id == LEPUS_CLASS_ARRAY ||
            p->class_id == LEPUS_CLASS_ARGUMENTS) {
          /* Special case deleting the last element of a fast Array */
          if (idx == p->u.array.count - 1) {
            LEPUS_FreeValue(ctx, p->u.array.u.values[idx]);
            p->u.array.count = idx;
            return TRUE;
          }
          if (convert_fast_array_to_array(ctx, p)) return -1;
          goto redo;
        } else {
          return FALSE; /* not configurable */
        }
      }
    } else {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->delete_property) {
        return em->delete_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), atom);
      }
    }
  }
  /* not found */
  return TRUE;
}

QJS_STATIC int call_setter(LEPUSContext *ctx, LEPUSObject *setter,
                           LEPUSValueConst this_obj, LEPUSValue val,
                           int flags) {
  LEPUSValue ret, func;
  if (likely(setter)) {
    func = LEPUS_MKPTR(LEPUS_TAG_OBJECT, setter);
    /* Note: the field could be removed in the setter */
    func = LEPUS_DupValue(ctx, func);
    ret = LEPUS_CallFree(ctx, func, this_obj, 1, (LEPUSValueConst *)&val);
    LEPUS_FreeValue(ctx, val);
    if (LEPUS_IsException(ret)) return -1;
    LEPUS_FreeValue(ctx, ret);
    return TRUE;
  } else {
    LEPUS_FreeValue(ctx, val);
    if ((flags & LEPUS_PROP_THROW) ||
        ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
      LEPUS_ThrowTypeError(ctx, "no setter for property");
      return -1;
    }
    return FALSE;
  }
}

/* set the array length and remove the array elements if necessary. */
int set_array_length(LEPUSContext *ctx, LEPUSObject *p, LEPUSProperty *prop,
                     LEPUSValue val, int flags) {
  uint32_t len, idx, cur_len;
  int i, ret;

  ret = LEPUS_ToArrayLengthFree(ctx, &len, val, FALSE);
  if (ret) return -1;
  if (likely(p->fast_array)) {
    uint32_t old_len = p->u.array.count;
    if (len < old_len) {
      for (i = len; i < old_len; i++) {
        LEPUS_FreeValue(ctx, p->u.array.u.values[i]);
      }
      p->u.array.count = len;
    }
#ifdef CONFIG_BIGNUM
    set_value(ctx, &prop->u.value, LEPUS_NewUint32(ctx, len));
#else
    prop->u.value = LEPUS_NewUint32(ctx, len);
#endif
  } else {
    /* Note: length is always a uint32 because the object is an
       array */
    LEPUS_ToUint32(ctx, &cur_len, prop->u.value);
    if (len < cur_len) {
      uint32_t d;
      LEPUSShape *sh;
      LEPUSShapeProperty *pr;

      d = cur_len - len;
      sh = p->shape;
      if (d <= sh->prop_count) {
        LEPUSAtom atom;

        /* faster to iterate */
        while (cur_len > len) {
          atom = LEPUS_NewAtomUInt32(ctx, cur_len - 1);
          ret = delete_property(ctx, p, atom);
          LEPUS_FreeAtom(ctx, atom);
          if (unlikely(!ret)) {
            /* unlikely case: property is not
               configurable */
            break;
          }
          cur_len--;
        }
      } else {
        /* faster to iterate thru all the properties. Need two
           passes in case one of the property is not
           configurable */
        cur_len = len;
        for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
          if (pr->atom != LEPUS_ATOM_NULL &&
              LEPUS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {
            if (idx >= cur_len && !(pr->flags & LEPUS_PROP_CONFIGURABLE)) {
              cur_len = idx + 1;
            }
          }
        }

        for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
          if (pr->atom != LEPUS_ATOM_NULL &&
              LEPUS_AtomIsArrayIndex(ctx, &idx, pr->atom)) {
            if (idx >= cur_len) {
              /* remove the property */
              delete_property(ctx, p, pr->atom);
              /* WARNING: the shape may have been modified */
              sh = p->shape;
              pr = get_shape_prop(sh) + i;
            }
          }
        }
      }
    } else {
      cur_len = len;
    }
    set_value(ctx, &p->prop[0].u.value, LEPUS_NewUint32(ctx, cur_len));
    if (unlikely(cur_len > len)) {
      return LEPUS_ThrowTypeErrorOrFalse(ctx, flags, "not configurable");
    }
  }
  return TRUE;
}

/* Preconditions: 'p' must be of class LEPUS_CLASS_ARRAY, p->fast_array =
   TRUE and p->extensible = TRUE */
QJS_STATIC int add_fast_array_element(LEPUSContext *ctx, LEPUSObject *p,
                                      LEPUSValue val, int flags) {
  uint32_t new_len, array_len;
  /* extend the array by one */
  /* XXX: convert to slow array if new_len > 2^31-1 elements */
  new_len = p->u.array.count + 1;
  /* update the length if necessary. We assume that if the length is
     not an integer, then if it >= 2^31.  */
  if (likely(LEPUS_VALUE_IS_INT(p->prop[0].u.value))) {
    array_len = LEPUS_VALUE_GET_INT(p->prop[0].u.value);
    if (new_len > array_len) {
      if (unlikely(!(get_shape_prop(p->shape)->flags & LEPUS_PROP_WRITABLE))) {
        LEPUS_FreeValue(ctx, val);
        return LEPUS_ThrowTypeErrorReadOnly(ctx, flags, LEPUS_ATOM_length);
      }
      p->prop[0].u.value = LEPUS_NewInt32(ctx, new_len);
    }
  }
  if (unlikely(new_len > p->u.array.u1.size)) {
    uint32_t new_size;
    size_t slack;
    LEPUSValue *new_array_prop;
    /* XXX: potential arithmetic overflow */
    new_size = max_int(new_len, p->u.array.u1.size * 3 / 2);
    new_array_prop = static_cast<LEPUSValue *>(lepus_realloc2(
        ctx, p->u.array.u.values, sizeof(LEPUSValue) * new_size, &slack));
    if (!new_array_prop) {
      LEPUS_FreeValue(ctx, val);
      return -1;
    }
    new_size += slack / sizeof(*new_array_prop);
    p->u.array.u.values = new_array_prop;
    p->u.array.u1.size = new_size;
  }
  p->u.array.u.values[new_len - 1] = val;
  p->u.array.count = new_len;
  return TRUE;
}

QJS_STATIC void lepus_free_desc(LEPUSContext *ctx,
                                LEPUSPropertyDescriptor *desc) {
  LEPUS_FreeValue(ctx, desc->getter);
  LEPUS_FreeValue(ctx, desc->setter);
  LEPUS_FreeValue(ctx, desc->value);
}

/* generic (and slower) version of LEPUS_SetProperty() for Reflect.set() */
int LEPUS_SetPropertyGeneric(LEPUSContext *ctx, LEPUSObject *p, LEPUSAtom prop,
                             LEPUSValue val, LEPUSValueConst this_obj,
                             int flags) {
  int ret;
  LEPUSPropertyDescriptor desc;

  while (p != NULL) {
    if (p->is_exotic) {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em && em->set_property) {
        ret = em->set_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), prop, val,
                               this_obj, flags);
        LEPUS_FreeValue(ctx, val);
        return ret;
      }
    }

    ret = LEPUS_GetOwnPropertyInternal(ctx, &desc, p, prop);
    if (ret < 0) return ret;
    if (ret) {
      if (desc.flags & LEPUS_PROP_GETSET) {
        LEPUSObject *setter;
        if (LEPUS_IsUndefined(desc.setter))
          setter = NULL;
        else
          setter = LEPUS_VALUE_GET_OBJ(desc.setter);
        ret = call_setter(ctx, setter, this_obj, val, flags);
        LEPUS_FreeValue(ctx, desc.getter);
        LEPUS_FreeValue(ctx, desc.setter);
        return ret;
      } else {
        LEPUS_FreeValue(ctx, desc.value);
        if (!(desc.flags & LEPUS_PROP_WRITABLE)) {
          goto read_only_error;
        }
      }
      break;
    }
    p = p->shape->proto;
  }
  this_obj = LEPUSRef2Value(ctx, this_obj);
  if (!LEPUS_IsObject(this_obj))
    return LEPUS_ThrowTypeErrorOrFalse(ctx, flags, "receiver is not an object");

  p = LEPUS_VALUE_GET_OBJ(this_obj);

  /* modify the property in this_obj if it already exists */
  ret = LEPUS_GetOwnPropertyInternal(ctx, &desc, p, prop);
  if (ret < 0) return ret;
  if (ret) {
    if (desc.flags & LEPUS_PROP_GETSET) {
      LEPUS_FreeValue(ctx, desc.getter);
      LEPUS_FreeValue(ctx, desc.setter);
      LEPUS_FreeValue(ctx, val);
      return LEPUS_ThrowTypeErrorOrFalse(ctx, flags, "setter is forbidden");
    } else {
      LEPUS_FreeValue(ctx, desc.value);
      if (!(desc.flags & LEPUS_PROP_WRITABLE) ||
          p->class_id == LEPUS_CLASS_MODULE_NS) {
      read_only_error:
        LEPUS_FreeValue(ctx, val);
        return LEPUS_ThrowTypeErrorReadOnly(ctx, flags, prop);
      }
    }
    ret = LEPUS_DefineProperty(ctx, this_obj, prop, val, LEPUS_UNDEFINED,
                               LEPUS_UNDEFINED, LEPUS_PROP_HAS_VALUE);
    LEPUS_FreeValue(ctx, val);
    return ret;
  }

  ret = LEPUS_CreateProperty(
      ctx, p, prop, val, LEPUS_UNDEFINED, LEPUS_UNDEFINED,
      flags | LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_ENUMERABLE |
          LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_HAS_CONFIGURABLE |
          LEPUS_PROP_C_W_E);
  LEPUS_FreeValue(ctx, val);
  return ret;
}

int LEPUS_SetPropertyInternal(LEPUSContext *ctx, LEPUSValueConst this_obj,
                              LEPUSAtom prop, LEPUSValue val, int flags) {
  return LEPUS_SetPropertyInternalImpl(ctx, this_obj, prop, val, flags, NULL);
}

/* return -1 in case of exception or TRUE or FALSE. Warning: 'val' is
   freed by the function. 'flags' is a bitmask of LEPUS_PROP_NO_ADD,
   LEPUS_PROP_THROW or LEPUS_PROP_THROW_STRICT. If LEPUS_PROP_NO_ADD is set,
   the new property is not added and an error is raised. */

int LEPUS_SetPropertyInternalImpl(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                  LEPUSAtom prop, LEPUSValue val, int flags,
                                  TypeSetFeedBack *feedback) {
#ifndef ENABLE_PRIMJS_IC
  assert(feedback == nullptr);
#endif
  LEPUSObject *p, *p1;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  int64_t tag;
  LEPUSPropertyDescriptor desc;
  int ret;
  char buf[ATOM_GET_STR_BUF_SIZE];
  intptr_t offset = 0;

  tag = LEPUS_VALUE_GET_TAG(this_obj);
#ifdef ENABLE_LEPUSNG
  // <ByteDance begin>
  if (tag == LEPUS_TAG_LEPUS_REF) {
    LEPUSValue prop_str = LEPUS_UNDEFINED;
    int idx = -1;
    if (__JS_AtomIsTaggedInt(prop)) {
      idx = __JS_AtomToUInt32(prop);
    } else {
      prop_str = LEPUS_AtomToString(ctx, prop);
    }
    LEPUSValue ret = ctx->rt->lepus_callbacks_.set_property(ctx, this_obj,
                                                            prop_str, idx, val);
    LEPUS_FreeValue(ctx, prop_str);

    if (LEPUS_IsException(ret)) {
      LEPUS_FreeValue(ctx, val);
      return -1;
    }

    if (LEPUS_IsUndefined(ret)) {
      LEPUS_FreeValue(ctx, val);
      return TRUE;
    }
    this_obj = ret;
    tag = LEPUS_VALUE_GET_TAG(this_obj);
  }
// <ByteDance end>
#endif
  if (unlikely(tag != LEPUS_TAG_OBJECT)) {
    switch (tag) {
#ifdef LYNX_DEV
      case LEPUS_TAG_NULL:
        LEPUS_FreeValue(ctx, val);
        // if not in the strict mode, set properties of null will do nothing and
        // will not throw exception
        if (ctx->no_lepus_strict_mode) {
          return 0;
        } else {
          LEPUS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of null",
                                   prop);
          return -1;
        }
      case LEPUS_TAG_UNDEFINED:
        LEPUS_FreeValue(ctx, val);
        if (ctx->no_lepus_strict_mode) {
          return 0;
        } else {
          LEPUS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of undefined",
                                   prop);
          return -1;
        }
#endif
// <bytedance begin>
#ifdef ENABLE_LEPUSNG
      case LEPUS_TAG_BIG_INT:
        p = NULL;
        p1 = NULL;
        goto prototype_lookup;
#endif
        // <bytedance end>
      default:
        /* even on a primitive type we can have setters on the prototype */
        p = NULL;
        p1 = LEPUS_VALUE_GET_OBJ(LEPUS_GetPrototype(ctx, this_obj));
        goto prototype_lookup;
    }
  }
  p = LEPUS_VALUE_GET_OBJ(this_obj);
retry:
#ifdef ENABLE_PRIMJS_IC
  prs = find_own_property_with_ic(&pr, p, prop, &offset);
#else
  prs = find_own_property(&pr, p, prop);
#endif
  if (prs) {
    if (likely((prs->flags & (LEPUS_PROP_TMASK | LEPUS_PROP_WRITABLE |
                              LEPUS_PROP_LENGTH)) == LEPUS_PROP_WRITABLE)) {
/* fast case */
#ifdef ENABLE_PRIMJS_IC
      if (feedback && p->shape->is_hashed) {
        lepus_free_shape_null(ctx->rt, feedback->old_shape);
        feedback->old_shape = lepus_dup_shape(p->shape);
        lepus_free_shape_null(ctx->rt, feedback->new_shape);
        feedback->new_shape = lepus_dup_shape(p->shape);
        feedback->length = 0;
        feedback->offset = offset;
        // feedback->hash = p->shape->hash;
      }
#endif
      set_value(ctx, &pr->u.value, val);
      return TRUE;
    } else if ((prs->flags & (LEPUS_PROP_LENGTH | LEPUS_PROP_WRITABLE)) ==
               (LEPUS_PROP_LENGTH | LEPUS_PROP_WRITABLE)) {
      assert(p->class_id == LEPUS_CLASS_ARRAY);
      assert(prop == LEPUS_ATOM_length);
// Need more tests
#ifdef ENABLE_PRIMJS_IC
      if (feedback && p->shape->is_hashed) {
        lepus_free_shape_null(ctx->rt, feedback->old_shape);
        feedback->old_shape = lepus_dup_shape(p->shape);
        feedback->length = 1;
        feedback->offset = offset;
      }
#endif
      return set_array_length(ctx, p, pr, val, flags);
    } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
      return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);
    } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
      /* LEPUS_PROP_WRITABLE is always true for variable
         references, but they are write protected in module name
         spaces. */
      if (p->class_id == LEPUS_CLASS_MODULE_NS) goto read_only_prop;
      set_value(ctx, pr->u.var_ref->pvalue, val);
      return TRUE;
    } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
      /* Instantiate property and retry (potentially useless) */
      if (LEPUS_AutoInitProperty(ctx, p, prop, pr, prs)) {
        LEPUS_FreeValue(ctx, val);
        return -1;
      }
      goto retry;
    } else {
      goto read_only_prop;
    }
  }

  p1 = p;
  for (;;) {
    if (p1->is_exotic) {
      if (p1->fast_array) {
        if (__JS_AtomIsTaggedInt(prop)) {
          uint32_t idx = __JS_AtomToUInt32(prop);
          if (idx < p1->u.array.count) {
            if (unlikely(p == p1))
              return LEPUS_SetPropertyValue(
                  ctx, this_obj, LEPUS_NewInt32(ctx, idx), val, flags);
            else
              break;
          } else if (p1->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
                     p1->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
            goto typed_array_oob;
          }
        } else if (p1->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
                   p1->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
          ret = LEPUS_AtomIsNumericIndex(ctx, prop);
          if (ret != 0) {
            if (ret < 0) {
              LEPUS_FreeValue(ctx, val);
              return -1;
            }
          typed_array_oob:
            val = LEPUS_ToNumberFree(ctx, val);
            LEPUS_FreeValue(ctx, val);
            if (LEPUS_IsException(val)) return -1;
            return FALSE;
          }
        }
      } else {
        const LEPUSClassExoticMethods *em =
            ctx->rt->class_array[p1->class_id].exotic;
        if (em) {
          if (em->set_property) {
            ret = em->set_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1), prop,
                                   val, this_obj, flags);
            LEPUS_FreeValue(ctx, val);
            return ret;
          }
          if (em->get_own_property) {
            ret = em->get_own_property(ctx, &desc,
                                       LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1), prop);
            if (ret < 0) {
              LEPUS_FreeValue(ctx, val);
              return ret;
            }
            if (ret) {
              if (desc.flags & LEPUS_PROP_GETSET) {
                LEPUSObject *setter;
                if (LEPUS_IsUndefined(desc.setter))
                  setter = NULL;
                else
                  setter = LEPUS_VALUE_GET_OBJ(desc.setter);
                ret = call_setter(ctx, setter, this_obj, val, flags);
                LEPUS_FreeValue(ctx, desc.getter);
                LEPUS_FreeValue(ctx, desc.setter);
                return ret;
              } else {
                LEPUS_FreeValue(ctx, desc.value);
                if (!(desc.flags & LEPUS_PROP_WRITABLE)) goto read_only_prop;
                if (likely(p == p1)) {
                  ret = LEPUS_DefineProperty(ctx, this_obj, prop, val,
                                             LEPUS_UNDEFINED, LEPUS_UNDEFINED,
                                             LEPUS_PROP_HAS_VALUE);
                  LEPUS_FreeValue(ctx, val);
                  return ret;
                } else {
                  break;
                }
              }
            }
          }
        }
      }
    }
    p1 = p1->shape->proto;
  prototype_lookup:
    if (!p1) break;

  retry2:
    prs = find_own_property(&pr, p1, prop);
    if (prs) {
      if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
        return call_setter(ctx, pr->u.getset.setter, this_obj, val, flags);
      } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
        /* Instantiate property and retry (potentially useless) */
        if (LEPUS_AutoInitProperty(ctx, p1, prop, pr, prs)) return -1;
        goto retry2;
      } else if (!(prs->flags & LEPUS_PROP_WRITABLE)) {
      read_only_prop:
        LEPUS_FreeValue(ctx, val);
        return LEPUS_ThrowTypeErrorReadOnly(ctx, flags, prop);
      }
    }
  }

  if (unlikely(flags & LEPUS_PROP_NO_ADD)) {
    LEPUS_FreeValue(ctx, val);
    LEPUS_ThrowReferenceErrorNotDefined(ctx, prop);
    return -1;
  }

  if (unlikely(!p)) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_ThrowTypeErrorOrFalse(ctx, flags, "not an object");
  }

  if (unlikely(!p->extensible)) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_ThrowTypeErrorOrFalse(ctx, flags, "object is not extensible");
  }

  if (p->is_exotic) {
    if (p->class_id == LEPUS_CLASS_ARRAY && p->fast_array &&
        __JS_AtomIsTaggedInt(prop)) {
      uint32_t idx = __JS_AtomToUInt32(prop);
      if (idx == p->u.array.count) {
        /* fast case */
        return add_fast_array_element(ctx, p, val, flags);
      } else {
        goto generic_create_prop;
      }
    } else {
    generic_create_prop:
      ret = LEPUS_CreateProperty(
          ctx, p, prop, val, LEPUS_UNDEFINED, LEPUS_UNDEFINED,
          flags | LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_ENUMERABLE |
              LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_HAS_CONFIGURABLE |
              LEPUS_PROP_C_W_E);
      LEPUS_FreeValue(ctx, val);
      return ret;
    }
  }
#ifdef ENABLE_PRIMJS_IC
  if (feedback && p->shape->is_hashed) {
    pr = add_property_with_ic(ctx, p, prop, LEPUS_PROP_C_W_E, feedback);
  } else {
    pr = add_property(ctx, p, prop, LEPUS_PROP_C_W_E);
  }
#else
  pr = add_property(ctx, p, prop, LEPUS_PROP_C_W_E);
#endif
  if (unlikely(!pr)) {
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  pr->u.value = val;
  return TRUE;
}

/* flags can be LEPUS_PROP_THROW or LEPUS_PROP_THROW_STRICT */
int LEPUS_SetPropertyValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                           LEPUSValue prop, LEPUSValue val, int flags) {
  if (likely(LEPUS_VALUE_IS_OBJECT(this_obj) && LEPUS_VALUE_IS_INT(prop))) {
    LEPUSObject *p;
    uint32_t idx;
    double d;
    int32_t v;

    /* fast path for array access */
    p = LEPUS_VALUE_GET_OBJ(this_obj);
    idx = LEPUS_VALUE_GET_INT(prop);
    switch (p->class_id) {
      case LEPUS_CLASS_ARRAY:
        if (unlikely(idx >= (uint32_t)p->u.array.count)) {
          LEPUSObject *p1;
          LEPUSShape *sh1;

          /* fast path to add an element to the array */
          if (idx != (uint32_t)p->u.array.count || !p->fast_array ||
              !p->extensible)
            goto slow_path;
          /* check if prototype chain has a numeric property */
          p1 = p->shape->proto;
          while (p1 != NULL) {
            sh1 = p1->shape;
            if (p1->class_id == LEPUS_CLASS_ARRAY) {
              if (unlikely(!p1->fast_array)) goto slow_path;
            } else if (p1->class_id == LEPUS_CLASS_OBJECT) {
              if (unlikely(sh1->has_small_array_index)) goto slow_path;
            } else {
              goto slow_path;
            }
            p1 = sh1->proto;
          }
          /* add element */
          return add_fast_array_element(ctx, p, val, flags);
        }
        set_value(ctx, &p->u.array.u.values[idx], val);
        break;
      case LEPUS_CLASS_ARGUMENTS:
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto slow_path;
        set_value(ctx, &p->u.array.u.values[idx], val);
        break;
      case LEPUS_CLASS_UINT8C_ARRAY:
        if (LEPUS_ToUint8ClampFree(ctx, &v, val)) return -1;
        /* Note: the conversion can detach the typed array, so the
           array bound check must be done after */
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.uint8_ptr[idx] = v;
        break;
      case LEPUS_CLASS_INT8_ARRAY:
      case LEPUS_CLASS_UINT8_ARRAY:
        if (LEPUS_ToInt32Free(ctx, &v, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.uint8_ptr[idx] = v;
        break;
      case LEPUS_CLASS_INT16_ARRAY:
      case LEPUS_CLASS_UINT16_ARRAY:
        if (LEPUS_ToInt32Free(ctx, &v, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.uint16_ptr[idx] = v;
        break;
      case LEPUS_CLASS_INT32_ARRAY:
      case LEPUS_CLASS_UINT32_ARRAY:
        if (LEPUS_ToInt32Free(ctx, &v, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.uint32_ptr[idx] = v;
        break;
#ifdef CONFIG_BIGNUM
      case LEPUS_CLASS_BIG_INT64_ARRAY:
      case LEPUS_CLASS_BIG_UINT64_ARRAY:
        /* XXX: need specific conversion function */
        {
          int64_t v;
          if (LEPUS_ToBigInt64Free(ctx, &v, val)) return -1;
          if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
          p->u.array.u.uint64_ptr[idx] = v;
        }
        break;
#endif
      case LEPUS_CLASS_FLOAT32_ARRAY:
        if (LEPUS_ToFloat64Free(ctx, &d, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) goto ta_out_of_bound;
        p->u.array.u.float_ptr[idx] = d;
        break;
      case LEPUS_CLASS_FLOAT64_ARRAY:
        if (LEPUS_ToFloat64Free(ctx, &d, val)) return -1;
        if (unlikely(idx >= (uint32_t)p->u.array.count)) {
        ta_out_of_bound:
          return LEPUS_ThrowTypeErrorOrFalse(ctx, flags,
                                             "out-of-bound numeric index");
          /* Accroding to 10.4.5.11, if index is invalid, return
           * NormalCompletion(undefined) */
        }
        p->u.array.u.double_ptr[idx] = d;
        break;
      default:
        goto slow_path;
    }
    return TRUE;
  } else {
    LEPUSAtom atom;
    int ret;
  slow_path:
    atom = lepus_value_to_atom(ctx, prop);
    LEPUS_FreeValue(ctx, prop);
    if (unlikely(atom == LEPUS_ATOM_NULL)) {
      LEPUS_FreeValue(ctx, val);
      return -1;
    }
    ret = LEPUS_SetPropertyInternal(ctx, this_obj, atom, val, flags);
    LEPUS_FreeAtom(ctx, atom);
    return ret;
  }
}

int LEPUS_SetPropertyUint32(LEPUSContext *ctx, LEPUSValueConst this_obj,
                            uint32_t idx, LEPUSValue val) {
  return LEPUS_SetPropertyValue(ctx, this_obj, LEPUS_NewUint32(ctx, idx), val,
                                LEPUS_PROP_THROW);
}

int LEPUS_SetPropertyInt64(LEPUSContext *ctx, LEPUSValueConst this_obj,
                           int64_t idx, LEPUSValue val) {
  LEPUSAtom prop;
  int res;

  if ((uint64_t)idx <= INT32_MAX) {
    /* fast path for fast arrays */
    return LEPUS_SetPropertyValue(ctx, this_obj, LEPUS_NewInt32(ctx, idx), val,
                                  LEPUS_PROP_THROW);
  }
  prop = LEPUS_NewAtomInt64(ctx, idx);
  if (prop == LEPUS_ATOM_NULL) {
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  res = LEPUS_SetProperty(ctx, this_obj, prop, val);
  LEPUS_FreeAtom(ctx, prop);
  return res;
}

int LEPUS_SetPropertyStr(LEPUSContext *ctx, LEPUSValueConst this_obj,
                         const char *prop, LEPUSValue val) {
  LEPUSAtom atom;
  int ret;
  atom = LEPUS_NewAtom(ctx, prop);
  ret = LEPUS_SetPropertyInternal(ctx, this_obj, atom, val, LEPUS_PROP_THROW);
  LEPUS_FreeAtom(ctx, atom);
  return ret;
}

/* compute the property flags. For each flag: (LEPUS_PROP_HAS_x forces
   it, otherwise def_flags is used)
   Note: makes assumption about the bit pattern of the flags
*/
QJS_STATIC int get_prop_flags(int flags, int def_flags) {
  int mask;
  mask = (flags >> LEPUS_PROP_HAS_SHIFT) & LEPUS_PROP_C_W_E;
  return (flags & mask) | (def_flags & ~mask);
}

QJS_STATIC int LEPUS_CreateProperty(LEPUSContext *ctx, LEPUSObject *p,
                                    LEPUSAtom prop, LEPUSValueConst val,
                                    LEPUSValueConst getter,
                                    LEPUSValueConst setter, int flags) {
  LEPUSProperty *pr;
  int ret, prop_flags;

  /* add a new property or modify an existing exotic one */
  if (p->is_exotic) {
    if (p->class_id == LEPUS_CLASS_ARRAY) {
      uint32_t idx, len;

      if (p->fast_array) {
        if (__JS_AtomIsTaggedInt(prop)) {
          idx = __JS_AtomToUInt32(prop);
          if (idx == p->u.array.count) {
            if (!p->extensible) goto not_extensible;
            if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET))
              goto convert_to_array;
            prop_flags = get_prop_flags(flags, 0);
            if (prop_flags != LEPUS_PROP_C_W_E) goto convert_to_array;
            return add_fast_array_element(ctx, p, LEPUS_DupValue(ctx, val),
                                          flags);
          } else {
            goto convert_to_array;
          }
        } else if (LEPUS_AtomIsArrayIndex(ctx, &idx, prop)) {
          /* convert the fast array to normal array */
        convert_to_array:
          if (convert_fast_array_to_array(ctx, p)) return -1;
          goto generic_array;
        }
      } else if (LEPUS_AtomIsArrayIndex(ctx, &idx, prop)) {
        LEPUSProperty *plen;
        LEPUSShapeProperty *pslen;
      generic_array:
        /* update the length field */
        plen = &p->prop[0];
        LEPUS_ToUint32(ctx, &len, plen->u.value);
        if ((idx + 1) > len) {
          pslen = get_shape_prop(p->shape);
          if (unlikely(!(pslen->flags & LEPUS_PROP_WRITABLE)))
            return LEPUS_ThrowTypeErrorReadOnly(ctx, flags, LEPUS_ATOM_length);
          /* XXX: should update the length after defining
             the property */
          len = idx + 1;
          set_value(ctx, &plen->u.value, LEPUS_NewUint32(ctx, len));
        }
      }
    } else if (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
               p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
      ret = LEPUS_AtomIsNumericIndex(ctx, prop);
      if (ret != 0) {
        if (ret < 0) return -1;
        /* 10.4.5.5: Always return true */
        // return LEPUS_ThrowTypeErrorOrFalse(
        //     ctx, flags, "cannot create numeric index in typed array");
      }
    } else if (!(flags & LEPUS_PROP_NO_EXOTIC)) {
      const LEPUSClassExoticMethods *em =
          ctx->rt->class_array[p->class_id].exotic;
      if (em) {
        if (em->define_own_property) {
          return em->define_own_property(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p),
                                         prop, val, getter, setter, flags);
        }
        ret = LEPUS_IsExtensible(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
        if (ret < 0) return -1;
        if (!ret) goto not_extensible;
      }
    }
  }

  if (!p->extensible) {
  not_extensible:
    return LEPUS_ThrowTypeErrorOrFalse(ctx, flags, "object is not extensible");
  }

  if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
    prop_flags = (flags & (LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_ENUMERABLE)) |
                 LEPUS_PROP_GETSET;
  } else {
    prop_flags = flags & LEPUS_PROP_C_W_E;
  }
  pr = add_property(ctx, p, prop, prop_flags);
  if (unlikely(!pr)) return -1;
  if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
    pr->u.getset.getter = NULL;
    if ((flags & LEPUS_PROP_HAS_GET) && LEPUS_IsFunction(ctx, getter)) {
      pr->u.getset.getter = LEPUS_VALUE_GET_OBJ(LEPUS_DupValue(ctx, getter));
    }
    pr->u.getset.setter = NULL;
    if ((flags & LEPUS_PROP_HAS_SET) && LEPUS_IsFunction(ctx, setter)) {
      pr->u.getset.setter = LEPUS_VALUE_GET_OBJ(LEPUS_DupValue(ctx, setter));
    }
  } else {
    if (flags & LEPUS_PROP_HAS_VALUE) {
      pr->u.value = LEPUS_DupValue(ctx, val);
    } else {
      pr->u.value = LEPUS_UNDEFINED;
    }
  }
  return TRUE;
}

/* return FALSE if not OK */
QJS_STATIC BOOL check_define_prop_flags(int prop_flags, int flags) {
  BOOL has_accessor, is_getset;

  if (!(prop_flags & LEPUS_PROP_CONFIGURABLE)) {
    if ((flags & (LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE)) ==
        (LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE)) {
      return FALSE;
    }
    if ((flags & LEPUS_PROP_HAS_ENUMERABLE) &&
        (flags & LEPUS_PROP_ENUMERABLE) != (prop_flags & LEPUS_PROP_ENUMERABLE))
      return FALSE;
  }
  if (flags & (LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE |
               LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
    if (!(prop_flags & LEPUS_PROP_CONFIGURABLE)) {
      has_accessor = ((flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) != 0);
      is_getset = ((prop_flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET);
      if (has_accessor != is_getset) return FALSE;
      if (!has_accessor && !is_getset && !(prop_flags & LEPUS_PROP_WRITABLE)) {
        /* not writable: cannot set the writable bit */
        if ((flags & (LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_WRITABLE)) ==
            (LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_WRITABLE))
          return FALSE;
      }
    }
  }
  return TRUE;
}

/* ensure that the shape can be safely modified */
QJS_STATIC int lepus_shape_prepare_update(LEPUSContext *ctx, LEPUSObject *p,
                                          LEPUSShapeProperty **pprs) {
  LEPUSShape *sh;
  uint32_t idx = 0; /* prevent warning */

  sh = p->shape;
  if (sh->is_hashed) {
    if (sh->header.ref_count != 1) {
      if (pprs) idx = *pprs - get_shape_prop(sh);
      /* clone the shape (the resulting one is no longer hashed) */
      sh = lepus_clone_shape(ctx, sh);
      if (!sh) return -1;
      lepus_free_shape(ctx->rt, p->shape);
      p->shape = sh;
      if (pprs) *pprs = get_shape_prop(sh) + idx;
    } else {
      lepus_shape_hash_unlink(ctx->rt, sh);
      sh->is_hashed = FALSE;
    }
  }
  return 0;
}

QJS_STATIC int lepus_update_property_flags(LEPUSContext *ctx, LEPUSObject *p,
                                           LEPUSShapeProperty **pprs,
                                           int flags) {
  if (flags != (*pprs)->flags) {
    if (lepus_shape_prepare_update(ctx, p, pprs)) return -1;
    (*pprs)->flags = flags;
  }
  return 0;
}

/* allowed flags:
   LEPUS_PROP_CONFIGURABLE, LEPUS_PROP_WRITABLE, LEPUS_PROP_ENUMERABLE
   LEPUS_PROP_HAS_GET, LEPUS_PROP_HAS_SET, LEPUS_PROP_HAS_VALUE,
   LEPUS_PROP_HAS_CONFIGURABLE, LEPUS_PROP_HAS_WRITABLE,
   LEPUS_PROP_HAS_ENUMERABLE, LEPUS_PROP_THROW, LEPUS_PROP_NO_EXOTIC. If
   LEPUS_PROP_THROW is set, return an exception instead of FALSE. if
   LEPUS_PROP_NO_EXOTIC is set, do not call the exotic define_own_property
   callback. return -1 (exception), FALSE or TRUE.
*/
int LEPUS_DefineProperty(LEPUSContext *ctx, LEPUSValueConst this_obj,
                         LEPUSAtom prop, LEPUSValueConst val,
                         LEPUSValueConst getter, LEPUSValueConst setter,
                         int flags) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  int mask, res;
  // <bytedance begin>
  this_obj = LEPUSRef2Value(ctx, this_obj);
  // <bytedance end>
  if (LEPUS_VALUE_IS_NOT_OBJECT(this_obj)) {
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  p = LEPUS_VALUE_GET_OBJ(this_obj);

redo_prop_update:
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    /* the range of the Array length property is always tested before */
    if ((prs->flags & LEPUS_PROP_LENGTH) && (flags & LEPUS_PROP_HAS_VALUE)) {
      uint32_t array_length;
      if (LEPUS_ToArrayLengthFree(ctx, &array_length, LEPUS_DupValue(ctx, val),
                                  FALSE)) {
        return -1;
      }
      /* this code relies on the fact that Uint32 are never allocated */
      val = (LEPUSValueConst)LEPUS_NewUint32(ctx, array_length);
      /* prs may have been modified */
      prs = find_own_property(&pr, p, prop);
      assert(prs != NULL);
    }
    /* property already exists */
    if (!check_define_prop_flags(prs->flags, flags)) {
    not_configurable:
      return LEPUS_ThrowTypeErrorOrFalse(ctx, flags,
                                         "property is not configurable");
    }
    if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
      /* Instantiate property and retry */
      if (LEPUS_AutoInitProperty(ctx, p, prop, pr, prs)) return -1;
      goto redo_prop_update;
    }

    if (flags & (LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE |
                 LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
      if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
        LEPUSObject *new_getter, *new_setter;

        if (LEPUS_IsFunction(ctx, getter)) {
          new_getter = LEPUS_VALUE_GET_OBJ(getter);
        } else {
          new_getter = NULL;
        }
        if (LEPUS_IsFunction(ctx, setter)) {
          new_setter = LEPUS_VALUE_GET_OBJ(setter);
        } else {
          new_setter = NULL;
        }

        if ((prs->flags & LEPUS_PROP_TMASK) != LEPUS_PROP_GETSET) {
          if (lepus_shape_prepare_update(ctx, p, &prs)) return -1;
          /* convert to getset */
          if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
            free_var_ref(ctx->rt, pr->u.var_ref);
          } else {
            LEPUS_FreeValue(ctx, pr->u.value);
          }
          prs->flags =
              (prs->flags & (LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_ENUMERABLE)) |
              LEPUS_PROP_GETSET;
          pr->u.getset.getter = NULL;
          pr->u.getset.setter = NULL;
        } else {
          if (!(prs->flags & LEPUS_PROP_CONFIGURABLE)) {
            if ((flags & LEPUS_PROP_HAS_GET) &&
                new_getter != pr->u.getset.getter) {
              goto not_configurable;
            }
            if ((flags & LEPUS_PROP_HAS_SET) &&
                new_setter != pr->u.getset.setter) {
              goto not_configurable;
            }
          }
        }
        if (flags & LEPUS_PROP_HAS_GET) {
          if (pr->u.getset.getter)
            LEPUS_FreeValue(ctx,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
          if (new_getter) LEPUS_DupValue(ctx, getter);
          pr->u.getset.getter = new_getter;
        }
        if (flags & LEPUS_PROP_HAS_SET) {
          if (pr->u.getset.setter)
            LEPUS_FreeValue(ctx,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
          if (new_setter) LEPUS_DupValue(ctx, setter);
          pr->u.getset.setter = new_setter;
        }
      } else {
        if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
          /* convert to data descriptor */
          if (lepus_shape_prepare_update(ctx, p, &prs)) return -1;
          if (pr->u.getset.getter)
            LEPUS_FreeValue(ctx,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
          if (pr->u.getset.setter)
            LEPUS_FreeValue(ctx,
                            LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
          prs->flags &= ~(LEPUS_PROP_TMASK | LEPUS_PROP_WRITABLE);
          pr->u.value = LEPUS_UNDEFINED;
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          /* Note: LEPUS_PROP_VARREF is always writable */
        } else {
          if ((prs->flags & (LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE)) ==
                  0 &&
              (flags & LEPUS_PROP_HAS_VALUE)) {
            if (!lepus_same_value(ctx, val, pr->u.value)) {
              goto not_configurable;
            } else {
              return TRUE;
            }
          }
        }
        if (prs->flags & LEPUS_PROP_LENGTH) {
          if (flags & LEPUS_PROP_HAS_VALUE) {
            res = set_array_length(ctx, p, pr, LEPUS_DupValue(ctx, val), flags);
          } else {
            res = TRUE;
          }
          /* still need to reset the writable flag if needed.
             The LEPUS_PROP_LENGTH is reset to have the correct
             read-only behavior in LEPUS_SetProperty(). */
          if ((flags & (LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_WRITABLE)) ==
              LEPUS_PROP_HAS_WRITABLE) {
            prs = get_shape_prop(p->shape);
            if (lepus_update_property_flags(
                    ctx, p, &prs,
                    prs->flags & ~(LEPUS_PROP_WRITABLE | LEPUS_PROP_LENGTH)))
              return -1;
          }
          return res;
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          if (flags & LEPUS_PROP_HAS_VALUE) {
            if (p->class_id == LEPUS_CLASS_MODULE_NS) {
              /* LEPUS_PROP_WRITABLE is always true for variable
                 references, but they are write protected in module name
                 spaces. */
              if (!lepus_same_value(ctx, val, *pr->u.var_ref->pvalue))
                goto not_configurable;
            }
            /* update the reference */
            set_value(ctx, pr->u.var_ref->pvalue, LEPUS_DupValue(ctx, val));
          }
          /* if writable is set to false, no longer a
             reference (for mapped arguments) */
          if ((flags & (LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_WRITABLE)) ==
              LEPUS_PROP_HAS_WRITABLE) {
            LEPUSValue val1;
            if (lepus_shape_prepare_update(ctx, p, &prs)) return -1;
            val1 = LEPUS_DupValue(ctx, *pr->u.var_ref->pvalue);
            free_var_ref(ctx->rt, pr->u.var_ref);
            pr->u.value = val1;
            prs->flags &= ~(LEPUS_PROP_TMASK | LEPUS_PROP_WRITABLE);
          }
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
          /* XXX: should never happen, type was reset above */
          abort();
        } else {
          if (flags & LEPUS_PROP_HAS_VALUE) {
            LEPUS_FreeValue(ctx, pr->u.value);
            pr->u.value = LEPUS_DupValue(ctx, val);
          }
          if (flags & LEPUS_PROP_HAS_WRITABLE) {
            if (lepus_update_property_flags(
                    ctx, p, &prs,
                    (prs->flags & ~LEPUS_PROP_WRITABLE) |
                        (flags & LEPUS_PROP_WRITABLE)))
              return -1;
          }
        }
      }
    }
    mask = 0;
    if (flags & LEPUS_PROP_HAS_CONFIGURABLE) mask |= LEPUS_PROP_CONFIGURABLE;
    if (flags & LEPUS_PROP_HAS_ENUMERABLE) mask |= LEPUS_PROP_ENUMERABLE;
    if (lepus_update_property_flags(ctx, p, &prs,
                                    (prs->flags & ~mask) | (flags & mask)))
      return -1;
    return TRUE;
  }

  /* handle modification of fast array elements */
  if (p->fast_array) {
    uint32_t idx;
    uint32_t prop_flags;
    if (p->class_id == LEPUS_CLASS_ARRAY) {
      if (__JS_AtomIsTaggedInt(prop)) {
        idx = __JS_AtomToUInt32(prop);
        if (idx < p->u.array.count) {
          prop_flags = get_prop_flags(flags, LEPUS_PROP_C_W_E);
          if (prop_flags != LEPUS_PROP_C_W_E) goto convert_to_slow_array;
          if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
          convert_to_slow_array:
            if (convert_fast_array_to_array(ctx, p))
              return -1;
            else
              goto redo_prop_update;
          }
          if (flags & LEPUS_PROP_HAS_VALUE) {
            set_value(ctx, &p->u.array.u.values[idx], LEPUS_DupValue(ctx, val));
          }
          return TRUE;
        }
      }
    } else if (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
               p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
      LEPUSValue num;
      int ret;

      if (!__JS_AtomIsTaggedInt(prop)) {
        /* slow path with to handle all numeric indexes */
        num = LEPUS_AtomIsNumericIndex1(ctx, prop);
        if (LEPUS_IsUndefined(num)) goto typed_array_done;
        if (LEPUS_IsException(num)) return -1;
        ret = LEPUS_NumberIsInteger(ctx, num);
        if (ret < 0) {
          LEPUS_FreeValue(ctx, num);
          return -1;
        }
        if (!ret) {
          LEPUS_FreeValue(ctx, num);
          return LEPUS_ThrowTypeErrorOrFalse(
              ctx, flags, "non integer index in typed array");
        }
        ret = LEPUS_NumberIsNegativeOrMinusZero(ctx, num);
        LEPUS_FreeValue(ctx, num);
        if (ret) {
          return LEPUS_ThrowTypeErrorOrFalse(ctx, flags,
                                             "negative index in typed array");
        }
        if (!__JS_AtomIsTaggedInt(prop)) goto typed_array_oob;
      }
      idx = __JS_AtomToUInt32(prop);
      /* if the typed array is detached, p->u.array.count = 0 */
      if (idx >= typed_array_get_length(ctx, p)) {
      typed_array_oob:
        return LEPUS_ThrowTypeErrorOrFalse(ctx, flags,
                                           "out-of-bound index in typed array");
      }
      prop_flags =
          get_prop_flags(flags, LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE);
      if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET) ||
          prop_flags != (LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE)) {
        return LEPUS_ThrowTypeErrorOrFalse(ctx, flags,
                                           "invalid descriptor flags");
      }
      if (flags & LEPUS_PROP_HAS_VALUE) {
        return LEPUS_SetPropertyValue(ctx, this_obj, LEPUS_NewInt32(ctx, idx),
                                      LEPUS_DupValue(ctx, val), flags);
      }
      return TRUE;
    typed_array_done:;
    }
  }

  return LEPUS_CreateProperty(ctx, p, prop, val, getter, setter, flags);
}

QJS_STATIC int LEPUS_DefineAutoInitProperty(
    LEPUSContext *ctx, LEPUSValueConst this_obj, LEPUSAtom prop,
    LEPUSValue (*init_func)(LEPUSContext *ctx, LEPUSObject *obj, LEPUSAtom prop,
                            void *opaque),
    void *opaque, int flags) {
  LEPUSObject *p;
  LEPUSProperty *pr;

  if (LEPUS_VALUE_IS_NOT_OBJECT(this_obj)) return FALSE;

  p = LEPUS_VALUE_GET_OBJ(this_obj);

  if (find_own_property(&pr, p, prop)) {
    /* property already exists */
    abort();
    return FALSE;
  }

  /* Specialized CreateProperty */
  pr = add_property(ctx, p, prop,
                    (flags & LEPUS_PROP_C_W_E) | LEPUS_PROP_AUTOINIT);
  if (unlikely(!pr)) return -1;
  pr->u.init.init_func = init_func;
  pr->u.init.opaque = opaque;
  return TRUE;
}

/* shortcut to add or redefine a new property value */
int LEPUS_DefinePropertyValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                              LEPUSAtom prop, LEPUSValue val, int flags) {
  int ret;
  ret = LEPUS_DefineProperty(
      ctx, this_obj, prop, val, LEPUS_UNDEFINED, LEPUS_UNDEFINED,
      flags | LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_CONFIGURABLE |
          LEPUS_PROP_HAS_WRITABLE | LEPUS_PROP_HAS_ENUMERABLE);
  LEPUS_FreeValue(ctx, val);
  return ret;
}

int LEPUS_DefinePropertyValueValue(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                   LEPUSValue prop, LEPUSValue val, int flags) {
  LEPUSAtom atom;
  int ret;
  atom = lepus_value_to_atom(ctx, prop);
  LEPUS_FreeValue(ctx, prop);
  if (unlikely(atom == LEPUS_ATOM_NULL)) {
    LEPUS_FreeValue(ctx, val);
    return -1;
  }
  ret = LEPUS_DefinePropertyValue(ctx, this_obj, atom, val, flags);
  LEPUS_FreeAtom(ctx, atom);
  return ret;
}

int LEPUS_DefinePropertyValueUint32(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                    uint32_t idx, LEPUSValue val, int flags) {
  return LEPUS_DefinePropertyValueValue(ctx, this_obj,
                                        LEPUS_NewUint32(ctx, idx), val, flags);
}

QJS_STATIC int LEPUS_DefinePropertyValueInt64(LEPUSContext *ctx,
                                              LEPUSValueConst this_obj,
                                              int64_t idx, LEPUSValue val,
                                              int flags) {
  return LEPUS_DefinePropertyValueValue(ctx, this_obj, LEPUS_NewInt64(ctx, idx),
                                        val, flags);
}

int LEPUS_DefinePropertyValueStr(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                 const char *prop, LEPUSValue val, int flags) {
  LEPUSAtom atom;
  int ret;
  atom = LEPUS_NewAtom(ctx, prop);
  ret = LEPUS_DefinePropertyValue(ctx, this_obj, atom, val, flags);
  LEPUS_FreeAtom(ctx, atom);
  return ret;
}

/* shortcut to add getter & setter */
int LEPUS_DefinePropertyGetSet(LEPUSContext *ctx, LEPUSValueConst this_obj,
                               LEPUSAtom prop, LEPUSValue getter,
                               LEPUSValue setter, int flags) {
  int ret;
  ret = LEPUS_DefineProperty(
      ctx, this_obj, prop, LEPUS_UNDEFINED, getter, setter,
      flags | LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET |
          LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_HAS_ENUMERABLE);
  LEPUS_FreeValue(ctx, getter);
  LEPUS_FreeValue(ctx, setter);
  return ret;
}

QJS_STATIC int LEPUS_CreateDataPropertyUint32(LEPUSContext *ctx,
                                              LEPUSValueConst this_obj,
                                              int64_t idx, LEPUSValue val,
                                              int flags) {
  return LEPUS_DefinePropertyValueValue(
      ctx, this_obj, LEPUS_NewInt64(ctx, idx), val,
      flags | LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_ENUMERABLE |
          LEPUS_PROP_WRITABLE);
}

QJS_STATIC BOOL lepus_object_has_name(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSProperty *pr;
  LEPUSShapeProperty *prs;
  LEPUSValueConst val;
  LEPUSString *p;

  prs = find_own_property(&pr, LEPUS_VALUE_GET_OBJ(obj), LEPUS_ATOM_name);
  if (!prs) return FALSE;
  if ((prs->flags & LEPUS_PROP_TMASK) != LEPUS_PROP_NORMAL) return TRUE;
  val = pr->u.value;
  if (!LEPUS_VALUE_IS_STRING(val)) return TRUE;
  p = LEPUS_VALUE_GET_STRING(val);
  return (p->len != 0);
}

int LEPUS_DefineObjectName(LEPUSContext *ctx, LEPUSValueConst obj,
                           LEPUSAtom name, int flags) {
  // <bytedance begin>
  obj = LEPUSRef2Value(ctx, obj);
  // <bytedance end>
  if (name != LEPUS_ATOM_NULL && LEPUS_IsObject(obj) &&
      !lepus_object_has_name(ctx, obj) &&
      LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_name,
                                LEPUS_AtomToString(ctx, name), flags) < 0) {
    return -1;
  }
  return 0;
}

int LEPUS_DefineObjectNameComputed(LEPUSContext *ctx, LEPUSValueConst obj,
                                   LEPUSValueConst str, int flags) {
  // <bytedance begin>
  obj = LEPUSRef2Value(ctx, obj);
  // <bytedance end>
  if (LEPUS_IsObject(obj) && !lepus_object_has_name(ctx, obj)) {
    LEPUSAtom prop;
    LEPUSValue name_str;
    prop = lepus_value_to_atom(ctx, str);
    if (prop == LEPUS_ATOM_NULL) return -1;
    name_str = lepus_get_function_name(ctx, prop);
    LEPUS_FreeAtom(ctx, prop);
    if (LEPUS_IsException(name_str)) return -1;
    if (LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_name, name_str, flags) <
        0)
      return -1;
  }
  return 0;
}

#define DEFINE_GLOBAL_LEX_VAR (1 << 7)
#define DEFINE_GLOBAL_FUNC_VAR (1 << 6)

LEPUSValue LEPUS_ThrowSyntaxErrorVarRedeclaration(LEPUSContext *ctx,
                                                  LEPUSAtom prop) {
#ifdef LYNX_DEV
  return LEPUS_ThrowSyntaxErrorAtom(ctx, "redeclaration of '%s'", prop);
#else
  return LEPUS_UNDEFINED;
#endif
}

/* flags is 0, DEFINE_GLOBAL_LEX_VAR or DEFINE_GLOBAL_FUNC_VAR */
/* XXX: could support exotic global object. */
int LEPUS_CheckDefineGlobalVar(LEPUSContext *ctx, LEPUSAtom prop, int flags) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  char buf[ATOM_GET_STR_BUF_SIZE];

  p = LEPUS_VALUE_GET_OBJ(ctx->global_obj);
  prs = find_own_property1(p, prop);
  /* XXX: should handle LEPUS_PROP_AUTOINIT */
  if (flags & DEFINE_GLOBAL_LEX_VAR) {
    if (prs && !(prs->flags & LEPUS_PROP_CONFIGURABLE)) goto fail_redeclaration;
  } else {
    if (!prs && !p->extensible) goto define_error;
    if (flags & DEFINE_GLOBAL_FUNC_VAR) {
      if (prs) {
        if (!(prs->flags & LEPUS_PROP_CONFIGURABLE) &&
            ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET ||
             ((prs->flags & (LEPUS_PROP_WRITABLE | LEPUS_PROP_ENUMERABLE)) !=
              (LEPUS_PROP_WRITABLE | LEPUS_PROP_ENUMERABLE)))) {
        define_error:
#ifdef LYNX_DEV
          LEPUS_ThrowTypeErrorAtom(ctx, "cannot define variable '%s'", prop);
#endif
          return -1;
        }
      }
    }
  }
  /* check if there already is a lexical declaration */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property1(p, prop);
  if (prs) {
  fail_redeclaration:
    LEPUS_ThrowSyntaxErrorVarRedeclaration(ctx, prop);
    return -1;
  }
  return 0;
}

/* def_flags is (0, DEFINE_GLOBAL_LEX_VAR) |
   LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE */
/* XXX: could support exotic global object. */
int LEPUS_DefineGlobalVar(LEPUSContext *ctx, LEPUSAtom prop, int def_flags) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  LEPUSValue val;
  int flags;

  if (def_flags & DEFINE_GLOBAL_LEX_VAR) {
    p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
    flags = LEPUS_PROP_ENUMERABLE | (def_flags & LEPUS_PROP_WRITABLE) |
            LEPUS_PROP_CONFIGURABLE;
    val = LEPUS_UNINITIALIZED;
  } else {
    p = LEPUS_VALUE_GET_OBJ(ctx->global_obj);
    flags = LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE |
            (def_flags & LEPUS_PROP_CONFIGURABLE);
    val = LEPUS_UNDEFINED;
  }
  prs = find_own_property1(p, prop);
  if (prs) return 0;
  if (!p->extensible) return 0;
  pr = add_property(ctx, p, prop, flags);
  if (unlikely(!pr)) return -1;
  pr->u.value = val;
  return 0;
}

/* 'def_flags' is 0 or LEPUS_PROP_CONFIGURABLE. */
/* XXX: could support exotic global object. */
int LEPUS_DefineGlobalFunction(LEPUSContext *ctx, LEPUSAtom prop,
                               LEPUSValueConst func, int def_flags) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  int flags;

  p = LEPUS_VALUE_GET_OBJ(ctx->global_obj);
  prs = find_own_property1(p, prop);
  flags = LEPUS_PROP_HAS_VALUE | LEPUS_PROP_THROW;
  if (!prs || (prs->flags & LEPUS_PROP_CONFIGURABLE)) {
    flags |= LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE | def_flags |
             LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_HAS_WRITABLE |
             LEPUS_PROP_HAS_ENUMERABLE;
  }
  if (LEPUS_DefineProperty(ctx, ctx->global_obj, prop, func, LEPUS_UNDEFINED,
                           LEPUS_UNDEFINED, flags) < 0)
    return -1;
  return 0;
}

LEPUSValue LEPUS_GetGlobalVar(LEPUSContext *ctx, LEPUSAtom prop,
                              BOOL throw_ref_error) {
  return LEPUS_GetGlobalVarImpl(ctx, prop, throw_ref_error, NULL);
}

LEPUSValue LEPUS_GetGlobalVarImpl(LEPUSContext *ctx, LEPUSAtom prop,
                                  BOOL throw_ref_error,
                                  TypeGetFeedBack *feedback) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;

  /* no exotic behavior is possible in global_var_obj */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    /* XXX: should handle LEPUS_PROP_TMASK properties */
    if (unlikely(LEPUS_IsUninitialized(pr->u.value)))
      return LEPUS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
    return LEPUS_DupValue(ctx, pr->u.value);
  }
  // <primjs begin>
#ifdef ENABLE_PRIMJS_IC
  if (feedback && feedback->shape == p->shape) {
    if (!feedback->proto_shape) {
      LEPUSProperty *pr = &p->prop[feedback->offset];
      return LEPUS_DupValue(ctx, pr->u.value);
    } else {
      /* Special Situation
      Lookup first as prototype
      a.__proto__ = {'b':1}
      a.b = 2
      Should invalidate inline cache */

      LEPUSProperty *pr = &p->shape->proto->prop[feedback->offset];
      return LEPUS_DupValue(ctx, pr->u.value);
    }
  }
#endif
  // <primjs end>
  return LEPUS_GetPropertyInternalImpl(
      ctx, ctx->global_obj, prop, ctx->global_obj, throw_ref_error, feedback);
}

/* construct a reference to a global variable */
int LEPUS_GetGlobalVarRef(LEPUSContext *ctx, LEPUSAtom prop, LEPUSValue *sp) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;

  /* no exotic behavior is possible in global_var_obj */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    /* XXX: should handle LEPUS_PROP_AUTOINIT properties? */
    /* XXX: conformance: do these tests in
       OP_put_var_ref/OP_get_var_ref ? */
    if (unlikely(LEPUS_IsUninitialized(pr->u.value))) {
      LEPUS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
      return -1;
    }
    if (unlikely(!(prs->flags & LEPUS_PROP_WRITABLE))) {
      return LEPUS_ThrowTypeErrorReadOnly(ctx, LEPUS_PROP_THROW, prop);
    }
    sp[0] = LEPUS_DupValue(ctx, ctx->global_var_obj);
  } else {
    int ret;
    ret = LEPUS_HasProperty(ctx, ctx->global_obj, prop);
    if (ret < 0) return -1;
    if (ret) {
      sp[0] = LEPUS_DupValue(ctx, ctx->global_obj);
    } else {
      sp[0] = LEPUS_UNDEFINED;
    }
  }
  sp[1] = LEPUS_AtomToValue(ctx, prop);
  return 0;
}

/* use for strict variable access: test if the variable exists */
int LEPUS_CheckGlobalVar(LEPUSContext *ctx, LEPUSAtom prop) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  int ret;

  /* no exotic behavior is possible in global_var_obj */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property1(p, prop);
  if (prs) {
    ret = TRUE;
  } else {
    ret = LEPUS_HasProperty(ctx, ctx->global_obj, prop);
    if (ret < 0) return -1;
  }
  return ret;
}

/* flag = 0: normal variable write
   flag = 1: initialize lexical variable
   flag = 2: normal variable write, strict check was done before
   flag = 3: add property in global var obj
*/
int LEPUS_SetGlobalVar(LEPUSContext *ctx, LEPUSAtom prop, LEPUSValue val,
                       int flag) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  int flags;

  if (flag == 3) {
    flags = LEPUS_PROP_THROW_STRICT;
    return LEPUS_SetPropertyInternal(ctx, ctx->global_var_obj, prop, val,
                                     flags);
  }
  /* no exotic behavior is possible in global_var_obj */
  p = LEPUS_VALUE_GET_OBJ(ctx->global_var_obj);
  prs = find_own_property(&pr, p, prop);
  if (prs) {
    /* XXX: should handle LEPUS_PROP_AUTOINIT properties? */
    if (flag != 1) {
      if (unlikely(LEPUS_IsUninitialized(pr->u.value))) {
        LEPUS_FreeValue(ctx, val);
        LEPUS_ThrowReferenceErrorUninitialized(ctx, prs->atom);
        return -1;
      }
      if (unlikely(!(prs->flags & LEPUS_PROP_WRITABLE))) {
        LEPUS_FreeValue(ctx, val);
        return LEPUS_ThrowTypeErrorReadOnly(ctx, LEPUS_PROP_THROW, prop);
      }
    }
    set_value(ctx, &pr->u.value, val);
    return 0;
  }

  flags = LEPUS_PROP_THROW_STRICT;
  if (flag != 2 && is_strict_mode(ctx)) flags |= LEPUS_PROP_NO_ADD;
  return LEPUS_SetPropertyInternal(ctx, ctx->global_obj, prop, val, flags);
}

/* return -1, FALSE or TRUE. return FALSE if not configurable or
   invalid object. return -1 in case of exception.
   flags can be 0, LEPUS_PROP_THROW or LEPUS_PROP_THROW_STRICT */
int LEPUS_DeleteProperty(LEPUSContext *ctx, LEPUSValueConst obj, LEPUSAtom prop,
                         int flags) {
  obj = LEPUS_ToObject(ctx, obj);
  if (LEPUS_IsException(obj)) return -1;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  int res = delete_property(ctx, p, prop);
  LEPUS_FreeValue(ctx, obj);
  if (res != FALSE) return res;
  if ((flags & LEPUS_PROP_THROW) ||
      ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
    LEPUS_ThrowTypeError(ctx, "could not delete property");
    return -1;
  }
  return FALSE;
}

QJS_STATIC int LEPUS_DeletePropertyInt64(LEPUSContext *ctx, LEPUSValueConst obj,
                                         int64_t idx, int flags) {
  LEPUSAtom prop;
  int res;

  if ((uint64_t)idx <= LEPUS_ATOM_MAX_INT) {
    /* fast path for fast arrays */
    return LEPUS_DeleteProperty(ctx, obj, __JS_AtomFromUInt32(idx), flags);
  }
  prop = LEPUS_NewAtomInt64(ctx, idx);
  if (prop == LEPUS_ATOM_NULL) return -1;
  res = LEPUS_DeleteProperty(ctx, obj, prop, flags);
  LEPUS_FreeAtom(ctx, prop);
  return res;
}

BOOL LEPUS_IsFunction(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  switch (p->class_id) {
    case LEPUS_CLASS_BYTECODE_FUNCTION:
      return TRUE;
    case LEPUS_CLASS_PROXY:
      return p->u.proxy_data->is_func;
    default:
      return (ctx->rt->class_array[p->class_id].call != NULL);
  }
}

QJS_STATIC BOOL LEPUS_IsCFunction(LEPUSContext *ctx, LEPUSValueConst val,
                                  LEPUSCFunction *func, int magic) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  if (p->class_id == LEPUS_CLASS_C_FUNCTION)
    return (p->u.cfunc.c_function.generic == func && p->u.cfunc.magic == magic);
  else
    return FALSE;
}

BOOL LEPUS_IsConstructor(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  return p->is_constructor;
}

BOOL LEPUS_SetConstructorBit(LEPUSContext *ctx, LEPUSValueConst func_obj,
                             BOOL val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(func_obj)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->is_constructor = val;
  return TRUE;
}

BOOL LEPUS_IsError(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  if (p->class_id == LEPUS_CLASS_ERROR) return TRUE;
#ifdef QJS_UNITTEST
  if (ctx->is_error_property_enabled) {
    /* check for a special property for test262 test suites */
    LEPUSValue isError;
    isError = LEPUS_GetPropertyStr(ctx, val, "isError");
    return LEPUS_ToBoolFree(ctx, isError);
  }
#endif
  return FALSE;
}

#ifdef QJS_UNITTEST
/* only used for test262 test suites */
void LEPUS_EnableIsErrorProperty(LEPUSContext *ctx, BOOL enable) {
  ctx->is_error_property_enabled = enable;
}
#endif

/* used to avoid catching interrupt exceptions */
BOOL LEPUS_IsUncatchableError(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  return p->class_id == LEPUS_CLASS_ERROR && p->is_uncatchable_error;
}

QJS_STATIC void LEPUS_SetUncatchableError(LEPUSContext *ctx,
                                          LEPUSValueConst val, BOOL flag) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return;
  p = LEPUS_VALUE_GET_OBJ(val);
  if (p->class_id == LEPUS_CLASS_ERROR) p->is_uncatchable_error = flag;
}

void LEPUS_ResetUncatchableError(LEPUSContext *ctx) {
  LEPUS_SetUncatchableError(ctx, ctx->rt->current_exception, FALSE);
}

void LEPUS_SetOpaque(LEPUSValue obj, void *opaque) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    p = LEPUS_VALUE_GET_OBJ(obj);
    p->u.opaque = opaque;
  }
}

/* return NULL if not an object of class class_id */
void *LEPUS_GetOpaque(LEPUSValueConst obj, LEPUSClassID class_id) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) return NULL;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (p->class_id != class_id) return NULL;
  return p->u.opaque;
}

void *LEPUS_GetOpaque2(LEPUSContext *ctx, LEPUSValueConst obj,
                       LEPUSClassID class_id) {
  void *p = LEPUS_GetOpaque(obj, class_id);
  if (unlikely(!p)) {
    LEPUS_ThrowTypeErrorInvalidClass(ctx, class_id);
  }
  return p;
}

LEPUSValue LEPUS_ToPrimitiveFree(LEPUSContext *ctx, LEPUSValue val, int hint) {
  int i;
  BOOL force_ordinary;

  LEPUSAtom method_name;
  LEPUSValue method, ret;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return val;
  force_ordinary = hint & HINT_FORCE_ORDINARY;
  hint &= ~HINT_FORCE_ORDINARY;
  if (!force_ordinary) {
    method = LEPUS_GetProperty(ctx, val, LEPUS_ATOM_Symbol_toPrimitive);
    if (LEPUS_IsException(method)) goto exception;
    /* ECMA says *If exoticToPrim is not undefined* but tests in
       test262 use null as a non callable converter */
    if (!LEPUS_IsUndefined(method) && !LEPUS_IsNull(method)) {
      LEPUSAtom atom;
      LEPUSValue arg;
      switch (hint) {
        case HINT_STRING:
          atom = LEPUS_ATOM_string;
          break;
        case HINT_NUMBER:
          atom = LEPUS_ATOM_number;
          break;
        default:
        case HINT_NONE:
          atom = LEPUS_ATOM_default;
          break;
#ifdef CONFIG_BIGNUM
        case HINT_INTEGER:
          atom = LEPUS_ATOM_integer;
          break;
#endif
      }
      arg = LEPUS_AtomToString(ctx, atom);
      ret = LEPUS_CallFree(ctx, method, val, 1, (LEPUSValueConst *)&arg);
      LEPUS_FreeValue(ctx, arg);
      if (LEPUS_IsException(ret)) goto exception;
      LEPUS_FreeValue(ctx, val);
      if (LEPUS_VALUE_IS_NOT_OBJECT(ret)) return ret;
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_ThrowTypeError(ctx, "toPrimitive");
    }
  }
  if (hint != HINT_STRING) hint = HINT_NUMBER;
  for (i = 0; i < 2; i++) {
    if ((i ^ hint) == 0) {
      method_name = LEPUS_ATOM_toString;
    } else {
      method_name = LEPUS_ATOM_valueOf;
    }
    method = LEPUS_GetProperty(ctx, val, method_name);
    if (LEPUS_IsException(method)) goto exception;
    if (LEPUS_IsFunction(ctx, method)) {
      ret = LEPUS_CallFree(ctx, method, val, 0, NULL);
      if (LEPUS_IsException(ret)) goto exception;
      if (LEPUS_VALUE_IS_NOT_OBJECT(ret)) {
        LEPUS_FreeValue(ctx, val);
        return ret;
      }
      LEPUS_FreeValue(ctx, ret);
    } else {
      LEPUS_FreeValue(ctx, method);
    }
  }
  LEPUS_ThrowTypeError(ctx, "toPrimitive");
exception:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue LEPUS_ToPrimitive(LEPUSContext *ctx, LEPUSValueConst val,
                                        int hint) {
  return LEPUS_ToPrimitiveFree(ctx, LEPUS_DupValue(ctx, val), hint);
}

int LEPUS_ToBoolFree(LEPUSContext *ctx, LEPUSValue val) {
  int64_t tag = LEPUS_VALUE_GET_TAG(val);
  switch (tag) {
    case LEPUS_TAG_BOOL:
      return LEPUS_VALUE_GET_BOOL(val);
    case LEPUS_TAG_INT:
      return LEPUS_VALUE_GET_INT(val) != 0;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      return FALSE;
    case LEPUS_TAG_EXCEPTION:
      return -1;
    case LEPUS_TAG_STRING: {
      BOOL ret = LEPUS_VALUE_GET_STRING(val)->len != 0;
      LEPUS_FreeValue(ctx, val);
      return ret;
    }
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      BOOL ret;
      ret = p->num.expn != BF_EXP_ZERO && p->num.expn != BF_EXP_NAN;
      LEPUS_FreeValue(ctx, val);
      return ret;
    }
#endif
// <bytedance begin>
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_BIG_INT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      BOOL ret = p->num == 0 ? FALSE : TRUE;
      LEPUS_FreeValue(ctx, val);
      return ret;
    }
#endif
      // <bytedance end>
    default:
      if (LEPUS_TAG_IS_FLOAT64(tag)) {
        double d = LEPUS_VALUE_GET_FLOAT64(val);
        return !isnan(d) && d != 0;
      } else {
        LEPUS_FreeValue(ctx, val);
        return TRUE;
      }
  }
}

int LEPUS_ToBool(LEPUSContext *ctx, LEPUSValueConst val) {
  return LEPUS_ToBoolFree(ctx, LEPUS_DupValue(ctx, val));
}

QJS_STATIC int skip_spaces(const char *pc) {
  const uint8_t *p, *p_next, *p_start;
  uint32_t c;

  p = p_start = (const uint8_t *)pc;
  for (;;) {
    c = *p;
    if (c < 128) {
      if (!((c >= 0x09 && c <= 0x0d) || (c == 0x20))) break;
      p++;
    } else {
      c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
      if (!lre_is_space(c)) break;
      p = p_next;
    }
  }
  return p - p_start;
}

#ifdef CONFIG_BIGNUM

/* force big int type if integer result */
#define BF_ATOF_BIG_INT (1 << 30)
/* return LEPUS_EXCEPTION if invalid syntax. Otherwise return NaN */
#define BF_ATOF_THROW (1 << 29)
#define BF_ATOF_FLOAT64 (1 << 28)

static LEPUSValue lepus_atof(LEPUSContext *ctx, const char *p, const char **pp,
                             int radix, int flags) {
  bf_t a_s, *a = &a_s;
  int res;
  slimb_t prec;
  LEPUSValue val;

  bf_init(ctx->bf_ctx, a);
  if (flags & BF_ATOF_FLOAT64) {
    prec = 53;
    flags |= bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL;
  } else {
    /* use the current precision */
    prec = ctx->fp_env.prec;
    flags |= ctx->fp_env.flags;
  }
  p += skip_spaces(p);
  res = bf_atof(a, p, &p, radix, prec, flags);
  if ((flags & BF_ATOF_THROW) && bf_is_nan(a)) {
    bf_delete(a);
    return LEPUS_EXCEPTION;
  }
  if (res & BF_ATOF_ST_INTEGER) {
    val = LEPUS_NewBigInt2(ctx, a, (flags & BF_ATOF_BIG_INT) != 0);
  } else if (flags & BF_ATOF_FLOAT64) {
    double d;
    bf_get_float64(a, &d, BF_RNDN);
    bf_delete(a);
    /* return int or float64 */
    val = LEPUS_NewFloat64(ctx, d);
  } else {
    val = LEPUS_NewBigFloat(ctx, a);
  }
  if (pp) *pp = p;
  return val;
}

#else

QJS_STATIC inline int to_digit(int c) {
  if (c >= '0' && c <= '9')
    return c - '0';
  else if (c >= 'A' && c <= 'Z')
    return c - 'A' + 10;
  else if (c >= 'a' && c <= 'z')
    return c - 'a' + 10;
  else
    return 36;
}

#define ATOD_INT_ONLY (1 << 0)
/* return LEPUS_EXCEPTION if invalid syntax. Otherwise return NaN */
#define ATOD_THROW (1 << 1)
/* accept Oo and Ob prefixes in addition to 0x prefix if radix = 0 */
#define ATOD_ACCEPT_BIN_OCT (1 << 2)
/* if set return NaN if empty number string */
#define ATOD_NAN_IF_EMPTY (1 << 3)
/* accept O prefix as octal if radix == 0 and properly formed (Annex B) */
#define ATOD_ACCEPT_LEGACY_OCTAL (1 << 4)
/* accept _ between digits as a digit separator */
#define ATOD_ACCEPT_UNDERSCORES (1 << 5)

/* radix = 0 accepts prefixes. radix = 16 also
   accepts 0x prefix. radix must be 0 or between 2 and 36 */
QJS_STATIC LEPUSValue lepus_atod(LEPUSContext *ctx, const char *str,
                                 const char **pp, int radix, int flags) {
  const char *p;
  const char *p_start;
  int is_neg, c, sep;
  double d;

  /* optional separator between digits */
  sep = (flags & ATOD_ACCEPT_UNDERSCORES) ? '_' : 256;

  p = str + skip_spaces(str);
  p_start = p;
  is_neg = 0;
  if (p[0] == '+') {
    p++;
    p_start++;
    if (!(flags & ATOD_INT_ONLY)) goto no_radix_prefix;
  } else if (p[0] == '-') {
    is_neg = 1;
    p++;
    p_start++;
    if (!(flags & ATOD_INT_ONLY)) goto no_radix_prefix;
  }
  if (p[0] == '0') {
    if ((p[1] == 'x' || p[1] == 'X') && (radix == 0 || radix == 16)) {
      p += 2;
      radix = 16;
    } else if ((p[1] == 'o' || p[1] == 'O') && radix == 0 &&
               (flags & ATOD_ACCEPT_BIN_OCT)) {
      p += 2;
      radix = 8;
    } else if ((p[1] == 'b' || p[1] == 'B') && radix == 0 &&
               (flags & ATOD_ACCEPT_BIN_OCT)) {
      p += 2;
      radix = 2;
    } else if ((p[1] >= '0' && p[1] <= '9') && radix == 0 &&
               (flags & ATOD_ACCEPT_LEGACY_OCTAL)) {
      int i;
      sep = 256;
      for (i = 1; (p[i] >= '0' && p[i] <= '7'); i++) continue;
      if (p[i] == '8' || p[i] == '9') goto no_prefix;
      p += 1;
      radix = 8;
    } else {
      goto no_prefix;
    }
    /* there must be a digit after the prefix */
    if (to_digit((uint8_t)*p) >= radix) goto fail;
  no_prefix:;
  } else {
  no_radix_prefix:
    if (!(flags & ATOD_INT_ONLY) && strstart(p, "Infinity", &p)) {
      d = 1.0 / 0.0;
      goto done;
    }
  }
  if (radix == 0) radix = 10;
  if ((flags & ATOD_INT_ONLY) || radix != 10) {
    uint64_t n_max, n;
    int int_exp;

    /* skip leading zeros */
    while (*p == '0') p++;
    n = 0;
    if (radix == 10)
      n_max = ((uint64_t)-1 - 9) / 10; /* most common case */
    else
      n_max = ((uint64_t)-1 - (radix - 1)) / radix;
    /* XXX: could be more precise */
    int_exp = 0;
    while (*p != '\0') {
      if (*p == sep && to_digit(p[1]) < radix) p++;
      c = to_digit((uint8_t)*p);
      if (c >= radix) break;
      if (n <= n_max) {
        n = n * radix + c;
      } else {
        int_exp++;
      }
      p++;
    }
    d = n;
    if (int_exp != 0) {
      d *= pow(radix, int_exp);
    }
  } else {
    p_start = p;
    while (is_digit((uint8_t)*p) ||
           (*p == sep && (p != p_start + 1 || p[-1] != '0') &&
            is_digit((uint8_t)p[1]))) {
      p++;
    }
    if (*p == '.' && (p > p_start || is_digit((uint8_t)p[1]))) {
      p++;
      if (*p == sep) goto fail;
      while (is_digit((uint8_t)*p) || (*p == sep && is_digit((uint8_t)p[1])))
        p++;
    }
    if (p > p_start && (*p == 'e' || *p == 'E')) {
      const char *p1 = p + 1;
      if (*p1 == '+') {
        p1++;
      } else if (*p1 == '-') {
        p1++;
      }
      if (is_digit((uint8_t)*p1)) {
        p = p1 + 1;
        while (is_digit((uint8_t)*p) || (*p == sep && is_digit((uint8_t)p[1])))
          p++;
      }
    }
    if (*p == '\0' && sep != '_') {
      d = strtod(p_start, NULL);
    } else {
      char buf1[64], *buf;
      int i, j, len;
      BOOL buf_allocated;

      buf = buf1;
      buf_allocated = FALSE;
      len = p - p_start;
      if (len >= sizeof(buf1)) {
        buf = static_cast<char *>(lepus_malloc(ctx, len + 1));
        if (!buf) return LEPUS_EXCEPTION;
        buf_allocated = TRUE;
      }
      for (i = j = 0; i < len; i++) {
        if (p_start[i] != '_') buf[j++] = p_start[i];
      }
      buf[j] = '\0';
      d = strtod(buf, NULL);
      if (buf_allocated) lepus_free(ctx, buf);
    }
  }
done:
  if (is_neg) d = -d;
  if (p == p_start && (flags & ATOD_NAN_IF_EMPTY)) {
    d = LEPUS_FLOAT64_NAN;
  }
  if (pp) *pp = p;
  return LEPUS_NewFloat64(ctx, d);
fail:
  if (pp) *pp = p;
  if (flags & ATOD_THROW)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NAN;
}
#endif

typedef enum LEPUSToNumberHintEnum {
  TON_FLAG_NUMBER,
  TON_FLAG_INTEGER,
  TON_FLAG_NUMERIC,
} LEPUSToNumberHintEnum;

QJS_STATIC LEPUSValue LEPUS_ToNumberHintFree(LEPUSContext *ctx, LEPUSValue val,
                                             LEPUSToNumberHintEnum flag) {
  int64_t tag;
  LEPUSValue ret;
  int hint;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
      if (flag == TON_FLAG_NUMBER && !is_bignum_mode(ctx)) {
        LEPUS_FreeValue(ctx, val);
        return LEPUS_ThrowTypeError(ctx, "cannot convert bigint to number");
      }
      /* fall thru */
    case LEPUS_TAG_BIG_FLOAT:
#endif
    case LEPUS_TAG_FLOAT64:
    case LEPUS_TAG_INT:
    case LEPUS_TAG_EXCEPTION:
      ret = val;
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(val));
      break;
    case LEPUS_TAG_NULL:
      ret = LEPUS_NewInt32(ctx, 0);
      break;
    case LEPUS_TAG_UNDEFINED:
      ret = LEPUS_NAN;
      break;
    case LEPUS_TAG_OBJECT:
#ifdef CONFIG_BIGNUM
      hint = flag == TON_FLAG_INTEGER ? HINT_INTEGER : HINT_NUMBER;
#else
      hint = HINT_NUMBER;
#endif
      val = LEPUS_ToPrimitiveFree(ctx, val, hint);
      if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
      goto redo;
    case LEPUS_TAG_STRING: {
      const char *str;
      const char *p;

      str = LEPUS_ToCString(ctx, val);
      LEPUS_FreeValue(ctx, val);
      if (!str) return LEPUS_EXCEPTION;
#ifdef CONFIG_BIGNUM
      {
        int flags;
        flags = BF_ATOF_BIN_OCT | BF_ATOF_NO_PREFIX_AFTER_SIGN |
                BF_ATOF_JS_QUIRKS | BF_ATOF_FLOAT64;
        if (is_bignum_mode(ctx))
          flags |= BF_ATOF_INT_PREC_INF;
        else
          flags |= BF_ATOF_ONLY_DEC_FLOAT;
        ret = lepus_atof(ctx, str, &p, 0, flags);
      }
#else
      ret = lepus_atod(ctx, str, &p, 0, ATOD_ACCEPT_BIN_OCT);
#endif
      p += skip_spaces(p);
      if (*p != '\0') {
        LEPUS_FreeValue(ctx, ret);
        ret = LEPUS_NAN;
      }
      LEPUS_FreeCString(ctx, str);
    } break;
    case LEPUS_TAG_SYMBOL:
      LEPUS_FreeValue(ctx, val);
      return LEPUS_ThrowTypeError(ctx, "cannot convert symbol to number");
    default:
      LEPUS_FreeValue(ctx, val);
      ret = LEPUS_NAN;
      break;
  }
  return ret;
}

QJS_STATIC LEPUSValue LEPUS_ToNumberFree(LEPUSContext *ctx, LEPUSValue val) {
  return LEPUS_ToNumberHintFree(ctx, val, TON_FLAG_NUMBER);
}

#ifdef CONFIG_BIGNUM
static LEPUSValue LEPUS_ToNumericFree(LEPUSContext *ctx, LEPUSValue val) {
  return LEPUS_ToNumberHintFree(ctx, val, TON_FLAG_NUMERIC);
}

static LEPUSValue LEPUS_ToNumeric(LEPUSContext *ctx, LEPUSValueConst val) {
  return LEPUS_ToNumericFree(ctx, LEPUS_DupValue(ctx, val));
}
#endif

QJS_STATIC __exception int __JS_ToFloat64Free(LEPUSContext *ctx, double *pres,
                                              LEPUSValue val) {
  double d;
  int64_t tag;

  val = LEPUS_ToNumberFree(ctx, val);
  if (LEPUS_IsException(val)) {
    *pres = LEPUS_FLOAT64_NAN;
    return -1;
  }
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      d = LEPUS_VALUE_GET_INT(val);
      break;
    case LEPUS_TAG_FLOAT64:
      d = LEPUS_VALUE_GET_FLOAT64(val);
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      /* XXX: there can be a double rounding issue with some
         primitives (such as LEPUS_ToUint8ClampFree()), but it is
         not critical to fix it. */
      bf_get_float64(&p->num, &d, BF_RNDN);
      LEPUS_FreeValue(ctx, val);
    } break;
#endif
    default:
      abort();
  }
  *pres = d;
  return 0;
}

QJS_STATIC inline int LEPUS_ToFloat64Free(LEPUSContext *ctx, double *pres,
                                          LEPUSValue val) {
  if (LEPUS_VALUE_IS_FLOAT64(val)) {
    *pres = LEPUS_VALUE_GET_FLOAT64(val);
    return 0;
  } else if (LEPUS_VALUE_IS_INT(val)) {
    *pres = LEPUS_VALUE_GET_INT(val);
    return 0;
  } else if (LEPUS_VALUE_IS_BOOL(val)) {
    *pres = LEPUS_VALUE_GET_BOOL(val);
    return 0;
  } else if (LEPUS_VALUE_IS_NULL(val)) {
    *pres = 0;
    return 0;
  } else {
    return __JS_ToFloat64Free(ctx, pres, val);
  }
}

int LEPUS_ToFloat64(LEPUSContext *ctx, double *pres, LEPUSValueConst val) {
  return LEPUS_ToFloat64Free(ctx, pres, LEPUS_DupValue(ctx, val));
}

QJS_STATIC LEPUSValue LEPUS_ToNumber(LEPUSContext *ctx, LEPUSValueConst val) {
  return LEPUS_ToNumberFree(ctx, LEPUS_DupValue(ctx, val));
}

QJS_STATIC __attribute__((unused)) LEPUSValue LEPUS_ToIntegerFree(
    LEPUSContext *ctx, LEPUSValue val) {
  int64_t tag;
  LEPUSValue ret;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      ret = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_INT(val));
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(val));
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      ret = LEPUS_NewInt32(ctx, 0);
      break;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (isnan(d)) {
        ret = LEPUS_NewInt32(ctx, 0);
      } else {
        /* convert -0 to +0 */
        /* XXX: should not be done here ? */
        d = trunc(d) + 0.0;
        ret = LEPUS_NewFloat64(ctx, d);
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
      if (!is_bignum_mode(ctx)) goto to_number;
      ret = val;
      break;
    case LEPUS_TAG_BIG_FLOAT: {
      bf_t a_s, *a, r_s, *r = &r_s;
      BOOL is_float, is_nan;

      a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, val);
      if (!bf_is_finite(a)) {
        is_nan = bf_is_nan(a);
        if (is_nan)
          ret = LEPUS_NewInt32(ctx, 0);
        else
          ret = LEPUS_DupValue(ctx, val);
      } else {
        bf_init(ctx->bf_ctx, r);
        bf_set(r, a);
        bf_rint(r, BF_PREC_INF, BF_RNDZ);
        ret = LEPUS_NewBigInt(ctx, r);
      }
      if (a == &a_s) bf_delete(a);
      LEPUS_FreeValue(ctx, val);
    } break;
#endif
    default:
#ifdef CONFIG_BIGNUM
    to_number:
#endif
      val = LEPUS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) return val;
      goto redo;
  }
  return ret;
}

/* Note: the integer value is satured to 32 bits */
QJS_STATIC int LEPUS_ToInt32SatFree(LEPUSContext *ctx, int *pres,
                                    LEPUSValue val) {
  int64_t tag;
  int ret;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      ret = LEPUS_VALUE_GET_INT(val);
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_VALUE_GET_BOOL(val);
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      ret = 0;
      break;
    case LEPUS_TAG_EXCEPTION:
      *pres = 0;
      return -1;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (isnan(d)) {
        ret = 0;
      } else {
        if (d < INT32_MIN)
          ret = INT32_MIN;
        else if (d > INT32_MAX)
          ret = INT32_MAX;
        else
          ret = (int)d;
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
    to_bf : {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_get_int32(&ret, &p->num, 0);
      LEPUS_FreeValue(ctx, val);
    } break;
    case LEPUS_TAG_BIG_INT:
      if (is_bignum_mode(ctx)) goto to_bf;
        /* fall thru */
#endif
    default:
      val = LEPUS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
  *pres = ret;
  return 0;
}

QJS_STATIC int LEPUS_ToInt32Sat(LEPUSContext *ctx, int *pres,
                                LEPUSValueConst val) {
  return LEPUS_ToInt32SatFree(ctx, pres, LEPUS_DupValue(ctx, val));
}

QJS_STATIC int LEPUS_ToInt32Clamp(LEPUSContext *ctx, int *pres,
                                  LEPUSValueConst val, int min, int max,
                                  int min_offset) {
  int res = LEPUS_ToInt32SatFree(ctx, pres, LEPUS_DupValue(ctx, val));
  if (res == 0) {
    if (*pres < min) {
      *pres += min_offset;
      if (*pres < min) *pres = min;
    } else {
      if (*pres > max) *pres = max;
    }
  }
  return res;
}

QJS_STATIC int LEPUS_ToInt64SatFree(LEPUSContext *ctx, int64_t *pres,
                                    LEPUSValue val) {
  int64_t tag;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      *pres = LEPUS_VALUE_GET_INT(val);
      return 0;
    case LEPUS_TAG_BOOL:
      *pres = LEPUS_VALUE_GET_BOOL(val);
      return 0;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      *pres = 0;
      return 0;
    case LEPUS_TAG_EXCEPTION:
      *pres = 0;
      return -1;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (isnan(d)) {
        *pres = 0;
      } else {
        if (d < INT64_MIN)
          *pres = INT64_MIN;
        else if (d > INT64_MAX)
          *pres = INT64_MAX;
        else
          *pres = (int64_t)d;
      }
    }
      return 0;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
    to_bf : {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_get_int64(pres, &p->num, 0);
      LEPUS_FreeValue(ctx, val);
    }
      return 0;
    case LEPUS_TAG_BIG_INT:
      if (is_bignum_mode(ctx)) goto to_bf;
        /* fall thru */
#endif
    default:
      val = LEPUS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
}

QJS_STATIC int LEPUS_ToInt64Sat(LEPUSContext *ctx, int64_t *pres,
                                LEPUSValueConst val) {
  return LEPUS_ToInt64SatFree(ctx, pres, LEPUS_DupValue(ctx, val));
}

QJS_STATIC int LEPUS_ToInt64Clamp(LEPUSContext *ctx, int64_t *pres,
                                  LEPUSValueConst val, int64_t min, int64_t max,
                                  int64_t neg_offset) {
  int res = LEPUS_ToInt64SatFree(ctx, pres, LEPUS_DupValue(ctx, val));
  if (res == 0) {
    if (*pres < 0) *pres += neg_offset;
    if (*pres < min)
      *pres = min;
    else if (*pres > max)
      *pres = max;
  }
  return res;
}

/* Same as LEPUS_ToInt32Free() but with a 64 bit result. Return (<0, 0)
   in case of exception */
QJS_STATIC int LEPUS_ToInt64Free(LEPUSContext *ctx, int64_t *pres,
                                 LEPUSValue val) {
  int64_t tag;
  int64_t ret;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      ret = LEPUS_VALUE_GET_INT(val);
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_VALUE_GET_BOOL(val);
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      ret = 0;
      break;
    case LEPUS_TAG_FLOAT64: {
      LEPUSFloat64Union u;
      double d;
      int e;
      d = LEPUS_VALUE_GET_FLOAT64(val);
      u.d = d;
      /* we avoid doing fmod(x, 2^64) */
      e = (u.u64 >> 52) & 0x7ff;
      if (likely(e <= (1023 + 62))) {
        /* fast case */
        ret = (int64_t)d;
      } else if (e <= (1023 + 62 + 53)) {
        uint64_t v;
        /* remainder modulo 2^64 */
        v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);
        ret = v << ((e - 1023) - 52);
        /* take the sign into account */
        if (u.u64 >> 63) ret = -ret;
      } else {
        ret = 0; /* also handles NaN and +inf */
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
    to_bf : {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_get_int64(&ret, &p->num, BF_GET_INT_MOD);
      LEPUS_FreeValue(ctx, val);
    } break;
    case LEPUS_TAG_BIG_INT:
      if (is_bignum_mode(ctx)) goto to_bf;
        /* fall thru */
#else
#ifdef ENABLE_LEPUSNG
    // <ByteDance change>
    case LEPUS_TAG_BIG_INT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      ret = p->num;
      LEPUS_FreeValue(ctx, val);
      break;
    }
#endif
#endif
    default:
      val = LEPUS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
  *pres = ret;
  return 0;
}

// <ByteDance begin>
// ref: https://bytedance.feishu.cn/docs/doccnieaLrWRdiuZSaS95tnNLcf#QbENE1
void LEPUS_SetNoStrictMode(LEPUSContext *ctx) {
  ctx->no_lepus_strict_mode = TRUE;
}
// <ByteDance end>

int LEPUS_ToInt64(LEPUSContext *ctx, int64_t *pres, LEPUSValueConst val) {
  return LEPUS_ToInt64Free(ctx, pres, LEPUS_DupValue(ctx, val));
}

/* return (<0, 0) in case of exception */
QJS_STATIC int LEPUS_ToInt32Free(LEPUSContext *ctx, int32_t *pres,
                                 LEPUSValue val) {
  int64_t tag;
  int32_t ret;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      ret = LEPUS_VALUE_GET_INT(val);
      break;
    case LEPUS_TAG_BOOL:
      ret = LEPUS_VALUE_GET_BOOL(val);
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      ret = 0;
      break;
    case LEPUS_TAG_FLOAT64: {
      LEPUSFloat64Union u;
      double d;
      int e;
      d = LEPUS_VALUE_GET_FLOAT64(val);
      u.d = d;
      /* we avoid doing fmod(x, 2^32) */
      e = (u.u64 >> 52) & 0x7ff;
      if (likely(e <= (1023 + 30))) {
        /* fast case */
        ret = (int32_t)d;
      } else if (e <= (1023 + 30 + 53)) {
        uint64_t v;
        /* remainder modulo 2^32 */
        v = (u.u64 & (((uint64_t)1 << 52) - 1)) | ((uint64_t)1 << 52);
        v = v << ((e - 1023) - 52 + 32);
        ret = v >> 32;
        /* take the sign into account */
        if (u.u64 >> 63) ret = -ret;
      } else {
        ret = 0; /* also handles NaN and +inf */
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
    to_bf : {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_get_int32(&ret, &p->num, BF_GET_INT_MOD);
      LEPUS_FreeValue(ctx, val);
    } break;
    case LEPUS_TAG_BIG_INT:
      if (is_bignum_mode(ctx)) goto to_bf;
        /* fall thru */
#endif
    default:
      val = LEPUS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
  *pres = ret;
  return 0;
}

int LEPUS_ToInt32(LEPUSContext *ctx, int32_t *pres, LEPUSValueConst val) {
  return LEPUS_ToInt32Free(ctx, pres, LEPUS_DupValue(ctx, val));
}

QJS_STATIC inline int LEPUS_ToUint32Free(LEPUSContext *ctx, uint32_t *pres,
                                         LEPUSValue val) {
  return LEPUS_ToInt32Free(ctx, (int32_t *)pres, val);
}

QJS_STATIC int LEPUS_ToUint8ClampFree(LEPUSContext *ctx, int32_t *pres,
                                      LEPUSValue val) {
  int64_t tag;
  int res;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      res = LEPUS_VALUE_GET_INT(val);
      res = max_int(0, min_int(255, res));
      break;
    case LEPUS_TAG_BOOL:
      res = LEPUS_VALUE_GET_BOOL(val);
      res = max_int(0, min_int(255, res));
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      res = 0;
#ifdef CONFIG_BIGNUM
    int_clamp:
#endif
      res = max_int(0, min_int(255, res));
      break;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (isnan(d)) {
        res = 0;
      } else {
        if (d < 0)
          res = 0;
        else if (d > 255)
          res = 255;
        else
          res = lrint(d);
      }
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      if (!is_bignum_mode(ctx)) goto to_number;
      bf_get_int32(&res, &p->num, 0);
      LEPUS_FreeValue(ctx, val);
    }
      goto int_clamp;
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_t r_s, *r = &r_s;
      bf_init(ctx->bf_ctx, r);
      bf_set(r, &p->num);
      bf_rint(r, BF_PREC_INF, BF_RNDN);
      bf_get_int32(&res, r, 0);
      bf_delete(r);
      LEPUS_FreeValue(ctx, val);
    }
      goto int_clamp;
#endif
    default:
#ifdef CONFIG_BIGNUM
    to_number:
#endif
      val = LEPUS_ToNumberFree(ctx, val);
      if (LEPUS_IsException(val)) {
        *pres = 0;
        return -1;
      }
      goto redo;
  }
  *pres = res;
  return 0;
}

QJS_STATIC __exception int LEPUS_ToArrayLengthFree(LEPUSContext *ctx,
                                                   uint32_t *plen,
                                                   LEPUSValue val,
                                                   BOOL is_array_ctor) {
  int64_t tag;
  uint32_t len;

  tag = LEPUS_VALUE_GET_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT: {
      int v;
      v = LEPUS_VALUE_GET_INT(val);
      if (v < 0) goto fail;
      len = v;
    } break;
    case LEPUS_TAG_BOOL: {
      int v;
      v = LEPUS_VALUE_GET_BOOL(val);
      len = v;
    } break;
    case LEPUS_TAG_NULL: {
      int v;
      v = 0;
      len = v;
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_t a;
      BOOL res;
      bf_get_int32((int32_t *)&len, &p->num, BF_GET_INT_MOD);
      bf_init(ctx->bf_ctx, &a);
      bf_set_ui(&a, len);
      res = bf_cmp_eq(&a, &p->num);
      bf_delete(&a);
      LEPUS_FreeValue(ctx, val);
      if (!res) goto fail;
    } break;
#endif
    default:
      if (LEPUS_TAG_IS_FLOAT64(tag)) {
        double d;
        d = LEPUS_VALUE_GET_FLOAT64(val);
        len = (uint32_t)d;
        if (len != d) goto fail;
      } else {
        uint32_t len1;
        if (is_array_ctor) {
          val = LEPUS_ToNumberFree(ctx, val);
          if (LEPUS_IsException(val)) return -1;
          /* cannot recurse because val is a number */
          if (LEPUS_ToArrayLengthFree(ctx, &len, val, TRUE)) return -1;
        } else {
          /* legacy behavior: must do the conversion twice and compare */
          if (LEPUS_ToUint32(ctx, &len, val)) {
            LEPUS_FreeValue(ctx, val);
            return -1;
          }
          val = LEPUS_ToNumberFree(ctx, val);
          if (LEPUS_IsException(val)) return -1;
          /* cannot recurse because val is a number */
          if (LEPUS_ToArrayLengthFree(ctx, &len1, val, FALSE)) return -1;
          if (len1 != len) {
          fail:
            LEPUS_ThrowRangeError(ctx, "invalid array length");
            return -1;
          }
        }
      }
      break;
  }
  *plen = len;
  return 0;
}

#define MAX_SAFE_INTEGER (((int64_t)1 << 53) - 1)

int LEPUS_ToIndex(LEPUSContext *ctx, uint64_t *plen, LEPUSValueConst val) {
  int64_t v;
  if (LEPUS_ToInt64Sat(ctx, &v, val)) return -1;
  if (v < 0 || v > MAX_SAFE_INTEGER) {
    LEPUS_ThrowRangeError(ctx, "invalid array index");
    *plen = 0;
    return -1;
  }
  *plen = v;
  return 0;
}

/* convert a value to a length between 0 and MAX_SAFE_INTEGER.
   return -1 for exception */
QJS_STATIC __exception int LEPUS_ToLengthFree(LEPUSContext *ctx, int64_t *plen,
                                              LEPUSValue val) {
  int res = LEPUS_ToInt64Clamp(ctx, plen, val, 0, MAX_SAFE_INTEGER, 0);
  LEPUS_FreeValue(ctx, val);
  return res;
}

/* Note: can return an exception */
/* XXX: bignum case */
QJS_STATIC int LEPUS_NumberIsInteger(LEPUSContext *ctx, LEPUSValueConst val) {
  double d;
  if (!LEPUS_IsNumber(val)) return FALSE;
  if (unlikely(LEPUS_ToFloat64(ctx, &d, val))) return -1;
  return isfinite(d) && floor(d) == d;
}

QJS_STATIC BOOL LEPUS_NumberIsNegativeOrMinusZero(LEPUSContext *ctx,
                                                  LEPUSValueConst val) {
  int64_t tag;

  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT: {
      int v;
      v = LEPUS_VALUE_GET_INT(val);
      return (v < 0);
    }
    case LEPUS_TAG_FLOAT64: {
      LEPUSFloat64Union u;
      u.d = LEPUS_VALUE_GET_FLOAT64(val);
      return (u.u64 >> 63);
    }
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      /* Note: integer zeros are not necessarily positive */
      return p->num.sign && !bf_is_zero(&p->num);
    }
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      return p->num.sign;
    } break;
#endif
    default:
      return FALSE;
  }
}

#ifdef CONFIG_BIGNUM

static LEPUSValue lepus_ftoa(LEPUSContext *ctx, LEPUSValueConst val1, int radix,
                             limb_t prec, bf_flags_t flags) {
  LEPUSValue val, ret;
  bf_t a_s, *a;
  BOOL is_float;
  char *str;
  int saved_sign;

  val = LEPUS_ToNumeric(ctx, val1);
  if (LEPUS_IsException(val)) return val;
  a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, val);
  saved_sign = a->sign;
  if (a->expn == BF_EXP_ZERO) a->sign = 0;
  flags |= BF_FTOA_JS_QUIRKS;
  if ((flags & BF_FTOA_FORMAT_MASK) == BF_FTOA_FORMAT_FREE_MIN) {
    /* Note: for floating point numbers with a radix which is not
       a power of two, the current precision is used to compute
       the number of digits. For integers, the full precision is
       always returned. */
    if (is_float || (flags & BF_FTOA_FORCE_EXP)) {
      if ((radix & (radix - 1)) != 0) {
        bf_t r_s, *r = &r_s;
        int prec, flags1;
        /* must round first */
        if (LEPUS_VALUE_GET_TAG(val) == LEPUS_TAG_BIG_FLOAT) {
          prec = ctx->fp_env.prec;
          flags1 =
              ctx->fp_env.flags &
              (BF_FLAG_SUBNORMAL | (BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT));
        } else {
          prec = 53;
          flags1 = bf_set_exp_bits(11) | BF_FLAG_SUBNORMAL;
        }
        bf_init(ctx->bf_ctx, r);
        bf_set(r, a);
        bf_round(r, prec, flags1 | BF_RNDN);
        bf_ftoa(&str, r, radix, prec, flags1 | flags);
        bf_delete(r);
      } else {
        bf_ftoa(&str, a, radix, BF_PREC_INF, flags);
      }
    } else {
      bf_ftoa(&str, a, radix, 0,
              BF_RNDZ | BF_FTOA_FORMAT_FRAC | BF_FTOA_JS_QUIRKS);
    }
  } else {
    bf_ftoa(&str, a, radix, prec, flags);
  }
  a->sign = saved_sign;
  if (a == &a_s) bf_delete(a);
  LEPUS_FreeValue(ctx, val);
  ret = LEPUS_NewString(ctx, str);
  bf_realloc(ctx->bf_ctx, str, 0);
  return ret;
}

#else /* !CONFIG_BIGNUM */

/* 2 <= base <= 36 */
QJS_STATIC char *i64toa(char *buf_end, int64_t n, unsigned int base) {
  char *q = buf_end;
  int digit, is_neg;

  is_neg = 0;
  if (n < 0) {
    is_neg = 1;
    n = -n;
  }
  *--q = '\0';
  do {
    digit = (uint64_t)n % base;
    n = (uint64_t)n / base;
    if (digit < 10)
      digit += '0';
    else
      digit += 'a' - 10;
    *--q = digit;
  } while (n != 0);
  if (is_neg) *--q = '-';
  return q;
}

/* buf1 contains the printf result */
QJS_STATIC void lepus_ecvt1(double d, int n_digits, int *decpt, int *sign,
                            char *buf, int rounding_mode, char *buf1,
                            int buf1_size) {
  if (rounding_mode != FE_TONEAREST) {
#ifdef LYNX_DEV
#ifndef LYNX_ARMEABI
    fesetround(rounding_mode);
#endif
#endif
  }
  snprintf(buf1, buf1_size, "%+.*e", n_digits - 1, d);
  if (rounding_mode != FE_TONEAREST) {
#ifdef LYNX_DEV
#ifndef LYNX_ARMEABI
    fesetround(FE_TONEAREST);
#endif
#endif
  }
  *sign = (buf1[0] == '-');
  /* mantissa */
  buf[0] = buf1[1];
  if (n_digits > 1) memcpy(buf + 1, buf1 + 3, n_digits - 1);
  buf[n_digits] = '\0';
  /* exponent */
  *decpt = atoi(buf1 + n_digits + 2 + (n_digits > 1)) + 1;
}

/* maximum buffer size for lepus_dtoa */
#define LEPUS_DTOA_BUF_SIZE 128

/* needed because ecvt usually limits the number of digits to
   17. Return the number of digits. */
QJS_STATIC int lepus_ecvt(double d, int n_digits, int *decpt, int *sign,
                          char *buf, BOOL is_fixed) {
  int rounding_mode;
  char buf_tmp[LEPUS_DTOA_BUF_SIZE];

  if (!is_fixed) {
    unsigned int n_digits_min, n_digits_max;
    /* find the minimum amount of digits (XXX: inefficient but simple) */
    n_digits_min = 1;
    n_digits_max = 17;
    while (n_digits_min < n_digits_max) {
      n_digits = (n_digits_min + n_digits_max) / 2;
      lepus_ecvt1(d, n_digits, decpt, sign, buf, FE_TONEAREST, buf_tmp,
                  sizeof(buf_tmp));
      if (strtod(buf_tmp, NULL) == d) {
        /* no need to keep the trailing zeros */
        while (n_digits >= 2 && buf[n_digits - 1] == '0') n_digits--;
        n_digits_max = n_digits;
      } else {
        n_digits_min = n_digits + 1;
      }
    }
    n_digits = n_digits_max;
    rounding_mode = FE_TONEAREST;
  } else {
    rounding_mode = FE_TONEAREST;
#ifdef CONFIG_PRINTF_RNDN
    {
      char buf1[LEPUS_DTOA_BUF_SIZE], buf2[LEPUS_DTOA_BUF_SIZE];
      int decpt1, sign1, decpt2, sign2;
      /* The LEPUS rounding is specified as round to nearest ties away
         from zero (RNDNA), but in printf the "ties" case is not
         specified (for example it is RNDN for glibc, RNDNA for
         Windows), so we must round manually. */
      lepus_ecvt1(d, n_digits + 1, &decpt1, &sign1, buf1, FE_TONEAREST, buf_tmp,
                  sizeof(buf_tmp));
      /* XXX: could use 2 digits to reduce the average running time */
      if (buf1[n_digits] == '5') {
        lepus_ecvt1(d, n_digits + 1, &decpt1, &sign1, buf1, FE_DOWNWARD,
                    buf_tmp, sizeof(buf_tmp));
        lepus_ecvt1(d, n_digits + 1, &decpt2, &sign2, buf2, FE_UPWARD, buf_tmp,
                    sizeof(buf_tmp));
        if (memcmp(buf1, buf2, n_digits + 1) == 0 && decpt1 == decpt2) {
          /* exact result: round away from zero */
          if (sign1)
            rounding_mode = FE_DOWNWARD;
          else
            rounding_mode = FE_UPWARD;
        }
      }
    }
#endif /* CONFIG_PRINTF_RNDN */
  }
  lepus_ecvt1(d, n_digits, decpt, sign, buf, rounding_mode, buf_tmp,
              sizeof(buf_tmp));
  return n_digits;
}

QJS_STATIC int lepus_fcvt1(char *buf, int buf_size, double d, int n_digits,
                           int rounding_mode) {
  int n;
  if (rounding_mode != FE_TONEAREST) {
#ifdef LYNX_DEV
#ifndef LYNX_ARMEABI
    fesetround(rounding_mode);
#endif
#endif
  }
  n = snprintf(buf, buf_size, "%.*f", n_digits, d);
  if (rounding_mode != FE_TONEAREST) {
#ifdef LYNX_DEV
#ifndef LYNX_ARMEABI
    fesetround(FE_TONEAREST);
#endif
#endif
  }
  assert(n < buf_size);
  return n;
}

QJS_STATIC void lepus_fcvt(char *buf, int buf_size, double d, int n_digits) {
  int rounding_mode;
  rounding_mode = FE_TONEAREST;
#ifdef CONFIG_PRINTF_RNDN
  {
    int n1, n2;
    char buf1[LEPUS_DTOA_BUF_SIZE];
    char buf2[LEPUS_DTOA_BUF_SIZE];

    /* The LEPUS rounding is specified as round to nearest ties away from
       zero (RNDNA), but in printf the "ties" case is not specified
       (for example it is RNDN for glibc, RNDNA for Windows), so we
       must round manually. */
    n1 = lepus_fcvt1(buf1, sizeof(buf1), d, n_digits + 1, FE_TONEAREST);
    rounding_mode = FE_TONEAREST;
    /* XXX: could use 2 digits to reduce the average running time */
    if (buf1[n1 - 1] == '5') {
      n1 = lepus_fcvt1(buf1, sizeof(buf1), d, n_digits + 1, FE_DOWNWARD);
      n2 = lepus_fcvt1(buf2, sizeof(buf2), d, n_digits + 1, FE_UPWARD);
      if (n1 == n2 && memcmp(buf1, buf2, n1) == 0) {
        /* exact result: round away from zero */
        if (buf1[0] == '-')
          rounding_mode = FE_DOWNWARD;
        else
          rounding_mode = FE_UPWARD;
      }
    }
  }
#endif /* CONFIG_PRINTF_RNDN */
  lepus_fcvt1(buf, buf_size, d, n_digits, rounding_mode);
}

/* radix != 10 is only supported with flags = LEPUS_DTOA_VAR_FORMAT */
/* use as many digits as necessary */
#define LEPUS_DTOA_VAR_FORMAT (0 << 0)
/* use n_digits significant digits (1 <= n_digits <= 101) */
#define LEPUS_DTOA_FIXED_FORMAT (1 << 0)
/* force fractional format: [-]dd.dd with n_digits fractional digits */
#define LEPUS_DTOA_FRAC_FORMAT (2 << 0)
/* force exponential notation either in fixed or variable format */
#define LEPUS_DTOA_FORCE_EXP (1 << 2)

/* XXX: slow and maybe not fully correct
   XXX: radix != 10 is only supported for small integers
*/
QJS_STATIC void lepus_dtoa1(char *buf, double d, int radix, int n_digits,
                            int flags) {
  char *q;

  if (!isfinite(d)) {
    if (isnan(d)) {
      strcpy(buf, "NaN");
    } else {
      q = buf;
      if (d < 0) *q++ = '-';
      strcpy(q, "Infinity");
    }
  } else if (flags == LEPUS_DTOA_VAR_FORMAT) {
    int64_t i64;
    char buf1[70], *ptr;
    i64 = (int64_t)d;
    if (d != i64 || i64 > MAX_SAFE_INTEGER || i64 < -MAX_SAFE_INTEGER)
      goto generic_conv;
    /* fast path for integers */
    ptr = i64toa(buf1 + sizeof(buf1), i64, radix);
    strcpy(buf, ptr);
  } else {
    if (d == 0.0) d = 0.0; /* convert -0 to 0 */
    if (flags == LEPUS_DTOA_FRAC_FORMAT) {
      lepus_fcvt(buf, LEPUS_DTOA_BUF_SIZE, d, n_digits);
    } else {
      char buf1[LEPUS_DTOA_BUF_SIZE];
      int sign, decpt, k, n, i, p, n_max;
      BOOL is_fixed;
    generic_conv:
      is_fixed = ((flags & 3) == LEPUS_DTOA_FIXED_FORMAT);
      if (is_fixed) {
        n_max = n_digits;
      } else {
        n_max = 21;
      }
      /* the number has k digits (k >= 1) */
      k = lepus_ecvt(d, n_digits, &decpt, &sign, buf1, is_fixed);
      n = decpt; /* d=10^(n-k)*(buf1) i.e. d= < x.yyyy 10^(n-1) */
      q = buf;
      if (sign) *q++ = '-';
      if (flags & LEPUS_DTOA_FORCE_EXP) goto force_exp;
      if (n >= 1 && n <= n_max) {
        if (k <= n) {
          memcpy(q, buf1, k);
          q += k;
          for (i = 0; i < (n - k); i++) *q++ = '0';
          *q = '\0';
        } else {
          /* k > n */
          memcpy(q, buf1, n);
          q += n;
          *q++ = '.';
          for (i = 0; i < (k - n); i++) *q++ = buf1[n + i];
          *q = '\0';
        }
      } else if (n >= -5 && n <= 0) {
        *q++ = '0';
        *q++ = '.';
        for (i = 0; i < -n; i++) *q++ = '0';
        memcpy(q, buf1, k);
        q += k;
        *q = '\0';
      } else {
      force_exp:
        /* exponential notation */
        *q++ = buf1[0];
        if (k > 1) {
          *q++ = '.';
          for (i = 1; i < k; i++) *q++ = buf1[i];
        }
        *q++ = 'e';
        p = n - 1;
        if (p >= 0) *q++ = '+';
        char pbuf[16];
        snprintf(pbuf, sizeof(pbuf), "%d", p);
        strcpy(q, pbuf);
      }
    }
  }
}

QJS_STATIC LEPUSValue lepus_dtoa(LEPUSContext *ctx, double d, int radix,
                                 int n_digits, int flags) {
  char buf[LEPUS_DTOA_BUF_SIZE];
  lepus_dtoa1(buf, d, radix, n_digits, flags);
  return LEPUS_NewString(ctx, buf);
}

#endif /* !CONFIG_BIGNUM */

QJS_STATIC LEPUSValue LEPUS_ToStringInternal(LEPUSContext *ctx,
                                             LEPUSValueConst val,
                                             BOOL is_ToPropertyKey) {
  int64_t tag;
  const char *str;
  char buf[32];

  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_STRING:
      return LEPUS_DupValue(ctx, val);
    case LEPUS_TAG_INT:
      snprintf(buf, sizeof(buf), "%d", LEPUS_VALUE_GET_INT(val));
      str = buf;
      goto new_string;
    case LEPUS_TAG_BOOL:
      return LEPUS_AtomToString(
          ctx, LEPUS_VALUE_GET_BOOL(val) ? LEPUS_ATOM_true : LEPUS_ATOM_false);
    case LEPUS_TAG_NULL:
      return LEPUS_AtomToString(ctx, LEPUS_ATOM_null);
    case LEPUS_TAG_UNDEFINED:
      return LEPUS_AtomToString(ctx, LEPUS_ATOM_undefined);
    case LEPUS_TAG_EXCEPTION:
      return LEPUS_EXCEPTION;
    case LEPUS_TAG_OBJECT: {
      LEPUSValue val1, ret;
      val1 = LEPUS_ToPrimitive(ctx, val, HINT_STRING);
      if (LEPUS_IsException(val1)) return val1;
      ret = LEPUS_ToStringInternal(ctx, val1, is_ToPropertyKey);
      LEPUS_FreeValue(ctx, val1);
      return ret;
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      str = "[function bytecode]";
      goto new_string;
    case LEPUS_TAG_SYMBOL:
      if (is_ToPropertyKey) {
        return LEPUS_DupValue(ctx, val);
      } else {
        return LEPUS_ThrowTypeError(ctx, "cannot convert symbol to string");
      }
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_FLOAT64:
    case LEPUS_TAG_BIG_FLOAT:
    case LEPUS_TAG_BIG_INT:
      return lepus_ftoa(ctx, val, 10, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
#else
    case LEPUS_TAG_FLOAT64:
      return lepus_dtoa(ctx, LEPUS_VALUE_GET_FLOAT64(val), 10, 0,
                        LEPUS_DTOA_VAR_FORMAT);
#endif
#ifdef ENABLE_LEPUSNG
      // <ByteDance begin>
    case LEPUS_TAG_LEPUS_REF:
      if (ctx->rt->lepus_callbacks_.lepus_ref_tostring) {
        return ctx->rt->lepus_callbacks_.lepus_ref_tostring(ctx, val);
      }
      // <ByteDance end>
#endif
    default:
      str = "[unsupported type]";
    new_string:
      return LEPUS_NewString(ctx, str);
  }
}

LEPUSValue LEPUS_ToString(LEPUSContext *ctx, LEPUSValueConst val) {
  return LEPUS_ToStringInternal(ctx, val, FALSE);
}

QJS_STATIC LEPUSValue LEPUS_ToStringFree(LEPUSContext *ctx, LEPUSValue val) {
  LEPUSValue ret;
  ret = LEPUS_ToString(ctx, val);
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue LEPUS_ToLocaleStringFree(LEPUSContext *ctx,
                                               LEPUSValue val) {
  if (LEPUS_IsUndefined(val) || LEPUS_IsNull(val))
    return LEPUS_ToStringFree(ctx, val);
  return LEPUS_InvokeFree(ctx, val, LEPUS_ATOM_toLocaleString, 0, NULL);
}

LEPUSValue LEPUS_ToPropertyKey(LEPUSContext *ctx, LEPUSValueConst val) {
  return LEPUS_ToStringInternal(ctx, val, TRUE);
}

QJS_STATIC LEPUSValue LEPUS_ToStringCheckObject(LEPUSContext *ctx,
                                                LEPUSValueConst val) {
  if (LEPUS_VALUE_IS_NULL(val) || LEPUS_VALUE_IS_UNDEFINED(val))
    return LEPUS_ThrowTypeError(ctx, "null or undefined are forbidden");
  return LEPUS_ToString(ctx, val);
}

QJS_STATIC LEPUSValue LEPUS_ToQuotedString(LEPUSContext *ctx,
                                           LEPUSValueConst val1) {
  LEPUSValue val;
  LEPUSString *p;
  int i;
  uint32_t c;
  StringBuffer b_s, *b = &b_s;
  char buf[16];

  val = LEPUS_ToStringCheckObject(ctx, val1);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);

  if (string_buffer_init(ctx, b, p->len + 2)) goto fail;

  if (string_buffer_putc8(b, '\"')) goto fail;
  for (i = 0; i < p->len;) {
    c = string_getc(p, &i);
    switch (c) {
      case '\t':
        c = 't';
        goto quote;
      case '\r':
        c = 'r';
        goto quote;
      case '\n':
        c = 'n';
        goto quote;
      case '\b':
        c = 'b';
        goto quote;
      case '\f':
        c = 'f';
        goto quote;
      case '\"':
      case '\\':
      quote:
        if (string_buffer_putc8(b, '\\')) goto fail;
        if (string_buffer_putc8(b, c)) goto fail;
        break;
      default:
        if (c < 32 || (c >= 0xd800 && c < 0xe000)) {
          snprintf(buf, sizeof(buf), "\\u%04x", c);
          if (string_buffer_puts8(b, buf)) goto fail;
        } else {
          if (string_buffer_putc(b, c)) goto fail;
        }
        break;
    }
  }
  if (string_buffer_putc8(b, '\"')) goto fail;
  LEPUS_FreeValue(ctx, val);
  return string_buffer_end(b);
fail:
  LEPUS_FreeValue(ctx, val);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

// <ByteDance begin>
#if defined(DUMP_QJS_VALUE)

#ifdef DEBUG_MEMORY
static __attribute__((unused)) void LEPUS_DumpObjectHeader(LEPUSRuntime *rt) {
  printf("DUMP_LEAKS: %14s %4s %4s %14s %10s %s\n", "ADDRESS", "REFS", "SHRF",
         "PROTO", "CLASS", "PROPS");
}
#else
static __attribute__((unused)) void LEPUS_DumpObjectHeader(LEPUSRuntime *rt) {
  printf("%14s %4s %4s %14s %10s %s\n", "ADDRESS", "REFS", "SHRF", "PROTO",
         "CLASS", "PROPS");
}
#endif

/* for debug only: dump an object without side effect */
static __attribute__((unused)) void LEPUS_DumpObject(LEPUSRuntime *rt,
                                                     LEPUSObject *p) {
  uint32_t i;
  char atom_buf[ATOM_GET_STR_BUF_SIZE];
  LEPUSShape *sh;
  LEPUSShapeProperty *prs;
  LEPUSProperty *pr;
  BOOL is_first = TRUE;
  char dump_buf[4096], fmt_buf[1024];
  dump_buf[0] = '\0';

#define write(...) \
  snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), strcat(dump_buf, fmt_buf);
  /* XXX: should encode atoms with special characters */
  sh = p->shape; /* the shape can be NULL while freeing an object */
  write("%14p %4d ", (void *)p, p->header.ref_count);
  if (sh) {
    write("%3d%c %14p ", sh->header.ref_count, " *"[sh->is_hashed],
          (void *)sh -> proto);
  } else {
    write("%3s  %14s ", "-", "-");
  }
  write("%10s ", LEPUS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf),
                                    rt->class_array[p->class_id].class_name));
  if (p->is_exotic && p->fast_array) {
    write("[ ");
    for (i = 0; i < p->u.array.count; i++) {
      if (i != 0) write(", ");
      switch (p->class_id) {
        case LEPUS_CLASS_ARRAY:
        case LEPUS_CLASS_ARGUMENTS:
          LEPUS_DumpValueShortNoPrint(rt, p->u.array.u.values[i], dump_buf);
          break;
        case LEPUS_CLASS_UINT8C_ARRAY ... LEPUS_CLASS_FLOAT64_ARRAY: {
          int size = 1 << typed_array_size_log2(p->class_id);
          const uint8_t *b = p->u.array.u.uint8_ptr + i * size;
          while (size-- > 0) write("%02X", *b++);
        } break;
      }
    }
    write(" ] ");
  }

  if (sh) {
    write("{ ");
    for (i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
      if (prs->atom != LEPUS_ATOM_NULL) {
        pr = &p->prop[i];
        if (!is_first) write(", ");
        write("%s: ",
              LEPUS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), prs->atom));
        if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
          write("[getset %p %p]", (void *)pr->u.getset.getter,
                (void *)pr->u.getset.setter);
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          write("[varref %p]", (void *)pr->u.var_ref);
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
          write("[autoinit %p %p]", (void *)pr->u.init.init_func,
                (void *)pr->u.init.opaque);
        } else {
          LEPUS_DumpValueShortNoPrint(rt, pr->u.value, dump_buf);
        }
        is_first = FALSE;
      }
    }
    write(" }");
  }

  if (lepus_class_has_bytecode(p->class_id)) {
    LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
    LEPUSVarRef **var_refs;
    if (b->closure_var_count) {
      var_refs = p->u.func.var_refs;
      write(" Closure:");
      for (i = 0; i < b->closure_var_count; i++) {
        write(" ");
        LEPUS_DumpValueShortNoPrint(rt, var_refs[i]->value, dump_buf);
      }
      if (p->u.func.home_object) {
        write(" HomeObject: ");
        LEPUS_DumpValueShortNoPrint(
            rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p->u.func.home_object), dump_buf);
      }
    }
  }
  write("\n");
#undef write

#ifdef DEBUG_MEMORY
  printf("DUMP_LEAKS: %s", dump_buf);
#else
  printf("%s", dump_buf);
#endif
}

static __attribute__((unused)) void LEPUS_DumpValueShortNoPrint(
    LEPUSRuntime *rt, LEPUSValueConst val, char dump_buf[]) {
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(val);
  const char *str;

  char fmt_buf[1024];

#define write(...) \
  snprintf(fmt_buf, sizeof(fmt_buf), __VA_ARGS__), strcat(dump_buf, fmt_buf);
  switch (tag) {
    case LEPUS_TAG_INT:
      write("%d", LEPUS_VALUE_GET_INT(val));
      break;
    case LEPUS_TAG_BOOL:
      if (LEPUS_VALUE_GET_BOOL(val))
        str = "true";
      else
        str = "false";
      goto print_str;
    case LEPUS_TAG_NULL:
      str = "null";
      goto print_str;
    case LEPUS_TAG_EXCEPTION:
      str = "exception";
      goto print_str;
    case LEPUS_TAG_UNINITIALIZED:
      str = "uninitialized";
      goto print_str;
    case LEPUS_TAG_UNDEFINED:
      str = "undefined";
    print_str:
      write("%s", str);
      break;
    case LEPUS_TAG_FLOAT64:
      write("%.14g", LEPUS_VALUE_GET_FLOAT64(val));
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT: {
      LEPUSBigFloat *p = LEPUS_VALUE_GET_PTR(val);
      char *str;
      bf_ftoa(&str, &p->num, 10, 0, BF_RNDZ | BF_FTOA_FORMAT_FRAC);
      write("%sn", str);
      bf_realloc(&rt->bf_ctx, str, 0);
    } break;
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *p = LEPUS_VALUE_GET_PTR(val);
      char *str;
      bf_ftoa(&str, &p->num, 16, BF_PREC_INF,
              BF_RNDZ | BF_FTOA_FORMAT_FREE | BF_FTOA_ADD_PREFIX);
      write("%sl", str);
      bf_realloc(&rt->bf_ctx, str, 0);
    } break;
#endif
    case LEPUS_TAG_STRING: {
      LEPUSString *p;
      p = LEPUS_VALUE_GET_STRING(val);
      LEPUS_DumpStringNoPrint(rt, p, dump_buf);
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE: {
      LEPUSFunctionBytecode *b =
          static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(val));
      char buf[ATOM_GET_STR_BUF_SIZE];
      write("[bytecode %s]",
            LEPUS_AtomGetStrRT(rt, buf, sizeof(buf), b->func_name));
    } break;
    case LEPUS_TAG_OBJECT: {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
      LEPUSAtom atom = rt->class_array[p->class_id].class_name;
      char atom_buf[ATOM_GET_STR_BUF_SIZE];
      write("[%s %p]", LEPUS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf), atom),
            (void *)p);
    } break;
    case LEPUS_TAG_SYMBOL: {
      LEPUSAtomStruct *p =
          static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
      char atom_buf[ATOM_GET_STR_BUF_SIZE];
      write("Symbol(%s)", LEPUS_AtomGetStrRT(rt, atom_buf, sizeof(atom_buf),
                                             lepus_get_atom_index(rt, p)));
    } break;
    case LEPUS_TAG_MODULE:
      write("[module]");
      break;
    case LEPUS_TAG_VAR_REF:
      write("[var_ref]");
      break;
    default:
#if defined(__aarch64__) && !defined(OS_WIN)
      write("[unknown tag %p]", (void *)tag);
#else
      write("[unknown tag %" PRId64 "]", tag);
#endif
      break;
  }
#undef write
}

static __attribute__((unused)) void LEPUS_DumpValueShort(LEPUSRuntime *rt,
                                                         LEPUSValueConst val) {
  char dump_buf[4096];
  dump_buf[0] = '\0';
  LEPUS_DumpValueShortNoPrint(rt, val, dump_buf);
  printf("%s", dump_buf);
}

static __attribute__((unused)) void LEPUS_DumpValue(LEPUSContext *ctx,
                                                    LEPUSValueConst val) {
  LEPUS_DumpValueShort(ctx->rt, val);
}

static __attribute__((unused)) void LEPUS_PrintValue(LEPUSContext *ctx,
                                                     const char *str,
                                                     LEPUSValueConst val) {
  printf("%s=", str);
  LEPUS_DumpValueShort(ctx->rt, val);
  printf("\n");
}
#endif  // DUMP_QJS_VALUE
// <ByteDance end>

/* return -1 if exception (proxy case) or TRUE/FALSE */
int LEPUS_IsArray(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_OBJECT(val)) {
    p = LEPUS_VALUE_GET_OBJ(val);
    if (unlikely(p->class_id == LEPUS_CLASS_PROXY))
      return lepus_proxy_isArray(ctx, val);
    else
      return p->class_id == LEPUS_CLASS_ARRAY;
  } else {
    return FALSE;
  }
}

QJS_STATIC double lepus_pow(double a, double b) {
  if (unlikely(!isfinite(b)) && fabs(a) == 1) {
    /* not compatible with IEEE 754 */
    return LEPUS_FLOAT64_NAN;
  } else {
    return pow(a, b);
  }
}

#ifdef CONFIG_BIGNUM

LEPUSValue LEPUS_NewBigInt64(LEPUSContext *ctx, int64_t v) {
  BOOL is_bignum = is_bignum_mode(ctx);
  if (is_bignum && v == (int32_t)v) {
    return LEPUS_NewInt32(ctx, v);
  } else {
    bf_t a_s, *a = &a_s;
    bf_init(ctx->bf_ctx, a);
    bf_set_si(a, v);
    return LEPUS_NewBigInt2(ctx, a, TRUE);
  }
}

LEPUSValue LEPUS_NewBigUint64(LEPUSContext *ctx, uint64_t v) {
  BOOL is_bignum = is_bignum_mode(ctx);
  if (is_bignum && v == (int32_t)v) {
    return LEPUS_NewInt32(ctx, v);
  } else {
    bf_t a_s, *a = &a_s;
    bf_init(ctx->bf_ctx, a);
    bf_set_ui(a, v);
    return LEPUS_NewBigInt2(ctx, a, TRUE);
  }
}

/* if the returned bigfloat is allocated it is equal to
   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. */
static bf_t *LEPUS_ToBigFloat(LEPUSContext *ctx, BOOL *pis_float, bf_t *buf,
                              LEPUSValueConst val) {
  int32_t tag;
  bf_t *r;
  BOOL is_float;
  LEPUSBigFloat *p;

  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
    case LEPUS_TAG_BOOL:
    case LEPUS_TAG_NULL:
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set_si(r, LEPUS_VALUE_GET_INT(val));
      is_float = FALSE;
      break;
    case LEPUS_TAG_FLOAT64:
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set_float64(r, LEPUS_VALUE_GET_FLOAT64(val));
      is_float = TRUE;
      break;
    case LEPUS_TAG_BIG_INT:
      is_float = FALSE;
      goto get_ptr;
    case LEPUS_TAG_BIG_FLOAT:
      is_float = TRUE;
    get_ptr:
      p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      r = &p->num;
      break;
    case LEPUS_TAG_UNDEFINED:
    default:
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set_nan(r);
      is_float = TRUE;
      break;
  }
  *pis_float = is_float;
  return r;
}

/* return NaN if bad bigint literal */
static LEPUSValue LEPUS_StringToBigInt(LEPUSContext *ctx, LEPUSValue val) {
  const char *str;
  const char *p;
  int flags, err;

  str = LEPUS_ToCString(ctx, val);
  LEPUS_FreeValue(ctx, val);
  if (!str) return LEPUS_EXCEPTION;
  flags = BF_ATOF_BIN_OCT | BF_ATOF_NO_PREFIX_AFTER_SIGN | BF_ATOF_JS_QUIRKS |
          BF_ATOF_INT_ONLY | BF_ATOF_INT_PREC_INF;
  if (!is_bignum_mode(ctx)) flags |= BF_ATOF_BIG_INT;
  val = lepus_atof(ctx, str, &p, 0, flags);
  p += skip_spaces(p);
  err = (*p != '\0');
  LEPUS_FreeCString(ctx, str);
  if (err) {
    LEPUS_FreeValue(ctx, val);
    val = LEPUS_NAN;
  }
  return val;
}

static LEPUSValue LEPUS_StringToBigIntErr(LEPUSContext *ctx, LEPUSValue val) {
  val = LEPUS_StringToBigInt(ctx, val);
  if (LEPUS_VALUE_GET_TAG(val) != LEPUS_TAG_BIG_INT) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_ThrowSyntaxError(ctx, "invalid bigint literal");
  }
  return val;
}

/* if the returned bigfloat is allocated it is equal to
   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. */
static bf_t *LEPUS_ToBigIntFree(LEPUSContext *ctx, bf_t *buf, LEPUSValue val) {
  int32_t tag;
  bf_t *r;
  LEPUSBigFloat *p;

redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      if (!is_bignum_mode(ctx)) goto fail;
      /* fall tru */
    case LEPUS_TAG_BOOL:
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set_si(r, LEPUS_VALUE_GET_INT(val));
      break;
    case LEPUS_TAG_FLOAT64: {
      double d = LEPUS_VALUE_GET_FLOAT64(val);
      if (!is_bignum_mode(ctx)) goto fail;
      if (!isfinite(d)) goto fail;
      r = buf;
      bf_init(ctx->bf_ctx, r);
      d = trunc(d);
      bf_set_float64(r, d);
    } break;
    case LEPUS_TAG_BIG_INT:
      p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      r = &p->num;
      break;
    case LEPUS_TAG_BIG_FLOAT:
      if (!is_bignum_mode(ctx)) goto fail;
      p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      if (!bf_is_finite(&p->num)) goto fail;
      r = buf;
      bf_init(ctx->bf_ctx, r);
      bf_set(r, &p->num);
      bf_rint(r, BF_PREC_INF, BF_RNDZ);
      LEPUS_FreeValue(ctx, val);
      break;
    case LEPUS_TAG_STRING:
      val = LEPUS_StringToBigIntErr(ctx, val);
      if (LEPUS_IsException(val)) return NULL;
      goto redo;
    case LEPUS_TAG_OBJECT:
      val = LEPUS_ToPrimitiveFree(
          ctx, val, is_bignum_mode(ctx) ? HINT_INTEGER : HINT_NUMBER);
      if (LEPUS_IsException(val)) return NULL;
      goto redo;
    default:
    fail:
      LEPUS_FreeValue(ctx, val);
      LEPUS_ThrowTypeError(ctx, "cannot convert to bigint");
      return NULL;
  }
  return r;
}

static bf_t *LEPUS_ToBigInt(LEPUSContext *ctx, bf_t *buf, LEPUSValueConst val) {
  return LEPUS_ToBigIntFree(ctx, buf, LEPUS_DupValue(ctx, val));
}

static __attribute__((unused)) LEPUSValue LEPUS_ToBigIntValueFree(
    LEPUSContext *ctx, LEPUSValue val) {
  if (LEPUS_VALUE_GET_TAG(val) == LEPUS_TAG_BIG_INT) {
    return val;
  } else {
    bf_t a_s, *a;
    a = LEPUS_ToBigIntFree(ctx, &a_s, val);
    if (!a) return LEPUS_EXCEPTION;
    return LEPUS_NewBigInt2(ctx, a, TRUE);
  }
}

/* free the bf_t allocated by LEPUS_ToBigInt */
static void LEPUS_FreeBigInt(LEPUSContext *ctx, bf_t *a, bf_t *buf) {
  if (a == buf) {
    bf_delete(a);
  } else {
    LEPUSBigFloat *p =
        (LEPUSBigFloat *)((uint8_t *)a - offsetof(LEPUSBigFloat, num));
    LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_BIG_FLOAT, p));
  }
}

/* XXX: merge with LEPUS_ToInt64Free with a specific flag */
static int LEPUS_ToBigInt64Free(LEPUSContext *ctx, int64_t *pres,
                                LEPUSValue val) {
  bf_t a_s, *a;

  a = LEPUS_ToBigIntFree(ctx, &a_s, val);
  if (!a) {
    *pres = 0;
    return -1;
  }
  bf_get_int64(pres, a, BF_GET_INT_MOD);
  LEPUS_FreeBigInt(ctx, a, &a_s);
  return 0;
}

int LEPUS_ToBigInt64(LEPUSContext *ctx, int64_t *pres, LEPUSValueConst val) {
  return LEPUS_ToBigInt64Free(ctx, pres, LEPUS_DupValue(ctx, val));
}

static LEPUSBigFloat *lepus_new_bf(LEPUSContext *ctx) {
  LEPUSBigFloat *p;
  p = static_cast<LEPUSBigFloat *>(lepus_mallocz(ctx, sizeof(*p)));
  if (!p) return NULL;
  p->header.ref_count = 1;
  bf_init(ctx->bf_ctx, &p->num);
  return p;
}

/* WARNING: 'a' is freed */
static LEPUSValue LEPUS_NewBigFloat(LEPUSContext *ctx, bf_t *a) {
  LEPUSValue ret;
  LEPUSBigFloat *p;

  p = lepus_new_bf(ctx);
  p->num = *a;
  ret = LEPUS_MKPTR(LEPUS_TAG_BIG_FLOAT, p);
  return ret;
}

/* WARNING: 'a' is freed */
static LEPUSValue LEPUS_NewBigInt2(LEPUSContext *ctx, bf_t *a,
                                   BOOL force_bigint) {
  LEPUSValue ret;
  LEPUSBigFloat *p;
  int32_t v;

  if (!force_bigint && bf_get_int32(&v, a, 0) == 0) {
    /* can fit in an int32 */
    ret = LEPUS_NewInt32(ctx, v);
    bf_delete(a);
  } else {
    p = lepus_new_bf(ctx);
    p->num = *a;
    /* normalize the zero representation */
    if (bf_is_zero(&p->num)) p->num.sign = 0;
    ret = LEPUS_MKPTR(LEPUS_TAG_BIG_INT, p);
  }
  return ret;
}

static LEPUSValue LEPUS_NewBigInt(LEPUSContext *ctx, bf_t *a) {
  return LEPUS_NewBigInt2(ctx, a, FALSE);
}

/* return < 0 if exception, 0 if overloading method, 1 if overloading
   operator called */
static __exception int lepus_call_binary_op_fallback(LEPUSContext *ctx,
                                                     LEPUSValue *pret,
                                                     LEPUSValueConst op1,
                                                     LEPUSValueConst op2,
                                                     OPCodeEnum op) {
  LEPUSAtom op_name;
  LEPUSValue method, ret, c1, c2;
  BOOL bool_result, swap_op;
  LEPUSValueConst args[2];

  bool_result = FALSE;
  swap_op = FALSE;
  c1 = LEPUS_UNDEFINED;
  c2 = LEPUS_UNDEFINED;
  switch (op) {
    case OP_add:
      op_name = LEPUS_ATOM_Symbol_operatorAdd;
      break;
    case OP_sub:
      op_name = LEPUS_ATOM_Symbol_operatorSub;
      break;
    case OP_mul:
      op_name = LEPUS_ATOM_Symbol_operatorMul;
      break;
    case OP_div:
    case OP_math_div:
      op_name = LEPUS_ATOM_Symbol_operatorDiv;
      break;
    case OP_mod:
      op_name = LEPUS_ATOM_Symbol_operatorMod;
      break;
    case OP_pow:
    case OP_math_pow:
      op_name = LEPUS_ATOM_Symbol_operatorPow;
      break;
    case OP_math_mod:
      op_name = LEPUS_ATOM_Symbol_operatorMathMod;
      break;
    case OP_shl:
      op_name = LEPUS_ATOM_Symbol_operatorShl;
      break;
    case OP_sar:
      op_name = LEPUS_ATOM_Symbol_operatorShr;
      break;
    case OP_and:
      op_name = LEPUS_ATOM_Symbol_operatorAnd;
      break;
    case OP_or:
      op_name = LEPUS_ATOM_Symbol_operatorOr;
      break;
    case OP_xor:
      op_name = LEPUS_ATOM_Symbol_operatorXor;
      break;
    case OP_lt:
      op_name = LEPUS_ATOM_Symbol_operatorCmpLT;
      bool_result = TRUE;
      break;
    case OP_lte:
      op_name = LEPUS_ATOM_Symbol_operatorCmpLE;
      bool_result = TRUE;
      break;
    case OP_gt:
      op_name = LEPUS_ATOM_Symbol_operatorCmpLT;
      bool_result = TRUE;
      swap_op = TRUE;
      break;
    case OP_gte:
      op_name = LEPUS_ATOM_Symbol_operatorCmpLE;
      bool_result = TRUE;
      swap_op = TRUE;
      break;
    case OP_eq:
    case OP_neq:
      op_name = LEPUS_ATOM_Symbol_operatorCmpEQ;
      bool_result = TRUE;
      break;
    default:
      goto fail;
  }
  c1 = LEPUS_GetProperty(ctx, op1, LEPUS_ATOM_constructor);
  if (LEPUS_IsException(c1)) goto exception;
  c2 = LEPUS_GetProperty(ctx, op2, LEPUS_ATOM_constructor);
  if (LEPUS_IsException(c2)) goto exception;
  if (LEPUS_VALUE_IS_NOT_OBJECT(c1) || LEPUS_VALUE_IS_NOT_OBJECT(c2)) goto fail;
  if (LEPUS_VALUE_GET_OBJ(c1) == LEPUS_VALUE_GET_OBJ(c2)) {
    /* if same constructor, there is no ambiguity */
    method = LEPUS_GetProperty(ctx, c1, op_name);
  } else {
    LEPUSValue val;
    int order1, order2;

    /* different constructors: we use a user-defined ordering */
    val = LEPUS_GetProperty(ctx, c1, LEPUS_ATOM_Symbol_operatorOrder);
    if (LEPUS_IsException(val)) goto exception;
    if (LEPUS_IsUndefined(val)) goto undef_order;
    if (LEPUS_ToInt32Free(ctx, &order1, val)) goto exception;
    val = LEPUS_GetProperty(ctx, c2, LEPUS_ATOM_Symbol_operatorOrder);
    if (LEPUS_IsException(val)) goto exception;
    if (LEPUS_IsUndefined(val)) {
    undef_order:
      LEPUS_FreeValue(ctx, c1);
      LEPUS_FreeValue(ctx, c2);
      *pret = LEPUS_UNDEFINED;
      return 0;
    }
    if (LEPUS_ToInt32Free(ctx, &order2, val)) goto exception;
    /* ambiguous priority: error */
    if (order1 == order2) {
      LEPUS_ThrowTypeError(ctx,
                           "operator_order is identical in both constructors");
      goto exception;
    }
    if (order1 > order2) {
      val = c1;
    } else {
      val = c2;
    }
    method = LEPUS_GetProperty(ctx, val, op_name);
  }
  LEPUS_FreeValue(ctx, c1);
  LEPUS_FreeValue(ctx, c2);
  c1 = LEPUS_UNDEFINED;
  c2 = LEPUS_UNDEFINED;
  if (LEPUS_IsException(method)) goto exception;
  if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
    *pret = LEPUS_UNDEFINED;
    return 0;
  }
  if (swap_op) {
    args[0] = op2;
    args[1] = op1;
  } else {
    args[0] = op1;
    args[1] = op2;
  }
  ret = LEPUS_CallFree(ctx, method, LEPUS_UNDEFINED, 2, args);
  if (LEPUS_IsException(ret)) goto exception;
  if (bool_result) {
    BOOL res = LEPUS_ToBoolFree(ctx, ret);
    if (op == OP_neq) res ^= 1;
    ret = LEPUS_NewBool(ctx, res);
  }
  *pret = ret;
  return 1;
fail:
  LEPUS_ThrowTypeError(ctx, "invalid types for binary operator");
exception:
  LEPUS_FreeValue(ctx, c1);
  LEPUS_FreeValue(ctx, c2);
  *pret = LEPUS_UNDEFINED;
  return -1;
}

static LEPUSValue throw_bf_exception(LEPUSContext *ctx, int status) {
  const char *str;
  if (status & BF_ST_DIVIDE_ZERO) {
    str = "division by zero";
  } else if (status & BF_ST_INVALID_OP) {
    str = "invalid operation";
  } else {
    str = "integer overflow";
  }
  return LEPUS_ThrowRangeError(ctx, "%s", str);
}

static no_inline __exception int lepus_unary_arith_slow(LEPUSContext *ctx,
                                                        LEPUSValue *sp,
                                                        OPCodeEnum op) {
  LEPUSValue op1, val, method;
  bf_t a_s, r_s, *r = &r_s, *a;
  BOOL is_float, is_legacy;
  LEPUSAtom op_name;
  int ret, v;
  int32_t tag;

  op1 = sp[-1];
  /* fast path for float64 */
  if (LEPUS_TAG_IS_FLOAT64(LEPUS_VALUE_GET_TAG(op1))) goto handle_float64;
  if (LEPUS_IsObject(op1)) {
    switch (op) {
      case OP_plus:
        op_name = LEPUS_ATOM_Symbol_operatorPlus;
        break;
      case OP_neg:
        op_name = LEPUS_ATOM_Symbol_operatorNeg;
        break;
      case OP_inc:
        op_name = LEPUS_ATOM_Symbol_operatorInc;
        break;
      case OP_dec:
        op_name = LEPUS_ATOM_Symbol_operatorDec;
        break;
      default:
        abort();
    }
    method = LEPUS_GetProperty(ctx, op1, op_name);
    if (LEPUS_IsException(method)) return -1;
    if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) goto to_number;
    val = LEPUS_CallFree(ctx, method, op1, 0, NULL);
    if (LEPUS_IsException(val)) return -1;
    LEPUS_FreeValue(ctx, op1);
    sp[-1] = val;
  } else {
  to_number:
    op1 = LEPUS_ToNumericFree(ctx, op1);
    if (LEPUS_IsException(op1)) goto exception;
    is_legacy = is_bignum_mode(ctx) ^ 1;
    tag = LEPUS_VALUE_GET_TAG(op1);
    switch (tag) {
      case LEPUS_TAG_INT: {
        int64_t v64;
        v64 = LEPUS_VALUE_GET_INT(op1);
        switch (op) {
          case OP_inc:
          case OP_dec:
            v = 2 * (op - OP_dec) - 1;
            v64 += v;
            break;
          case OP_plus:
            break;
          case OP_neg:
            if (v64 == 0 && is_legacy) {
              sp[-1] = __JS_NewFloat64(ctx, -0.0);
              return 0;
            } else {
              v64 = -v64;
            }
            break;
          default:
            abort();
        }
        sp[-1] = LEPUS_NewInt64(ctx, v64);
      } break;
      case LEPUS_TAG_BIG_INT:
        if (is_legacy && op == OP_plus) {
          LEPUS_ThrowTypeError(ctx, "bigint argument with unary +");
          LEPUS_FreeValue(ctx, op1);
          goto exception;
        }
        a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
        bf_init(ctx->bf_ctx, r);
        ret = 0;
        switch (op) {
          case OP_inc:
          case OP_dec:
            v = 2 * (op - OP_dec) - 1;
            ret = bf_add_si(r, a, v, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
            break;
          case OP_plus:
            bf_set(r, a);
            break;
          case OP_neg:
            bf_set(r, a);
            bf_neg(r);
            break;
          default:
            abort();
        }
        if (a == &a_s) bf_delete(a);
        LEPUS_FreeValue(ctx, op1);
        if (unlikely(ret)) {
          bf_delete(r);
          throw_bf_exception(ctx, ret);
          goto exception;
        }
        sp[-1] = LEPUS_NewBigInt2(ctx, r, is_legacy);
        break;
      case LEPUS_TAG_BIG_FLOAT:
        a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
        bf_init(ctx->bf_ctx, r);
        ret = 0;
        switch (op) {
          case OP_inc:
          case OP_dec:
            v = 2 * (op - OP_dec) - 1;
            bf_add_si(r, a, v, ctx->fp_env.prec, ctx->fp_env.flags);
            break;
          case OP_plus:
            bf_set(r, a);
            break;
          case OP_neg:
            bf_set(r, a);
            bf_neg(r);
            break;
          default:
            abort();
        }
        if (a == &a_s) bf_delete(a);
        LEPUS_FreeValue(ctx, op1);
        if (unlikely(ret)) {
          bf_delete(r);
          throw_bf_exception(ctx, ret);
          goto exception;
        }
        sp[-1] = LEPUS_NewBigFloat(ctx, r);
        break;
      default:
      handle_float64 : {
        double d;
        d = LEPUS_VALUE_GET_FLOAT64(op1);
        switch (op) {
          case OP_inc:
          case OP_dec:
            v = 2 * (op - OP_dec) - 1;
            d += v;
            break;
          case OP_plus:
            break;
          case OP_neg:
            d = -d;
            break;
          default:
            abort();
        }
        sp[-1] = __JS_NewFloat64(ctx, d);
      } break;
    }
  }
  return 0;
exception:
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

__exception int lepus_post_inc_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                    OPCodeEnum op) {
  LEPUSValue op1;

  /* XXX: allow custom operators */
  op1 = sp[-1];
  op1 = LEPUS_ToNumericFree(ctx, op1);
  if (LEPUS_IsException(op1)) {
    sp[-1] = LEPUS_UNDEFINED;
    return -1;
  }
  sp[-1] = op1;
  sp[0] = LEPUS_DupValue(ctx, op1);
  return lepus_unary_arith_slow(
      ctx, sp + 1, static_cast<OPCodeEnum>(op - OP_post_dec + OP_dec));
}

static no_inline int lepus_not_slow(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue op1, method, val;
  bf_t a_s, r_s, *r = &r_s, *a;
  int ret;
  BOOL is_legacy;

  op1 = sp[-1];
  if (LEPUS_IsObject(op1)) {
    method = LEPUS_GetProperty(ctx, op1, LEPUS_ATOM_Symbol_operatorNot);
    if (LEPUS_IsException(method)) return -1;
    if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) goto to_number;
    val = LEPUS_CallFree(ctx, method, op1, 0, NULL);
    if (LEPUS_IsException(val)) return -1;
    LEPUS_FreeValue(ctx, op1);
    sp[-1] = val;
  } else {
    if (LEPUS_IsString(op1)) {
    to_number:
      op1 = LEPUS_ToNumberHintFree(ctx, op1, TON_FLAG_INTEGER);
      if (LEPUS_IsException(op1)) goto exception;
    }
    is_legacy = is_bignum_mode(ctx) ^ 1;
    if (!is_legacy || LEPUS_VALUE_GET_TAG(op1) == LEPUS_TAG_BIG_INT) {
      a = LEPUS_ToBigIntFree(ctx, &a_s, op1);
      bf_init(ctx->bf_ctx, r);
      ret = bf_add_si(r, a, 1, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
      bf_neg(r);
      LEPUS_FreeBigInt(ctx, a, &a_s);
      if (unlikely(ret)) {
        bf_delete(r);
        throw_bf_exception(ctx, ret);
        goto exception;
      }
      sp[-1] = LEPUS_NewBigInt2(ctx, r, is_legacy);
    } else {
      int32_t v1;
      if (unlikely(LEPUS_ToInt32Free(ctx, &v1, op1))) goto exception;
      sp[-1] = LEPUS_NewInt32(ctx, ~v1);
    }
  }
  return 0;
exception:
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline __exception int lepus_binary_arith_slow(LEPUSContext *ctx,
                                                         LEPUSValue *sp,
                                                         OPCodeEnum op) {
  LEPUSValue op1, op2, res;
  BOOL is_float, is_legacy;
  uint32_t tag1, tag2;
  int ret, rnd_mode;
  double d1, d2;

  op1 = sp[-2];
  op2 = sp[-1];
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  /* fast path for float operations */
  if (tag1 == LEPUS_TAG_FLOAT64 && tag2 == LEPUS_TAG_FLOAT64) {
    d1 = LEPUS_VALUE_GET_FLOAT64(op1);
    d2 = LEPUS_VALUE_GET_FLOAT64(op2);
    goto handle_float64;
  }

  /* try to call an overloaded operator */
  if ((tag1 == LEPUS_TAG_OBJECT &&
       (tag2 != LEPUS_TAG_NULL && tag2 != LEPUS_TAG_UNDEFINED)) ||
      (tag2 == LEPUS_TAG_OBJECT &&
       (tag1 != LEPUS_TAG_NULL && tag1 != LEPUS_TAG_UNDEFINED))) {
    ret = lepus_call_binary_op_fallback(ctx, &res, op1, op2, op);
    if (ret != 0) {
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      if (ret < 0) {
        goto exception;
      } else {
        sp[-2] = res;
        return 0;
      }
    }
  }

  op1 = LEPUS_ToNumericFree(ctx, op1);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = LEPUS_ToNumericFree(ctx, op2);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);

  is_legacy = is_bignum_mode(ctx) ^ 1;
  if (is_legacy && (tag1 == LEPUS_TAG_BIG_INT || tag2 == LEPUS_TAG_BIG_INT) &&
      tag1 != tag2) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    LEPUS_ThrowTypeError(ctx, "both operands must be bigint");
    goto exception;
  }

  if (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_INT) {
    int32_t v1, v2;
    int64_t v;
    v1 = LEPUS_VALUE_GET_INT(op1);
    v2 = LEPUS_VALUE_GET_INT(op2);
    switch (op) {
      case OP_sub:
        v = (int64_t)v1 - (int64_t)v2;
        break;
      case OP_mul:
        v = (int64_t)v1 * (int64_t)v2;
        if (is_legacy && v == 0 && (v1 | v2) < 0) {
          sp[-2] = __JS_NewFloat64(ctx, -0.0);
          return 0;
        }
        break;
      case OP_math_div:
        goto op_fallback2;
      case OP_div:
        sp[-2] = __JS_NewFloat64(ctx, (double)v1 / (double)v2);
        return 0;
      case OP_math_mod:
        if (unlikely(v2 == 0)) {
          throw_bf_exception(ctx, BF_ST_DIVIDE_ZERO);
          goto exception;
        }
        v = (int64_t)v1 % (int64_t)v2;
        if (v < 0) {
          if (v2 < 0)
            v -= v2;
          else
            v += v2;
        }
        break;
      case OP_mod:
        if (is_legacy && (v1 < 0 || v2 <= 0)) {
          sp[-2] = LEPUS_NewFloat64(ctx, fmod(v1, v2));
          return 0;
        } else {
          if (unlikely(v2 == 0)) {
            throw_bf_exception(ctx, BF_ST_DIVIDE_ZERO);
            goto exception;
          }
          v = (int64_t)v1 % (int64_t)v2;
        }
        break;
      case OP_pow:
      case OP_math_pow:
        if (is_legacy) {
          sp[-2] = LEPUS_NewFloat64(ctx, lepus_pow(v1, v2));
          return 0;
        } else {
          goto handle_bigint;
        }
        break;
      default:
        abort();
    }
    sp[-2] = LEPUS_NewInt64(ctx, v);
  } else if ((tag1 == LEPUS_TAG_BIG_INT &&
              (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_BIG_INT)) ||
             (tag2 == LEPUS_TAG_BIG_INT && tag1 == LEPUS_TAG_INT)) {
    /* big int result */
    bf_t a_s, b_s, r_s, *r, *a, *b;
  handle_bigint:
    a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = LEPUS_ToBigFloat(ctx, &is_float, &b_s, op2);
    r = &r_s;
    bf_init(ctx->bf_ctx, r);
    ret = 0;
    switch (op) {
      case OP_sub:
        ret = bf_sub(r, a, b, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
        break;
      case OP_mul:
        ret = bf_mul(r, a, b, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
        break;
      case OP_math_div:
        goto op_fallback;
      case OP_div:
        if (is_legacy) {
          bf_t rem_s, *rem = &rem_s;
          bf_init(ctx->bf_ctx, rem);
          ret = bf_divrem(r, rem, a, b, BF_PREC_INF, BF_RNDZ, BF_RNDZ) &
                BF_ST_INVALID_OP;
          bf_delete(rem);
        } else {
          bf_div(r, a, b, 53,
                 bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL);
          goto float64_result;
        }
        break;
      case OP_math_mod:
        /* Euclidian remainder */
        rnd_mode = BF_DIVREM_EUCLIDIAN;
        goto do_int_mod;
      case OP_mod:
        rnd_mode = BF_RNDZ;
      do_int_mod : {
        bf_t q_s, *q = &q_s;
        bf_init(ctx->bf_ctx, q);
        ret = bf_divrem(q, r, a, b, BF_PREC_INF, BF_RNDZ, rnd_mode) &
              BF_ST_INVALID_OP;
        bf_delete(q);
      } break;
      case OP_pow:
      case OP_math_pow:
        if (b->sign) {
          if (is_legacy) {
            ret = BF_ST_INVALID_OP;
          } else if (op == OP_math_pow) {
          op_fallback:
            bf_delete(r);
            if (a == &a_s) bf_delete(a);
            if (b == &b_s) bf_delete(b);
          op_fallback2:
            ret = lepus_call_binary_op_fallback(ctx, &res, op1, op2, op);
            LEPUS_FreeValue(ctx, op1);
            LEPUS_FreeValue(ctx, op2);
            if (ret < 0) {
              goto exception;
            } else if (ret == 0) {
              LEPUS_ThrowTypeError(
                  ctx, "operator must be defined for exact division or power");
              goto exception;
            }
            sp[-2] = res;
            return 0;
          } else {
            double dr;
            bf_pow(r, a, b, 53,
                   bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL);
          float64_result:
            bf_get_float64(r, &dr, BF_RNDN);
            bf_delete(r);
            if (a == &a_s) bf_delete(a);
            if (b == &b_s) bf_delete(b);
            LEPUS_FreeValue(ctx, op1);
            LEPUS_FreeValue(ctx, op2);
            sp[-2] = __JS_NewFloat64(ctx, dr);
            return 0;
          }
        } else {
          ret = bf_pow(r, a, b, BF_PREC_INF, BF_RNDZ | BF_POW_JS_QUICKS) &
                BF_ST_OVERFLOW;
        }
        break;
      default:
        abort();
    }
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    if (unlikely(ret)) {
      bf_delete(r);
      throw_bf_exception(ctx, ret);
      goto exception;
    }
    sp[-2] = LEPUS_NewBigInt2(ctx, r, is_legacy);
  } else if ((tag1 == LEPUS_TAG_FLOAT64 &&
              (tag2 == LEPUS_TAG_FLOAT64 || tag2 == LEPUS_TAG_INT ||
               tag2 == LEPUS_TAG_BIG_INT)) ||
             (tag2 == LEPUS_TAG_FLOAT64 &&
              (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_BIG_INT))) {
    double dr;
    /* float64 result */
    LEPUS_ToFloat64Free(ctx, &d1, op1);
    LEPUS_ToFloat64Free(ctx, &d2, op2);
  handle_float64:
    switch (op) {
      case OP_sub:
        dr = d1 - d2;
        break;
      case OP_mul:
        dr = d1 * d2;
        break;
      case OP_div:
      case OP_math_div:
        dr = d1 / d2;
        break;
      case OP_mod:
        dr = fmod(d1, d2);
        break;
      case OP_math_mod:
        if (d1 >= 0 && d2 >= 0) {
          dr = fmod(d1, d2);
        } else {
          /* XXX: slow */
          bf_t a, b, r, q;
          bf_init(ctx->bf_ctx, &a);
          bf_init(ctx->bf_ctx, &b);
          bf_init(ctx->bf_ctx, &r);
          bf_set_float64(&a, d1);
          bf_set_float64(&b, d2);
          bf_divrem(&q, &r, &a, &b, 53,
                    bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL,
                    BF_DIVREM_EUCLIDIAN);
          bf_get_float64(&q, &dr, BF_RNDN);
          bf_delete(&a);
          bf_delete(&b);
          bf_delete(&q);
          bf_delete(&r);
        }
        break;
      case OP_pow:
      case OP_math_pow:
        dr = lepus_pow(d1, d2);
        break;
      default:
        abort();
    }
    sp[-2] = __JS_NewFloat64(ctx, dr);
  } else {
    bf_t a_s, b_s, r_s, *r, *a, *b;
    /* big float result */
    a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = LEPUS_ToBigFloat(ctx, &is_float, &b_s, op2);
    r = &r_s;
    bf_init(ctx->bf_ctx, r);
    ret = 0;
    switch (op) {
      case OP_sub:
        bf_sub(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
        break;
      case OP_mul:
        bf_mul(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
        break;
      case OP_math_div:
      case OP_div:
        bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
        break;
      case OP_math_mod:
        /* Euclidian remainder */
        rnd_mode = BF_DIVREM_EUCLIDIAN;
        goto do_mod;
      case OP_mod:
        rnd_mode = BF_RNDZ;
      do_mod : {
        bf_t q_s, *q = &q_s;
        bf_init(ctx->bf_ctx, q);
        bf_divrem(q, r, a, b, ctx->fp_env.prec, ctx->fp_env.flags, rnd_mode);
        bf_delete(q);
      } break;
      case OP_pow:
      case OP_math_pow:
        bf_pow(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags | BF_POW_JS_QUICKS);
        break;
      default:
        abort();
    }
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    if (unlikely(ret)) {
      bf_delete(r);
      throw_bf_exception(ctx, ret);
      goto exception;
    }
    sp[-2] = LEPUS_NewBigFloat(ctx, r);
  }
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline __exception int lepus_add_slow(LEPUSContext *ctx,
                                                LEPUSValue *sp) {
  LEPUSValue op1, op2, res;
  uint32_t tag1, tag2;
  BOOL is_float, is_legacy;
  int ret;

  op1 = sp[-2];
  op2 = sp[-1];

  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  /* fast path for float64 */
  if (tag1 == LEPUS_TAG_FLOAT64 && tag2 == LEPUS_TAG_FLOAT64) {
    double d1, d2;
    d1 = LEPUS_VALUE_GET_FLOAT64(op1);
    d2 = LEPUS_VALUE_GET_FLOAT64(op2);
    sp[-2] = __JS_NewFloat64(ctx, d1 + d2);
    return 0;
  }

  if (tag1 == LEPUS_TAG_OBJECT || tag2 == LEPUS_TAG_OBJECT) {
    /* try to call an overloaded operator */
    if ((tag1 == LEPUS_TAG_OBJECT &&
         (tag2 != LEPUS_TAG_NULL && tag2 != LEPUS_TAG_UNDEFINED)) ||
        (tag2 == LEPUS_TAG_OBJECT &&
         (tag1 != LEPUS_TAG_NULL && tag1 != LEPUS_TAG_UNDEFINED))) {
      ret = lepus_call_binary_op_fallback(ctx, &res, op1, op2, OP_add);
      if (ret != 0) {
        LEPUS_FreeValue(ctx, op1);
        LEPUS_FreeValue(ctx, op2);
        if (ret < 0) {
          goto exception;
        } else {
          sp[-2] = res;
          return 0;
        }
      }
    }

    op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }

    op2 = LEPUS_ToPrimitiveFree(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
    tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  }

  if (tag1 == LEPUS_TAG_STRING || tag2 == LEPUS_TAG_STRING) {
    sp[-2] = LEPUS_ConcatString(ctx, op1, op2);
    if (LEPUS_IsException(sp[-2])) goto exception;
    return 0;
  }

  op1 = LEPUS_ToNumericFree(ctx, op1);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = LEPUS_ToNumericFree(ctx, op2);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);

  is_legacy = is_bignum_mode(ctx) ^ 1;
  if (is_legacy && (tag1 == LEPUS_TAG_BIG_INT || tag2 == LEPUS_TAG_BIG_INT) &&
      tag1 != tag2) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    LEPUS_ThrowTypeError(ctx, "both operands must be bigint");
    goto exception;
  }

  if (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_INT) {
    int32_t v1, v2;
    int64_t v;
    v1 = LEPUS_VALUE_GET_INT(op1);
    v2 = LEPUS_VALUE_GET_INT(op2);
    v = (int64_t)v1 + (int64_t)v2;
    sp[-2] = LEPUS_NewInt64(ctx, v);
  } else if ((tag1 == LEPUS_TAG_BIG_INT &&
              (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_BIG_INT)) ||
             (tag2 == LEPUS_TAG_BIG_INT && tag1 == LEPUS_TAG_INT)) {
    bf_t a_s, b_s, r_s, *r, *a, *b;
    /* big int result */
    a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = LEPUS_ToBigFloat(ctx, &is_float, &b_s, op2);
    r = &r_s;
    bf_init(ctx->bf_ctx, r);
    ret = bf_add(r, a, b, BF_PREC_INF, BF_RNDZ) & BF_ST_OVERFLOW;
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    if (unlikely(ret)) {
      bf_delete(r);
      throw_bf_exception(ctx, ret);
      goto exception;
    }
    sp[-2] = LEPUS_NewBigInt2(ctx, r, is_legacy);
  } else if ((tag1 == LEPUS_TAG_FLOAT64 &&
              (tag2 == LEPUS_TAG_FLOAT64 || tag2 == LEPUS_TAG_INT ||
               tag2 == LEPUS_TAG_BIG_INT)) ||
             (tag2 == LEPUS_TAG_FLOAT64 &&
              (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_BIG_INT))) {
    double d1, d2;
    /* float64 result */
    LEPUS_ToFloat64Free(ctx, &d1, op1);
    LEPUS_ToFloat64Free(ctx, &d2, op2);
    sp[-2] = __JS_NewFloat64(ctx, d1 + d2);
  } else {
    bf_t a_s, b_s, r_s, *r, *a, *b;
    /* big float result */
    a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = LEPUS_ToBigFloat(ctx, &is_float, &b_s, op2);

    r = &r_s;
    bf_init(ctx->bf_ctx, r);
    bf_add(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    if (unlikely(ret)) {
      bf_delete(r);
      throw_bf_exception(ctx, ret);
      goto exception;
    }
    sp[-2] = LEPUS_NewBigFloat(ctx, r);
  }
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline __exception int lepus_binary_logic_slow(LEPUSContext *ctx,
                                                         LEPUSValue *sp,
                                                         OPCodeEnum op) {
  LEPUSValue op1, op2, res;
  bf_t a_s, b_s, r_s, *r, *a, *b;
  int ret;
  uint32_t tag1, tag2;
  BOOL is_legacy;

  op1 = sp[-2];
  op2 = sp[-1];
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);

  /* try to call an overloaded operator */
  if ((tag1 == LEPUS_TAG_OBJECT &&
       (tag2 != LEPUS_TAG_NULL && tag2 != LEPUS_TAG_UNDEFINED)) ||
      (tag2 == LEPUS_TAG_OBJECT &&
       (tag1 != LEPUS_TAG_NULL && tag1 != LEPUS_TAG_UNDEFINED))) {
    ret = lepus_call_binary_op_fallback(ctx, &res, op1, op2, op);
    if (ret != 0) {
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      if (ret < 0) {
        goto exception;
      } else {
        sp[-2] = res;
        return 0;
      }
    }
  }

  op1 = LEPUS_ToNumberHintFree(ctx, op1, TON_FLAG_INTEGER);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = LEPUS_ToNumberHintFree(ctx, op2, TON_FLAG_INTEGER);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }

  is_legacy = is_bignum_mode(ctx) ^ 1;
  if (is_legacy) {
    uint32_t v1, v2, r;

    tag1 = LEPUS_VALUE_GET_TAG(op1);
    tag2 = LEPUS_VALUE_GET_TAG(op2);
    if (tag1 == LEPUS_TAG_BIG_INT || tag2 == LEPUS_TAG_BIG_INT) {
      if (tag1 != tag2) {
        LEPUS_FreeValue(ctx, op1);
        LEPUS_FreeValue(ctx, op2);
        LEPUS_ThrowTypeError(ctx, "both operands must be bigint");
        goto exception;
      }
    } else {
      if (unlikely(LEPUS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      if (unlikely(LEPUS_ToInt32Free(ctx, (int32_t *)&v2, op2))) goto exception;
      switch (op) {
        case OP_shl:
          r = v1 << (v2 & 0x1f);
          break;
        case OP_sar:
          r = (int)v1 >> (v2 & 0x1f);
          break;
        case OP_and:
          r = v1 & v2;
          break;
        case OP_or:
          r = v1 | v2;
          break;
        case OP_xor:
          r = v1 ^ v2;
          break;
        default:
          abort();
      }
      sp[-2] = LEPUS_NewInt32(ctx, r);
      return 0;
    }
  }

  a = LEPUS_ToBigIntFree(ctx, &a_s, op1);
  b = LEPUS_ToBigIntFree(ctx, &b_s, op2);

  r = &r_s;
  bf_init(ctx->bf_ctx, r);
  ret = 0;
  switch (op) {
    case OP_shl:
    case OP_sar: {
      slimb_t v2;
#if LIMB_BITS == 32
      bf_get_int32(&v2, b, 0);
      if (v2 == INT32_MIN) v2 = INT32_MIN + 1;
#else
      bf_get_int64(&v2, b, 0);
      if (v2 == INT64_MIN) v2 = INT64_MIN + 1;
#endif
      if (op == OP_sar) v2 = -v2;
      bf_set(r, a);
      ret = bf_mul_2exp(r, v2, BF_PREC_INF, BF_RNDZ);
      if (v2 < 0) {
        ret |= bf_rint(r, BF_PREC_INF, BF_RNDD);
      }
      ret &= BF_ST_OVERFLOW;
    } break;
    case OP_and:
      bf_logic_and(r, a, b);
      break;
    case OP_or:
      bf_logic_or(r, a, b);
      break;
    case OP_xor:
      bf_logic_xor(r, a, b);
      break;
    default:
      abort();
  }
  LEPUS_FreeBigInt(ctx, a, &a_s);
  LEPUS_FreeBigInt(ctx, b, &b_s);
  if (unlikely(ret)) {
    bf_delete(r);
    throw_bf_exception(ctx, ret);
    goto exception;
  }
  sp[-2] = LEPUS_NewBigInt2(ctx, r, is_legacy);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline int lepus_relational_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                           OPCodeEnum op) {
  LEPUSValue op1, op2, ret;
  int res;
  uint32_t tag1, tag2;

  op1 = sp[-2];
  op2 = sp[-1];
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  /* try to call an overloaded operator */
  if ((tag1 == LEPUS_TAG_OBJECT &&
       (tag2 != LEPUS_TAG_NULL && tag2 != LEPUS_TAG_UNDEFINED)) ||
      (tag2 == LEPUS_TAG_OBJECT &&
       (tag1 != LEPUS_TAG_NULL && tag1 != LEPUS_TAG_UNDEFINED))) {
    res = lepus_call_binary_op_fallback(ctx, &ret, op1, op2, op);
    if (res != 0) {
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      if (res < 0) {
        goto exception;
      } else {
        sp[-2] = ret;
        return 0;
      }
    }
  }
  op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NUMBER);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = LEPUS_ToPrimitiveFree(ctx, op2, HINT_NUMBER);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);

  if (tag1 == LEPUS_TAG_STRING && tag2 == LEPUS_TAG_STRING) {
    LEPUSString *p1, *p2;
    p1 = LEPUS_VALUE_GET_STRING(op1);
    p2 = LEPUS_VALUE_GET_STRING(op2);
    res = lepus_string_compare(ctx, p1, p2);
    switch (op) {
      case OP_lt:
        res = (res < 0);
        break;
      case OP_lte:
        res = (res <= 0);
        break;
      case OP_gt:
        res = (res > 0);
        break;
      default:
      case OP_gte:
        res = (res >= 0);
        break;
    }
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
  } else if ((tag1 <= LEPUS_TAG_NULL || tag1 == LEPUS_TAG_FLOAT64) &&
             (tag2 <= LEPUS_TAG_NULL || tag2 == LEPUS_TAG_FLOAT64)) {
    /* can use floating point comparison */
    double d1, d2;
    if (tag1 == LEPUS_TAG_FLOAT64) {
      d1 = LEPUS_VALUE_GET_FLOAT64(op1);
    } else {
      d1 = LEPUS_VALUE_GET_INT(op1);
    }
    if (tag2 == LEPUS_TAG_FLOAT64) {
      d2 = LEPUS_VALUE_GET_FLOAT64(op2);
    } else {
      d2 = LEPUS_VALUE_GET_INT(op2);
    }
    switch (op) {
      case OP_lt:
        res = (d1 < d2); /* if NaN return false */
        break;
      case OP_lte:
        res = (d1 <= d2); /* if NaN return false */
        break;
      case OP_gt:
        res = (d1 > d2); /* if NaN return false */
        break;
      default:
      case OP_gte:
        res = (d1 >= d2); /* if NaN return false */
        break;
    }
  } else {
    bf_t a_s, b_s, *a, *b;
    BOOL is_float;

    if (((tag1 == LEPUS_TAG_BIG_INT && tag2 == LEPUS_TAG_STRING) ||
         (tag2 == LEPUS_TAG_BIG_INT && tag1 == LEPUS_TAG_STRING)) &&
        !is_bignum_mode(ctx)) {
      if (tag1 == LEPUS_TAG_STRING) {
        op1 = LEPUS_StringToBigInt(ctx, op1);
        if (LEPUS_VALUE_GET_TAG(op1) != LEPUS_TAG_BIG_INT)
          goto invalid_bigint_string;
      }
      if (tag2 == LEPUS_TAG_STRING) {
        op2 = LEPUS_StringToBigInt(ctx, op2);
        if (LEPUS_VALUE_GET_TAG(op2) != LEPUS_TAG_BIG_INT) {
        invalid_bigint_string:
          LEPUS_FreeValue(ctx, op1);
          LEPUS_FreeValue(ctx, op2);
          res = FALSE;
          goto done;
        }
      }
    } else {
      op1 = LEPUS_ToNumericFree(ctx, op1);
      if (LEPUS_IsException(op1)) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      op2 = LEPUS_ToNumericFree(ctx, op2);
      if (LEPUS_IsException(op2)) {
        LEPUS_FreeValue(ctx, op1);
        goto exception;
      }
    }

    a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
    b = LEPUS_ToBigFloat(ctx, &is_float, &b_s, op2);

    switch (op) {
      case OP_lt:
        res = bf_cmp_lt(a, b); /* if NaN return false */
        break;
      case OP_lte:
        res = bf_cmp_le(a, b); /* if NaN return false */
        break;
      case OP_gt:
        res = bf_cmp_lt(b, a); /* if NaN return false */
        break;
      default:
      case OP_gte:
        res = bf_cmp_le(b, a); /* if NaN return false */
        break;
    }
    if (a == &a_s) bf_delete(a);
    if (b == &b_s) bf_delete(b);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
  }
done:
  sp[-2] = LEPUS_NewBool(ctx, res);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static BOOL tag_is_number(uint32_t tag) {
  return (tag == LEPUS_TAG_INT || tag == LEPUS_TAG_BIG_INT ||
          tag == LEPUS_TAG_FLOAT64 || tag == LEPUS_TAG_BIG_FLOAT);
}

static no_inline __exception int lepus_eq_slow(LEPUSContext *ctx,
                                               LEPUSValue *sp, BOOL is_neq) {
  LEPUSValue op1, op2, ret;
  int res;
  uint32_t tag1, tag2;

  op1 = sp[-2];
  op2 = sp[-1];
redo:
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  if (tag_is_number(tag1) && tag_is_number(tag2)) {
    if (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_INT) {
      res = LEPUS_VALUE_GET_INT(op1) == LEPUS_VALUE_GET_INT(op2);
    } else if ((tag1 == LEPUS_TAG_FLOAT64 &&
                (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64)) ||
               (tag2 == LEPUS_TAG_FLOAT64 &&
                (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64))) {
      double d1, d2;
      if (tag1 == LEPUS_TAG_FLOAT64) {
        d1 = LEPUS_VALUE_GET_FLOAT64(op1);
      } else {
        d1 = LEPUS_VALUE_GET_INT(op1);
      }
      if (tag2 == LEPUS_TAG_FLOAT64) {
        d2 = LEPUS_VALUE_GET_FLOAT64(op2);
      } else {
        d2 = LEPUS_VALUE_GET_INT(op2);
      }
      res = (d1 == d2);
    } else {
      bf_t a_s, b_s, *a, *b;
      BOOL is_float;
      a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
      b = LEPUS_ToBigFloat(ctx, &is_float, &b_s, op2);
      res = bf_cmp_eq(a, b);
      if (a == &a_s) bf_delete(a);
      if (b == &b_s) bf_delete(b);
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
    }
  } else if (tag1 == tag2) {
    if (tag1 == LEPUS_TAG_OBJECT) {
      /* try the fallback operator */
      res = lepus_call_binary_op_fallback(ctx, &ret, op1, op2,
                                          is_neq ? OP_neq : OP_eq);
      if (res != 0) {
        LEPUS_FreeValue(ctx, op1);
        LEPUS_FreeValue(ctx, op2);
        if (res < 0) {
          goto exception;
        } else {
          sp[-2] = ret;
          return 0;
        }
      }
    }
    res = lepus_strict_eq2(ctx, op1, op2, LEPUS_EQ_STRICT);
  } else if ((tag1 == LEPUS_TAG_NULL && tag2 == LEPUS_TAG_UNDEFINED) ||
             (tag2 == LEPUS_TAG_NULL && tag1 == LEPUS_TAG_UNDEFINED)) {
    res = TRUE;
  } else if ((tag1 == LEPUS_TAG_STRING && tag_is_number(tag2)) ||
             (tag2 == LEPUS_TAG_STRING && tag_is_number(tag1))) {
    if ((tag1 == LEPUS_TAG_BIG_INT || tag2 == LEPUS_TAG_BIG_INT) &&
        !is_bignum_mode(ctx)) {
      if (tag1 == LEPUS_TAG_STRING) {
        op1 = LEPUS_StringToBigInt(ctx, op1);
        if (LEPUS_VALUE_GET_TAG(op1) != LEPUS_TAG_BIG_INT)
          goto invalid_bigint_string;
      }
      if (tag2 == LEPUS_TAG_STRING) {
        op2 = LEPUS_StringToBigInt(ctx, op2);
        if (LEPUS_VALUE_GET_TAG(op2) != LEPUS_TAG_BIG_INT) {
        invalid_bigint_string:
          LEPUS_FreeValue(ctx, op1);
          LEPUS_FreeValue(ctx, op2);
          res = FALSE;
          goto done;
        }
      }
    } else {
      op1 = LEPUS_ToNumericFree(ctx, op1);
      if (LEPUS_IsException(op1)) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      op2 = LEPUS_ToNumericFree(ctx, op2);
      if (LEPUS_IsException(op2)) {
        LEPUS_FreeValue(ctx, op1);
        goto exception;
      }
    }
    res = lepus_strict_eq(ctx, op1, op2);
  } else if (tag1 == LEPUS_TAG_BOOL) {
    op1 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_INT(op1));
    goto redo;
  } else if (tag2 == LEPUS_TAG_BOOL) {
    op2 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_INT(op2));
    goto redo;
  } else if ((tag1 == LEPUS_TAG_OBJECT &&
              (tag_is_number(tag2) || tag2 == LEPUS_TAG_STRING ||
               tag2 == LEPUS_TAG_SYMBOL)) ||
             (tag2 == LEPUS_TAG_OBJECT &&
              (tag_is_number(tag1) || tag1 == LEPUS_TAG_STRING ||
               tag1 == LEPUS_TAG_SYMBOL))) {
    /* try the fallback operator */
    res = lepus_call_binary_op_fallback(ctx, &ret, op1, op2,
                                        is_neq ? OP_neq : OP_eq);
    if (res != 0) {
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      if (res < 0) {
        goto exception;
      } else {
        sp[-2] = ret;
        return 0;
      }
    }

    op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    op2 = LEPUS_ToPrimitiveFree(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    goto redo;
  } else {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    res = FALSE;
  }
done:
  sp[-2] = LEPUS_NewBool(ctx, res ^ is_neq);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static no_inline int lepus_shr_slow(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue op1, op2;
  uint32_t v1, v2, r;

  op1 = sp[-2];
  op2 = sp[-1];
  op1 = LEPUS_ToNumericFree(ctx, op1);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = LEPUS_ToNumericFree(ctx, op2);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }
  /* XXX: could forbid >>> in bignum mode */
  if (!is_bignum_mode(ctx) && (LEPUS_VALUE_GET_TAG(op1) == LEPUS_TAG_BIG_INT ||
                               LEPUS_VALUE_GET_TAG(op2) == LEPUS_TAG_BIG_INT)) {
    LEPUS_ThrowTypeError(ctx, "bigint operands are forbidden for >>>");
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  /* cannot give an exception */
  LEPUS_ToUint32Free(ctx, &v1, op1);
  LEPUS_ToUint32Free(ctx, &v2, op2);
  r = v1 >> (v2 & 0x1f);
  sp[-2] = LEPUS_NewUint32(ctx, r);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

static double bf_mul_pow10_to_float64(LEPUSContext *ctx, const bf_t *a,
                                      int64_t exponent) {
  bf_t r_s, *r = &r_s;
  double d;
  /* always convert to Float64 */
  bf_init(ctx->bf_ctx, r);
  bf_mul_pow_radix(r, a, 10, exponent, 53,
                   bf_set_exp_bits(11) | BF_RNDN | BF_FLAG_SUBNORMAL);
  bf_get_float64(r, &d, BF_RNDN);
  bf_delete(r);
  return d;
}

static no_inline int lepus_mul_pow10(LEPUSContext *ctx, LEPUSValue *sp) {
  bf_t a_s, *a, r_s, *r = &r_s;
  BOOL is_float;
  LEPUSValue op1, op2;
  slimb_t e;
  int ret;

  op1 = sp[-2];
  op2 = sp[-1];
  a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
  if (!a) return -1;
#if LIMB_BITS == 32
  ret = LEPUS_ToInt32(ctx, &e, op2);
#else
  ret = LEPUS_ToInt64(ctx, &e, op2);
#endif
  if (ret) {
    if (a == &a_s) bf_delete(a);
    return -1;
  }

  bf_init(ctx->bf_ctx, r);
  bf_mul_pow_radix(r, a, 10, e, ctx->fp_env.prec, ctx->fp_env.flags);
  if (a == &a_s) bf_delete(a);
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  sp[-2] = LEPUS_NewBigFloat(ctx, r);
  return 0;
}

#else /* !CONFIG_BIGNUM */

QJS_STATIC no_inline __exception int lepus_unary_arith_slow(LEPUSContext *ctx,
                                                            LEPUSValue *sp,
                                                            OPCodeEnum op) {
  LEPUSValue op1;
  double d;

  op1 = sp[-1];
  if (unlikely(LEPUS_ToFloat64Free(ctx, &d, op1))) {
    sp[-1] = LEPUS_UNDEFINED;
    return -1;
  }
  switch (op) {
    case OP_inc:
      d++;
      break;
    case OP_dec:
      d--;
      break;
    case OP_plus:
      break;
    case OP_neg:
      d = -d;
      break;
    default:
      abort();
  }
  sp[-1] = LEPUS_NewFloat64(ctx, d);
  return 0;
}

/* specific case necessary for correct return value semantics */
__exception int lepus_post_inc_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                    OPCodeEnum op) {
  LEPUSValue op1;
  double d, r;

  op1 = sp[-1];
  if (unlikely(LEPUS_ToFloat64Free(ctx, &d, op1))) {
    sp[-1] = LEPUS_UNDEFINED;
    return -1;
  }
  r = d + 2 * (op - OP_post_dec) - 1;
  sp[0] = LEPUS_NewFloat64(ctx, r);
  sp[-1] = LEPUS_NewFloat64(ctx, d);
  return 0;
}

QJS_STATIC no_inline __exception int lepus_binary_arith_slow(LEPUSContext *ctx,
                                                             LEPUSValue *sp,
                                                             OPCodeEnum op) {
  LEPUSValue op1, op2;
  double d1, d2, r;

  op1 = sp[-2];
  op2 = sp[-1];
  if (unlikely(LEPUS_ToFloat64Free(ctx, &d1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(LEPUS_ToFloat64Free(ctx, &d2, op2))) {
    goto exception;
  }
  switch (op) {
    case OP_sub:
      r = d1 - d2;
      break;
    case OP_mul:
      r = d1 * d2;
      break;
    case OP_div:
      r = d1 / d2;
      break;
    case OP_mod:
      r = fmod(d1, d2);
      break;
    case OP_pow:
      r = lepus_pow(d1, d2);
      break;
    default:
      abort();
  }
  sp[-2] = LEPUS_NewFloat64(ctx, r);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline __exception int lepus_add_slow(LEPUSContext *ctx,
                                                    LEPUSValue *sp) {
  LEPUSValue op1, op2;

  op1 = sp[-2];
  op2 = sp[-1];
  if ((LEPUS_VALUE_IS_INT(op1) || LEPUS_VALUE_IS_FLOAT64(op1)) &&
      (LEPUS_VALUE_IS_INT(op2) || LEPUS_VALUE_IS_FLOAT64(op2))) {
    goto add_numbers;
  } else {
    op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    op2 = LEPUS_ToPrimitiveFree(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    if (LEPUS_VALUE_IS_STRING(op1) || LEPUS_VALUE_IS_STRING(op2)) {
      sp[-2] = LEPUS_ConcatString(ctx, op1, op2);
      if (LEPUS_IsException(sp[-2])) goto exception;
    } else {
      double d1, d2;
    add_numbers:
      if (LEPUS_ToFloat64Free(ctx, &d1, op1)) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      if (LEPUS_ToFloat64Free(ctx, &d2, op2)) goto exception;
      sp[-2] = LEPUS_NewFloat64(ctx, d1 + d2);
    }
  }
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline __exception int lepus_binary_logic_slow(LEPUSContext *ctx,
                                                             LEPUSValue *sp,
                                                             OPCodeEnum op) {
  LEPUSValue op1, op2;
  uint32_t v1, v2, r;

  op1 = sp[-2];
  op2 = sp[-1];
  if (unlikely(LEPUS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(LEPUS_ToInt32Free(ctx, (int32_t *)&v2, op2))) goto exception;
  switch (op) {
    case OP_shl:
      r = v1 << (v2 & 0x1f);
      break;
    case OP_sar:
      r = (int)v1 >> (v2 & 0x1f);
      break;
    case OP_and:
      r = v1 & v2;
      break;
    case OP_or:
      r = v1 | v2;
      break;
    case OP_xor:
      r = v1 ^ v2;
      break;
    default:
      abort();
  }
  sp[-2] = LEPUS_NewInt32(ctx, r);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline int lepus_not_slow(LEPUSContext *ctx, LEPUSValue *sp) {
  int32_t v1;

  if (unlikely(LEPUS_ToInt32Free(ctx, &v1, sp[-1]))) {
    sp[-1] = LEPUS_UNDEFINED;
    return -1;
  }
  sp[-1] = LEPUS_NewInt32(ctx, ~v1);
  return 0;
}

QJS_STATIC no_inline int lepus_relational_slow(LEPUSContext *ctx,
                                               LEPUSValue *sp, OPCodeEnum op) {
  LEPUSValue op1, op2;
  int res;

  op1 = sp[-2];
  op2 = sp[-1];
  op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NUMBER);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = LEPUS_ToPrimitiveFree(ctx, op2, HINT_NUMBER);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }
  if (LEPUS_VALUE_IS_STRING(op1) && LEPUS_VALUE_IS_STRING(op2)) {
    LEPUSString *p1, *p2;
    p1 = LEPUS_VALUE_GET_STRING(op1);
    p2 = LEPUS_VALUE_GET_STRING(op2);
    res = lepus_string_compare(ctx, p1, p2);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    switch (op) {
      case OP_lt:
        res = (res < 0);
        break;
      case OP_lte:
        res = (res <= 0);
        break;
      case OP_gt:
        res = (res > 0);
        break;
      default:
      case OP_gte:
        res = (res >= 0);
        break;
    }
  } else {
    double d1, d2;
    if (LEPUS_ToFloat64Free(ctx, &d1, op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    if (LEPUS_ToFloat64Free(ctx, &d2, op2)) goto exception;
    switch (op) {
      case OP_lt:
        res = (d1 < d2); /* if NaN return false */
        break;
      case OP_lte:
        res = (d1 <= d2); /* if NaN return false */
        break;
      case OP_gt:
        res = (d1 > d2); /* if NaN return false */
        break;
      default:
      case OP_gte:
        res = (d1 >= d2); /* if NaN return false */
        break;
    }
  }
  sp[-2] = LEPUS_NewBool(ctx, res);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline __exception int lepus_eq_slow(LEPUSContext *ctx,
                                                   LEPUSValue *sp,
                                                   BOOL is_neq) {
  LEPUSValue op1, op2;
  int64_t tag1, tag2;
  BOOL res;

  op1 = sp[-2];
  op2 = sp[-1];
redo:
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  if (tag1 == tag2 || (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_FLOAT64) ||
      (tag2 == LEPUS_TAG_INT && tag1 == LEPUS_TAG_FLOAT64)) {
    res = lepus_strict_eq(ctx, op1, op2);
  } else if ((tag1 == LEPUS_TAG_NULL && tag2 == LEPUS_TAG_UNDEFINED) ||
             (tag2 == LEPUS_TAG_NULL && tag1 == LEPUS_TAG_UNDEFINED)) {
    res = TRUE;
  } else if ((tag1 == LEPUS_TAG_STRING &&
              (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64)) ||
             (tag2 == LEPUS_TAG_STRING &&
              (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64))) {
    double d1;
    double d2;
    if (LEPUS_ToFloat64Free(ctx, &d1, op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    if (LEPUS_ToFloat64Free(ctx, &d2, op2)) goto exception;
    res = (d1 == d2);
  } else if (tag1 == LEPUS_TAG_BOOL) {
    op1 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(op1));
    goto redo;
  } else if (tag2 == LEPUS_TAG_BOOL) {
    op2 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(op2));
    goto redo;
  } else if (tag1 == LEPUS_TAG_OBJECT &&
             (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64 ||
              tag2 == LEPUS_TAG_STRING || tag2 == LEPUS_TAG_SYMBOL)) {
    op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    goto redo;
  } else if (tag2 == LEPUS_TAG_OBJECT &&
             (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64 ||
              tag1 == LEPUS_TAG_STRING || tag1 == LEPUS_TAG_SYMBOL)) {
    op2 = LEPUS_ToPrimitiveFree(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    goto redo;
  } else {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    res = FALSE;
  }
  sp[-2] = LEPUS_NewBool(ctx, res ^ is_neq);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC no_inline int lepus_shr_slow(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue op1, op2;
  uint32_t v1, v2, r;

  op1 = sp[-2];
  op2 = sp[-1];
  if (unlikely(LEPUS_ToUint32Free(ctx, &v1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(LEPUS_ToUint32Free(ctx, &v2, op2))) goto exception;
  r = v1 >> (v2 & 0x1f);
  sp[-2] = LEPUS_NewUint32(ctx, r);
  return 0;
exception:
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

// <ByteDance begin>
#ifdef ENABLE_LEPUSNG
QJS_STATIC LEPUSBigFloat *lepus_new_bf(LEPUSContext *ctx) {
  LEPUSBigFloat *p;
  p = static_cast<LEPUSBigFloat *>(lepus_mallocz(ctx, sizeof(*p)));
  if (!p) return NULL;
  p->header.ref_count = 1;
  return p;
}

LEPUSValue LEPUS_NewBigUint64(LEPUSContext *ctx, uint64_t v) {
  LEPUSBigFloat *p = lepus_new_bf(ctx);
  p->num = v;
  return LEPUS_MKPTR(LEPUS_TAG_BIG_INT, p);
}

LEPUSValue LEPUS_NewLepusWrap(LEPUSContext *ctx, void *p, int tag) {
  LEPUSLepusRef *pref;
  pref = static_cast<LEPUSLepusRef *>(lepus_mallocz(ctx, sizeof(*pref)));
  if (!pref) return LEPUS_UNDEFINED;
  pref->header.ref_count = 1;

  pref->tag = tag;
  pref->p = p;
  pref->lepus_val = LEPUS_UNDEFINED;

  return LEPUS_MKPTR(LEPUS_TAG_LEPUS_REF, pref);
}

void RegisterLepusRefCallbacks(LEPUSRuntime *rt,
                               LEPUSLepusRefCallbacks *funcs) {
  if (!rt) return;
  rt->lepus_callbacks_.free_value = funcs->free_value;
  rt->lepus_callbacks_.get_property = funcs->get_property;
  rt->lepus_callbacks_.get_length = funcs->get_length;
  rt->lepus_callbacks_.convert_to_object = funcs->convert_to_object;
  rt->lepus_callbacks_.set_property = funcs->set_property;
  rt->lepus_callbacks_.free_str_cache = funcs->free_str_cache;
  rt->lepus_callbacks_.lepus_ref_equal = funcs->lepus_ref_equal;
  rt->lepus_callbacks_.lepus_ref_tostring = funcs->lepus_ref_tostring;
  return;
}

void RegisterVMSDKCallbacks(LEPUSRuntime *rt, void **funcs,
                            int32_t callback_size) {
  if (!rt || !funcs) return;
  int32_t num = 0;
#define Name(name)                                                           \
  if (num < callback_size) {                                                 \
    rt->vmsdk_callbacks_.name =                                              \
        reinterpret_cast<decltype(rt->vmsdk_callbacks_.name)>(funcs[num++]); \
  } else {                                                                   \
    rt->vmsdk_callbacks_.name = NULL;                                        \
  }
  VMSDKCallBackName(Name)
#undef Name
}

void LEPUS_SetStringCache(LEPUSContext *ctx, LEPUSValue val, void *p) {
  if (!LEPUS_IsString(val)) return;
  LEPUSString *str = LEPUS_VALUE_GET_STRING(val);
  void *old_ptr = str->cache_;
  str->cache_ = p;
  ctx->rt->lepus_callbacks_.free_str_cache(old_ptr, p);
  return;
}

void LEPUS_FreeStringCache(LEPUSRuntime *rt, LEPUSString *p) {
  if (p->cache_ && (rt->lepus_callbacks_.free_str_cache)) {
    rt->lepus_callbacks_.free_str_cache(p->cache_, NULL);
    p->cache_ = NULL;
  }
}

void *LEPUS_GetStringCache(LEPUSValue val) {
  if (!LEPUS_IsString(val)) return NULL;
  LEPUSString *str = LEPUS_VALUE_GET_STRING(val);
  return str->cache_;
}
#endif
// <ByteDance end>

#endif /* !CONFIG_BIGNUM */

/* XXX: Should take LEPUSValueConst arguments */
QJS_STATIC BOOL lepus_strict_eq2(LEPUSContext *ctx, LEPUSValue op1,
                                 LEPUSValue op2,
                                 LEPUSStrictEqModeEnum eq_mode) {
  BOOL res;
  int64_t tag1, tag2;
  double d1, d2;

  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  switch (tag1) {
    case LEPUS_TAG_BOOL:
      if (tag1 != tag2) {
        res = FALSE;
      } else {
        res = LEPUS_VALUE_GET_BOOL(op1) == LEPUS_VALUE_GET_BOOL(op2);
        goto done_no_free;
      }
      break;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      res = (tag1 == tag2);
      break;
    case LEPUS_TAG_STRING: {
      LEPUSString *p1, *p2;
      if (tag1 != tag2) {
        res = FALSE;
      } else {
        p1 = LEPUS_VALUE_GET_STRING(op1);
        p2 = LEPUS_VALUE_GET_STRING(op2);
        // <ByteDance change>
        if (p1 == p2) {
          res = TRUE;
        } else if (p1->atom_type == LEPUS_ATOM_TYPE_STRING &&
                   p2->atom_type == LEPUS_ATOM_TYPE_STRING) {
          res = FALSE;
        } else {
          res = (lepus_string_compare(ctx, p1, p2) == 0);
        }
      }
    } break;
    case LEPUS_TAG_SYMBOL: {
      LEPUSAtomStruct *p1, *p2;
      if (tag1 != tag2) {
        res = FALSE;
      } else {
        p1 = static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(op1));
        p2 = static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(op2));
        res = (p1 == p2);
      }
    } break;
    case LEPUS_TAG_OBJECT:
      if (tag1 != tag2)
        res = FALSE;
      else
        res = LEPUS_VALUE_GET_OBJ(op1) == LEPUS_VALUE_GET_OBJ(op2);
      break;
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF: {
      if (tag1 != tag2)
        res = FALSE;
      else
        res = (LEPUS_GetLepusRefPoint(op1) == LEPUS_GetLepusRefPoint(op2));
    } break;
    case LEPUS_TAG_LEPUS_CPOINTER: {
      if (tag1 != tag2) {
        res = FALSE;
      } else {
        res = (LEPUS_VALUE_GET_PTR(op1) == LEPUS_VALUE_GET_PTR(op2));
      }
    } break;
#endif
    case LEPUS_TAG_INT:
      d1 = LEPUS_VALUE_GET_INT(op1);
      if (tag2 == LEPUS_TAG_INT) {
        d2 = LEPUS_VALUE_GET_INT(op2);
        goto number_test;
      } else if (tag2 == LEPUS_TAG_FLOAT64) {
#ifdef CONFIG_BIGNUM
        if (is_bignum_mode(ctx)) {
          res = FALSE;
        } else
#endif
        {
          d2 = LEPUS_VALUE_GET_FLOAT64(op2);
          goto number_test;
        }
      } else
#ifdef CONFIG_BIGNUM
          if (tag2 == LEPUS_TAG_BIG_INT && is_bignum_mode(ctx)) {
        goto bigint_test;
      } else
#endif
      {
        res = FALSE;
      }
      break;
    case LEPUS_TAG_FLOAT64:
      d1 = LEPUS_VALUE_GET_FLOAT64(op1);
      if (tag2 == LEPUS_TAG_FLOAT64) {
        d2 = LEPUS_VALUE_GET_FLOAT64(op2);
      } else if (tag2 == LEPUS_TAG_INT
#ifdef CONFIG_BIGNUM
                 && !is_bignum_mode(ctx)
#endif
      ) {
        d2 = LEPUS_VALUE_GET_INT(op2);
      } else {
        res = FALSE;
        break;
      }
    number_test:
      if (unlikely(eq_mode >= LEPUS_EQ_SAME_VALUE)) {
        LEPUSFloat64Union u1, u2;
        /* NaN is not always normalized, so this test is necessary */
        if (isnan(d1) || isnan(d2)) {
          res = isnan(d1) == isnan(d2);
        } else if (eq_mode == LEPUS_EQ_SAME_VALUE_ZERO) {
          res = (d1 == d2); /* +0 == -0 */
        } else {
          u1.d = d1;
          u2.d = d2;
          res = (u1.u64 == u2.u64); /* +0 != -0 */
        }
      } else {
        res = (d1 == d2); /* if NaN return false and +0 == -0 */
      }
      goto done_no_free;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT: {
      bf_t a_s, *a, b_s, *b;
      BOOL is_float;
      if (tag1 == tag2) {
        /* OK */
      } else if (tag2 == LEPUS_TAG_INT && is_bignum_mode(ctx)) {
        /* OK */
      } else {
        res = FALSE;
        break;
      }
    bigint_test:
      a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
      b = LEPUS_ToBigFloat(ctx, &is_float, &b_s, op2);
      res = bf_cmp_eq(a, b);
      if (a == &a_s) bf_delete(a);
      if (b == &b_s) bf_delete(a);
    } break;
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *p1, *p2;
      const bf_t *a, *b;
      if (tag1 != tag2) {
        res = FALSE;
        break;
      }
      p1 = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(op1));
      p2 = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(op2));
      a = &p1->num;
      b = &p2->num;
      if (unlikely(eq_mode >= LEPUS_EQ_SAME_VALUE)) {
        if (eq_mode == LEPUS_EQ_SAME_VALUE_ZERO && a->expn == BF_EXP_ZERO &&
            b->expn == BF_EXP_ZERO) {
          res = TRUE;
        } else {
          res = (bf_cmp_full(a, b) == 0);
        }
      } else {
        res = bf_cmp_eq(a, b);
      }
    } break;
#endif
// <bytedance begin>
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_BIG_INT: {
      LEPUSBigFloat *p1 =
          static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(op1));
      if (tag2 == LEPUS_TAG_BIG_INT) {
        LEPUSBigFloat *p2 =
            static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(op2));
        if (p2->num == p1->num) {
          res = TRUE;
        } else {
          res = FALSE;
        }
      } else {
        res = FALSE;
      }
    } break;
#endif
      // <bytedance end>
    default:
      res = FALSE;
      break;
  }
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
done_no_free:
  return res;
}

QJS_STATIC BOOL lepus_strict_eq(LEPUSContext *ctx, LEPUSValue op1,
                                LEPUSValue op2) {
  return lepus_strict_eq2(ctx, op1, op2, LEPUS_EQ_STRICT);
}

QJS_STATIC BOOL lepus_same_value(LEPUSContext *ctx, LEPUSValueConst op1,
                                 LEPUSValueConst op2) {
  return lepus_strict_eq2(ctx, LEPUS_DupValue(ctx, op1),
                          LEPUS_DupValue(ctx, op2), LEPUS_EQ_SAME_VALUE);
}

QJS_STATIC BOOL lepus_same_value_zero(LEPUSContext *ctx, LEPUSValueConst op1,
                                      LEPUSValueConst op2) {
  return lepus_strict_eq2(ctx, LEPUS_DupValue(ctx, op1),
                          LEPUS_DupValue(ctx, op2), LEPUS_EQ_SAME_VALUE_ZERO);
}

QJS_STATIC no_inline int lepus_strict_eq_slow(LEPUSContext *ctx, LEPUSValue *sp,
                                              BOOL is_neq) {
  BOOL res;
  res = lepus_strict_eq(ctx, sp[-2], sp[-1]);
  sp[-2] = LEPUS_NewBool(ctx, res ^ is_neq);
  return 0;
}

QJS_STATIC __exception int lepus_operator_in(LEPUSContext *ctx,
                                             LEPUSValue *sp) {
  LEPUSValue op1, op2;
  LEPUSAtom atom;
  int ret;

  op1 = sp[-2];
  op2 = sp[-1];

  if (LEPUS_VALUE_IS_NOT_OBJECT(op2)) {
    atom = lepus_value_to_atom(ctx, op1);
    if (unlikely(atom == LEPUS_ATOM_NULL)) {
      LEPUS_ThrowTypeError(ctx, "invalid 'in' operand search for null");
      return -1;
    }
    const char *msg = LEPUS_AtomToCString(ctx, atom);
    char buffer[200];
    if (msg) {
      snprintf(buffer, 199, "invalid 'in' operand search for '%s'", msg);
      LEPUS_FreeCString(ctx, msg);
    } else {
      snprintf(buffer, 199, "invalid 'in' operand search for null");
    }
    LEPUS_ThrowTypeError(ctx, "%s", buffer);
    LEPUS_FreeAtom(ctx, atom);
    return -1;
  }

  atom = lepus_value_to_atom(ctx, op1);
  if (unlikely(atom == LEPUS_ATOM_NULL)) return -1;
  ret = LEPUS_HasProperty(ctx, op2, atom);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0) return -1;
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  sp[-2] = LEPUS_NewBool(ctx, ret);
  return 0;
}

QJS_STATIC __exception int lepus_has_unscopable(LEPUSContext *ctx,
                                                LEPUSValueConst obj,
                                                LEPUSAtom atom) {
  LEPUSValue arr, val;
  int ret;

  arr = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_Symbol_unscopables);
  if (LEPUS_IsException(arr)) return -1;
  ret = 0;
  if (LEPUS_IsObject(arr)) {
    val = LEPUS_GetProperty(ctx, arr, atom);
    ret = LEPUS_ToBoolFree(ctx, val);
  }
  LEPUS_FreeValue(ctx, arr);
  return ret;
}

QJS_STATIC __exception int lepus_operator_instanceof(LEPUSContext *ctx,
                                                     LEPUSValue *sp) {
  LEPUSValue op1, op2;
  BOOL ret;

  op1 = sp[-2];
  op2 = sp[-1];
  ret = LEPUS_IsInstanceOf(ctx, op1, op2);
  if (ret < 0) return ret;
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  sp[-2] = LEPUS_NewBool(ctx, ret);
  return 0;
}

__exception int lepus_operator_typeof(LEPUSContext *ctx, LEPUSValue op1) {
  LEPUSAtom atom;
  int64_t tag;

  tag = LEPUS_VALUE_GET_NORM_TAG(op1);
  switch (tag) {
// <bytedance begin>
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF:
      if (ctx && (LEPUS_LepusRefIsArray(ctx->rt, op1) ||
                  LEPUS_LepusRefIsTable(ctx->rt, op1))) {
        atom = LEPUS_ATOM_object;
      } else {
        atom = LEPUS_ATOM_unknown;
      }
      break;
#endif
      // <bytedance end>

#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_INT:
      if (is_bignum_mode(ctx))
        atom = LEPUS_ATOM_bigint;
      else
        atom = LEPUS_ATOM_number;
      break;
    case LEPUS_TAG_BIG_INT:
      atom = LEPUS_ATOM_bigint;
      break;
    case LEPUS_TAG_FLOAT64:
      atom = LEPUS_ATOM_number;
      break;
    case LEPUS_TAG_BIG_FLOAT:
      atom = LEPUS_ATOM_bigfloat;
      break;
#else
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64:
// <bytedance begin>
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_BIG_INT:
#endif
      // <bytedance end>
      atom = LEPUS_ATOM_number;
      break;
#endif
    case LEPUS_TAG_UNDEFINED:
      atom = LEPUS_ATOM_undefined;
      break;
    case LEPUS_TAG_BOOL:
      atom = LEPUS_ATOM_boolean;
      break;
    case LEPUS_TAG_STRING:
      atom = LEPUS_ATOM_string;
      break;
    case LEPUS_TAG_OBJECT:
      if (LEPUS_IsFunction(ctx, op1))
        atom = LEPUS_ATOM_function;
      else
        goto obj_type;
      break;
    case LEPUS_TAG_NULL:
    obj_type:
      atom = LEPUS_ATOM_object;
      break;
    case LEPUS_TAG_SYMBOL:
      atom = LEPUS_ATOM_symbol;
      break;
    default:
      atom = LEPUS_ATOM_unknown;
      break;
  }
  return atom;
}

QJS_STATIC __exception int lepus_operator_delete(LEPUSContext *ctx,
                                                 LEPUSValue *sp) {
  LEPUSValue op1, op2;
  LEPUSAtom atom;
  int ret;

  op1 = sp[-2];
  op2 = sp[-1];
  atom = lepus_value_to_atom(ctx, op2);
  if (unlikely(atom == LEPUS_ATOM_NULL)) return -1;
  ret = LEPUS_DeleteProperty(ctx, op1, atom, LEPUS_PROP_THROW_STRICT);
  LEPUS_FreeAtom(ctx, atom);
  if (unlikely(ret < 0)) return -1;
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  sp[-2] = LEPUS_NewBool(ctx, ret);
  return 0;
}

QJS_STATIC LEPUSValue lepus_throw_type_error(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  return LEPUS_ThrowTypeError(ctx, "invalid property access");
}

/* XXX: not 100% compatible, but mozilla seems to use a similar
   implementation to ensure that caller in non strict mode does not
   throw (ES5 compatibility) */
QJS_STATIC LEPUSValue lepus_function_proto_caller(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv) {
  LEPUSFunctionBytecode *b = LEPUS_GetFunctionBytecode(this_val);
  if (!b || (b->lepus_mode & LEPUS_MODE_STRICT) || !b->has_prototype) {
    return lepus_throw_type_error(ctx, this_val, 0, NULL);
  }
  return LEPUS_UNDEFINED;
}

QJS_HIDE LEPUSValue lepus_function_proto_fileName(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val) {
  LEPUSFunctionBytecode *b = LEPUS_GetFunctionBytecode(this_val);
  if (b && b->has_debug) {
    return LEPUS_AtomToString(ctx, b->debug.filename);
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue
lepus_function_proto_lineNumber(LEPUSContext *ctx, LEPUSValueConst this_val) {
  LEPUSFunctionBytecode *b = LEPUS_GetFunctionBytecode(this_val);
  if (b && b->has_debug) {
    return LEPUS_NewInt32(ctx, b->debug.line_num);
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC int lepus_arguments_define_own_property(
    LEPUSContext *ctx, LEPUSValueConst this_obj, LEPUSAtom prop,
    LEPUSValueConst val, LEPUSValueConst getter, LEPUSValueConst setter,
    int flags) {
  LEPUSObject *p;
  uint32_t idx;
  p = LEPUS_VALUE_GET_OBJ(this_obj);
  /* convert to normal array when redefining an existing numeric field */
  if (p->fast_array && LEPUS_AtomIsArrayIndex(ctx, &idx, prop) &&
      idx < p->u.array.count) {
    if (convert_fast_array_to_array(ctx, p)) return -1;
  }
  /* run the default define own property */
  return LEPUS_DefineProperty(ctx, this_obj, prop, val, getter, setter,
                              flags | LEPUS_PROP_NO_EXOTIC);
}

LEPUSValue lepus_build_arguments(LEPUSContext *ctx, int argc,
                                 LEPUSValueConst *argv) {
  LEPUSValue val, *tab;
  LEPUSProperty *pr;
  LEPUSObject *p;
  int i;

  val = LEPUS_NewObjectProtoClass(ctx, ctx->class_proto[LEPUS_CLASS_OBJECT],
                                  LEPUS_CLASS_ARGUMENTS);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_OBJ(val);

  /* add the length field (cannot fail) */
  pr = add_property(ctx, p, LEPUS_ATOM_length,
                    LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  pr->u.value = LEPUS_NewInt32(ctx, argc);

  /* initialize the fast array part */
  tab = NULL;
  if (argc > 0) {
    tab = static_cast<LEPUSValue *>(lepus_malloc(ctx, sizeof(tab[0]) * argc));
    if (!tab) {
      LEPUS_FreeValue(ctx, val);
      return LEPUS_EXCEPTION;
    }
    for (i = 0; i < argc; i++) {
      tab[i] = LEPUS_DupValue(ctx, argv[i]);
    }
  }
  p->u.array.u.values = tab;
  p->u.array.count = argc;

  LEPUS_DefinePropertyValue(ctx, val, LEPUS_ATOM_Symbol_iterator,
                            LEPUS_DupValue(ctx, ctx->array_proto_values),
                            LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE);
  /* add callee property to throw a TypeError in strict mode */
  LEPUS_DefineProperty(ctx, val, LEPUS_ATOM_callee, LEPUS_UNDEFINED,
                       ctx->throw_type_error, ctx->throw_type_error,
                       LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET);
  return val;
}

#define GLOBAL_VAR_OFFSET 0x40000000
#define ARGUMENT_VAR_OFFSET 0x20000000

/* legacy arguments object: add references to the function arguments */
LEPUSValue lepus_build_mapped_arguments(LEPUSContext *ctx, int argc,
                                        LEPUSValueConst *argv,
                                        LEPUSStackFrame *sf, int arg_count) {
  LEPUSValue val;
  LEPUSProperty *pr;
  LEPUSObject *p;
  int i;

  val = LEPUS_NewObjectProtoClass(ctx, ctx->class_proto[LEPUS_CLASS_OBJECT],
                                  LEPUS_CLASS_MAPPED_ARGUMENTS);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_OBJ(val);

  /* add the length field (cannot fail) */
  pr = add_property(ctx, p, LEPUS_ATOM_length,
                    LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  pr->u.value = LEPUS_NewInt32(ctx, argc);

  for (i = 0; i < arg_count; i++) {
    LEPUSVarRef *var_ref;
    var_ref = get_var_ref(ctx, sf, i, TRUE);
    if (!var_ref) goto fail;
    pr = add_property(ctx, p, __JS_AtomFromUInt32(i),
                      LEPUS_PROP_C_W_E | LEPUS_PROP_VARREF);
    if (!pr) {
      free_var_ref(ctx->rt, var_ref);
      goto fail;
    }
    pr->u.var_ref = var_ref;
  }

  /* the arguments not mapped to the arguments of the function can
     be normal properties */
  for (i = arg_count; i < argc; i++) {
    if (LEPUS_DefinePropertyValueUint32(
            ctx, val, i, LEPUS_DupValue(ctx, argv[i]), LEPUS_PROP_C_W_E) < 0)
      goto fail;
  }

  LEPUS_DefinePropertyValue(ctx, val, LEPUS_ATOM_Symbol_iterator,
                            LEPUS_DupValue(ctx, ctx->array_proto_values),
                            LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE);
  /* callee returns this function in non strict mode */
  LEPUS_DefinePropertyValue(
      ctx, val, LEPUS_ATOM_callee,
      LEPUS_DupValue(ctx, ctx->rt->current_stack_frame->cur_func),
      LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE);
  return val;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

LEPUSValue lepus_build_rest(LEPUSContext *ctx, int first, int argc,
                            LEPUSValueConst *argv) {
  LEPUSValue val;
  int i, ret;

  val = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(val)) return val;
  for (i = first; i < argc; i++) {
    ret = LEPUS_DefinePropertyValueUint32(
        ctx, val, i - first, LEPUS_DupValue(ctx, argv[i]), LEPUS_PROP_C_W_E);
    if (ret < 0) {
      LEPUS_FreeValue(ctx, val);
      return LEPUS_EXCEPTION;
    }
  }
  return val;
}

QJS_STATIC LEPUSValue build_for_in_iterator(LEPUSContext *ctx, LEPUSValue obj) {
  LEPUSObject *p, *p1;
  LEPUSPropertyEnum *tab_atom;
  int i;
  LEPUSValue enum_obj;
  LEPUSForInIterator *it;
  int64_t tag;
  uint32_t tab_atom_count;

  tag = LEPUS_VALUE_GET_TAG(obj);
  if (tag != LEPUS_TAG_OBJECT && tag != LEPUS_TAG_NULL &&
      tag != LEPUS_TAG_UNDEFINED) {
    obj = LEPUS_ToObjectFree(ctx, obj);
  }

  it = static_cast<LEPUSForInIterator *>(lepus_malloc(ctx, sizeof(*it)));
  if (!it) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  enum_obj =
      LEPUS_NewObjectProtoClass(ctx, LEPUS_NULL, LEPUS_CLASS_FOR_IN_ITERATOR);
  if (LEPUS_IsException(enum_obj)) {
    lepus_free(ctx, it);
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  it->is_array = FALSE;
  it->obj = obj;
  it->idx = 0;
  p = LEPUS_VALUE_GET_OBJ(enum_obj);
  p->u.for_in_iterator = it;

  if (tag == LEPUS_TAG_NULL || tag == LEPUS_TAG_UNDEFINED) return enum_obj;

  p = LEPUS_VALUE_GET_OBJ(obj);

  /* fast path: assume no enumerable properties in the prototype chain */
  p1 = p->shape->proto;
  while (p1 != NULL) {
    if (LEPUS_GetOwnPropertyNamesInternal(
            ctx, &tab_atom, &tab_atom_count, p1,
            LEPUS_GPN_STRING_MASK | LEPUS_GPN_ENUM_ONLY))
      goto fail;
    lepus_free_prop_enum(ctx, tab_atom, tab_atom_count);
    if (tab_atom_count != 0) {
      goto slow_path;
    }
    p1 = p1->shape->proto;
  }
  if (p->fast_array) {
    LEPUSShape *sh;
    LEPUSShapeProperty *prs;
    /* check that there are no enumerable normal fields */
    sh = p->shape;
    for (i = 0, prs = get_shape_prop(sh); i < sh->prop_count; i++, prs++) {
      if (prs->flags & LEPUS_PROP_ENUMERABLE) goto normal_case;
    }
    /* 10.4.5.1 + 10.4.5.10 + 10.4.5.11, if detached, return undefined */
    /* for fast arrays, we only store the number of elements */
    it->is_array = TRUE;
    it->array_length = p->u.array.count;
  } else {
  normal_case:
    if (LEPUS_GetOwnPropertyNamesInternal(
            ctx, &tab_atom, &tab_atom_count, p,
            LEPUS_GPN_STRING_MASK | LEPUS_GPN_ENUM_ONLY))
      goto fail;
    for (i = 0; i < tab_atom_count; i++) {
      LEPUS_SetPropertyInternal(ctx, enum_obj, tab_atom[i].atom, LEPUS_NULL, 0);
    }
    lepus_free_prop_enum(ctx, tab_atom, tab_atom_count);
  }
  return enum_obj;

slow_path:
  /* non enumerable properties hide the enumerables ones in the
     prototype chain */
  while (p != NULL) {
    if (LEPUS_GetOwnPropertyNamesInternal(
            ctx, &tab_atom, &tab_atom_count, p,
            LEPUS_GPN_STRING_MASK | LEPUS_GPN_SET_ENUM))
      goto fail;
    for (i = 0; i < tab_atom_count; i++) {
      LEPUS_DefinePropertyValue(
          ctx, enum_obj, tab_atom[i].atom, LEPUS_NULL,
          (tab_atom[i].is_enumerable ? LEPUS_PROP_ENUMERABLE : 0));
    }
    lepus_free_prop_enum(ctx, tab_atom, tab_atom_count);
    p = p->shape->proto;
  }
  return enum_obj;

fail:
  LEPUS_FreeValue(ctx, enum_obj);
  return LEPUS_EXCEPTION;
}

/* obj -> enum_obj */
QJS_STATIC __exception int lepus_for_in_start(LEPUSContext *ctx,
                                              LEPUSValue *sp) {
  sp[-1] = build_for_in_iterator(ctx, sp[-1]);
  if (LEPUS_IsException(sp[-1])) return -1;
  return 0;
}

/* enum_obj -> enum_obj value done */
__exception int lepus_for_in_next(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValueConst enum_obj;
  LEPUSObject *p;
  LEPUSAtom prop;
  LEPUSForInIterator *it;
  int ret;

  enum_obj = sp[-1];
  /* fail safe */
  if (LEPUS_VALUE_IS_NOT_OBJECT(enum_obj)) goto done;
  p = LEPUS_VALUE_GET_OBJ(enum_obj);
  if (p->class_id != LEPUS_CLASS_FOR_IN_ITERATOR) goto done;
  it = p->u.for_in_iterator;

  for (;;) {
    if (it->is_array) {
      if (it->idx >= it->array_length) goto done;
      prop = __JS_AtomFromUInt32(it->idx);
      it->idx++;
    } else {
      LEPUSShape *sh = p->shape;
      LEPUSShapeProperty *prs;
      if (it->idx >= sh->prop_count) goto done;
      prs = get_shape_prop(sh) + it->idx;
      prop = prs->atom;
      it->idx++;
      if (prop == LEPUS_ATOM_NULL || !(prs->flags & LEPUS_PROP_ENUMERABLE))
        continue;
    }
    /* check if the property was deleted */
    ret = LEPUS_HasProperty(ctx, it->obj, prop);
    if (ret < 0) return ret;
    if (ret) break;
  }
  /* return the property */
  sp[0] = LEPUS_AtomToValue(ctx, prop);
  sp[1] = LEPUS_FALSE;
  return 0;
done:
  /* return the end */
  sp[0] = LEPUS_UNDEFINED;
  sp[1] = LEPUS_TRUE;
  return 0;
}

QJS_STATIC LEPUSValue LEPUS_GetIterator2(LEPUSContext *ctx, LEPUSValueConst obj,
                                         LEPUSValueConst method) {
  LEPUSValue enum_obj;

  enum_obj = LEPUS_Call(ctx, method, obj, 0, NULL);
  if (LEPUS_IsException(enum_obj)) return enum_obj;
  if (!LEPUS_IsObject(enum_obj)) {
    LEPUS_FreeValue(ctx, enum_obj);
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  }
  return enum_obj;
}

QJS_STATIC LEPUSValue LEPUS_GetIterator(LEPUSContext *ctx, LEPUSValueConst obj,
                                        BOOL is_async) {
  LEPUSValue method, ret, sync_iter;

  if (is_async) {
    method = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_Symbol_asyncIterator);
    if (LEPUS_IsException(method)) return method;
    if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
      method = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_Symbol_iterator);
      if (LEPUS_IsException(method)) return method;
      sync_iter = LEPUS_GetIterator2(ctx, obj, method);
      LEPUS_FreeValue(ctx, method);
      if (LEPUS_IsException(sync_iter)) return sync_iter;
      ret = LEPUS_CreateAsyncFromSyncIterator(ctx, sync_iter);
      LEPUS_FreeValue(ctx, sync_iter);
      return ret;
    }
  } else {
    method = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_Symbol_iterator);
    if (LEPUS_IsException(method)) return method;
  }
  if (!LEPUS_IsFunction(ctx, method)) {
    LEPUS_FreeValue(ctx, method);
    return LEPUS_ThrowTypeError(ctx, "value is not iterable");
  }
  ret = LEPUS_GetIterator2(ctx, obj, method);
  LEPUS_FreeValue(ctx, method);
  return ret;
}

/* return *pdone = 2 if the iterator object is not parsed */
QJS_STATIC LEPUSValue LEPUS_IteratorNext2(LEPUSContext *ctx,
                                          LEPUSValueConst enum_obj,
                                          LEPUSValueConst method, int argc,
                                          LEPUSValueConst *argv, int *pdone) {
  LEPUSValue obj;

  /* fast path for the built-in iterators (avoid creating the
     intermediate result object) */
  if (LEPUS_IsObject(method)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(method);
    if (p->class_id == LEPUS_CLASS_C_FUNCTION &&
        p->u.cfunc.cproto == LEPUS_CFUNC_iterator_next) {
      LEPUSCFunctionType func;
      LEPUSValueConst args[1];

      /* in case the function expects one argument */
      if (argc == 0) {
        args[0] = LEPUS_UNDEFINED;
        argv = args;
      }
      func = p->u.cfunc.c_function;
      return func.iterator_next(ctx, enum_obj, argc, argv, pdone,
                                p->u.cfunc.magic);
    }
  }
  obj = LEPUS_Call(ctx, method, enum_obj, argc, argv);
  if (LEPUS_IsException(obj)) goto fail;
  if (!LEPUS_IsObject(obj)) {
    LEPUS_FreeValue(ctx, obj);
    LEPUS_ThrowTypeError(ctx, "iterator must return an object");
    goto fail;
  }
  *pdone = 2;
  return obj;
fail:
  *pdone = FALSE;
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue LEPUS_IteratorNext(LEPUSContext *ctx,
                                         LEPUSValueConst enum_obj,
                                         LEPUSValueConst method, int argc,
                                         LEPUSValueConst *argv, BOOL *pdone) {
  LEPUSValue obj, value, done_val;
  int done;

  obj = LEPUS_IteratorNext2(ctx, enum_obj, method, argc, argv, &done);
  if (LEPUS_IsException(obj)) goto fail;
  if (done != 2) {
    *pdone = done;
    return obj;
  } else {
    done_val = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_done);
    if (LEPUS_IsException(done_val)) goto fail;
    *pdone = LEPUS_ToBoolFree(ctx, done_val);
    value = LEPUS_UNDEFINED;
    if (!*pdone) {
      value = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_value);
    }
    LEPUS_FreeValue(ctx, obj);
    return value;
  }
fail:
  LEPUS_FreeValue(ctx, obj);
  *pdone = FALSE;
  return LEPUS_EXCEPTION;
}

/* return < 0 in case of exception */
int LEPUS_IteratorClose(LEPUSContext *ctx, LEPUSValueConst enum_obj,
                        BOOL is_exception_pending) {
  LEPUSValue method, ret, ex_obj;
  int res;

  if (is_exception_pending) {
    ex_obj = ctx->rt->current_exception;
    ctx->rt->current_exception = LEPUS_NULL;
    res = -1;
  } else {
    ex_obj = LEPUS_UNDEFINED;
    res = 0;
  }
  method = LEPUS_GetProperty(ctx, enum_obj, LEPUS_ATOM_return);
  if (LEPUS_IsException(method)) {
    res = -1;
    goto done;
  }
  if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
    goto done;
  }
  ret = LEPUS_CallFree(ctx, method, enum_obj, 0, NULL);
  if (!is_exception_pending) {
    if (LEPUS_IsException(ret)) {
      res = -1;
    } else if (!LEPUS_IsObject(ret)) {
      LEPUS_ThrowTypeErrorNotAnObject(ctx);
      res = -1;
    }
  }
  LEPUS_FreeValue(ctx, ret);
done:
  if (is_exception_pending) {
    LEPUS_Throw(ctx, ex_obj);
  }
  return res;
}

/* obj -> enum_rec (3 slots) */
__exception int lepus_for_of_start(LEPUSContext *ctx, LEPUSValue *sp,
                                   BOOL is_async) {
  LEPUSValue op1, obj, method;
  op1 = sp[-1];
  obj = LEPUS_GetIterator(ctx, op1, is_async);
  if (LEPUS_IsException(obj)) return -1;
  LEPUS_FreeValue(ctx, op1);
  sp[-1] = obj;
  method = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_next);
  if (LEPUS_IsException(method)) return -1;
  sp[0] = method;
  return 0;
}

/* enum_rec -> enum_rec value done */
__exception int lepus_for_of_next(LEPUSContext *ctx, LEPUSValue *sp,
                                  int offset) {
  LEPUSValue value = LEPUS_UNDEFINED;
  int done = 1;

  if (likely(!LEPUS_IsUndefined(sp[offset]))) {
    value = LEPUS_IteratorNext(ctx, sp[offset], sp[offset + 1], 0, NULL, &done);
    if (LEPUS_IsException(value)) done = -1;
    if (done) {
      /* value is LEPUS_UNDEFINED or LEPUS_EXCEPTION */
      /* replace the iteration object with undefined */
      LEPUS_FreeValue(ctx, sp[offset]);
      sp[offset] = LEPUS_UNDEFINED;
      if (done < 0)
        return -1;
      else {
        LEPUS_FreeValue(ctx, value);
        value = LEPUS_UNDEFINED;
      }
    }
  }
  sp[0] = value;
  sp[1] = LEPUS_NewBool(ctx, done);
  return 0;
}

__exception int lepus_for_await_of_next(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue result;
  result = LEPUS_Call(ctx, sp[-2], sp[-3], 0, NULL);
  if (LEPUS_IsException(result)) return -1;
  sp[0] = result;
  return 0;
}

QJS_STATIC LEPUSValue LEPUS_IteratorGetCompleteValue(LEPUSContext *ctx,
                                                     LEPUSValueConst obj,
                                                     BOOL *pdone) {
  LEPUSValue done_val, value;
  BOOL done;
  done_val = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_done);
  if (LEPUS_IsException(done_val)) goto fail;
  done = LEPUS_ToBoolFree(ctx, done_val);
  value = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_value);
  if (LEPUS_IsException(value)) goto fail;
  *pdone = done;
  return value;
fail:
  *pdone = FALSE;
  return LEPUS_EXCEPTION;
}

__exception int lepus_iterator_get_value_done(LEPUSContext *ctx,
                                              LEPUSValue *sp) {
  LEPUSValue obj, value;
  BOOL done;
  obj = sp[-1];
  if (!LEPUS_IsObject(obj)) {
    LEPUS_ThrowTypeError(ctx, "iterator must return an object");
    return -1;
  }
  value = LEPUS_IteratorGetCompleteValue(ctx, obj, &done);
  if (LEPUS_IsException(value)) return -1;
  LEPUS_FreeValue(ctx, obj);
  sp[-1] = value;
  sp[0] = LEPUS_NewBool(ctx, done);
  return 0;
}

QJS_STATIC LEPUSValue lepus_create_iterator_result(LEPUSContext *ctx,
                                                   LEPUSValue val, BOOL done) {
  LEPUSValue obj;
  obj = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(obj)) {
    LEPUS_FreeValue(ctx, val);
    return obj;
  }
  if (LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_value, val,
                                LEPUS_PROP_C_W_E) < 0) {
    goto fail;
  }
  if (LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_done,
                                LEPUS_NewBool(ctx, done),
                                LEPUS_PROP_C_W_E) < 0) {
  fail:
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  return obj;
}

QJS_STATIC LEPUSValue lepus_array_iterator_next(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc, LEPUSValueConst *argv,
                                                BOOL *pdone, int magic);

QJS_STATIC LEPUSValue lepus_create_array_iterator(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv,
                                                  int magic);

QJS_STATIC BOOL lepus_is_fast_array(LEPUSContext *ctx, LEPUSValueConst obj) {
  /* Try and handle fast arrays explicitly */
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
    if (p->class_id == LEPUS_CLASS_ARRAY && p->fast_array) {
      return TRUE;
    }
  }
  return FALSE;
}

/* Access an Array's internal LEPUSValue array if available */
QJS_STATIC BOOL lepus_get_fast_array(LEPUSContext *ctx, LEPUSValueConst obj,
                                     LEPUSValue **arrpp, uint32_t *countp) {
  /* Try and handle fast arrays explicitly */
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
    if (p->class_id == LEPUS_CLASS_ARRAY && p->fast_array) {
      *countp = p->u.array.count;
      *arrpp = p->u.array.u.values;
      return TRUE;
    }
  }
  return FALSE;
}

__exception int lepus_append_enumerate(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue iterator, enumobj, method, value;
  int pos, is_array_iterator;
  LEPUSValue *arrp;
  uint32_t i, count32;

  if (!LEPUS_VALUE_IS_INT(sp[-2])) {
    LEPUS_ThrowInternalError(ctx, "invalid index for append");
    return -1;
  }

  pos = LEPUS_VALUE_GET_INT(sp[-2]);

  /* XXX: further optimisations:
     - use ctx->array_proto_values?
     - check if array_iterator_prototype next method is built-in and
       avoid constructing actual iterator object?
     - build this into lepus_for_of_start and use in all `for (x of o)` loops
   */
  iterator = LEPUS_GetProperty(ctx, sp[-1], LEPUS_ATOM_Symbol_iterator);
  if (LEPUS_IsException(iterator)) return -1;
  is_array_iterator = LEPUS_IsCFunction(
      ctx, iterator, (LEPUSCFunction *)lepus_create_array_iterator,
      LEPUS_ITERATOR_KIND_VALUE);
  LEPUS_FreeValue(ctx, iterator);

  enumobj = LEPUS_GetIterator(ctx, sp[-1], FALSE);
  if (LEPUS_IsException(enumobj)) return -1;
  method = LEPUS_GetProperty(ctx, enumobj, LEPUS_ATOM_next);
  if (LEPUS_IsException(method)) {
    LEPUS_FreeValue(ctx, enumobj);
    return -1;
  }
  if (is_array_iterator &&
      LEPUS_IsCFunction(ctx, method,
                        (LEPUSCFunction *)lepus_array_iterator_next, 0) &&
      lepus_get_fast_array(ctx, sp[-1], &arrp, &count32)) {
    int64_t len;
    /* Handle fast arrays explicitly */
    if (lepus_get_length64(ctx, &len, sp[-1])) goto exception;
    for (i = 0; i < count32; i++) {
      if (LEPUS_DefinePropertyValueUint32(ctx, sp[-3], pos++,
                                          LEPUS_DupValue(ctx, arrp[i]),
                                          LEPUS_PROP_C_W_E) < 0)
        goto exception;
    }
    if (len > count32) {
      /* This is not strictly correct because the trailing elements are
         empty instead of undefined. Append undefined entries instead.
       */
      pos += len - count32;
      if (LEPUS_SetProperty(ctx, sp[-3], LEPUS_ATOM_length,
                            LEPUS_NewUint32(ctx, pos)) < 0)
        goto exception;
    }
  } else {
    for (;;) {
      BOOL done;
      value = LEPUS_IteratorNext(ctx, enumobj, method, 0, NULL, &done);
      if (LEPUS_IsException(value)) goto exception;
      if (done) {
        /* value is LEPUS_UNDEFINED */
        break;
      }
      if (LEPUS_DefinePropertyValueUint32(ctx, sp[-3], pos++, value,
                                          LEPUS_PROP_C_W_E) < 0)
        goto exception;
    }
  }
  sp[-2] = LEPUS_NewInt32(ctx, pos);
  LEPUS_FreeValue(ctx, enumobj);
  LEPUS_FreeValue(ctx, method);
  return 0;

exception:
  LEPUS_IteratorClose(ctx, enumobj, TRUE);
  LEPUS_FreeValue(ctx, enumobj);
  LEPUS_FreeValue(ctx, method);
  return -1;
}

QJS_STATIC __exception int LEPUS_CopyDataProperties(LEPUSContext *ctx,
                                                    LEPUSValueConst target,
                                                    LEPUSValueConst source,
                                                    LEPUSValueConst excluded,
                                                    BOOL setprop) {
  LEPUSPropertyEnum *tab_atom;
  LEPUSValue val;
  uint32_t i, tab_atom_count;
  LEPUSObject *p;
  LEPUSObject *pexcl = NULL;
  int ret = 0, flags;
// <ByteDance begin>
#ifdef ENABLE_LEPUSNG
  if (LEPUS_VALUE_IS_LEPUS_REF(source)) {
    source = ctx->rt->lepus_callbacks_.convert_to_object(ctx, source);
  }
#endif
  // <ByteDance end>

  if (LEPUS_VALUE_IS_NOT_OBJECT(source)) return 0;

  if (LEPUS_VALUE_IS_OBJECT(excluded)) pexcl = LEPUS_VALUE_GET_OBJ(excluded);

  p = LEPUS_VALUE_GET_OBJ(source);
  if (LEPUS_GetOwnPropertyNamesInternal(
          ctx, &tab_atom, &tab_atom_count, p,
          LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK | LEPUS_GPN_ENUM_ONLY))
    return -1;

  flags = LEPUS_PROP_C_W_E;

  for (i = 0; i < tab_atom_count; i++) {
    if (pexcl) {
      ret = LEPUS_GetOwnPropertyInternal(ctx, NULL, pexcl, tab_atom[i].atom);
      if (ret) {
        if (ret < 0) break;
        ret = 0;
        continue;
      }
    }
    ret = -1;
    val = LEPUS_GetProperty(ctx, source, tab_atom[i].atom);
    if (LEPUS_IsException(val)) break;
    if (setprop)
      ret = LEPUS_SetProperty(ctx, target, tab_atom[i].atom, val);
    else
      ret =
          LEPUS_DefinePropertyValue(ctx, target, tab_atom[i].atom, val, flags);
    if (ret < 0) break;
    ret = 0;
  }
  lepus_free_prop_enum(ctx, tab_atom, tab_atom_count);
  return ret;
}

/* only valid inside C functions */
QJS_HIDE LEPUSValueConst LEPUS_GetActiveFunction(LEPUSContext *ctx) {
  if (ctx->rt->current_stack_frame) {
    return ctx->rt->current_stack_frame->cur_func;
  } else {
    return LEPUS_UNDEFINED;
  }
}

LEPUSVarRef *get_var_ref(LEPUSContext *ctx, LEPUSStackFrame *sf, int var_idx,
                         BOOL is_arg) {
  LEPUSVarRef *var_ref;
  struct list_head *el;

  list_for_each(el, &sf->var_ref_list) {
    var_ref = list_entry(el, LEPUSVarRef, link);
    if (var_ref->var_idx == var_idx && var_ref->is_arg == is_arg) {
      var_ref->header.ref_count++;
      return var_ref;
    }
  }
  /* create a new one */
  var_ref = static_cast<LEPUSVarRef *>(lepus_malloc(ctx, sizeof(LEPUSVarRef)));
  if (!var_ref) return NULL;
  var_ref->header.ref_count = 1;
  var_ref->gc_header.mark = 0;
  var_ref->is_arg = is_arg;
  var_ref->var_idx = var_idx;
  list_add_tail(&var_ref->link, &sf->var_ref_list);
  if (is_arg)
    var_ref->pvalue = &sf->arg_buf[var_idx];
  else
    var_ref->pvalue = &sf->var_buf[var_idx];
  var_ref->value = LEPUS_UNDEFINED;
  return var_ref;
}

QJS_STATIC LEPUSValue lepus_closure2(LEPUSContext *ctx, LEPUSValue func_obj,
                                     LEPUSFunctionBytecode *b,
                                     LEPUSVarRef **cur_var_refs,
                                     LEPUSStackFrame *sf) {
  LEPUSObject *p;
  LEPUSVarRef **var_refs;
  int i;

  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->u.func.function_bytecode = b;
  p->u.func.home_object = NULL;
  p->u.func.var_refs = NULL;
  if (b->closure_var_count) {
    var_refs = static_cast<LEPUSVarRef **>(
        lepus_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count));
    if (!var_refs) goto fail;
    p->u.func.var_refs = var_refs;
    for (i = 0; i < b->closure_var_count; i++) {
      LEPUSClosureVar *cv = &b->closure_var[i];
      LEPUSVarRef *var_ref;
      if (cv->is_local) {
        /* reuse the existing variable reference if it already exists */
        var_ref = get_var_ref(ctx, sf, cv->var_idx, cv->is_arg);
        if (!var_ref) goto fail;
      } else {
        var_ref = cur_var_refs[cv->var_idx];
        var_ref->header.ref_count++;
      }
      var_refs[i] = var_ref;
    }
  }
  return func_obj;
fail:
  /* bfunc is freed when func_obj is freed */
  LEPUS_FreeValue(ctx, func_obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_instantiate_prototype(LEPUSContext *ctx,
                                                  LEPUSObject *p,
                                                  LEPUSAtom atom,
                                                  void *opaque) {
  LEPUSValue obj, this_val;
  int ret;

  this_val = LEPUS_MKPTR(LEPUS_TAG_OBJECT, p);
  obj = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  set_cycle_flag(ctx, obj);
  set_cycle_flag(ctx, this_val);
  ret = LEPUS_DefinePropertyValue(
      ctx, obj, LEPUS_ATOM_constructor, LEPUS_DupValue(ctx, this_val),
      LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  if (ret < 0) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  return obj;
}

static const uint16_t func_kind_to_class_id[] = {
    [LEPUS_FUNC_NORMAL] = LEPUS_CLASS_BYTECODE_FUNCTION,
    [LEPUS_FUNC_GENERATOR] = LEPUS_CLASS_GENERATOR_FUNCTION,
    [LEPUS_FUNC_ASYNC] = LEPUS_CLASS_ASYNC_FUNCTION,
    [LEPUS_FUNC_ASYNC_GENERATOR] = LEPUS_CLASS_ASYNC_GENERATOR_FUNCTION,
};

LEPUSValue lepus_closure(LEPUSContext *ctx, LEPUSValue bfunc,
                         LEPUSVarRef **cur_var_refs, LEPUSStackFrame *sf) {
  LEPUSFunctionBytecode *b;
  LEPUSValue func_obj;
  LEPUSAtom name_atom;

  b = static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(bfunc));
  func_obj = LEPUS_NewObjectClass(ctx, func_kind_to_class_id[b->func_kind]);
  if (LEPUS_IsException(func_obj)) {
    LEPUS_FreeValue(ctx, bfunc);
    return LEPUS_EXCEPTION;
  }
  func_obj = lepus_closure2(ctx, func_obj, b, cur_var_refs, sf);
  if (LEPUS_IsException(func_obj)) {
    /* bfunc has been freed */
    goto fail;
  }
  name_atom = b->func_name;
  if (name_atom == LEPUS_ATOM_NULL) name_atom = LEPUS_ATOM_empty_string;
  lepus_function_set_properties(ctx, func_obj, name_atom, b->defined_arg_count);

  if (b->func_kind & LEPUS_FUNC_GENERATOR) {
    LEPUSValue proto;
    int proto_class_id;
    /* generators have a prototype field which is used as
       prototype for the generator object */
    if (b->func_kind == LEPUS_FUNC_ASYNC_GENERATOR)
      proto_class_id = LEPUS_CLASS_ASYNC_GENERATOR;
    else
      proto_class_id = LEPUS_CLASS_GENERATOR;
    proto = LEPUS_NewObjectProto(ctx, ctx->class_proto[proto_class_id]);
    if (LEPUS_IsException(proto)) goto fail;
    LEPUS_DefinePropertyValue(ctx, func_obj, LEPUS_ATOM_prototype, proto,
                              LEPUS_PROP_WRITABLE);
  } else if (b->has_prototype) {
    /* add the 'prototype' property: delay instantiation to avoid
       creating cycles for every javascript function. The prototype
       object is created on the fly when first accessed */
    LEPUS_SetConstructorBit(ctx, func_obj, TRUE);
    LEPUS_DefineAutoInitProperty(ctx, func_obj, LEPUS_ATOM_prototype,
                                 lepus_instantiate_prototype, NULL,
                                 LEPUS_PROP_WRITABLE);
  }
  return func_obj;
fail:
  /* bfunc is freed when func_obj is freed */
  LEPUS_FreeValue(ctx, func_obj);
  return LEPUS_EXCEPTION;
}

#define LEPUS_DEFINE_CLASS_HAS_HERITAGE (1 << 0)

int lepus_op_define_class(LEPUSContext *ctx, LEPUSValue *sp,
                          LEPUSAtom class_name, int class_flags,
                          LEPUSVarRef **cur_var_refs, LEPUSStackFrame *sf) {
  LEPUSValue bfunc, parent_class, proto = LEPUS_UNDEFINED;
  LEPUSValue ctor = LEPUS_UNDEFINED, parent_proto = LEPUS_UNDEFINED;
  LEPUSFunctionBytecode *b;

  parent_class = sp[-2];
  bfunc = sp[-1];

  if (class_flags & LEPUS_DEFINE_CLASS_HAS_HERITAGE) {
    if (LEPUS_IsNull(parent_class)) {
      parent_proto = LEPUS_NULL;
      parent_class = LEPUS_DupValue(ctx, ctx->function_proto);
    } else {
      if (!LEPUS_IsConstructor(ctx, parent_class)) {
        LEPUS_ThrowTypeError(ctx, "parent class must be constructor");
        goto fail;
      }
      parent_proto = LEPUS_GetProperty(ctx, parent_class, LEPUS_ATOM_prototype);
      if (LEPUS_IsException(parent_proto)) goto fail;
      if (!LEPUS_IsNull(parent_proto) && !LEPUS_IsObject(parent_proto)) {
        LEPUS_ThrowTypeError(ctx, "parent prototype must be an object or null");
        goto fail;
      }
    }
  } else {
    /* parent_class is LEPUS_UNDEFINED in this case */
    parent_proto = LEPUS_DupValue(ctx, ctx->class_proto[LEPUS_CLASS_OBJECT]);
    parent_class = LEPUS_DupValue(ctx, ctx->function_proto);
  }
  proto = LEPUS_NewObjectProto(ctx, parent_proto);
  if (LEPUS_IsException(proto)) goto fail;

  b = static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(bfunc));
  assert(b->func_kind == LEPUS_FUNC_NORMAL);
  ctor = LEPUS_NewObjectProtoClass(ctx, parent_class,
                                   LEPUS_CLASS_BYTECODE_FUNCTION);
  if (LEPUS_IsException(ctor)) goto fail;
  ctor = lepus_closure2(ctx, ctor, b, cur_var_refs, sf);
  bfunc = LEPUS_UNDEFINED;
  if (LEPUS_IsException(ctor)) goto fail;
  lepus_method_set_home_object(ctx, ctor, proto);
  LEPUS_SetConstructorBit(ctx, ctor, TRUE);

  LEPUS_DefinePropertyValue(ctx, ctor, LEPUS_ATOM_length,
                            LEPUS_NewInt32(ctx, b->defined_arg_count),
                            LEPUS_PROP_CONFIGURABLE);

  /* the constructor property must be first. It can be overriden by
     computed property names */
  if (LEPUS_DefinePropertyValue(
          ctx, proto, LEPUS_ATOM_constructor, LEPUS_DupValue(ctx, ctor),
          LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE | LEPUS_PROP_THROW) < 0)
    goto fail;
  /* set the prototype property */
  if (LEPUS_DefinePropertyValue(ctx, ctor, LEPUS_ATOM_prototype,
                                LEPUS_DupValue(ctx, proto),
                                LEPUS_PROP_THROW) < 0)
    goto fail;
  set_cycle_flag(ctx, ctor);
  set_cycle_flag(ctx, proto);

  if (class_name != LEPUS_ATOM_NULL) {
    if (LEPUS_DefineObjectName(ctx, ctor, class_name, LEPUS_PROP_CONFIGURABLE) <
        0)
      goto fail;
  }

  LEPUS_FreeValue(ctx, parent_proto);
  LEPUS_FreeValue(ctx, parent_class);

  sp[-2] = ctor;
  sp[-1] = proto;
  return 0;
fail:
  LEPUS_FreeValue(ctx, parent_class);
  LEPUS_FreeValue(ctx, parent_proto);
  LEPUS_FreeValue(ctx, bfunc);
  LEPUS_FreeValue(ctx, proto);
  LEPUS_FreeValue(ctx, ctor);
  sp[-2] = LEPUS_UNDEFINED;
  sp[-1] = LEPUS_UNDEFINED;
  return -1;
}

QJS_STATIC void close_var_refs(LEPUSRuntime *rt, LEPUSStackFrame *sf) {
  struct list_head *el, *el1;
  LEPUSVarRef *var_ref;
  int var_idx;

  list_for_each_safe(el, el1, &sf->var_ref_list) {
    var_ref = list_entry(el, LEPUSVarRef, link);
    var_idx = var_ref->var_idx;
    if (var_ref->is_arg)
      var_ref->value = LEPUS_DupValueRT(rt, sf->arg_buf[var_idx]);
    else
      var_ref->value = LEPUS_DupValueRT(rt, sf->var_buf[var_idx]);
    var_ref->pvalue = &var_ref->value;
    var_ref->link.prev = NULL; /* the reference is no longer to a
                                  local variable */
  }
}

void close_lexical_var(LEPUSContext *ctx, LEPUSStackFrame *sf, int idx,
                       int is_arg) {
  struct list_head *el, *el1;
  LEPUSVarRef *var_ref;
  int var_idx = idx;

  list_for_each_safe(el, el1, &sf->var_ref_list) {
    var_ref = list_entry(el, LEPUSVarRef, link);
    if (var_idx == var_ref->var_idx && var_ref->is_arg == is_arg) {
      var_ref->value = LEPUS_DupValue(ctx, sf->var_buf[var_idx]);
      var_ref->pvalue = &var_ref->value;
      list_del(&var_ref->link);
      var_ref->link.prev = NULL; /* the reference is no longer to a
                                    local variable */
    }
  }
}

QJS_STATIC LEPUSValue lepus_call_c_function(LEPUSContext *ctx,
                                            LEPUSValueConst func_obj,
                                            LEPUSValueConst this_obj, int argc,
                                            LEPUSValueConst *argv, int flags) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSCFunctionType func;
  LEPUSObject *p;
  LEPUSStackFrame sf_s, *sf = &sf_s, *prev_sf;
  LEPUSValue ret_val;
  LEPUSValueConst *arg_buf;
  int arg_count, i;
  LEPUSCFunctionEnum cproto;

  p = LEPUS_VALUE_GET_OBJ(func_obj);
  cproto = static_cast<LEPUSCFunctionEnum>(p->u.cfunc.cproto);
  arg_count = p->u.cfunc.length;

  /* better to always check stack overflow */
  if (lepus_check_stack_overflow(ctx, sizeof(arg_buf[0]) * arg_count))
    return LEPUS_ThrowStackOverflow(ctx);
#ifdef ENABLE_QUICKJS_DEBUGGER
  BOOL is_debug_mode = ctx->debugger_mode;
  if (is_debug_mode) {
    sf->pthis = this_obj;
  } else {
    sf->pthis = LEPUS_UNDEFINED;
  }
#endif
  prev_sf = rt->current_stack_frame;
  sf->prev_frame = prev_sf;
  rt->current_stack_frame = sf;
#ifdef CONFIG_BIGNUM
  /* we only propagate the bignum mode as some runtime functions
     test it */
  if (prev_sf)
    sf->lepus_mode = prev_sf->lepus_mode & LEPUS_MODE_BIGINT;
  else
    sf->lepus_mode = 0;
#else
  sf->lepus_mode = 0;
#endif
  sf->cur_func = (LEPUSValue)func_obj;
  sf->arg_count = argc;
  arg_buf = argv;

  // <ByteDance begin>
#ifdef OS_IOS
  size_t alloca_size = 0;
#endif
  if (unlikely(argc < arg_count)) {
    /* ensure that at least argc_count arguments are readable */
#ifdef OS_IOS
    alloca_size = sizeof(arg_buf[0]) * arg_count;
    if (lepus_check_virtual_outofmemory(ctx, alloca_size)) {
      return LEPUS_ThrowOutOfMemory(ctx);
    }
    if (lepus_check_virtual_sp_overflow(ctx, alloca_size)) {
      return LEPUS_ThrowStackOverflow(ctx);
    }
    arg_buf = lepus_get_virtual_sp(ctx);
    lepus_push_virtual_sp(ctx, alloca_size);
#elif !defined(OS_WIN)
    arg_buf = static_cast<LEPUSValue *>(alloca(sizeof(arg_buf[0]) * arg_count));
#else
        arg_buf =
            static_cast<LEPUSValue *>(_alloca(sizeof(arg_buf[0]) * arg_count));
#endif

    for (i = 0; i < argc; i++) arg_buf[i] = argv[i];
    for (i = argc; i < arg_count; i++) arg_buf[i] = LEPUS_UNDEFINED;
    sf->arg_count = arg_count;
  }

  // <ByteDance end>
  sf->arg_buf = (LEPUSValue *)arg_buf;

  func = p->u.cfunc.c_function;
  switch (cproto) {
    case LEPUS_CFUNC_constructor:
    case LEPUS_CFUNC_constructor_or_func:
      if (!(flags & LEPUS_CALL_FLAG_CONSTRUCTOR)) {
        if (cproto == LEPUS_CFUNC_constructor) {
        not_a_constructor:
          ret_val = LEPUS_ThrowTypeError(ctx, "must be called with new");
          break;
        } else {
          this_obj = LEPUS_UNDEFINED;
        }
      }
      /* here this_obj is new_target */
      /* fall thru */
    case LEPUS_CFUNC_generic:
      ret_val = func.generic(ctx, this_obj, argc, arg_buf);
      break;
    case LEPUS_CFUNC_constructor_magic:
    case LEPUS_CFUNC_constructor_or_func_magic:
      if (!(flags & LEPUS_CALL_FLAG_CONSTRUCTOR)) {
        if (cproto == LEPUS_CFUNC_constructor_magic) {
          goto not_a_constructor;
        } else {
          this_obj = LEPUS_UNDEFINED;
        }
      }
      /* fall thru */
    case LEPUS_CFUNC_generic_magic:
      ret_val =
          func.generic_magic(ctx, this_obj, argc, arg_buf, p->u.cfunc.magic);
      break;
    case LEPUS_CFUNC_getter:
      ret_val = func.getter(ctx, this_obj);
      break;
    case LEPUS_CFUNC_setter:
      ret_val = func.setter(ctx, this_obj, arg_buf[0]);
      break;
    case LEPUS_CFUNC_getter_magic:
      ret_val = func.getter_magic(ctx, this_obj, p->u.cfunc.magic);
      break;
    case LEPUS_CFUNC_setter_magic:
      ret_val = func.setter_magic(ctx, this_obj, arg_buf[0], p->u.cfunc.magic);
      break;
    case LEPUS_CFUNC_f_f: {
      double d1;

      if (unlikely(LEPUS_ToFloat64(ctx, &d1, arg_buf[0]))) {
        ret_val = LEPUS_EXCEPTION;
        break;
      }
      ret_val = LEPUS_NewFloat64(ctx, func.f_f(d1));
    } break;
    case LEPUS_CFUNC_f_f_f: {
      double d1, d2;

      if (unlikely(LEPUS_ToFloat64(ctx, &d1, arg_buf[0]))) {
        ret_val = LEPUS_EXCEPTION;
        break;
      }
      if (unlikely(LEPUS_ToFloat64(ctx, &d2, arg_buf[1]))) {
        ret_val = LEPUS_EXCEPTION;
        break;
      }
      ret_val = LEPUS_NewFloat64(ctx, func.f_f_f(d1, d2));
    } break;
    case LEPUS_CFUNC_iterator_next: {
      int done;
      ret_val = func.iterator_next(ctx, this_obj, argc, arg_buf, &done,
                                   p->u.cfunc.magic);
      if (!LEPUS_IsException(ret_val) && done != 2) {
        ret_val = lepus_create_iterator_result(ctx, ret_val, done);
      }
    } break;
    default:
      abort();
  }

  rt->current_stack_frame = sf->prev_frame;
  // <ByteDance add>
#ifdef OS_IOS
  lepus_pop_virtual_sp(ctx, alloca_size);
#endif
  return ret_val;
}

QJS_STATIC LEPUSValue lepus_call_bound_function(LEPUSContext *ctx,
                                                LEPUSValueConst func_obj,
                                                LEPUSValueConst this_obj,
                                                int argc, LEPUSValueConst *argv,
                                                int flags) {
  LEPUSObject *p;
  LEPUSBoundFunction *bf;
  LEPUSValueConst *arg_buf, new_target;
  int arg_count, i;

  p = LEPUS_VALUE_GET_OBJ(func_obj);
  bf = p->u.bound_function;
  arg_count = bf->argc + argc;
  if (lepus_check_stack_overflow(ctx, sizeof(LEPUSValue) * arg_count))
    return LEPUS_ThrowStackOverflow(ctx);
  // <ByteDance begin>
  LEPUSValue ret;
#ifdef OS_IOS
  size_t alloca_size = sizeof(LEPUSValue) * arg_count;
  if (lepus_check_virtual_outofmemory(ctx, alloca_size)) {
    return LEPUS_ThrowOutOfMemory(ctx);
  }
  if (lepus_check_virtual_sp_overflow(ctx, alloca_size)) {
    return LEPUS_ThrowStackOverflow(ctx);
  }
  // arg_buf = alloca(sizeof(LEPUSValue) * arg_count);
  // allocat stack size
  arg_buf = lepus_get_virtual_sp(ctx);
  lepus_push_virtual_sp(ctx, alloca_size);
#elif !defined(OS_WIN)
  arg_buf = static_cast<LEPUSValue *>(alloca(sizeof(LEPUSValue) * arg_count));
#else
      arg_buf =
          static_cast<LEPUSValue *>(_alloca(sizeof(LEPUSValue) * arg_count));
#endif
  // <ByteDance end>

  for (i = 0; i < bf->argc; i++) {
    arg_buf[i] = bf->argv[i];
  }
  for (i = 0; i < argc; i++) {
    arg_buf[bf->argc + i] = argv[i];
  }
  if (flags & LEPUS_CALL_FLAG_CONSTRUCTOR) {
    new_target = this_obj;
    if (lepus_same_value(ctx, func_obj, new_target)) new_target = bf->func_obj;
    ret = LEPUS_CallConstructor2(ctx, bf->func_obj, new_target, arg_count,
                                 arg_buf);
  } else {
    ret = LEPUS_Call(ctx, bf->func_obj, bf->this_val, arg_count, arg_buf);
  }
#ifdef OS_IOS
  lepus_pop_virtual_sp(ctx, alloca_size);
#endif
  return ret;
  // <ByteDance end>
}

QJS_STATIC no_inline __exception int __js_poll_interrupts(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  ctx->interrupt_counter = LEPUS_INTERRUPT_COUNTER_INIT;
  if (rt->interrupt_handler) {
    if (rt->interrupt_handler(rt, rt->interrupt_opaque)) {
      /* XXX: should set a specific flag to avoid catching */
      LEPUS_ThrowInternalError(ctx, "interrupted");
      LEPUS_SetUncatchableError(ctx, ctx->rt->current_exception, TRUE);
      return -1;
    }
  }
  return 0;
}

QJS_STATIC inline __exception int lepus_poll_interrupts(LEPUSContext *ctx) {
  if (unlikely(--ctx->interrupt_counter <= 0)) {
    return __js_poll_interrupts(ctx);
  } else {
    return 0;
  }
}

/* argv[] is modified if (flags & LEPUS_CALL_FLAG_COPY_ARGV) = 0. */
QJS_STATIC LEPUSValue LEPUS_CallInternal(LEPUSContext *caller_ctx,
                                         LEPUSValueConst func_obj,
                                         LEPUSValueConst this_obj,
                                         LEPUSValueConst new_target, int argc,
                                         LEPUSValue *argv, int flags) {
  LEPUSRuntime *rt = caller_ctx->rt;
#ifdef ENABLE_QUICKJS_CPU_PROFILER
  if (caller_ctx->debugger_mode && rt->debugger_callbacks_.inspector_check &&
      caller_ctx->debugger_info &&
      caller_ctx->debugger_info->cpu_profiling_started) {
    // before each pc, call this function for debugger processing
    rt->debugger_callbacks_.inspector_check(caller_ctx);
  }
#endif
  LEPUSContext *ctx;
  LEPUSObject *p;
  LEPUSFunctionBytecode *b;
  LEPUSStackFrame sf_s, *sf = &sf_s;
  const uint8_t *pc;
  int opcode, arg_allocated_size, i;
  LEPUSValue *local_buf, *stack_buf, *var_buf, *arg_buf, *sp, ret_val, *pval;
  LEPUSVarRef **var_refs;
  size_t alloca_size;
#ifdef ENABLE_QUICKJS_DEBUGGER
  BOOL is_debug_mode = caller_ctx->debugger_mode;
  if (is_debug_mode) {
    sf->pthis = this_obj;
  } else {
    sf->pthis = LEPUS_UNDEFINED;
  }
#endif

#if !DIRECT_DISPATCH
  //#ifdef 0 && ENABLE_QUICKJS_SECURITY_MODE
#if 0
#define SWITCH(pc)                                                  \
  opcode = *pc;                                                     \
  if (ctx->op_transform_callback.decode_opcode) {                   \
    opcode = ctx->op_transform_callback.decode_opcode(ctx, opcode); \
  }                                                                 \
  pc++;                                                             \
  switch (opcode)
#else
#define SWITCH(pc) switch (opcode = *pc++)
#endif
#define CASE(op) case op
#define DEFAULT default
#define BREAK break
#else
  static const void *const dispatch_table[256] = {
#define DEF(id, size, n_pop, n_push, f) &&case_OP_##id,
#if SHORT_OPCODES
#define def(id, size, n_pop, n_push, f)
#else
#define def(id, size, n_pop, n_push, f) &&case_default,
#endif
#include "quickjs-opcode.h"
    [OP_COUNT... 255] = &&case_default
  };
  //#ifdef 0 && ENABLE_QUICKJS_SECURITY_MODE
#if 0
#define SWITCH(pc)                                                       \
  opcode = *pc;                                                          \
  if (ctx->op_transform_callback.decode_opcode) {                        \
    opcode = (int)ctx->op_transform_callback.decode_opcode(ctx, opcode); \
  }                                                                      \
  pc++;                                                                  \
  goto *dispatch_table[opcode];
#else
#define SWITCH(pc) goto *dispatch_table[opcode = *pc++];
#endif
#define CASE(op) case_##op
#define DEFAULT case_default
#define BREAK SWITCH(pc)
#endif
  // <Bytedance begin>
#ifdef OS_IOS
  BOOL need_free_local_buf = 0;
  // <Bytedance end>
#endif
  if (lepus_poll_interrupts(caller_ctx)) return LEPUS_EXCEPTION;
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(func_obj))) {
    if (flags & LEPUS_CALL_FLAG_GENERATOR) {
      LEPUSAsyncFunctionState *s =
          static_cast<LEPUSAsyncFunctionState *>(LEPUS_VALUE_GET_PTR(func_obj));
      /* func_obj get contains a pointer to LEPUSFuncAsyncState */
      /* the stack frame is already allocated */
      sf = &s->frame;
      p = LEPUS_VALUE_GET_OBJ(sf->cur_func);
      b = p->u.func.function_bytecode;
      ctx = caller_ctx;
      var_refs = p->u.func.var_refs;
      local_buf = arg_buf = sf->arg_buf;
      var_buf = sf->var_buf;
      stack_buf = sf->var_buf + b->var_count;
      sp = sf->cur_sp;
      sf->cur_sp = NULL; /* cur_sp is NULL if the function is running */
      pc = sf->cur_pc;
      sf->prev_frame = rt->current_stack_frame;
      rt->current_stack_frame = sf;
      if (s->throw_flag)
        goto exception;
      else
        goto restart;
    } else {
      goto not_a_function;
    }
  }
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  if (unlikely(p->class_id != LEPUS_CLASS_BYTECODE_FUNCTION)) {
    LEPUSClassCall *call_func;
    call_func = rt->class_array[p->class_id].call;
    if (!call_func) {
    not_a_function:
      return LEPUS_ThrowTypeError(caller_ctx, "not a function");
    }
    return call_func(caller_ctx, func_obj, this_obj, argc,
                     (LEPUSValueConst *)argv, flags);
  }
  b = p->u.func.function_bytecode;

  if (unlikely(argc < b->arg_count || (flags & LEPUS_CALL_FLAG_COPY_ARGV))) {
    arg_allocated_size = b->arg_count;
  } else {
    arg_allocated_size = 0;
  }

  alloca_size =
      sizeof(LEPUSValue) * (arg_allocated_size + b->var_count + b->stack_size);
  if (lepus_check_stack_overflow(caller_ctx, alloca_size))
    return LEPUS_ThrowStackOverflow(caller_ctx);

  sf->lepus_mode = b->lepus_mode;
  arg_buf = argv;
  sf->arg_count = argc;
  sf->cur_func = (LEPUSValue)func_obj;
  init_list_head(&sf->var_ref_list);
  var_refs = p->u.func.var_refs;

  // <Bytedance begin>
#ifdef OS_IOS
  need_free_local_buf = 1;
  if (lepus_check_virtual_outofmemory(caller_ctx, alloca_size)) {
    return LEPUS_ThrowOutOfMemory(caller_ctx);
  }
  if (lepus_check_virtual_sp_overflow(caller_ctx, alloca_size)) {
    return LEPUS_ThrowStackOverflow(caller_ctx);
  }

  local_buf = lepus_get_virtual_sp(caller_ctx);
  lepus_push_virtual_sp(caller_ctx, alloca_size);
#elif !defined(OS_WIN)
  local_buf = static_cast<LEPUSValue *>(alloca(alloca_size));
#else
      local_buf = static_cast<LEPUSValue *>(_alloca(alloca_size));
#endif
  // <Bytdance end>
  if (unlikely(arg_allocated_size)) {
    int n = min_int(argc, b->arg_count);
    arg_buf = local_buf;
    for (i = 0; i < n; i++) arg_buf[i] = LEPUS_DupValue(caller_ctx, argv[i]);
    for (; i < b->arg_count; i++) arg_buf[i] = LEPUS_UNDEFINED;
    sf->arg_count = b->arg_count;
  }
  var_buf = local_buf + arg_allocated_size;
  sf->var_buf = var_buf;
  sf->arg_buf = arg_buf;

  for (i = 0; i < b->var_count; i++) var_buf[i] = LEPUS_UNDEFINED;

  stack_buf = var_buf + b->var_count;
  sp = stack_buf;
  pc = b->byte_code_buf;
  sf->prev_frame = rt->current_stack_frame;
  rt->current_stack_frame = sf;
  ctx = caller_ctx;
restart:
  for (;;) {
    int call_argc;
    LEPUSValue *call_argv;

    // <bytedance begin>
#ifdef ENABLE_QUICKJS_DEBUGGER
    ctx->debugger_current_pc = pc + 1;
    if (is_debug_mode && ctx->debugger_info &&
        !ctx->debugger_info->cpu_profiling_started &&
        ctx->rt->debugger_callbacks_.inspector_check) {
      // before each pc, call this function for debugger processing
      ctx->rt->debugger_callbacks_.inspector_check(ctx);
    }
#endif
    // <bytedance end>

    SWITCH(pc) {
      CASE(OP_push_i32) : *sp++ = LEPUS_NewInt32(ctx, get_u32(pc));
      pc += 4;
      BREAK;
      CASE(OP_push_const) : {
        *sp = LEPUS_DupValue(ctx, b->cpool[get_u32(pc)]);
#ifdef ENABLE_QUICKJS_DEBUGGER
        if (is_debug_mode) {
          DebuggerPause(ctx, *sp, pc);
        }
#endif
        sp++;
        pc += 4;
        BREAK;
      }
#if SHORT_OPCODES
      CASE(OP_push_minus1)
          : CASE(OP_push_0)
          : CASE(OP_push_1)
          : CASE(OP_push_2)
          : CASE(OP_push_3)
          : CASE(OP_push_4)
          : CASE(OP_push_5)
          : CASE(OP_push_6)
          : CASE(OP_push_7) : *sp++ = LEPUS_NewInt32(ctx, opcode - OP_push_0);
      BREAK;
      CASE(OP_push_i8) : *sp++ = LEPUS_NewInt32(ctx, get_i8(pc));
      pc += 1;
      BREAK;
      CASE(OP_push_i16) : *sp++ = LEPUS_NewInt32(ctx, get_i16(pc));
      pc += 2;
      BREAK;
      CASE(OP_push_const8) : {
        *sp = LEPUS_DupValue(ctx, b->cpool[*pc]);
#ifdef ENABLE_QUICKJS_DEBUGGER
        if (is_debug_mode) {
          DebuggerPause(ctx, *sp, pc);
        }
#endif
        sp++;
        pc++;
        BREAK;
      }
      CASE(OP_fclosure8)
          : *sp++ = lepus_closure(ctx, LEPUS_DupValue(ctx, b->cpool[*pc++]),
                                  var_refs, sf);
      if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      BREAK;
      CASE(OP_push_empty_string)
          : *sp++ = LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string);
      BREAK;
      CASE(OP_get_length) : {
        LEPUSValue val;

        val = LEPUS_GetProperty(ctx, sp[-1], LEPUS_ATOM_length);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = val;
      }
      BREAK;
#endif
      CASE(OP_push_atom_value) : *sp++ = LEPUS_AtomToValue(ctx, get_u32(pc));
      pc += 4;
      BREAK;
      CASE(OP_undefined) : *sp++ = LEPUS_UNDEFINED;
      BREAK;
      CASE(OP_null) : *sp++ = LEPUS_NULL;
      BREAK;
      CASE(OP_push_this)
          : /* OP_push_this is only called at the start of a function */
      {
        LEPUSValue val;
        if (!(b->lepus_mode & LEPUS_MODE_STRICT)) {
          if (likely(LEPUS_VALUE_IS_OBJECT(this_obj))) goto normal_this;
          if (LEPUS_VALUE_IS_NULL(this_obj) ||
              LEPUS_VALUE_IS_UNDEFINED(this_obj)) {
            val = LEPUS_DupValue(ctx, ctx->global_obj);
          } else {
            val = LEPUS_ToObject(ctx, this_obj);
            if (LEPUS_IsException(val)) goto exception;
          }
        } else {
        normal_this:
          val = LEPUS_DupValue(ctx, this_obj);
        }
        *sp++ = val;
      }
      BREAK;
      CASE(OP_push_false) : *sp++ = LEPUS_FALSE;
      BREAK;
      CASE(OP_push_true) : *sp++ = LEPUS_TRUE;
      BREAK;
      CASE(OP_object) : *sp++ = LEPUS_NewObject(ctx);
      if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      BREAK;
      CASE(OP_special_object) : {
        int arg = *pc++;
        switch (arg) {
          case OP_SPECIAL_OBJECT_ARGUMENTS:
            *sp++ = lepus_build_arguments(ctx, argc, (LEPUSValueConst *)argv);
            if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
            break;
          case OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS:
            *sp++ =
                lepus_build_mapped_arguments(ctx, argc, (LEPUSValueConst *)argv,
                                             sf, min_int(argc, b->arg_count));
            if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
            break;
          case OP_SPECIAL_OBJECT_THIS_FUNC:
            *sp++ = LEPUS_DupValue(ctx, sf->cur_func);
            break;
          case OP_SPECIAL_OBJECT_NEW_TARGET:
            *sp++ = LEPUS_DupValue(ctx, new_target);
            break;
          case OP_SPECIAL_OBJECT_HOME_OBJECT: {
            LEPUSObject *p1;
            p1 = p->u.func.home_object;
            if (unlikely(!p1))
              *sp++ = LEPUS_UNDEFINED;
            else
              *sp++ = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p1));
          } break;
          case OP_SPECIAL_OBJECT_VAR_OBJECT:
            *sp++ = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
            if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
            break;
          default:
            abort();
        }
      }
      BREAK;
      CASE(OP_rest) : {
        int first = get_u16(pc);
        pc += 2;
        *sp++ = lepus_build_rest(ctx, first, argc, (LEPUSValueConst *)argv);
        if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      }
      BREAK;

      CASE(OP_drop) : LEPUS_FreeValue(ctx, sp[-1]);
      sp--;
      BREAK;
      CASE(OP_nip) : LEPUS_FreeValue(ctx, sp[-2]);
      sp[-2] = sp[-1];
      sp--;
      BREAK;
      CASE(OP_nip1)
          : /* a b c -> b c */
            LEPUS_FreeValue(ctx, sp[-3]);
      sp[-3] = sp[-2];
      sp[-2] = sp[-1];
      sp--;
      BREAK;
      CASE(OP_dup) : sp[0] = LEPUS_DupValue(ctx, sp[-1]);
      sp++;
      BREAK;
      CASE(OP_dup2)
          : /* a b -> a b a b */
            sp[0] = LEPUS_DupValue(ctx, sp[-2]);
      sp[1] = LEPUS_DupValue(ctx, sp[-1]);
      sp += 2;
      BREAK;
      CASE(OP_dup3)
          : /* a b c -> a b c a b c */
            sp[0] = LEPUS_DupValue(ctx, sp[-3]);
      sp[1] = LEPUS_DupValue(ctx, sp[-2]);
      sp[2] = LEPUS_DupValue(ctx, sp[-1]);
      sp += 3;
      BREAK;
      CASE(OP_dup1)
          : /* a b -> a a b */
            sp[0] = sp[-1];
      sp[-1] = LEPUS_DupValue(ctx, sp[-2]);
      sp++;
      BREAK;
      CASE(OP_insert2)
          : /* obj a -> a obj a (dup_x1) */
            sp[0] = sp[-1];
      sp[-1] = sp[-2];
      sp[-2] = LEPUS_DupValue(ctx, sp[0]);
      sp++;
      BREAK;
      CASE(OP_insert3)
          : /* obj prop a -> a obj prop a (dup_x2) */
            sp[0] = sp[-1];
      sp[-1] = sp[-2];
      sp[-2] = sp[-3];
      sp[-3] = LEPUS_DupValue(ctx, sp[0]);
      sp++;
      BREAK;
      CASE(OP_insert4)
          : /* this obj prop a -> a this obj prop a */
            sp[0] = sp[-1];
      sp[-1] = sp[-2];
      sp[-2] = sp[-3];
      sp[-3] = sp[-4];
      sp[-4] = LEPUS_DupValue(ctx, sp[0]);
      sp++;
      BREAK;
      CASE(OP_perm3)
          : /* obj a b -> a obj b (213) */
      {
        LEPUSValue tmp;
        tmp = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = tmp;
      }
      BREAK;
      CASE(OP_rot3l)
          : /* x a b -> a b x (231) */
      {
        LEPUSValue tmp;
        tmp = sp[-3];
        sp[-3] = sp[-2];
        sp[-2] = sp[-1];
        sp[-1] = tmp;
      }
      BREAK;
      CASE(OP_rot4l)
          : /* x a b c -> a b c x */
      {
        LEPUSValue tmp;
        tmp = sp[-4];
        sp[-4] = sp[-3];
        sp[-3] = sp[-2];
        sp[-2] = sp[-1];
        sp[-1] = tmp;
      }
      BREAK;
      CASE(OP_rot5l)
          : /* x a b c d -> a b c d x */
      {
        LEPUSValue tmp;
        tmp = sp[-5];
        sp[-5] = sp[-4];
        sp[-4] = sp[-3];
        sp[-3] = sp[-2];
        sp[-2] = sp[-1];
        sp[-1] = tmp;
      }
      BREAK;
      CASE(OP_rot3r)
          : /* a b x -> x a b (312) */
      {
        LEPUSValue tmp;
        tmp = sp[-1];
        sp[-1] = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = tmp;
      }
      BREAK;
      CASE(OP_perm4)
          : /* obj prop a b -> a obj prop b */
      {
        LEPUSValue tmp;
        tmp = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = sp[-4];
        sp[-4] = tmp;
      }
      BREAK;
      CASE(OP_perm5)
          : /* this obj prop a b -> a this obj prop b */
      {
        LEPUSValue tmp;
        tmp = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = sp[-4];
        sp[-4] = sp[-5];
        sp[-5] = tmp;
      }
      BREAK;
      CASE(OP_swap)
          : /* a b -> b a */
      {
        LEPUSValue tmp;
        tmp = sp[-2];
        sp[-2] = sp[-1];
        sp[-1] = tmp;
      }
      BREAK;
      CASE(OP_swap2)
          : /* a b c d -> c d a b */
      {
        LEPUSValue tmp1, tmp2;
        tmp1 = sp[-4];
        tmp2 = sp[-3];
        sp[-4] = sp[-2];
        sp[-3] = sp[-1];
        sp[-2] = tmp1;
        sp[-1] = tmp2;
      }
      BREAK;

      CASE(OP_fclosure) : {
        LEPUSValue bfunc = LEPUS_DupValue(ctx, b->cpool[get_u32(pc)]);
        pc += 4;
        *sp++ = lepus_closure(ctx, bfunc, var_refs, sf);
        if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      }
      BREAK;
#if SHORT_OPCODES
      CASE(OP_call0)
          : CASE(OP_call1)
          : CASE(OP_call2) : CASE(OP_call3) : call_argc = opcode - OP_call0;
      goto has_call_argc;
#endif
      CASE(OP_call) : CASE(OP_tail_call) : {
        call_argc = get_u16(pc);
        pc += 2;
        goto has_call_argc;
      has_call_argc:
        call_argv = sp - call_argc;
        sf->cur_pc = pc;
        ret_val = LEPUS_CallInternal(ctx, call_argv[-1], LEPUS_UNDEFINED,
                                     LEPUS_UNDEFINED, call_argc, call_argv, 0);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        if (opcode == OP_tail_call) goto done;
        for (i = -1; i < call_argc; i++) LEPUS_FreeValue(ctx, call_argv[i]);
        sp -= call_argc + 1;
        *sp++ = ret_val;
      }
      BREAK;
      CASE(OP_call_constructor) : {
        call_argc = get_u16(pc);
        pc += 2;
        call_argv = sp - call_argc;
        sf->cur_pc = pc;
        ret_val = LEPUS_CallConstructorInternal(
            ctx, call_argv[-2], call_argv[-1], call_argc, call_argv, 0);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        for (i = -2; i < call_argc; i++) LEPUS_FreeValue(ctx, call_argv[i]);
        sp -= call_argc + 2;
        *sp++ = ret_val;
      }
      BREAK;
      CASE(OP_call_method) : CASE(OP_tail_call_method) : {
        call_argc = get_u16(pc);
        pc += 2;
        call_argv = sp - call_argc;
        sf->cur_pc = pc;
        ret_val = LEPUS_CallInternal(ctx, call_argv[-1], call_argv[-2],
                                     LEPUS_UNDEFINED, call_argc, call_argv, 0);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        if (opcode == OP_tail_call_method) goto done;
        for (i = -2; i < call_argc; i++) LEPUS_FreeValue(ctx, call_argv[i]);
        sp -= call_argc + 2;
        *sp++ = ret_val;
      }
      BREAK;
      CASE(OP_array_from) : {
        int i, ret;

        call_argc = get_u16(pc);
        pc += 2;
        ret_val = LEPUS_NewArray(ctx);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        call_argv = sp - call_argc;
        for (i = 0; i < call_argc; i++) {
          ret = LEPUS_DefinePropertyValue(ctx, ret_val, __JS_AtomFromUInt32(i),
                                          call_argv[i],
                                          LEPUS_PROP_C_W_E | LEPUS_PROP_THROW);
          call_argv[i] = LEPUS_UNDEFINED;
          if (ret < 0) {
            LEPUS_FreeValue(ctx, ret_val);
            goto exception;
          }
        }
        sp -= call_argc;
        *sp++ = ret_val;
      }
      BREAK;

      CASE(OP_apply) : {
        int magic;
        magic = get_u16(pc);
        pc += 2;

        ret_val = lepus_function_apply(ctx, sp[-3], 2,
                                       (LEPUSValueConst *)&sp[-2], magic);
        if (unlikely(LEPUS_IsException(ret_val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-3]);
        LEPUS_FreeValue(ctx, sp[-2]);
        LEPUS_FreeValue(ctx, sp[-1]);
        sp -= 3;
        *sp++ = ret_val;
      }
      BREAK;
      CASE(OP_return) : ret_val = *--sp;
      goto done;
      CASE(OP_return_undef) : ret_val = LEPUS_UNDEFINED;
      goto done;

      CASE(OP_check_ctor_return)
          : /* return TRUE if 'this' should be returned */
            if (!LEPUS_IsObject(sp[-1])) {
        if (!LEPUS_IsUndefined(sp[-1])) {
          LEPUS_ThrowTypeError(
              caller_ctx,
              "derived class constructor must return an object or undefined");
          goto exception;
        }
        sp[0] = LEPUS_TRUE;
      }
      else {
        sp[0] = LEPUS_FALSE;
      }
      sp++;
      BREAK;
      CASE(OP_check_ctor) : if (LEPUS_IsUndefined(new_target)) {
        LEPUS_ThrowTypeError(caller_ctx,
                             "class constructors must be invoked with 'new'");
        goto exception;
      }
      BREAK;
      CASE(OP_check_brand)
          : if (LEPUS_CheckBrand(ctx, sp[-2], sp[-1]) < 0) goto exception;
      BREAK;
      CASE(OP_add_brand)
          : if (LEPUS_AddBrand(ctx, sp[-2], sp[-1]) < 0) goto exception;
      LEPUS_FreeValue(ctx, sp[-2]);
      LEPUS_FreeValue(ctx, sp[-1]);
      sp -= 2;
      BREAK;

      CASE(OP_throw) : LEPUS_Throw(ctx, *--sp);
      goto exception;

      CASE(OP_throw_var)
          :
#define LEPUS_THROW_VAR_RO 0
#define LEPUS_THROW_VAR_REDECL 1
#define LEPUS_THROW_VAR_UNINITIALIZED 2
#define LEPUS_THROW_ERROR_DELETE_SUPER 3
      {
        LEPUSAtom atom;
        atom = get_u32(pc);
        int type = pc[4];
        pc += 5;
        if (type == LEPUS_THROW_VAR_RO)
          LEPUS_ThrowTypeErrorReadOnly(ctx, LEPUS_PROP_THROW, atom);
        else if (type == LEPUS_THROW_VAR_REDECL)
          LEPUS_ThrowSyntaxErrorVarRedeclaration(ctx, atom);
        else if (type == LEPUS_THROW_VAR_UNINITIALIZED)
          LEPUS_ThrowReferenceErrorUninitialized(ctx, atom);
        else if (type == LEPUS_THROW_ERROR_DELETE_SUPER)
          LEPUS_ThrowReferenceError(ctx, "unsupported reference to 'super'");
        else
          LEPUS_ThrowInternalError(ctx, "invalid throw var type %d", type);
      }
      goto exception;

      CASE(OP_eval) : {
        LEPUSValue obj;
        int scope_idx;

        scope_idx = get_u16(pc) - 1;
        pc += 2;
        obj = sp[-1];
        sp[-1] = LEPUS_EvalObject(ctx, LEPUS_UNDEFINED, obj,
                                  LEPUS_EVAL_TYPE_DIRECT, scope_idx);
        LEPUS_FreeValue(ctx, obj);
        if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
      }
      BREAK;

      CASE(OP_regexp) : {
        sp[-2] = lepus_regexp_constructor_internal(ctx, LEPUS_UNDEFINED, sp[-2],
                                                   sp[-1]);
        sp--;
      }
      BREAK;

      CASE(OP_get_super_ctor) : {
        LEPUSValue proto;
        proto = LEPUS_DupValue(ctx, LEPUS_GetPrototype(ctx, sp[-1]));
        if (LEPUS_IsException(proto)) goto exception;
        if (!LEPUS_IsConstructor(ctx, proto)) {
          LEPUS_FreeValue(ctx, proto);
          LEPUS_ThrowTypeError(ctx, "not a constructor");
          goto exception;
        }
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = proto;
      }
      BREAK;

      CASE(OP_get_super) : {
        LEPUSValue proto;
        proto = LEPUS_DupValue(ctx, LEPUS_GetPrototype(ctx, sp[-1]));
        if (LEPUS_IsException(proto)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = proto;
      }
      BREAK;

      CASE(OP_import) : {
#ifndef NO_QUICKJS_COMPILER
        LEPUSValue val;
        val = lepus_dynamic_import(ctx, sp[-1]);
        if (LEPUS_IsException(val)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = val;
#endif
      }
      BREAK;

      CASE(OP_check_var) : {
        int ret;
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret = LEPUS_CheckGlobalVar(ctx, atom);
        if (ret < 0) goto exception;
        *sp++ = LEPUS_NewBool(ctx, ret);
      }
      BREAK;

      CASE(OP_get_var_undef) : CASE(OP_get_var) : {
        LEPUSValue val;
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        val = LEPUS_GetGlobalVar(ctx, atom, opcode - OP_get_var_undef);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        *sp++ = val;
      }
      BREAK;

      CASE(OP_put_var) : CASE(OP_put_var_init) : {
        int ret;
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret = LEPUS_SetGlobalVar(ctx, atom, sp[-1], opcode - OP_put_var);
        sp--;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_put_var_strict) : {
        int ret;
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        /* sp[-2] is LEPUS_TRUE or LEPUS_FALSE */
        if (unlikely(!LEPUS_VALUE_GET_BOOL(sp[-2]))) {
          LEPUS_ThrowReferenceErrorNotDefined(ctx, atom);
          goto exception;
        }
        ret = LEPUS_SetGlobalVar(ctx, atom, sp[-1], 2);
        sp -= 2;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_check_define_var) : {
        LEPUSAtom atom;
        int flags;
        atom = get_u32(pc);
        flags = pc[4];
        pc += 5;
        if (LEPUS_CheckDefineGlobalVar(ctx, atom, flags)) goto exception;
      }
      BREAK;
      CASE(OP_define_var) : {
        LEPUSAtom atom;
        int flags;
        atom = get_u32(pc);
        flags = pc[4];
        pc += 5;
        if (LEPUS_DefineGlobalVar(ctx, atom, flags)) goto exception;
      }
      BREAK;
      CASE(OP_define_func) : {
        LEPUSAtom atom;
        int flags;
        atom = get_u32(pc);
        flags = pc[4];
        pc += 5;
        if (LEPUS_DefineGlobalFunction(ctx, atom, sp[-1], flags))
          goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp--;
      }
      BREAK;

      CASE(OP_get_loc) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        sp[0] = LEPUS_DupValue(ctx, var_buf[idx]);
        sp++;
      }
      BREAK;
      CASE(OP_put_loc) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &var_buf[idx], sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_set_loc) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &var_buf[idx], LEPUS_DupValue(ctx, sp[-1]));
      }
      BREAK;
      CASE(OP_get_arg) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        sp[0] = LEPUS_DupValue(ctx, arg_buf[idx]);
        sp++;
      }
      BREAK;
      CASE(OP_put_arg) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &arg_buf[idx], sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_set_arg) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &arg_buf[idx], LEPUS_DupValue(ctx, sp[-1]));
      }
      BREAK;

#if SHORT_OPCODES
      CASE(OP_get_loc8) : *sp++ = LEPUS_DupValue(ctx, var_buf[*pc++]);
      BREAK;
      CASE(OP_put_loc8) : set_value(ctx, &var_buf[*pc++], *--sp);
      BREAK;
      CASE(OP_set_loc8)
          : set_value(ctx, &var_buf[*pc++], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;

      CASE(OP_get_loc0) : *sp++ = LEPUS_DupValue(ctx, var_buf[0]);
      BREAK;
      CASE(OP_get_loc1) : *sp++ = LEPUS_DupValue(ctx, var_buf[1]);
      BREAK;
      CASE(OP_get_loc2) : *sp++ = LEPUS_DupValue(ctx, var_buf[2]);
      BREAK;
      CASE(OP_get_loc3) : *sp++ = LEPUS_DupValue(ctx, var_buf[3]);
      BREAK;
      CASE(OP_put_loc0) : set_value(ctx, &var_buf[0], *--sp);
      BREAK;
      CASE(OP_put_loc1) : set_value(ctx, &var_buf[1], *--sp);
      BREAK;
      CASE(OP_put_loc2) : set_value(ctx, &var_buf[2], *--sp);
      BREAK;
      CASE(OP_put_loc3) : set_value(ctx, &var_buf[3], *--sp);
      BREAK;
      CASE(OP_set_loc0)
          : set_value(ctx, &var_buf[0], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_loc1)
          : set_value(ctx, &var_buf[1], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_loc2)
          : set_value(ctx, &var_buf[2], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_loc3)
          : set_value(ctx, &var_buf[3], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_get_arg0) : *sp++ = LEPUS_DupValue(ctx, arg_buf[0]);
      BREAK;
      CASE(OP_get_arg1) : *sp++ = LEPUS_DupValue(ctx, arg_buf[1]);
      BREAK;
      CASE(OP_get_arg2) : *sp++ = LEPUS_DupValue(ctx, arg_buf[2]);
      BREAK;
      CASE(OP_get_arg3) : *sp++ = LEPUS_DupValue(ctx, arg_buf[3]);
      BREAK;
      CASE(OP_put_arg0) : set_value(ctx, &arg_buf[0], *--sp);
      BREAK;
      CASE(OP_put_arg1) : set_value(ctx, &arg_buf[1], *--sp);
      BREAK;
      CASE(OP_put_arg2) : set_value(ctx, &arg_buf[2], *--sp);
      BREAK;
      CASE(OP_put_arg3) : set_value(ctx, &arg_buf[3], *--sp);
      BREAK;
      CASE(OP_set_arg0)
          : set_value(ctx, &arg_buf[0], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_arg1)
          : set_value(ctx, &arg_buf[1], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_arg2)
          : set_value(ctx, &arg_buf[2], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_arg3)
          : set_value(ctx, &arg_buf[3], LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_get_var_ref0) : *sp++ = LEPUS_DupValue(ctx, *var_refs[0]->pvalue);
      BREAK;
      CASE(OP_get_var_ref1) : *sp++ = LEPUS_DupValue(ctx, *var_refs[1]->pvalue);
      BREAK;
      CASE(OP_get_var_ref2) : *sp++ = LEPUS_DupValue(ctx, *var_refs[2]->pvalue);
      BREAK;
      CASE(OP_get_var_ref3) : *sp++ = LEPUS_DupValue(ctx, *var_refs[3]->pvalue);
      BREAK;
      CASE(OP_put_var_ref0) : set_value(ctx, var_refs[0]->pvalue, *--sp);
      BREAK;
      CASE(OP_put_var_ref1) : set_value(ctx, var_refs[1]->pvalue, *--sp);
      BREAK;
      CASE(OP_put_var_ref2) : set_value(ctx, var_refs[2]->pvalue, *--sp);
      BREAK;
      CASE(OP_put_var_ref3) : set_value(ctx, var_refs[3]->pvalue, *--sp);
      BREAK;
      CASE(OP_set_var_ref0)
          : set_value(ctx, var_refs[0]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_var_ref1)
          : set_value(ctx, var_refs[1]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_var_ref2)
          : set_value(ctx, var_refs[2]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
      CASE(OP_set_var_ref3)
          : set_value(ctx, var_refs[3]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      BREAK;
#endif

      CASE(OP_get_var_ref) : {
        int idx;
        LEPUSValue val;
        idx = get_u16(pc);
        pc += 2;
        val = *var_refs[idx]->pvalue;
        sp[0] = LEPUS_DupValue(ctx, val);
        sp++;
      }
      BREAK;
      CASE(OP_put_var_ref) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_set_var_ref) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, var_refs[idx]->pvalue, LEPUS_DupValue(ctx, sp[-1]));
      }
      BREAK;
      CASE(OP_get_var_ref_check) : {
        int idx;
        LEPUSValue val;
        idx = get_u16(pc);
        pc += 2;
        val = *var_refs[idx]->pvalue;
        if (unlikely(LEPUS_IsUninitialized(val))) {
          LEPUS_ThrowReferenceErrorUninitialized(ctx, LEPUS_ATOM_NULL);
          goto exception;
        }
        sp[0] = LEPUS_DupValue(ctx, val);
        sp++;
      }
      BREAK;
      CASE(OP_put_var_ref_check) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(LEPUS_IsUninitialized(*var_refs[idx]->pvalue))) {
          LEPUS_ThrowReferenceErrorUninitialized(ctx, LEPUS_ATOM_NULL);
          goto exception;
        }
        set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_put_var_ref_check_init) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(!LEPUS_IsUninitialized(*var_refs[idx]->pvalue))) {
          LEPUS_ThrowReferenceErrorUninitialized(ctx, LEPUS_ATOM_NULL);
          goto exception;
        }
        set_value(ctx, var_refs[idx]->pvalue, sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_set_loc_uninitialized) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        set_value(ctx, &var_buf[idx], LEPUS_UNINITIALIZED);
      }
      BREAK;
      CASE(OP_get_loc_check) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(LEPUS_IsUninitialized(var_buf[idx]))) {
          LEPUS_ThrowReferenceErrorUninitialized(ctx, LEPUS_ATOM_NULL);
          goto exception;
        }
        sp[0] = LEPUS_DupValue(ctx, var_buf[idx]);
        sp++;
      }
      BREAK;
      CASE(OP_put_loc_check) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(LEPUS_IsUninitialized(var_buf[idx]))) {
          LEPUS_ThrowReferenceErrorUninitialized(ctx, LEPUS_ATOM_NULL);
          goto exception;
        }
        set_value(ctx, &var_buf[idx], sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_put_loc_check_init) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        if (unlikely(!LEPUS_IsUninitialized(var_buf[idx]))) {
          LEPUS_ThrowReferenceError(ctx, "'this' can be initialized only once");
          goto exception;
        }
        set_value(ctx, &var_buf[idx], sp[-1]);
        sp--;
      }
      BREAK;
      CASE(OP_close_loc) : {
        int idx;
        idx = get_u16(pc);
        pc += 2;
        close_lexical_var(ctx, sf, idx, FALSE);
      }
      BREAK;

      CASE(OP_make_loc_ref)
          : CASE(OP_make_arg_ref) : CASE(OP_make_var_ref_ref) : {
        LEPUSVarRef *var_ref;
        LEPUSProperty *pr;
        LEPUSAtom atom;
        int idx;
        atom = get_u32(pc);
        idx = get_u16(pc + 4);
        pc += 6;
        *sp++ = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
        if (unlikely(LEPUS_IsException(sp[-1]))) goto exception;
        if (opcode == OP_make_var_ref_ref) {
          var_ref = var_refs[idx];
          var_ref->header.ref_count++;
        } else {
          var_ref = get_var_ref(ctx, sf, idx, opcode == OP_make_arg_ref);
          if (!var_ref) goto exception;
        }
        pr = add_property(ctx, LEPUS_VALUE_GET_OBJ(sp[-1]), atom,
                          LEPUS_PROP_WRITABLE | LEPUS_PROP_VARREF);
        if (!pr) {
          free_var_ref(rt, var_ref);
          goto exception;
        }
        pr->u.var_ref = var_ref;
        *sp++ = LEPUS_AtomToValue(ctx, atom);
      }
      BREAK;
      CASE(OP_make_var_ref) : {
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        if (LEPUS_GetGlobalVarRef(ctx, atom, sp)) goto exception;
        sp += 2;
      }
      BREAK;

      CASE(OP_goto) : pc += (int32_t)get_u32(pc);
      if (unlikely(lepus_poll_interrupts(ctx))) goto exception;
      BREAK;
#if SHORT_OPCODES
      CASE(OP_goto16) : pc += (int16_t)get_u16(pc);
      if (unlikely(lepus_poll_interrupts(ctx))) goto exception;
      BREAK;
      CASE(OP_goto8) : pc += (int8_t)pc[0];
      if (unlikely(lepus_poll_interrupts(ctx))) goto exception;
      BREAK;
#endif
      CASE(OP_if_true) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        pc += 4;
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = LEPUS_ToBoolFree(ctx, op1);
        }
        sp--;
        if (res) {
          pc += (int32_t)get_u32(pc - 4) - 4;
        }
        if (unlikely(lepus_poll_interrupts(ctx))) goto exception;
      }
      BREAK;
      CASE(OP_if_false) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        pc += 4;
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = LEPUS_ToBoolFree(ctx, op1);
        }
        sp--;
        if (!res) {
          pc += (int32_t)get_u32(pc - 4) - 4;
        }
        if (unlikely(lepus_poll_interrupts(ctx))) goto exception;
      }
      BREAK;
#if SHORT_OPCODES
      CASE(OP_if_true8) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        pc += 1;
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = LEPUS_ToBoolFree(ctx, op1);
        }
        sp--;
        if (res) {
          pc += (int8_t)pc[-1] - 1;
        }
        if (unlikely(lepus_poll_interrupts(ctx))) goto exception;
      }
      BREAK;
      CASE(OP_if_false8) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        pc += 1;
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = LEPUS_ToBoolFree(ctx, op1);
        }
        sp--;
        if (!res) {
          pc += (int8_t)pc[-1] - 1;
        }
        if (unlikely(lepus_poll_interrupts(ctx))) goto exception;
      }
      BREAK;
#endif
      CASE(OP_catch) : {
        int32_t diff;
        diff = get_u32(pc);
        sp[0] = LEPUS_NewCatchOffset(ctx, pc + diff - b->byte_code_buf);
        sp++;
        pc += 4;
      }
      BREAK;
      CASE(OP_gosub) : {
        int32_t diff;
        diff = get_u32(pc);
        /* XXX: should have a different tag to avoid security flaw */
        sp[0] = LEPUS_NewInt32(ctx, pc + 4 - b->byte_code_buf);
        sp++;
        pc += diff;
      }
      BREAK;
      CASE(OP_ret) : {
        LEPUSValue op1;
        uint32_t pos;
        op1 = sp[-1];
        if (unlikely(!LEPUS_VALUE_IS_INT(op1))) goto ret_fail;
        pos = LEPUS_VALUE_GET_INT(op1);
        if (unlikely(pos >= b->byte_code_len)) {
        ret_fail:
          LEPUS_ThrowInternalError(ctx, "invalid ret value");
          goto exception;
        }
        sp--;
        pc = b->byte_code_buf + pos;
      }
      BREAK;

      CASE(OP_for_in_start) : if (lepus_for_in_start(ctx, sp)) goto exception;
      BREAK;
      CASE(OP_for_in_next) : if (lepus_for_in_next(ctx, sp)) goto exception;
      sp += 2;
      BREAK;
      CASE(OP_for_of_start)
          : if (lepus_for_of_start(ctx, sp, FALSE)) goto exception;
      sp += 1;
      *sp++ = LEPUS_NewCatchOffset(ctx, 0);
      BREAK;
      CASE(OP_for_of_next) : {
        int offset = -3 - pc[0];
        pc += 1;
        if (lepus_for_of_next(ctx, sp, offset)) goto exception;
        sp += 2;
      }
      BREAK;
      CASE(OP_for_await_of_start)
          : if (lepus_for_of_start(ctx, sp, TRUE)) goto exception;
      sp += 1;
      *sp++ = LEPUS_NewCatchOffset(ctx, 0);
      BREAK;
      CASE(OP_for_await_of_next)
          : if (lepus_for_await_of_next(ctx, sp)) goto exception;
      sp += 1;
      BREAK;
      CASE(OP_iterator_get_value_done)
          : if (lepus_iterator_get_value_done(ctx, sp)) goto exception;
      sp += 1;
      BREAK;

      CASE(OP_iterator_close)
          : sp--; /* drop the catch offset to avoid getting caught by exception
                   */
      LEPUS_FreeValue(ctx, sp[-1]); /* drop the next method */
      sp--;
      if (!LEPUS_IsUndefined(sp[-1])) {
        if (LEPUS_IteratorClose(ctx, sp[-1], FALSE)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
      }
      sp--;
      BREAK;
      CASE(OP_iterator_close_return) : {
        LEPUSValue ret_val;
        /* iter_obj next catch_offset ... ret_val ->
           ret_eval iter_obj next catch_offset */
        ret_val = *--sp;
        while (sp > stack_buf && !LEPUS_VALUE_IS_CATCH_OFFSET(sp[-1])) {
          LEPUS_FreeValue(ctx, *--sp);
        }
        if (unlikely(sp < stack_buf + 3)) {
          LEPUS_ThrowInternalError(ctx, "iterator_close_return");
          LEPUS_FreeValue(ctx, ret_val);
          goto exception;
        }
        sp[0] = sp[-1];
        sp[-1] = sp[-2];
        sp[-2] = sp[-3];
        sp[-3] = ret_val;
        sp++;
      }
      BREAK;

      CASE(OP_async_iterator_close)
          : /* iter_obj next catch_offset -> value flag */
      {
        LEPUSValue ret, method;
        int ret_flag;
        method = LEPUS_GetProperty(ctx, sp[-3], LEPUS_ATOM_return);
        if (LEPUS_IsException(method)) goto exception;
        if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
          ret = LEPUS_UNDEFINED;
          ret_flag = TRUE;
        } else {
          ret = LEPUS_CallFree(ctx, method, sp[-3], 0, NULL);
          if (LEPUS_IsException(ret)) goto exception;
          ret_flag = FALSE;
        }
        LEPUS_FreeValue(ctx, sp[-3]);
        LEPUS_FreeValue(ctx, sp[-2]);
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-3] = ret;
        sp[-2] = LEPUS_NewBool(ctx, ret_flag);
        sp -= 1;
      }
      BREAK;

      CASE(OP_async_iterator_next)
          : /* stack: iter_obj next catch_offset val */
      {
        LEPUSValue ret;
        ret = LEPUS_Call(ctx, sp[-3], sp[-4], 1, (LEPUSValueConst *)(sp - 1));
        if (LEPUS_IsException(ret)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = ret;
      }
      BREAK;

      CASE(OP_async_iterator_get)
          : /* stack: iter_obj next catch_offset val */
      {
        LEPUSValue method, ret;
        BOOL ret_flag;
        int flags;
        flags = *pc++;
        if (flags == 2) {
          LEPUS_ThrowTypeError(ctx, "iterator does not have a throw method");
          goto exception;
        }
        method = LEPUS_GetProperty(
            ctx, sp[-4], flags ? LEPUS_ATOM_throw : LEPUS_ATOM_return);
        if (LEPUS_IsException(method)) goto exception;
        if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
          ret_flag = TRUE;
        } else {
          ret = LEPUS_CallFree(ctx, method, sp[-4], 1,
                               (LEPUSValueConst *)(sp - 1));
          if (LEPUS_IsException(ret)) goto exception;
          LEPUS_FreeValue(ctx, sp[-1]);
          sp[-1] = ret;
          ret_flag = FALSE;
        }
        sp[0] = LEPUS_NewBool(ctx, ret_flag);
        sp += 1;
      }
      BREAK;

      CASE(OP_lnot) : {
        int res;
        LEPUSValue op1;

        op1 = sp[-1];
        int64_t tag = LEPUS_VALUE_GET_TAG(op1);
        if (tag == LEPUS_TAG_BOOL) {
          res = LEPUS_VALUE_GET_BOOL(op1);
        } else if (tag == LEPUS_TAG_INT) {
          res = LEPUS_VALUE_GET_INT(op1);
        } else if (tag == LEPUS_TAG_UNDEFINED) {
          res = 0;
        } else if (tag == LEPUS_TAG_NULL) {
          res = 0;
        } else {
          res = LEPUS_ToBoolFree(ctx, op1);
        }
        sp[-1] = LEPUS_NewBool(ctx, !res);
      }
      BREAK;

      CASE(OP_get_field) : {
        LEPUSValue val;
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        val = LEPUS_GetProperty(ctx, sp[-1], atom);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = val;
      }
      BREAK;

      CASE(OP_get_field2) : {
        LEPUSValue val;
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        val = LEPUS_GetProperty(ctx, sp[-1], atom);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        *sp++ = val;
      }
      BREAK;

      CASE(OP_put_field) : {
        int ret;
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret = LEPUS_SetPropertyInternal(ctx, sp[-2], atom, sp[-1],
                                        LEPUS_PROP_THROW_STRICT);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp -= 2;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_private_symbol) : {
        LEPUSAtom atom;
        LEPUSValue val;

        atom = get_u32(pc);
        pc += 4;
        val = LEPUS_NewSymbolFromAtom(ctx, atom, LEPUS_ATOM_TYPE_PRIVATE);
        if (LEPUS_IsException(val)) goto exception;
        *sp++ = val;
      }
      BREAK;

      CASE(OP_get_private_field) : {
        LEPUSValue val;

        val = LEPUS_GetPrivateField(ctx, sp[-2], sp[-1]);
        LEPUS_FreeValue(ctx, sp[-1]);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp[-2] = val;
        sp--;
        if (unlikely(LEPUS_IsException(val))) goto exception;
      }
      BREAK;

      CASE(OP_put_private_field) : {
        int ret;
        ret = LEPUS_SetPrivateField(ctx, sp[-3], sp[-1], sp[-2]);
        LEPUS_FreeValue(ctx, sp[-3]);
        LEPUS_FreeValue(ctx, sp[-1]);
        sp -= 3;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_define_private_field) : {
        int ret;
        ret = LEPUS_DefinePrivateField(ctx, sp[-3], sp[-2], sp[-1]);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp -= 2;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_define_field) : {
        int ret;
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret = LEPUS_DefinePropertyValue(ctx, sp[-2], atom, sp[-1],
                                        LEPUS_PROP_C_W_E | LEPUS_PROP_THROW);
        sp--;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_set_name) : {
        int ret;
        LEPUSAtom atom;
        atom = get_u32(pc);
        pc += 4;

        ret =
            LEPUS_DefineObjectName(ctx, sp[-1], atom, LEPUS_PROP_CONFIGURABLE);
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;
      CASE(OP_set_name_computed) : {
        int ret;
        ret = LEPUS_DefineObjectNameComputed(ctx, sp[-1], sp[-2],
                                             LEPUS_PROP_CONFIGURABLE);
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;
      CASE(OP_set_proto) : {
        LEPUSValue proto;
        proto = sp[-1];
        if (LEPUS_IsObject(proto) || LEPUS_IsNull(proto)) {
          if (LEPUS_SetPrototypeInternal(ctx, sp[-2], proto, TRUE) < 0)
            goto exception;
        }
        LEPUS_FreeValue(ctx, proto);
        sp--;
      }
      BREAK;
      CASE(OP_set_home_object)
          : lepus_method_set_home_object(ctx, sp[-1], sp[-2]);
      BREAK;
      CASE(OP_define_method) : CASE(OP_define_method_computed) : {
        LEPUSValue getter, setter, value;
        LEPUSValueConst obj;
        LEPUSAtom atom;
        int flags, ret, op_flags;
        BOOL is_computed;
#define OP_DEFINE_METHOD_METHOD 0
#define OP_DEFINE_METHOD_GETTER 1
#define OP_DEFINE_METHOD_SETTER 2
#define OP_DEFINE_METHOD_ENUMERABLE 4

        is_computed = (opcode == OP_define_method_computed);
        if (is_computed) {
          atom = lepus_value_to_atom(ctx, sp[-2]);
          if (unlikely(atom == LEPUS_ATOM_NULL)) goto exception;
          opcode += OP_define_method - OP_define_method_computed;
        } else {
          atom = get_u32(pc);
          pc += 4;
        }
        op_flags = *pc++;

        obj = sp[-2 - is_computed];
        flags = LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE |
                LEPUS_PROP_HAS_ENUMERABLE | LEPUS_PROP_THROW;
        if (op_flags & OP_DEFINE_METHOD_ENUMERABLE)
          flags |= LEPUS_PROP_ENUMERABLE;
        op_flags &= 3;
        value = LEPUS_UNDEFINED;
        getter = LEPUS_UNDEFINED;
        setter = LEPUS_UNDEFINED;
        if (op_flags == OP_DEFINE_METHOD_METHOD) {
          value = sp[-1];
          flags |= LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE |
                   LEPUS_PROP_WRITABLE;
        } else if (op_flags == OP_DEFINE_METHOD_GETTER) {
          getter = sp[-1];
          flags |= LEPUS_PROP_HAS_GET;
        } else {
          setter = sp[-1];
          flags |= LEPUS_PROP_HAS_SET;
        }
        ret = lepus_method_set_properties(ctx, sp[-1], atom, flags, obj);
        if (ret >= 0) {
          ret = LEPUS_DefineProperty(ctx, obj, atom, value, getter, setter,
                                     flags);
        }
        LEPUS_FreeValue(ctx, sp[-1]);
        if (is_computed) {
          LEPUS_FreeAtom(ctx, atom);
          LEPUS_FreeValue(ctx, sp[-2]);
        }
        sp -= 1 + is_computed;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_define_class) : {
        int class_flags;
        LEPUSAtom atom;

        atom = get_u32(pc);
        class_flags = pc[4];
        pc += 5;
        if (lepus_op_define_class(ctx, sp, atom, class_flags, var_refs, sf) < 0)
          goto exception;
      }
      BREAK;

      CASE(OP_get_array_el) : {
        LEPUSValue val;

        val = LEPUS_GetPropertyValue(ctx, sp[-2], sp[-1]);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp[-2] = val;
        sp--;
        if (unlikely(LEPUS_IsException(val))) goto exception;
      }
      BREAK;

      CASE(OP_get_array_el2) : {
        LEPUSValue val;

        val = LEPUS_GetPropertyValue(ctx, sp[-2], sp[-1]);
        sp[-1] = val;
        if (unlikely(LEPUS_IsException(val))) goto exception;
      }
      BREAK;

      CASE(OP_get_ref_value) : {
        LEPUSValue val;
        if (unlikely(LEPUS_IsUndefined(sp[-2]))) {
          LEPUSAtom atom = lepus_value_to_atom(ctx, sp[-1]);
          if (atom != LEPUS_ATOM_NULL) {
            LEPUS_ThrowReferenceErrorNotDefined(ctx, atom);
            LEPUS_FreeAtom(ctx, atom);
          }
          goto exception;
        }
        val = LEPUS_GetPropertyValue(ctx, sp[-2], LEPUS_DupValue(ctx, sp[-1]));
        if (unlikely(LEPUS_IsException(val))) goto exception;
        sp[0] = val;
        sp++;
      }
      BREAK;

      CASE(OP_get_super_value) : {
        LEPUSValue val;
        LEPUSAtom atom;
        atom = lepus_value_to_atom(ctx, sp[-1]);
        if (unlikely(atom == LEPUS_ATOM_NULL)) goto exception;
        val = LEPUS_GetPropertyInternal(ctx, sp[-2], atom, sp[-3], FALSE);
        LEPUS_FreeAtom(ctx, atom);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        LEPUS_FreeValue(ctx, sp[-2]);
        LEPUS_FreeValue(ctx, sp[-3]);
        sp[-3] = val;
        sp -= 2;
      }
      BREAK;

      CASE(OP_put_array_el) : {
        int ret;

        ret = LEPUS_SetPropertyValue(
            ctx, sp[-3], sp[-2], sp[-1],
            (LEPUS_IsTypedArray(ctx, sp[-3]) ? 0 : LEPUS_PROP_THROW_STRICT));
        LEPUS_FreeValue(ctx, sp[-3]);
        sp -= 3;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_put_ref_value) : {
        int ret;
        if (unlikely(LEPUS_IsUndefined(sp[-3]))) {
          if (is_strict_mode(ctx)) {
            LEPUSAtom atom = lepus_value_to_atom(ctx, sp[-2]);
            if (atom != LEPUS_ATOM_NULL) {
              LEPUS_ThrowReferenceErrorNotDefined(ctx, atom);
              LEPUS_FreeAtom(ctx, atom);
            }
            goto exception;
          } else {
            sp[-3] = LEPUS_DupValue(ctx, ctx->global_obj);
          }
        }
        ret = LEPUS_SetPropertyValue(ctx, sp[-3], sp[-2], sp[-1],
                                     LEPUS_PROP_THROW_STRICT);
        LEPUS_FreeValue(ctx, sp[-3]);
        sp -= 3;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_put_super_value) : {
        int ret;
        LEPUSAtom atom;
        if (LEPUS_VALUE_IS_NOT_OBJECT(sp[-3])) {
          LEPUS_ThrowTypeErrorNotAnObject(ctx);
          goto exception;
        }
        atom = lepus_value_to_atom(ctx, sp[-2]);
        if (unlikely(atom == LEPUS_ATOM_NULL)) goto exception;
        ret = LEPUS_SetPropertyGeneric(ctx, LEPUS_VALUE_GET_OBJ(sp[-3]), atom,
                                       sp[-1], sp[-4], LEPUS_PROP_THROW_STRICT);
        LEPUS_FreeAtom(ctx, atom);
        LEPUS_FreeValue(ctx, sp[-4]);
        LEPUS_FreeValue(ctx, sp[-3]);
        LEPUS_FreeValue(ctx, sp[-2]);
        sp -= 4;
        if (ret < 0) goto exception;
      }
      BREAK;

      CASE(OP_define_array_el) : {
        int ret;
        ret = LEPUS_DefinePropertyValueValue(
            ctx, sp[-3], LEPUS_DupValue(ctx, sp[-2]), sp[-1],
            LEPUS_PROP_C_W_E | LEPUS_PROP_THROW);
        sp -= 1;
        if (unlikely(ret < 0)) goto exception;
      }
      BREAK;

      CASE(OP_append)
          : /* array pos enumobj -- array pos */
      {
        if (lepus_append_enumerate(ctx, sp)) goto exception;
        LEPUS_FreeValue(ctx, *--sp);
      }
      BREAK;

      CASE(OP_copy_data_properties)
          : /* target source excludeList */
      {
        /* stack offsets (-1 based):
           2 bits for target,
           3 bits for source,
           2 bits for exclusionList */
        int mask;

        mask = *pc++;
        if (LEPUS_CopyDataProperties(ctx, sp[-1 - (mask & 3)],
                                     sp[-1 - ((mask >> 2) & 7)],
                                     sp[-1 - ((mask >> 5) & 7)], 0))
          goto exception;
      }
      BREAK;

      CASE(OP_add) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int64_t r;
          r = (int64_t)LEPUS_VALUE_GET_INT(op1) + LEPUS_VALUE_GET_INT(op2);
          if (unlikely((int)r != r)) goto add_slow;
          sp[-2] = LEPUS_NewInt32(ctx, r);
          sp--;
        } else if (LEPUS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
          sp[-2] = __JS_NewFloat64(
              ctx, LEPUS_VALUE_GET_FLOAT64(op1) + LEPUS_VALUE_GET_FLOAT64(op2));
          sp--;
        } else {
        add_slow:
          if (lepus_add_slow(ctx, sp)) goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_add_loc) : {
        LEPUSValue *pv;
        int idx;
        idx = *pc;
        pc += 1;

        pv = &var_buf[idx];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(*pv, sp[-1]))) {
          int64_t r;
          r = (int64_t)LEPUS_VALUE_GET_INT(*pv) + LEPUS_VALUE_GET_INT(sp[-1]);
          if (unlikely((int)r != r)) goto add_loc_slow;
          *pv = LEPUS_NewInt32(ctx, r);
          sp--;
        } else if (LEPUS_VALUE_IS_STRING(*pv)) {
          LEPUSValue op1;
          op1 = sp[-1];
          sp--;
          op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NONE);
          if (LEPUS_IsException(op1)) {
            goto exception;
          }
          op1 = LEPUS_ConcatString(ctx, LEPUS_DupValue(ctx, *pv), op1);
          if (LEPUS_IsException(op1)) {
            goto exception;
          }
          set_value(ctx, pv, op1);
        } else {
          LEPUSValue ops[2];
        add_loc_slow:
          /* In case of exception, lepus_add_slow frees ops[0]
             and ops[1]. */
          ops[0] = LEPUS_DupValue(ctx, *pv);
          ops[1] = sp[-1];
          sp--;
          if (lepus_add_slow(ctx, ops + 2)) {
            goto exception;
          }
          set_value(ctx, pv, ops[0]);
        }
      }
      BREAK;
      CASE(OP_sub) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int64_t r;
          r = (int64_t)LEPUS_VALUE_GET_INT(op1) - LEPUS_VALUE_GET_INT(op2);
          if (unlikely((int)r != r)) goto binary_arith_slow;
          sp[-2] = LEPUS_NewInt32(ctx, r);
          sp--;
        } else if (LEPUS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
          sp[-2] = __JS_NewFloat64(
              ctx, LEPUS_VALUE_GET_FLOAT64(op1) - LEPUS_VALUE_GET_FLOAT64(op2));
          sp--;
        } else {
          goto binary_arith_slow;
        }
      }
      BREAK;
      CASE(OP_mul) : {
        LEPUSValue op1, op2;
        double d;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int32_t v1, v2;
          int64_t r;
          v1 = LEPUS_VALUE_GET_INT(op1);
          v2 = LEPUS_VALUE_GET_INT(op2);
          r = (int64_t)v1 * v2;
#ifdef CONFIG_BIGNUM
          if (unlikely((int)r != r) || (r == 0 && !is_bignum_mode(ctx)))
            goto binary_arith_slow;
#else
          if (unlikely((int)r != r)) {
            d = (double)r;
            goto mul_fp_res;
          }
          /* need to test zero case for -0 result */
          if (unlikely(r == 0 && (v1 | v2) < 0)) {
            d = -0.0;
            goto mul_fp_res;
          }
#endif
          sp[-2] = LEPUS_NewInt32(ctx, r);
          sp--;
        } else if (LEPUS_VALUE_IS_BOTH_FLOAT(op1, op2)) {
          d = LEPUS_VALUE_GET_FLOAT64(op1) * LEPUS_VALUE_GET_FLOAT64(op2);
#ifndef CONFIG_BIGNUM
        mul_fp_res:
#endif
          sp[-2] = __JS_NewFloat64(ctx, d);
          sp--;
        } else {
          goto binary_arith_slow;
        }
      }
      BREAK;
#ifdef CONFIG_BIGNUM
      CASE(OP_math_div) : CASE(OP_div) : goto binary_arith_slow;
#else
      CASE(OP_div) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int v1, v2;
          v1 = LEPUS_VALUE_GET_INT(op1);
          v2 = LEPUS_VALUE_GET_INT(op2);
          sp[-2] = LEPUS_NewFloat64(ctx, (double)v1 / (double)v2);
          sp--;
        } else {
          goto binary_arith_slow;
        }
      }
      BREAK;
#endif
      CASE(OP_mod)
          :
#ifdef CONFIG_BIGNUM
            CASE(OP_math_mod)
          :
#endif
      {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          int v1, v2, r;
          v1 = LEPUS_VALUE_GET_INT(op1);
          v2 = LEPUS_VALUE_GET_INT(op2);
          /* We must avoid v2 = 0, v1 = INT32_MIN and v2 =
             -1 and the cases where the result is -0. */
          if (unlikely(v1 < 0 || v2 <= 0)) goto binary_arith_slow;
          r = v1 % v2;
          sp[-2] = LEPUS_NewInt32(ctx, r);
          sp--;
        } else {
          goto binary_arith_slow;
        }
      }
      BREAK;
      CASE(OP_pow)
          :
#ifdef CONFIG_BIGNUM
            CASE(OP_math_pow)
          :
#endif
            binary_arith_slow
          : if (lepus_binary_arith_slow(
                    ctx, sp, static_cast<OPCodeEnum>(opcode))) goto exception;
      sp--;
      BREAK;

      CASE(OP_plus) : {
        LEPUSValue op1;
        uint32_t tag;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1) || LEPUS_VALUE_IS_FLOAT64(op1)) {
        } else {
          if (lepus_unary_arith_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
        }
      }
      BREAK;
      CASE(OP_neg) : {
        LEPUSValue op1;
        int val;
        double d;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
#ifdef CONFIG_BIGNUM
          if (unlikely(val == INT32_MIN) || (val == 0 && !is_bignum_mode(ctx)))
            goto slow_neg;
#else
          /* Note: -0 cannot be expressed as integer */
          if (unlikely(val == 0)) {
            d = -0.0;
            goto neg_fp_res;
          }
          if (unlikely(val == INT32_MIN)) {
            d = -(double)val;
            goto neg_fp_res;
          }
#endif
          sp[-1] = LEPUS_NewInt32(ctx, -val);
        } else if (LEPUS_VALUE_IS_FLOAT64(op1)) {
          d = -LEPUS_VALUE_GET_FLOAT64(op1);
#ifndef CONFIG_BIGNUM
        neg_fp_res:
#endif
          sp[-1] = __JS_NewFloat64(ctx, d);
        } else {
#ifdef CONFIG_BIGNUM
        slow_neg:
#endif
          if (lepus_unary_arith_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
        }
      }
      BREAK;
      CASE(OP_inc) : {
        LEPUSValue op1;
        int val;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
          if (unlikely(val == INT32_MAX)) goto inc_slow;
          sp[-1] = LEPUS_NewInt32(ctx, val + 1);
        } else {
        inc_slow:
          if (lepus_unary_arith_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
        }
      }
      BREAK;
      CASE(OP_dec) : {
        LEPUSValue op1;
        int val;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
          if (unlikely(val == INT32_MIN)) goto dec_slow;
          sp[-1] = LEPUS_NewInt32(ctx, val - 1);
        } else {
        dec_slow:
          if (lepus_unary_arith_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
        }
      }
      BREAK;
      CASE(OP_post_inc)
          : CASE(OP_post_dec)
          : if (lepus_post_inc_slow(
                    ctx, sp, static_cast<OPCodeEnum>(opcode))) goto exception;
      sp++;
      BREAK;
      CASE(OP_inc_loc) : {
        LEPUSValue op1;
        int val;
        int idx;
        idx = *pc;
        pc += 1;

        op1 = var_buf[idx];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
          if (unlikely(val == INT32_MAX)) goto inc_loc_slow;
          var_buf[idx] = LEPUS_NewInt32(ctx, val + 1);
        } else {
        inc_loc_slow:
          /* must duplicate otherwise the variable value may
            be destroyed before JS code accesses it */
          op1 = LEPUS_DupValue(ctx, op1);
          if (lepus_unary_arith_slow(ctx, &op1 + 1, OP_inc)) goto exception;
          set_value(ctx, &var_buf[idx], op1);
        }
      }
      BREAK;
      CASE(OP_dec_loc) : {
        LEPUSValue op1;
        int val;
        int idx;
        idx = *pc;
        pc += 1;

        op1 = var_buf[idx];
        if (LEPUS_VALUE_IS_INT(op1)) {
          val = LEPUS_VALUE_GET_INT(op1);
          if (unlikely(val == INT32_MIN)) goto dec_loc_slow;
          var_buf[idx] = LEPUS_NewInt32(ctx, val - 1);
        } else {
        dec_loc_slow:
          /* must duplicate otherwise the variable value may
            be destroyed before JS code accesses it */
          op1 = LEPUS_DupValue(ctx, op1);
          if (lepus_unary_arith_slow(ctx, &op1 + 1, OP_dec)) goto exception;
          set_value(ctx, &var_buf[idx], op1);
        }
      }
      BREAK;
      CASE(OP_not) : {
        LEPUSValue op1;
        op1 = sp[-1];
        if (LEPUS_VALUE_IS_INT(op1)) {
          sp[-1] = LEPUS_NewInt32(ctx, ~LEPUS_VALUE_GET_INT(op1));
        } else {
          if (lepus_not_slow(ctx, sp)) goto exception;
        }
      }
      BREAK;

      CASE(OP_shl) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          uint32_t v1, v2;
          v1 = LEPUS_VALUE_GET_INT(op1);
          v2 = LEPUS_VALUE_GET_INT(op2);
#ifdef CONFIG_BIGNUM
          {
            int64_t r;
            if (is_bignum_mode(ctx)) {
              if (v2 > 0x1f) goto shl_slow;
              r = (int64_t)v1 << v2;
              if ((int)r != r) goto shl_slow;
            } else {
              v2 &= 0x1f;
            }
          }
#else
          v2 &= 0x1f;
#endif
          sp[-2] = LEPUS_NewInt32(ctx, v1 << v2);
          sp--;
        } else {
#ifdef CONFIG_BIGNUM
        shl_slow:
#endif
          if (lepus_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_shr) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          uint32_t v2;
          v2 = LEPUS_VALUE_GET_INT(op2);
          /* v1 >>> v2 retains its LEPUS semantics if CONFIG_BIGNUM */
          v2 &= 0x1f;
          sp[-2] =
              LEPUS_NewUint32(ctx, (uint32_t)LEPUS_VALUE_GET_INT(op1) >> v2);
          sp--;
        } else {
          if (lepus_shr_slow(ctx, sp)) goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_sar) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          uint32_t v2;
          v2 = LEPUS_VALUE_GET_INT(op2);
#ifdef CONFIG_BIGNUM
          if (unlikely(v2 > 0x1f)) {
            if (is_bignum_mode(ctx))
              goto sar_slow;
            else
              v2 &= 0x1f;
          }
#else
          v2 &= 0x1f;
#endif
          sp[-2] = LEPUS_NewInt32(ctx, (int)LEPUS_VALUE_GET_INT(op1) >> v2);
          sp--;
        } else {
#ifdef CONFIG_BIGNUM
        sar_slow:
#endif
          if (lepus_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_and) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          sp[-2] = LEPUS_NewInt32(
              ctx, LEPUS_VALUE_GET_INT(op1) & LEPUS_VALUE_GET_INT(op2));
          sp--;
        } else {
          if (lepus_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_or) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          sp[-2] = LEPUS_NewInt32(
              ctx, LEPUS_VALUE_GET_INT(op1) | LEPUS_VALUE_GET_INT(op2));
          sp--;
        } else {
          if (lepus_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;
      CASE(OP_xor) : {
        LEPUSValue op1, op2;
        op1 = sp[-2];
        op2 = sp[-1];
        if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {
          sp[-2] = LEPUS_NewInt32(
              ctx, LEPUS_VALUE_GET_INT(op1) ^ LEPUS_VALUE_GET_INT(op2));
          sp--;
        } else {
          if (lepus_binary_logic_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)))
            goto exception;
          sp--;
        }
      }
      BREAK;

#define OP_CMP(opcode, binary_op, slow_call)                                 \
  CASE(opcode) : {                                                           \
    LEPUSValue op1, op2;                                                     \
    op1 = sp[-2];                                                            \
    op2 = sp[-1];                                                            \
    if (likely(LEPUS_VALUE_IS_BOTH_INT(op1, op2))) {                         \
      sp[-2] = LEPUS_NewBool(                                                \
          ctx, LEPUS_VALUE_GET_INT(op1) binary_op LEPUS_VALUE_GET_INT(op2)); \
      sp--;                                                                  \
    } else {                                                                 \
      if (slow_call) goto exception;                                         \
      sp--;                                                                  \
    }                                                                        \
  }                                                                          \
  BREAK

      OP_CMP(OP_lt, <,
             lepus_relational_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)));
      OP_CMP(OP_lte, <=,
             lepus_relational_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)));
      OP_CMP(OP_gt, >,
             lepus_relational_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)));
      OP_CMP(OP_gte, >=,
             lepus_relational_slow(ctx, sp, static_cast<OPCodeEnum>(opcode)));
      OP_CMP(OP_eq, ==, lepus_eq_slow(ctx, sp, 0));
      OP_CMP(OP_neq, !=, lepus_eq_slow(ctx, sp, 1));
      OP_CMP(OP_strict_eq, ==, lepus_strict_eq_slow(ctx, sp, 0));
      OP_CMP(OP_strict_neq, !=, lepus_strict_eq_slow(ctx, sp, 1));

#ifdef CONFIG_BIGNUM
      CASE(OP_mul_pow10) : if (lepus_mul_pow10(ctx, sp)) goto exception;
      sp--;
      BREAK;
#endif
      CASE(OP_in) : if (lepus_operator_in(ctx, sp)) goto exception;
      sp--;
      BREAK;
      CASE(OP_instanceof)
          : if (lepus_operator_instanceof(ctx, sp)) goto exception;
      sp--;
      BREAK;
      CASE(OP_typeof) : {
        LEPUSValue op1;
        LEPUSAtom atom;

        op1 = sp[-1];
        atom = lepus_operator_typeof(ctx, op1);
        LEPUS_FreeValue(ctx, op1);
        sp[-1] = LEPUS_AtomToString(ctx, atom);
      }
      BREAK;
      CASE(OP_delete) : if (lepus_operator_delete(ctx, sp)) goto exception;
      sp--;
      BREAK;
      CASE(OP_delete_var) : {
        LEPUSAtom atom;
        int ret;

        atom = get_u32(pc);
        pc += 4;

        ret = LEPUS_DeleteProperty(ctx, ctx->global_obj, atom, 0);
        if (unlikely(ret < 0)) goto exception;
        *sp++ = LEPUS_NewBool(ctx, ret);
      }
      BREAK;

      CASE(OP_to_object) : if (LEPUS_VALUE_IS_NOT_OBJECT(sp[-1])) {
        ret_val = LEPUS_ToObject(ctx, sp[-1]);
        if (LEPUS_IsException(ret_val)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = ret_val;
      }
      BREAK;

      CASE(OP_to_propkey) : switch (LEPUS_VALUE_GET_TAG(sp[-1])) {
        case LEPUS_TAG_INT:
        case LEPUS_TAG_STRING:
        case LEPUS_TAG_SYMBOL:
          break;
        default:
          ret_val = LEPUS_ToPropertyKey(ctx, sp[-1]);
          if (LEPUS_IsException(ret_val)) goto exception;
          LEPUS_FreeValue(ctx, sp[-1]);
          sp[-1] = ret_val;
          break;
      }
      BREAK;

      CASE(OP_to_propkey2)
          : /* must be tested first */
            if (unlikely(LEPUS_IsUndefined(sp[-2]) || LEPUS_IsNull(sp[-2]))) {
        LEPUS_ThrowTypeError(ctx, "value has no property");
        goto exception;
      }
      switch (LEPUS_VALUE_GET_TAG(sp[-1])) {
        case LEPUS_TAG_INT:
        case LEPUS_TAG_STRING:
        case LEPUS_TAG_SYMBOL:
          break;
        default:
          ret_val = LEPUS_ToPropertyKey(ctx, sp[-1]);
          if (LEPUS_IsException(ret_val)) goto exception;
          LEPUS_FreeValue(ctx, sp[-1]);
          sp[-1] = ret_val;
          break;
      }
      BREAK;
#if 0
        CASE(OP_to_string):
            if (!LEPUS_VALUE_IS_STRING(sp[-1])) {
                ret_val = LEPUS_ToString(ctx, sp[-1]);
                if (LEPUS_IsException(ret_val))
                    goto exception;
                LEPUS_FreeValue(ctx, sp[-1]);
                sp[-1] = ret_val;
            }
            BREAK;
#endif
      CASE(OP_with_get_var)
          : CASE(OP_with_put_var)
          : CASE(OP_with_delete_var)
          : CASE(OP_with_make_ref)
          : CASE(OP_with_get_ref) : CASE(OP_with_get_ref_undef) : {
        LEPUSAtom atom;
        int32_t diff;
        LEPUSValue obj, val;
        int ret, is_with;
        atom = get_u32(pc);
        diff = get_u32(pc + 4);
        is_with = pc[8];
        pc += 9;

        obj = sp[-1];
        ret = LEPUS_HasProperty(ctx, obj, atom);
        if (unlikely(ret < 0)) goto exception;
        if (ret) {
          if (is_with) {
            ret = lepus_has_unscopable(ctx, obj, atom);
            if (unlikely(ret < 0)) goto exception;
            if (ret) goto no_with;
          }
          switch (opcode) {
            case OP_with_get_var:
              val = LEPUS_GetProperty(ctx, obj, atom);
              if (unlikely(LEPUS_IsException(val))) goto exception;
              set_value(ctx, &sp[-1], val);
              break;
            case OP_with_put_var:
              ret = LEPUS_SetPropertyInternal(ctx, obj, atom, sp[-2],
                                              LEPUS_PROP_THROW_STRICT);
              LEPUS_FreeValue(ctx, sp[-1]);
              sp -= 2;
              if (unlikely(ret < 0)) goto exception;
              break;
            case OP_with_delete_var:
              ret = LEPUS_DeleteProperty(ctx, obj, atom, 0);
              if (unlikely(ret < 0)) goto exception;
              LEPUS_FreeValue(ctx, sp[-1]);
              sp[-1] = LEPUS_NewBool(ctx, ret);
              break;
            case OP_with_make_ref:
              /* produce a pair object/propname on the stack */
              *sp++ = LEPUS_AtomToValue(ctx, atom);
              break;
            case OP_with_get_ref:
              /* produce a pair object/method on the stack */
              val = LEPUS_GetProperty(ctx, obj, atom);
              if (unlikely(LEPUS_IsException(val))) goto exception;
              *sp++ = val;
              break;
            case OP_with_get_ref_undef:
              /* produce a pair undefined/function on the stack */
              val = LEPUS_GetProperty(ctx, obj, atom);
              if (unlikely(LEPUS_IsException(val))) goto exception;
              LEPUS_FreeValue(ctx, sp[-1]);
              sp[-1] = LEPUS_UNDEFINED;
              *sp++ = val;
              break;
          }
          pc += diff - 5;
        } else {
        no_with:
          /* if not jumping, drop the object argument */
          LEPUS_FreeValue(ctx, sp[-1]);
          sp--;
        }
      }
      BREAK;

      CASE(OP_await) : ret_val = LEPUS_NewInt32(ctx, FUNC_RET_AWAIT);
      goto done_generator;
      CASE(OP_yield) : ret_val = LEPUS_NewInt32(ctx, FUNC_RET_YIELD);
      goto done_generator;
      CASE(OP_yield_star)
          : CASE(OP_async_yield_star)
          : ret_val = LEPUS_NewInt32(ctx, FUNC_RET_YIELD_STAR);
      goto done_generator;
      CASE(OP_return_async)
          : CASE(OP_initial_yield) : ret_val = LEPUS_UNDEFINED;
      goto done_generator;

      CASE(OP_nop) : BREAK;
#if SHORT_OPCODES
      CASE(OP_is_undefined) : if (LEPUS_VALUE_IS_UNDEFINED(sp[-1])) {
        goto set_true;
      }
      else {
        goto free_and_set_false;
      }
      CASE(OP_is_null) : if (LEPUS_VALUE_IS_NULL(sp[-1])) { goto set_true; }
      else {
        goto free_and_set_false;
      }
      CASE(OP_is_function)
          : if (lepus_operator_typeof(ctx, sp[-1]) == LEPUS_ATOM_function) {
        goto free_and_set_true;
      }
      else {
        goto free_and_set_false;
      }
    free_and_set_true:
      LEPUS_FreeValue(ctx, sp[-1]);
    set_true:
      sp[-1] = LEPUS_TRUE;
      BREAK;
    free_and_set_false:
      LEPUS_FreeValue(ctx, sp[-1]);
      sp[-1] = LEPUS_FALSE;
      BREAK;
#endif
      CASE(OP_invalid)
          : DEFAULT
          : LEPUS_ThrowInternalError(ctx, "invalid opcode: pc=%u opcode=0x%02x",
                                     (int)(pc - b->byte_code_buf - 1), opcode);
      goto exception;
    }
  }
exception:
  if (rt->exception_needs_backtrace) {
    /* add the backtrace information now (it is not done
       before if the exception happens in a bytecode
       operation */
    build_backtrace(ctx, rt->current_exception, NULL, 0, pc, 0);
  }
  if (!LEPUS_IsUncatchableError(ctx, rt->current_exception)) {
    while (sp > stack_buf) {
      LEPUSValue val = *--sp;
      LEPUS_FreeValue(ctx, val);
      if (LEPUS_VALUE_IS_CATCH_OFFSET(val)) {
        int pos = LEPUS_VALUE_GET_CATCH_OFFSET(val);
        if (pos == 0) {
          /* enumerator: close it with a throw */
          LEPUS_FreeValue(ctx, sp[-1]); /* drop the next method */
          sp--;
          LEPUS_IteratorClose(ctx, sp[-1], TRUE);
        } else {
          *sp++ = rt->current_exception;
          rt->current_exception = LEPUS_NULL;
          pc = b->byte_code_buf + pos;
          goto restart;
        }
      }
    }
  }
  ret_val = LEPUS_EXCEPTION;
  /* the local variables are freed by the caller in the generator
     case. Hence the label 'done' should never be reached in a
     generator function. */
  if (b->func_kind != LEPUS_FUNC_NORMAL) {
  done_generator:
    sf->cur_pc = pc;
    sf->cur_sp = sp;
  } else {
  done:
    if (unlikely(!list_empty(&sf->var_ref_list))) {
      /* variable references reference the stack: must close them */
      close_var_refs(rt, sf);
    }
    /* free the local variables and stack */
    for (pval = local_buf; pval < sp; pval++) {
      LEPUS_FreeValue(ctx, *pval);
    }
  }
#ifdef OS_IOS
  if (need_free_local_buf) lepus_pop_virtual_sp(ctx, alloca_size);
#endif
  rt->current_stack_frame = sf->prev_frame;
  return ret_val;
}

QJS_STATIC inline LEPUSValue LEPUS_CallInternalTI(
    LEPUSContext *caller_ctx, LEPUSValue func_obj, LEPUSValue this_obj,
    LEPUSValue new_target, int argc, LEPUSValue *argv, int flags) {
#ifdef ENABLE_PRIMJS_SNAPSHOT
  if (caller_ctx->rt->use_primjs) {
    return entry(this_obj, new_target, func_obj, (address)caller_ctx, argc,
                 argv, flags);
  } else {
    return LEPUS_CallInternal(caller_ctx, func_obj, this_obj, new_target, argc,
                              argv, flags);
  }
#else
  return LEPUS_CallInternal(caller_ctx, func_obj, this_obj, new_target, argc,
                            argv, flags);
#endif
}

LEPUSValue LEPUS_Call(LEPUSContext *ctx, LEPUSValueConst func_obj,
                      LEPUSValueConst this_obj, int argc,
                      LEPUSValueConst *argv) {
  LEPUSValue res =
      LEPUS_CallInternalTI(ctx, func_obj, this_obj, LEPUS_UNDEFINED, argc,
                           (LEPUSValue *)argv, LEPUS_CALL_FLAG_COPY_ARGV);
  return res;
}

QJS_STATIC LEPUSValue LEPUS_CallFree(LEPUSContext *ctx, LEPUSValue func_obj,
                                     LEPUSValueConst this_obj, int argc,
                                     LEPUSValueConst *argv) {
  LEPUSValue res =
      LEPUS_CallInternalTI(ctx, func_obj, this_obj, LEPUS_UNDEFINED, argc,
                           (LEPUSValue *)argv, LEPUS_CALL_FLAG_COPY_ARGV);
  LEPUS_FreeValue(ctx, func_obj);
  return res;
}

QJS_STATIC LEPUSValue lepus_get_prototype_from_ctor(LEPUSContext *ctx,
                                                    LEPUSValueConst ctor,
                                                    LEPUSValueConst def_proto) {
  LEPUSValue proto;
  proto = LEPUS_GetProperty(ctx, ctor, LEPUS_ATOM_prototype);
  if (LEPUS_IsException(proto)) return proto;
  if (!LEPUS_IsObject(proto)) {
    LEPUS_FreeValue(ctx, proto);
    proto = LEPUS_DupValue(ctx, def_proto);
  }
  return proto;
}

QJS_STATIC LEPUSValue lepus_create_from_ctor(LEPUSContext *ctx,
                                             LEPUSValueConst ctor,
                                             int class_id) {
  LEPUSValue proto, obj;
  if (LEPUS_IsUndefined(ctor)) {
    proto = LEPUS_DupValue(ctx, ctx->class_proto[class_id]);
  } else {
    proto = LEPUS_GetProperty(ctx, ctor, LEPUS_ATOM_prototype);
    if (LEPUS_IsException(proto)) return proto;
    if (!LEPUS_IsObject(proto)) {
      LEPUS_FreeValue(ctx, proto);
      /* check if revoked proxy */
      {
        LEPUSProxyData *s = static_cast<LEPUSProxyData *>(
            LEPUS_GetOpaque(ctor, LEPUS_CLASS_PROXY));
        if (s && s->is_revoked) return LEPUS_ThrowTypeErrorRevokedProxy(ctx);
      }
      /* XXX: should use the ctor realm instead of 'ctx' */
      proto = LEPUS_DupValue(ctx, ctx->class_proto[class_id]);
    }
  }
  obj = LEPUS_NewObjectProtoClass(ctx, proto, class_id);
  LEPUS_FreeValue(ctx, proto);
  return obj;
}

/* argv[] is modified if (flags & CALL_FLAG_COPY_ARGV) = 0. */
LEPUSValue LEPUS_CallConstructorInternal(LEPUSContext *ctx,
                                         LEPUSValueConst func_obj,
                                         LEPUSValueConst new_target, int argc,
                                         LEPUSValue *argv, int flags) {
  LEPUSObject *p;
  LEPUSFunctionBytecode *b;

  if (lepus_poll_interrupts(ctx)) return LEPUS_EXCEPTION;
  flags |= LEPUS_CALL_FLAG_CONSTRUCTOR;
  if (unlikely(LEPUS_VALUE_IS_NOT_OBJECT(func_obj))) goto not_a_function;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  if (unlikely(!p->is_constructor))
    return LEPUS_ThrowTypeError(ctx, "not a constructor");
  if (unlikely(p->class_id != LEPUS_CLASS_BYTECODE_FUNCTION)) {
    LEPUSClassCall *call_func;
    call_func = ctx->rt->class_array[p->class_id].call;
    if (!call_func) {
    not_a_function:
      return LEPUS_ThrowTypeError(ctx, "not a function");
    }
    LEPUSValue res = call_func(ctx, func_obj, new_target, argc,
                               (LEPUSValueConst *)argv, flags);
    return res;
  }

  b = p->u.func.function_bytecode;
  if (b->is_derived_class_constructor) {
    LEPUSValue res = LEPUS_CallInternalTI(ctx, func_obj, LEPUS_UNDEFINED,
                                          new_target, argc, argv, flags);
    return res;
  } else {
    LEPUSValue obj, ret;
    /* legacy constructor behavior */
    obj = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_OBJECT);
    if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
    ret =
        LEPUS_CallInternalTI(ctx, func_obj, obj, new_target, argc, argv, flags);
    if (LEPUS_VALUE_IS_OBJECT(ret) || LEPUS_IsException(ret)) {
      LEPUS_FreeValue(ctx, obj);
      return ret;
    } else {
      LEPUS_FreeValue(ctx, ret);
      return obj;
    }
  }
}

LEPUSValue LEPUS_CallConstructor2(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                  LEPUSValueConst new_target, int argc,
                                  LEPUSValueConst *argv) {
  return LEPUS_CallConstructorInternal(ctx, func_obj, new_target, argc,
                                       (LEPUSValue *)argv,
                                       LEPUS_CALL_FLAG_COPY_ARGV);
}

LEPUSValue LEPUS_CallConstructor(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                 int argc, LEPUSValueConst *argv) {
  return LEPUS_CallConstructorInternal(ctx, func_obj, func_obj, argc,
                                       (LEPUSValue *)argv,
                                       LEPUS_CALL_FLAG_COPY_ARGV);
}

LEPUSValue LEPUS_Invoke(LEPUSContext *ctx, LEPUSValueConst this_val,
                        LEPUSAtom atom, int argc, LEPUSValueConst *argv) {
  LEPUSValue func_obj;
  func_obj = LEPUS_GetProperty(ctx, this_val, atom);
  if (LEPUS_IsException(func_obj)) return func_obj;
  return LEPUS_CallFree(ctx, func_obj, this_val, argc, argv);
}

QJS_STATIC LEPUSValue LEPUS_InvokeFree(LEPUSContext *ctx, LEPUSValue this_val,
                                       LEPUSAtom atom, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue res = LEPUS_Invoke(ctx, this_val, atom, argc, argv);
  LEPUS_FreeValue(ctx, this_val);
  return res;
}

/* LEPUSAsyncFunctionState (used by generator and async functions) */
QJS_STATIC __exception int async_func_init(LEPUSContext *ctx,
                                           LEPUSAsyncFunctionState *s,
                                           LEPUSValueConst func_obj,
                                           LEPUSValueConst this_obj, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSObject *p;
  LEPUSFunctionBytecode *b;
  LEPUSStackFrame *sf;
  int local_count, i, arg_buf_len, n;

  sf = &s->frame;
  init_list_head(&sf->var_ref_list);
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  b = p->u.func.function_bytecode;
  sf->lepus_mode = b->lepus_mode;
  sf->cur_pc = b->byte_code_buf;
  arg_buf_len = max_int(b->arg_count, argc);
  local_count =
      arg_buf_len + b->var_count + b->stack_size + 10 * sizeof(char *);
  sf->arg_buf = static_cast<LEPUSValue *>(
      lepus_malloc(ctx, sizeof(LEPUSValue) * max_int(local_count, 1)));
  if (!sf->arg_buf) return -1;
  sf->cur_func = LEPUS_DupValue(ctx, func_obj);
  s->this_val = LEPUS_DupValue(ctx, this_obj);
  s->argc = argc;
  sf->arg_count = arg_buf_len;
  sf->var_buf = sf->arg_buf + arg_buf_len;
  sf->cur_sp = sf->var_buf + b->var_count;
  for (i = 0; i < argc; i++) sf->arg_buf[i] = LEPUS_DupValue(ctx, argv[i]);
  n = arg_buf_len + b->var_count;
  for (i = argc; i < n; i++) sf->arg_buf[i] = LEPUS_UNDEFINED;
  return 0;
}

QJS_STATIC void async_func_mark(LEPUSRuntime *rt, LEPUSAsyncFunctionState *s,
                                LEPUS_MarkFunc *mark_func) {
  LEPUSStackFrame *sf;
  LEPUSValue *sp;

  sf = &s->frame;
  LEPUS_MarkValue(rt, sf->cur_func, mark_func);
  LEPUS_MarkValue(rt, s->this_val, mark_func);
  if (sf->cur_sp) {
    /* if the function is running, cur_sp is not known so we
       cannot mark the stack. Marking the variables is not needed
       because a running function cannot be part of a removable
       cycle */
    for (sp = sf->arg_buf; sp < sf->cur_sp; sp++) {
      LEPUS_MarkValue(rt, *sp, mark_func);
    }
  }
}

QJS_STATIC void async_func_free(LEPUSRuntime *rt, LEPUSAsyncFunctionState *s) {
  LEPUSStackFrame *sf;
  LEPUSValue *sp;

  sf = &s->frame;

  /* close the closure variables. */
  close_var_refs(rt, sf);

  if (sf->arg_buf) {
    /* cannot free the function if it is running */
    assert(sf->cur_sp != NULL);

    for (sp = sf->arg_buf; sp < sf->cur_sp; sp++) {
      LEPUS_FreeValueRT(rt, *sp);
    }
    lepus_free_rt(rt, sf->arg_buf);
  }
  LEPUS_FreeValueRT(rt, sf->cur_func);
  LEPUS_FreeValueRT(rt, s->this_val);
}

QJS_STATIC LEPUSValue async_func_resume(LEPUSContext *ctx,
                                        LEPUSAsyncFunctionState *s) {
  LEPUSValue func_obj;
  if (unlikely(lepus_check_stack_overflow(ctx, 0)))
    return LEPUS_ThrowStackOverflow(ctx);
  /* the tag does not matter provided it is not an object */
  func_obj = LEPUS_MKPTR(LEPUS_TAG_STRING, s);

  return LEPUS_CallInternalTI(ctx, func_obj, s->this_val, LEPUS_UNDEFINED,
                              s->argc, s->frame.arg_buf,
                              LEPUS_CALL_FLAG_GENERATOR);
}

/* Generators */

typedef enum LEPUSGeneratorStateEnum {
  LEPUS_GENERATOR_STATE_SUSPENDED_START,
  LEPUS_GENERATOR_STATE_SUSPENDED_YIELD,
  LEPUS_GENERATOR_STATE_SUSPENDED_YIELD_STAR,
  LEPUS_GENERATOR_STATE_EXECUTING,
  LEPUS_GENERATOR_STATE_COMPLETED,
} LEPUSGeneratorStateEnum;

typedef struct LEPUSGeneratorData {
  LEPUSGeneratorStateEnum state;
  LEPUSAsyncFunctionState func_state;
} LEPUSGeneratorData;

QJS_STATIC void free_generator_stack_rt(LEPUSRuntime *rt,
                                        LEPUSGeneratorData *s) {
  if (s->state == LEPUS_GENERATOR_STATE_COMPLETED) return;
  async_func_free(rt, &s->func_state);
  s->state = LEPUS_GENERATOR_STATE_COMPLETED;
}

QJS_STATIC void lepus_generator_finalizer(LEPUSRuntime *rt, LEPUSValue obj) {
  LEPUSGeneratorData *s = static_cast<LEPUSGeneratorData *>(
      LEPUS_GetOpaque(obj, LEPUS_CLASS_GENERATOR));

  if (s) {
    free_generator_stack_rt(rt, s);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void free_generator_stack(LEPUSContext *ctx, LEPUSGeneratorData *s) {
  free_generator_stack_rt(ctx->rt, s);
}

QJS_STATIC void lepus_generator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                     LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSGeneratorData *s = p->u.generator_data;

  if (!s || s->state == LEPUS_GENERATOR_STATE_COMPLETED) return;
  async_func_mark(rt, &s->func_state, mark_func);
}

/* XXX: use enum */
#define GEN_MAGIC_NEXT 0
#define GEN_MAGIC_RETURN 1
#define GEN_MAGIC_THROW 2

QJS_STATIC LEPUSValue lepus_generator_next(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv, BOOL *pdone,
                                           int magic) {
  LEPUSGeneratorData *s = static_cast<LEPUSGeneratorData *>(
      LEPUS_GetOpaque(this_val, LEPUS_CLASS_GENERATOR));
  LEPUSStackFrame *sf;
  LEPUSValue ret, func_ret;
  LEPUSValueConst iter_args[1];

  *pdone = TRUE;
  if (!s) return LEPUS_ThrowTypeError(ctx, "not a generator");
  sf = &s->func_state.frame;
redo:
  switch (s->state) {
    default:
    case LEPUS_GENERATOR_STATE_SUSPENDED_START:
      if (magic == GEN_MAGIC_NEXT) {
        goto exec_no_arg;
      } else {
        free_generator_stack(ctx, s);
        goto done;
      }
      break;
    case LEPUS_GENERATOR_STATE_SUSPENDED_YIELD_STAR: {
      int done;
      LEPUSValue method, iter_obj;
      iter_obj = sf->cur_sp[-2];
      if (magic == GEN_MAGIC_NEXT) {
        method = LEPUS_DupValue(ctx, sf->cur_sp[-1]);
      } else {
        method = LEPUS_GetProperty(
            ctx, iter_obj,
            magic == GEN_MAGIC_RETURN ? LEPUS_ATOM_return : LEPUS_ATOM_throw);
        if (LEPUS_IsException(method)) goto iter_exception;
      }
      if (magic != GEN_MAGIC_NEXT &&
          (LEPUS_IsUndefined(method) || LEPUS_IsNull(method))) {
        /* default action */
        if (magic == GEN_MAGIC_RETURN) {
          ret = LEPUS_DupValue(ctx, argv[0]);
          goto iter_done;
        } else {
          if (LEPUS_IteratorClose(ctx, iter_obj, FALSE)) goto iter_exception;
          LEPUS_ThrowTypeError(ctx, "iterator does not have a throw method");
          goto iter_exception;
        }
      }
      ret = LEPUS_IteratorNext2(ctx, iter_obj, method, argc, argv, &done);
      LEPUS_FreeValue(ctx, method);
      if (LEPUS_IsException(ret)) {
      iter_exception:
        goto exec_throw;
      }
      /* if not done, the iterator returns the exact object
         returned by 'method' */
      if (done == 2) {
        LEPUSValue done_val, value;
        done_val = LEPUS_GetProperty(ctx, ret, LEPUS_ATOM_done);
        if (LEPUS_IsException(done_val)) {
          LEPUS_FreeValue(ctx, ret);
          goto iter_exception;
        }
        done = LEPUS_ToBoolFree(ctx, done_val);
        if (done) {
          value = LEPUS_GetProperty(ctx, ret, LEPUS_ATOM_value);
          LEPUS_FreeValue(ctx, ret);
          if (LEPUS_IsException(value)) goto iter_exception;
          ret = value;
          goto iter_done;
        } else {
          *pdone = 2;
        }
      } else {
        if (done) {
          /* 'yield *' returns the value associated to done = true */
        iter_done:
          LEPUS_FreeValue(ctx, sf->cur_sp[-2]);
          LEPUS_FreeValue(ctx, sf->cur_sp[-1]);
          sf->cur_sp--;
          goto exec_arg;
        } else {
          *pdone = FALSE;
        }
      }
      break;
    } break;
    case LEPUS_GENERATOR_STATE_SUSPENDED_YIELD:
      /* cur_sp[-1] was set to LEPUS_UNDEFINED in the previous call */
      ret = LEPUS_DupValue(ctx, argv[0]);
      if (magic == GEN_MAGIC_THROW) {
        LEPUS_Throw(ctx, ret);
      exec_throw:
        s->func_state.throw_flag = TRUE;
      } else {
      exec_arg:
        sf->cur_sp[-1] = ret;
        sf->cur_sp[0] = LEPUS_NewBool(ctx, (magic == GEN_MAGIC_RETURN));
        sf->cur_sp++;
      exec_no_arg:
        s->func_state.throw_flag = FALSE;
      }
      s->state = LEPUS_GENERATOR_STATE_EXECUTING;
      func_ret = async_func_resume(ctx, &s->func_state);
      s->state = LEPUS_GENERATOR_STATE_SUSPENDED_YIELD;
      if (LEPUS_IsException(func_ret)) {
        /* finalize the execution in case of exception */
        free_generator_stack(ctx, s);
        return func_ret;
      }
      if (LEPUS_VALUE_IS_INT(func_ret)) {
        if (LEPUS_VALUE_GET_INT(func_ret) == FUNC_RET_YIELD_STAR) {
          /* 'yield *' */
          s->state = LEPUS_GENERATOR_STATE_SUSPENDED_YIELD_STAR;
          iter_args[0] = LEPUS_UNDEFINED;
          argc = 1;
          argv = iter_args;
          goto redo;
        } else {
          /* get the return the yield value at the top of the stack */
          ret = sf->cur_sp[-1];
          sf->cur_sp[-1] = LEPUS_UNDEFINED;
          *pdone = FALSE;
        }
      } else {
        /* end of iterator */
        ret = sf->cur_sp[-1];
        sf->cur_sp[-1] = LEPUS_UNDEFINED;
        LEPUS_FreeValue(ctx, func_ret);
        free_generator_stack(ctx, s);
      }
      break;
    case LEPUS_GENERATOR_STATE_COMPLETED:
    done:
      /* execution is finished */
      switch (magic) {
        default:
        case GEN_MAGIC_NEXT:
          ret = LEPUS_UNDEFINED;
          break;
        case GEN_MAGIC_RETURN:
          ret = LEPUS_DupValue(ctx, argv[0]);
          break;
        case GEN_MAGIC_THROW:
          ret = LEPUS_Throw(ctx, LEPUS_DupValue(ctx, argv[0]));
          break;
      }
      break;
    case LEPUS_GENERATOR_STATE_EXECUTING:
      ret = LEPUS_ThrowTypeError(ctx, "cannot invoke a running generator");
      break;
  }
  return ret;
}
QJS_STATIC LEPUSValue lepus_generator_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_obj,
    int argc, LEPUSValueConst *argv, int flags) {
  LEPUSValue obj, func_ret;
  LEPUSGeneratorData *s;
  s = static_cast<LEPUSGeneratorData *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) return LEPUS_EXCEPTION;
  s->state = LEPUS_GENERATOR_STATE_SUSPENDED_START;
  if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
    s->state = LEPUS_GENERATOR_STATE_COMPLETED;
    goto fail;
  }

  /* execute the function up to 'OP_initial_yield' */
  func_ret = async_func_resume(ctx, &s->func_state);
  if (LEPUS_IsException(func_ret)) goto fail;
  LEPUS_FreeValue(ctx, func_ret);

  obj = lepus_create_from_ctor(ctx, func_obj, LEPUS_CLASS_GENERATOR);
  if (LEPUS_IsException(obj)) goto fail;
  LEPUS_SetOpaque(obj, s);
  return obj;
fail:
  free_generator_stack_rt(ctx->rt, s);
  lepus_free(ctx, s);
  return LEPUS_EXCEPTION;
}

/* AsyncFunction */

QJS_STATIC void lepus_async_function_terminate(LEPUSRuntime *rt,
                                               LEPUSAsyncFunctionData *s) {
  if (s->is_active) {
    async_func_free(rt, &s->func_state);
    s->is_active = FALSE;
  }
}

QJS_STATIC void lepus_async_function_free0(LEPUSRuntime *rt,
                                           LEPUSAsyncFunctionData *s) {
  lepus_async_function_terminate(rt, s);
  LEPUS_FreeValueRT(rt, s->resolving_funcs[0]);
  LEPUS_FreeValueRT(rt, s->resolving_funcs[1]);
  lepus_free_rt(rt, s);
}

QJS_STATIC void lepus_async_function_free(LEPUSRuntime *rt,
                                          LEPUSAsyncFunctionData *s) {
  if (--s->header.ref_count == 0) {
    lepus_async_function_free0(rt, s);
  }
}

QJS_STATIC void lepus_async_function_resolve_finalizer(LEPUSRuntime *rt,
                                                       LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSAsyncFunctionData *s = p->u.async_function_data;
  if (s) {
    lepus_async_function_free(rt, s);
  }
}

QJS_STATIC void lepus_async_function_resolve_mark(LEPUSRuntime *rt,
                                                  LEPUSValueConst val,
                                                  LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSAsyncFunctionData *s = p->u.async_function_data;
  if (s) {
    LEPUS_MarkValue(rt, LEPUS_MKPTR(LEPUS_TAG_ASYNC_FUNCTION, s), mark_func);
  }
}

QJS_STATIC int lepus_async_function_resolve_create(
    LEPUSContext *ctx, LEPUSAsyncFunctionData *s, LEPUSValue *resolving_funcs) {
  int i;
  LEPUSObject *p;

  for (i = 0; i < 2; i++) {
    resolving_funcs[i] = LEPUS_NewObjectProtoClass(
        ctx, ctx->function_proto, LEPUS_CLASS_ASYNC_FUNCTION_RESOLVE + i);
    if (LEPUS_IsException(resolving_funcs[i])) {
      if (i == 1) LEPUS_FreeValue(ctx, resolving_funcs[0]);
      return -1;
    }
    p = LEPUS_VALUE_GET_OBJ(resolving_funcs[i]);
    s->header.ref_count++;
    p->u.async_function_data = s;
  }
  return 0;
}

QJS_STATIC void lepus_async_function_resume(LEPUSContext *ctx,
                                            LEPUSAsyncFunctionData *s) {
  LEPUSValue func_ret, ret2;
  func_ret = async_func_resume(ctx, &s->func_state);
  if (LEPUS_IsException(func_ret)) {
    LEPUSValue error;
  fail:
    error = LEPUS_GetException(ctx);
    ret2 = LEPUS_Call(ctx, s->resolving_funcs[1], LEPUS_UNDEFINED, 1,
                      (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
    lepus_async_function_terminate(ctx->rt, s);
    LEPUS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
  } else {
    LEPUSValue value;
    value = s->func_state.frame.cur_sp[-1];
    s->func_state.frame.cur_sp[-1] = LEPUS_UNDEFINED;
    if (LEPUS_IsUndefined(func_ret)) {
      /* function returned */
      ret2 = LEPUS_Call(ctx, s->resolving_funcs[0], LEPUS_UNDEFINED, 1,
                        (LEPUSValueConst *)&value);
      LEPUS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
      LEPUS_FreeValue(ctx, value);
      lepus_async_function_terminate(ctx->rt, s);
    } else {
      LEPUSValue promise, resolving_funcs[2], resolving_funcs1[2];
      int i, res;

      /* await */
      LEPUS_FreeValue(ctx, func_ret); /* not used */
      promise = lepus_promise_resolve(ctx, ctx->promise_ctor, 1,
                                      (LEPUSValueConst *)&value, 0);
      LEPUS_FreeValue(ctx, value);
      if (LEPUS_IsException(promise)) goto fail;
      if (lepus_async_function_resolve_create(ctx, s, resolving_funcs)) {
        LEPUS_FreeValue(ctx, promise);
        goto fail;
      }

      /* Note: no need to create 'thrownawayCapability' as in
         the spec */
      for (i = 0; i < 2; i++) resolving_funcs1[i] = LEPUS_UNDEFINED;
      res =
          perform_promise_then(ctx, promise, (LEPUSValueConst *)resolving_funcs,
                               (LEPUSValueConst *)resolving_funcs1);
      LEPUS_FreeValue(ctx, promise);
      for (i = 0; i < 2; i++) LEPUS_FreeValue(ctx, resolving_funcs[i]);
      if (res) goto fail;
    }
  }
}

QJS_STATIC LEPUSValue lepus_async_function_resolve_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_obj,
    int argc, LEPUSValueConst *argv, int flags) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(func_obj);
  LEPUSAsyncFunctionData *s = p->u.async_function_data;
  BOOL is_reject = p->class_id - LEPUS_CLASS_ASYNC_FUNCTION_RESOLVE;
  LEPUSValueConst arg;

  if (argc > 0)
    arg = argv[0];
  else
    arg = LEPUS_UNDEFINED;
  s->func_state.throw_flag = is_reject;
  if (is_reject) {
    LEPUS_Throw(ctx, LEPUS_DupValue(ctx, arg));
  } else {
    /* return value of await */
    s->func_state.frame.cur_sp[-1] = LEPUS_DupValue(ctx, arg);
  }
  lepus_async_function_resume(ctx, s);
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue lepus_async_function_call(LEPUSContext *ctx,
                                                LEPUSValueConst func_obj,
                                                LEPUSValueConst this_obj,
                                                int argc, LEPUSValueConst *argv,
                                                int flags) {
  LEPUSValue promise;
  LEPUSAsyncFunctionData *s;

  s = static_cast<LEPUSAsyncFunctionData *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) return LEPUS_EXCEPTION;
  s->header.ref_count = 1;
  s->gc_header.mark = 0;

  s->is_active = FALSE;
  s->resolving_funcs[0] = LEPUS_UNDEFINED;
  s->resolving_funcs[1] = LEPUS_UNDEFINED;

  promise = LEPUS_NewPromiseCapability(ctx, s->resolving_funcs);
  if (LEPUS_IsException(promise)) goto fail;

  if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
  fail:
    LEPUS_FreeValue(ctx, promise);
    lepus_async_function_free(ctx->rt, s);
    return LEPUS_EXCEPTION;
  }
  s->is_active = TRUE;

  lepus_async_function_resume(ctx, s);

  lepus_async_function_free(ctx->rt, s);

  return promise;
}

/* AsyncGenerator */

typedef enum LEPUSAsyncGeneratorStateEnum {
  LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_START,
  LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD,
  LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR,
  LEPUS_ASYNC_GENERATOR_STATE_EXECUTING,
  LEPUS_ASYNC_GENERATOR_STATE_AWAITING_RETURN,
  LEPUS_ASYNC_GENERATOR_STATE_COMPLETED,
} LEPUSAsyncGeneratorStateEnum;

typedef struct LEPUSAsyncGeneratorRequest {
  struct list_head link;
  /* completion */
  int completion_type; /* GEN_MAGIC_x */
  LEPUSValue result;
  /* promise capability */
  LEPUSValue promise;
  LEPUSValue resolving_funcs[2];
} LEPUSAsyncGeneratorRequest;

typedef struct LEPUSAsyncGeneratorData {
  LEPUSObject *generator; /* back pointer to the object (const) */
  LEPUSAsyncGeneratorStateEnum state;
  LEPUSAsyncFunctionState func_state;
  struct list_head queue; /* list of LEPUSAsyncGeneratorRequest.link */
} LEPUSAsyncGeneratorData;

QJS_STATIC void lepus_async_generator_free(LEPUSRuntime *rt,
                                           LEPUSAsyncGeneratorData *s) {
  struct list_head *el, *el1;
  LEPUSAsyncGeneratorRequest *req;

  list_for_each_safe(el, el1, &s->queue) {
    req = list_entry(el, LEPUSAsyncGeneratorRequest, link);
    LEPUS_FreeValueRT(rt, req->result);
    LEPUS_FreeValueRT(rt, req->promise);
    LEPUS_FreeValueRT(rt, req->resolving_funcs[0]);
    LEPUS_FreeValueRT(rt, req->resolving_funcs[1]);
    lepus_free_rt(rt, req);
  }
  if (s->state != LEPUS_ASYNC_GENERATOR_STATE_COMPLETED &&
      s->state != LEPUS_ASYNC_GENERATOR_STATE_AWAITING_RETURN) {
    async_func_free(rt, &s->func_state);
  }
  lepus_free_rt(rt, s);
}

QJS_STATIC void lepus_async_generator_finalizer(LEPUSRuntime *rt,
                                                LEPUSValue obj) {
  LEPUSAsyncGeneratorData *s = static_cast<LEPUSAsyncGeneratorData *>(
      LEPUS_GetOpaque(obj, LEPUS_CLASS_ASYNC_GENERATOR));

  if (s) {
    lepus_async_generator_free(rt, s);
  }
}

QJS_STATIC void lepus_async_generator_mark(LEPUSRuntime *rt,
                                           LEPUSValueConst val,
                                           LEPUS_MarkFunc *mark_func) {
  LEPUSAsyncGeneratorData *s = static_cast<LEPUSAsyncGeneratorData *>(
      LEPUS_GetOpaque(val, LEPUS_CLASS_ASYNC_GENERATOR));
  struct list_head *el;
  LEPUSAsyncGeneratorRequest *req;
  if (s) {
    list_for_each(el, &s->queue) {
      req = list_entry(el, LEPUSAsyncGeneratorRequest, link);
      LEPUS_MarkValue(rt, req->result, mark_func);
      LEPUS_MarkValue(rt, req->promise, mark_func);
      LEPUS_MarkValue(rt, req->resolving_funcs[0], mark_func);
      LEPUS_MarkValue(rt, req->resolving_funcs[1], mark_func);
    }
    if (s->state != LEPUS_ASYNC_GENERATOR_STATE_COMPLETED &&
        s->state != LEPUS_ASYNC_GENERATOR_STATE_AWAITING_RETURN) {
      async_func_mark(rt, &s->func_state, mark_func);
    }
  }
}

QJS_STATIC LEPUSValue lepus_async_generator_resolve_function(
    LEPUSContext *ctx, LEPUSValueConst this_obj, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data);

QJS_STATIC int lepus_async_generator_resolve_function_create(
    LEPUSContext *ctx, LEPUSValueConst generator, LEPUSValue *resolving_funcs,
    BOOL is_resume_next) {
  int i;
  LEPUSValue func;

  for (i = 0; i < 2; i++) {
    func = LEPUS_NewCFunctionData(ctx, lepus_async_generator_resolve_function,
                                  1, i + is_resume_next * 2, 1, &generator);
    if (LEPUS_IsException(func)) {
      if (i == 1) LEPUS_FreeValue(ctx, resolving_funcs[0]);
      return -1;
    }
    resolving_funcs[i] = func;
  }
  return 0;
}

QJS_STATIC int lepus_async_generator_await(LEPUSContext *ctx,
                                           LEPUSAsyncGeneratorData *s,
                                           LEPUSValueConst value) {
  LEPUSValue promise, resolving_funcs[2], resolving_funcs1[2];
  int i, res;

  promise = lepus_promise_resolve(ctx, ctx->promise_ctor, 1, &value, 0);
  if (LEPUS_IsException(promise)) goto fail;

  if (lepus_async_generator_resolve_function_create(
          ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, s->generator), resolving_funcs,
          FALSE)) {
    LEPUS_FreeValue(ctx, promise);
    goto fail;
  }

  /* Note: no need to create 'thrownawayCapability' as in
     the spec */
  for (i = 0; i < 2; i++) resolving_funcs1[i] = LEPUS_UNDEFINED;
  res = perform_promise_then(ctx, promise, (LEPUSValueConst *)resolving_funcs,
                             (LEPUSValueConst *)resolving_funcs1);
  LEPUS_FreeValue(ctx, promise);
  for (i = 0; i < 2; i++) LEPUS_FreeValue(ctx, resolving_funcs[i]);
  if (res) goto fail;
  return 0;
fail:
  return -1;
}

QJS_STATIC void lepus_async_generator_resolve_or_reject(
    LEPUSContext *ctx, LEPUSAsyncGeneratorData *s, LEPUSValueConst result,
    int is_reject) {
  LEPUSAsyncGeneratorRequest *next;
  LEPUSValue ret;

  next = list_entry(s->queue.next, LEPUSAsyncGeneratorRequest, link);
  list_del(&next->link);
  ret = LEPUS_Call(ctx, next->resolving_funcs[is_reject], LEPUS_UNDEFINED, 1,
                   &result);
  LEPUS_FreeValue(ctx, ret);
  LEPUS_FreeValue(ctx, next->result);
  LEPUS_FreeValue(ctx, next->promise);
  LEPUS_FreeValue(ctx, next->resolving_funcs[0]);
  LEPUS_FreeValue(ctx, next->resolving_funcs[1]);
  lepus_free(ctx, next);
}

QJS_STATIC void lepus_async_generator_resolve(LEPUSContext *ctx,
                                              LEPUSAsyncGeneratorData *s,
                                              LEPUSValueConst value,
                                              BOOL done) {
  LEPUSValue result;
  result = lepus_create_iterator_result(ctx, LEPUS_DupValue(ctx, value), done);
  /* XXX: better exception handling ? */
  lepus_async_generator_resolve_or_reject(ctx, s, result, 0);
  LEPUS_FreeValue(ctx, result);
}

QJS_STATIC void lepus_async_generator_reject(LEPUSContext *ctx,
                                             LEPUSAsyncGeneratorData *s,
                                             LEPUSValueConst exception) {
  lepus_async_generator_resolve_or_reject(ctx, s, exception, 1);
}

QJS_STATIC void lepus_async_generator_complete(LEPUSContext *ctx,
                                               LEPUSAsyncGeneratorData *s) {
  if (s->state != LEPUS_ASYNC_GENERATOR_STATE_COMPLETED) {
    s->state = LEPUS_ASYNC_GENERATOR_STATE_COMPLETED;
    async_func_free(ctx->rt, &s->func_state);
  }
}

QJS_STATIC int lepus_async_generator_completed_return(
    LEPUSContext *ctx, LEPUSAsyncGeneratorData *s, LEPUSValueConst value) {
  LEPUSValue promise, resolving_funcs[2], resolving_funcs1[2];
  int res;

  promise = lepus_promise_resolve(ctx, ctx->promise_ctor, 1,
                                  (LEPUSValueConst *)&value, 0);
  if (LEPUS_IsException(promise)) return -1;
  if (lepus_async_generator_resolve_function_create(
          ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, s->generator), resolving_funcs1,
          TRUE)) {
    LEPUS_FreeValue(ctx, promise);
    return -1;
  }
  resolving_funcs[0] = LEPUS_UNDEFINED;
  resolving_funcs[1] = LEPUS_UNDEFINED;
  res = perform_promise_then(ctx, promise, (LEPUSValueConst *)resolving_funcs1,
                             (LEPUSValueConst *)resolving_funcs);
  LEPUS_FreeValue(ctx, resolving_funcs1[0]);
  LEPUS_FreeValue(ctx, resolving_funcs1[1]);
  LEPUS_FreeValue(ctx, promise);
  return res;
}

QJS_STATIC void lepus_async_generator_resume_next(LEPUSContext *ctx,
                                                  LEPUSAsyncGeneratorData *s) {
  LEPUSAsyncGeneratorRequest *next;
  LEPUSValue func_ret, value;

  for (;;) {
    if (list_empty(&s->queue)) break;
    next = list_entry(s->queue.next, LEPUSAsyncGeneratorRequest, link);
    switch (s->state) {
      case LEPUS_ASYNC_GENERATOR_STATE_EXECUTING:
        /* only happens when restarting execution after await() */
        goto resume_exec;
      case LEPUS_ASYNC_GENERATOR_STATE_AWAITING_RETURN:
        goto done;
      case LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_START:
        if (next->completion_type == GEN_MAGIC_NEXT) {
          goto exec_no_arg;
        } else {
          lepus_async_generator_complete(ctx, s);
        }
        break;
      case LEPUS_ASYNC_GENERATOR_STATE_COMPLETED:
        if (next->completion_type == GEN_MAGIC_NEXT) {
          lepus_async_generator_resolve(ctx, s, LEPUS_UNDEFINED, TRUE);
        } else if (next->completion_type == GEN_MAGIC_RETURN) {
          s->state = LEPUS_ASYNC_GENERATOR_STATE_AWAITING_RETURN;
          lepus_async_generator_completed_return(ctx, s, next->result);
          goto done;
        } else {
          lepus_async_generator_reject(ctx, s, next->result);
        }
        goto done;
      case LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD:
      case LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR:
        value = LEPUS_DupValue(ctx, next->result);
        if (next->completion_type == GEN_MAGIC_THROW &&
            s->state == LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD) {
          LEPUS_Throw(ctx, value);
          s->func_state.throw_flag = TRUE;
        } else {
          /* 'yield' returns a value. 'yield *' also returns a value
             in case the 'throw' method is called */
          s->func_state.frame.cur_sp[-1] = value;
          s->func_state.frame.cur_sp[0] =
              LEPUS_NewInt32(ctx, next->completion_type);
          s->func_state.frame.cur_sp++;
        exec_no_arg:
          s->func_state.throw_flag = FALSE;
        }
        s->state = LEPUS_ASYNC_GENERATOR_STATE_EXECUTING;
      resume_exec:
        func_ret = async_func_resume(ctx, &s->func_state);
        if (LEPUS_IsException(func_ret)) {
          value = LEPUS_GetException(ctx);
          lepus_async_generator_complete(ctx, s);
          lepus_async_generator_reject(ctx, s, value);
          LEPUS_FreeValue(ctx, value);
        } else if (LEPUS_VALUE_IS_INT(func_ret)) {
          int func_ret_code;
          value = s->func_state.frame.cur_sp[-1];
          s->func_state.frame.cur_sp[-1] = LEPUS_UNDEFINED;
          func_ret_code = LEPUS_VALUE_GET_INT(func_ret);
          switch (func_ret_code) {
            case FUNC_RET_YIELD:
            case FUNC_RET_YIELD_STAR:
              if (func_ret_code == FUNC_RET_YIELD_STAR)
                s->state = LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD_STAR;
              else
                s->state = LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD;
              lepus_async_generator_resolve(ctx, s, value, FALSE);
              LEPUS_FreeValue(ctx, value);
              break;
            case FUNC_RET_AWAIT:
              lepus_async_generator_await(ctx, s, value);
              LEPUS_FreeValue(ctx, value);
              goto done;
            default:
              abort();
          }
        } else {
          assert(LEPUS_IsUndefined(func_ret));
          /* end of function */
          value = s->func_state.frame.cur_sp[-1];
          s->func_state.frame.cur_sp[-1] = LEPUS_UNDEFINED;
          lepus_async_generator_complete(ctx, s);
          lepus_async_generator_resolve(ctx, s, value, TRUE);
          LEPUS_FreeValue(ctx, value);
        }
        break;
      default:
        abort();
    }
  }
done:;
}

QJS_STATIC LEPUSValue lepus_async_generator_resolve_function(
    LEPUSContext *ctx, LEPUSValueConst this_obj, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  BOOL is_reject = magic & 1;
  LEPUSAsyncGeneratorData *s = static_cast<LEPUSAsyncGeneratorData *>(
      LEPUS_GetOpaque(func_data[0], LEPUS_CLASS_ASYNC_GENERATOR));
  LEPUSValueConst arg = argv[0];

  /* XXX: what if s == NULL */

  if (magic >= 2) {
    /* resume next case in AWAITING_RETURN state */
    assert(s->state == LEPUS_ASYNC_GENERATOR_STATE_AWAITING_RETURN ||
           s->state == LEPUS_ASYNC_GENERATOR_STATE_COMPLETED);
    s->state = LEPUS_ASYNC_GENERATOR_STATE_COMPLETED;
    if (is_reject) {
      lepus_async_generator_reject(ctx, s, arg);
    } else {
      lepus_async_generator_resolve(ctx, s, arg, TRUE);
    }
  } else {
    /* restart function execution after await() */
    assert(s->state == LEPUS_ASYNC_GENERATOR_STATE_EXECUTING);
    s->func_state.throw_flag = is_reject;
    if (is_reject) {
      LEPUS_Throw(ctx, LEPUS_DupValue(ctx, arg));
    } else {
      /* return value of await */
      s->func_state.frame.cur_sp[-1] = LEPUS_DupValue(ctx, arg);
    }
    lepus_async_generator_resume_next(ctx, s);
  }
  return LEPUS_UNDEFINED;
}

/* magic = GEN_MAGIC_x */
QJS_STATIC LEPUSValue lepus_async_generator_next(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 int magic) {
  LEPUSAsyncGeneratorData *s = static_cast<LEPUSAsyncGeneratorData *>(
      LEPUS_GetOpaque(this_val, LEPUS_CLASS_ASYNC_GENERATOR));
  LEPUSValue promise, resolving_funcs[2];
  LEPUSAsyncGeneratorRequest *req;

  promise = LEPUS_NewPromiseCapability(ctx, resolving_funcs);
  if (LEPUS_IsException(promise)) return LEPUS_EXCEPTION;
  if (!s) {
    LEPUSValue err, res2;
    LEPUS_ThrowTypeError(ctx, "not an AsyncGenerator object");
    err = LEPUS_GetException(ctx);
    res2 = LEPUS_Call(ctx, resolving_funcs[1], LEPUS_UNDEFINED, 1,
                      (LEPUSValueConst *)&err);
    LEPUS_FreeValue(ctx, err);
    LEPUS_FreeValue(ctx, res2);
    LEPUS_FreeValue(ctx, resolving_funcs[0]);
    LEPUS_FreeValue(ctx, resolving_funcs[1]);
    return promise;
  }
  req = static_cast<LEPUSAsyncGeneratorRequest *>(
      lepus_mallocz(ctx, sizeof(*req)));
  if (!req) goto fail;
  req->completion_type = magic;
  req->result = LEPUS_DupValue(ctx, argv[0]);
  req->promise = LEPUS_DupValue(ctx, promise);
  req->resolving_funcs[0] = resolving_funcs[0];
  req->resolving_funcs[1] = resolving_funcs[1];
  list_add_tail(&req->link, &s->queue);
  if (s->state != LEPUS_ASYNC_GENERATOR_STATE_EXECUTING) {
    lepus_async_generator_resume_next(ctx, s);
  }
  return promise;
fail:
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  LEPUS_FreeValue(ctx, promise);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_async_generator_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_obj,
    int argc, LEPUSValueConst *argv, int flags) {
  LEPUSValue obj, func_ret;
  LEPUSAsyncGeneratorData *s;

  s = static_cast<LEPUSAsyncGeneratorData *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) return LEPUS_EXCEPTION;
  s->state = LEPUS_ASYNC_GENERATOR_STATE_SUSPENDED_START;
  init_list_head(&s->queue);
  if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
    s->state = LEPUS_ASYNC_GENERATOR_STATE_COMPLETED;
    goto fail;
  }

  /* execute the function up to 'OP_initial_yield' (no yield nor
     await are possible) */
  func_ret = async_func_resume(ctx, &s->func_state);
  if (LEPUS_IsException(func_ret)) goto fail;
  LEPUS_FreeValue(ctx, func_ret);

  obj = lepus_create_from_ctor(ctx, func_obj, LEPUS_CLASS_ASYNC_GENERATOR);
  if (LEPUS_IsException(obj)) goto fail;
  s->generator = LEPUS_VALUE_GET_OBJ(obj);
  LEPUS_SetOpaque(obj, s);
  return obj;
fail:
  lepus_async_generator_free(ctx->rt, s);
  return LEPUS_EXCEPTION;
}

/* LEPUS parser */

enum TOK {
  TOK_NUMBER = -128,
  TOK_STRING,
  TOK_TEMPLATE,
  TOK_IDENT,
  TOK_REGEXP,
  /* warning: order matters (see lepus_parse_assign_expr) */
  TOK_MUL_ASSIGN,
  TOK_DIV_ASSIGN,
  TOK_MOD_ASSIGN,
  TOK_PLUS_ASSIGN,
  TOK_MINUS_ASSIGN,
  TOK_SHL_ASSIGN,
  TOK_SAR_ASSIGN,
  TOK_SHR_ASSIGN,
  TOK_AND_ASSIGN,
  TOK_XOR_ASSIGN,
  TOK_OR_ASSIGN,
#ifdef CONFIG_BIGNUM
  TOK_MATH_POW_ASSIGN,
#endif
  TOK_POW_ASSIGN,
  TOK_DOUBLE_QUESTION_MARK_ASSIGN,
  TOK_DEC,
  TOK_INC,
  TOK_SHL,
  TOK_SAR,
  TOK_SHR,
  TOK_LT,
  TOK_LTE,
  TOK_GT,
  TOK_GTE,
  TOK_EQ,
  TOK_STRICT_EQ,
  TOK_NEQ,
  TOK_STRICT_NEQ,
  TOK_LAND,
  TOK_LOR,
#ifdef CONFIG_BIGNUM
  TOK_MATH_POW,
#endif
  TOK_POW,
  TOK_ARROW,
  TOK_ELLIPSIS,
  TOK_DOUBLE_QUESTION_MARK,
  TOK_QUESTION_MARK_DOT,
  TOK_ERROR,
  TOK_PRIVATE_NAME,
  TOK_EOF,
  /* keywords: WARNING: same order as atoms */
  TOK_NULL, /* must be first */
  TOK_FALSE,
  TOK_TRUE,
  TOK_IF,
  TOK_ELSE,
  TOK_RETURN,
  TOK_VAR,
  TOK_THIS,
  TOK_DELETE,
  TOK_VOID,
  TOK_TYPEOF,
  TOK_NEW,
  TOK_IN,
  TOK_INSTANCEOF,
  TOK_DO,
  TOK_WHILE,
  TOK_FOR,
  TOK_BREAK,
  TOK_CONTINUE,
  TOK_SWITCH,
  TOK_CASE,
  TOK_DEFAULT,
  TOK_THROW,
  TOK_TRY,
  TOK_CATCH,
  TOK_FINALLY,
  TOK_FUNCTION,
  TOK_DEBUGGER,
  TOK_WITH,
  /* FutureReservedWord */
  TOK_CLASS,
  TOK_CONST,
  TOK_ENUM,
  TOK_EXPORT,
  TOK_EXTENDS,
  TOK_IMPORT,
  TOK_SUPER,
  /* FutureReservedWords when parsing strict mode code */
  TOK_IMPLEMENTS,
  TOK_INTERFACE,
  TOK_LET,
  TOK_PACKAGE,
  TOK_PRIVATE,
  TOK_PROTECTED,
  TOK_PUBLIC,
  TOK_STATIC,
  TOK_YIELD,
  TOK_AWAIT, /* must be last */
  TOK_OF,    /* only used for lepus_parse_skip_parens_token() */
};

#define TOK_FIRST_KEYWORD TOK_NULL
#define TOK_LAST_KEYWORD TOK_AWAIT

/* unicode code points */
#define CP_NBSP 0x00a0
#define CP_BOM 0xfeff

#define CP_LS 0x2028
#define CP_PS 0x2029

typedef struct BlockEnv {
  struct BlockEnv *prev;
  LEPUSAtom label_name; /* LEPUS_ATOM_NULL if none */
  int label_break;      /* -1 if none */
  int label_cont;       /* -1 if none */
  int drop_count;       /* number of stack elements to drop */
  int label_finally;    /* -1 if none */
  int scope_level;
  int has_iterator;
} BlockEnv;

typedef struct LEPUSHoistedDef {  // called LEPUSGlobalVar in latest version
  int cpool_idx;                  /* -1 means variable global definition */
  uint8_t force_init : 1;         /* initialize to undefined */
  uint8_t is_lexical : 1;         /* global let/const definition */
  uint8_t is_const : 1;           /* const definition */
  int var_idx;                    /* function object index if cpool_idx >= 0 */
  int scope_level;                /* scope of definition */
  LEPUSAtom var_name;             /* variable name if cpool_idx < 0 */
} LEPUSHoistedDef;

typedef struct RelocEntry {
  struct RelocEntry *next;
  uint32_t addr; /* address to patch */
  int size;      /* address size: 1, 2 or 4 bytes */
} RelocEntry;

typedef struct JumpSlot {
  int op;
  int size;
  int pos;
  int label;
} JumpSlot;

typedef struct LabelSlot {
  int ref_count;
  int pos;  /* phase 1 address, -1 means not resolved yet */
  int pos2; /* phase 2 address, -1 means not resolved yet */
  int addr; /* phase 3 address, -1 means not resolved yet */
  RelocEntry *first_reloc;
} LabelSlot;

typedef struct LineNumberSlot {
  uint32_t pc;
  // <ByteDance begin>
  uint64_t line_num;
  // <ByteDance end>
} LineNumberSlot;

typedef enum LEPUSParseFunctionEnum {
  LEPUS_PARSE_FUNC_STATEMENT,
  LEPUS_PARSE_FUNC_VAR,
  LEPUS_PARSE_FUNC_EXPR,
  LEPUS_PARSE_FUNC_ARROW,
  LEPUS_PARSE_FUNC_GETTER,
  LEPUS_PARSE_FUNC_SETTER,
  LEPUS_PARSE_FUNC_METHOD,
  LEPUS_PARSE_FUNC_CLASS_CONSTRUCTOR,
  LEPUS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR,
} LEPUSParseFunctionEnum;

typedef enum LEPUSParseExportEnum {
  LEPUS_PARSE_EXPORT_NONE,
  LEPUS_PARSE_EXPORT_NAMED,
  LEPUS_PARSE_EXPORT_DEFAULT,
} LEPUSParseExportEnum;

typedef struct LEPUSFunctionDef {
  LEPUSContext *ctx;
  struct LEPUSFunctionDef *parent;
  int parent_cpool_idx;   /* index in the constant pool of the parent
                             or -1 if none */
  int parent_scope_level; /* scope level in parent at point of definition */
  struct list_head child_list; /* list of LEPUSFunctionDef.link */
  struct list_head link;

  BOOL is_eval;         /* TRUE if eval code */
  int eval_type;        /* only valid if is_eval = TRUE */
  BOOL is_global_var;   /* TRUE if variables are not defined locally:
                           eval global, eval module or non strict eval */
  BOOL is_func_expr;    /* TRUE if function expression */
  BOOL has_home_object; /* TRUE if the home object is available */
  BOOL has_prototype;   /* true if a prototype field is necessary */
  BOOL has_simple_parameter_list;
  BOOL has_parameter_expressions; /* if true, an argument scope is created */
  BOOL has_use_strict;            /* to reject directive in special cases */
  BOOL has_eval_call; /* true if the function contains a call to eval() */
  BOOL has_arguments_binding; /* true if the 'arguments' binding is
                                 available in the function */
  BOOL has_this_binding;      /* true if the 'this' and new.target binding are
                                 available in the function */
  BOOL new_target_allowed;    /* true if the 'new.target' does not
                                 throw a syntax error */
  BOOL super_call_allowed;    /* true if super() is allowed */
  BOOL super_allowed;         /* true if super. or super[] is allowed */
  BOOL arguments_allowed; /* true if the 'arguments' identifier is allowed */
  BOOL is_derived_class_constructor;
  BOOL in_function_body;
  LEPUSFunctionKindEnum func_kind : 8;
  LEPUSParseFunctionEnum func_type : 8;
  uint8_t lepus_mode;  /* bitmap of LEPUS_MODE_x */
  LEPUSAtom func_name; /* LEPUS_ATOM_NULL if no name */

  LEPUSVarDef *vars;
  int var_size; /* allocated size for vars[] */
  int var_count;
  LEPUSVarDef *args;
  int arg_size;  /* allocated size for args[] */
  int arg_count; /* number of arguments */
  int defined_arg_count;
  int var_object_idx;     /* -1 if none */
  int arg_var_object_idx; /* -1 if none (var object for the argument scope) */
  int arguments_var_idx;  /* -1 if none */
  int arguments_arg_idx;  /* argument variable definition in argument scope, -1
                             if none */
  int func_var_idx;       /* variable containing the current function (-1
                             if none, only used if is_func_expr is true) */
  int eval_ret_idx; /* variable containing the return value of the eval, -1 if
                       none */
  int this_var_idx; /* variable containg the 'this' value, -1 if none */
  int new_target_var_idx; /* variable containg the 'new.target' value, -1 if
                             none */
  int this_active_func_var_idx; /* variable containg the 'this.active_func'
                                   value, -1 if none */
  int home_object_var_idx;
  BOOL need_home_object;

  int scope_level; /* index into fd->scopes if the current lexical scope */
  int scope_first; /* index into vd->vars of first lexically scoped variable */
  int scope_size;  /* allocated size of fd->scopes array */
  int scope_count; /* number of entries used in the fd->scopes array */
  LEPUSVarScope *scopes;
  LEPUSVarScope def_scope_array[4];
  int body_scope; /* scope of the body of the function or eval */

  int hoisted_def_count;
  int hoisted_def_size;
  LEPUSHoistedDef *hoisted_def;

  DynBuf byte_code;
  int last_opcode_pos; /* -1 if no last opcode */
  int last_opcode_line_num;
  BOOL use_short_opcodes; /* true if short opcodes are used in byte_code */

  LabelSlot *label_slots;
  int label_size; /* allocated size for label_slots[] */
  int label_count;
  BlockEnv *top_break; /* break/continue label stack */

  /* constant pool (strings, functions, numbers) */
  LEPUSValue *cpool;
  uint32_t cpool_count;
  uint32_t cpool_size;

  /* list of variables in the closure */
  int closure_var_count;
  int closure_var_size;
  LEPUSClosureVar *closure_var;

  JumpSlot *jump_slots;
  int jump_size;
  int jump_count;

  LineNumberSlot *line_number_slots;
  int line_number_size;
  int line_number_count;
  // <ByteDance begin>
  int64_t line_number_last;
  int64_t line_number_last_pc;
  // <ByteDance end>

  /* pc2line table */
  LEPUSAtom filename;
  int line_num;
#ifdef ENABLE_QUICKJS_DEBUGGER
  int64_t column_num;
  LEPUSScriptSource *script;
#endif
  DynBuf pc2line;

  char *source; /* raw source, utf-8 encoded */
  int source_len;

  LEPUSModuleDef *module; /* != NULL when parsing a module */
// <primjs begin>
#ifdef ENABLE_PRIMJS_IC
  uint32_t get_feedback_vec_size;
  uint32_t set_feedback_vec_size;
#endif
  // <primjs end>

} LEPUSFunctionDef;

typedef struct LEPUSToken {
  int val;
  int line_num; /* line number of token start */
  const uint8_t *ptr;
  union {
    struct {
      LEPUSValue str;
      int sep;
    } str;
    struct {
      LEPUSValue val;
#ifdef CONFIG_BIGNUM
      slimb_t exponent; /* may be != 0 only if val is a float */
#endif
    } num;
    struct {
      LEPUSAtom atom;
      BOOL has_escape;
      BOOL is_reserved;
    } ident;
    struct {
      LEPUSValue body;
      LEPUSValue flags;
    } regexp;
  } u;
} LEPUSToken;

#ifndef NO_QUICKJS_COMPILER
typedef struct LEPUSParseState {
  LEPUSContext *ctx;
  int last_line_num; /* line number of last token */
  int line_num;      /* line number of current offset */
  const char *filename;
  LEPUSToken token;
  BOOL got_lf; /* true if got line feed before the current token */
  const uint8_t *last_ptr;
  const uint8_t *buf_ptr;
  const uint8_t *buf_end;
  // <ByteDance begin>
  int debugger_last_line_num;
  const uint8_t *line_begin_ptr;
  const uint8_t *last_line_begin_ptr;
  const uint8_t *last_emit_ptr;
  const uint8_t *func_call_ptr;
  const uint8_t *utf8_parse_front;
  int utf8_adapte_size;
  int func_call_adapte_size;
  int last_utf8_adapte_size;
  const uint8_t *last_last_ptr;
  // <ByteDance end>
  /* current function code */
  LEPUSFunctionDef *cur_func;
  BOOL is_module; /* parsing a module */
  BOOL allow_html_comments;
} LEPUSParseState;
#endif

const LEPUSOpCode opcode_info[OP_COUNT + (OP_TEMP_END - OP_TEMP_START)] = {
#define FMT(f)
#if defined(ENABLE_PRIMJS_SNAPSHOT) || defined(DUMP_BYTECODE)
#define DEF(id, size, n_pop, n_push, f) {#id, size, n_pop, n_push, OP_FMT_##f},
#else
#define DEF(id, size, n_pop, n_push, f) {size, n_pop, n_push, OP_FMT_##f},
#endif
#include "quickjs-opcode.h"
#undef DEF
#undef FMT
};

#ifndef NO_QUICKJS_COMPILER
QJS_STATIC __exception int next_token(LEPUSParseState *s);

QJS_STATIC void free_token(LEPUSParseState *s, LEPUSToken *token) {
  switch (token->val) {
#ifdef CONFIG_BIGNUM
    case TOK_NUMBER:
      LEPUS_FreeValue(s->ctx, token->u.num.val);
      break;
#endif
    case TOK_STRING:
    case TOK_TEMPLATE:
      LEPUS_FreeValue(s->ctx, token->u.str.str);
      break;
    case TOK_REGEXP:
      LEPUS_FreeValue(s->ctx, token->u.regexp.body);
      LEPUS_FreeValue(s->ctx, token->u.regexp.flags);
      break;
    case TOK_IDENT:
    case TOK_FIRST_KEYWORD ... TOK_LAST_KEYWORD:
    case TOK_PRIVATE_NAME:
      LEPUS_FreeAtom(s->ctx, token->u.ident.atom);
      break;
    default:
      break;
  }
}

QJS_STATIC void __attribute((unused))
dump_token(LEPUSParseState *s, const LEPUSToken *token) {
  switch (token->val) {
    case TOK_NUMBER: {
      double d;
      LEPUS_ToFloat64(s->ctx, &d, token->u.num.val); /* no exception possible */
      printf("number: %.14g\n", d);
    } break;
    case TOK_IDENT:
    dump_atom : {
      char buf[ATOM_GET_STR_BUF_SIZE];
      printf("ident: '%s'\n",
             LEPUS_AtomGetStr(s->ctx, buf, sizeof(buf), token->u.ident.atom));
    } break;
    case TOK_STRING: {
      const char *str;
      /* XXX: quote the string */
      str = LEPUS_ToCString(s->ctx, token->u.str.str);
      printf("string: '%s'\n", str);
      LEPUS_FreeCString(s->ctx, str);
    } break;
    case TOK_TEMPLATE: {
      const char *str;
      str = LEPUS_ToCString(s->ctx, token->u.str.str);
      printf("template: `%s`\n", str);
      LEPUS_FreeCString(s->ctx, str);
    } break;
    case TOK_REGEXP: {
      const char *str, *str2;
      str = LEPUS_ToCString(s->ctx, token->u.regexp.body);
      str2 = LEPUS_ToCString(s->ctx, token->u.regexp.flags);
      printf("regexp: '%s' '%s'\n", str, str2);
      LEPUS_FreeCString(s->ctx, str);
      LEPUS_FreeCString(s->ctx, str2);
    } break;
    case TOK_EOF:
      printf("eof\n");
      break;
    default:
      if (s->token.val >= TOK_NULL && s->token.val <= TOK_LAST_KEYWORD) {
        goto dump_atom;
      } else if (s->token.val >= 256) {
        printf("token: %d\n", token->val);
      } else {
        printf("token: '%c'\n", token->val);
      }
      break;
  }
}

// <ByteDance begin>
QJS_STATIC uint64_t compute_column(LEPUSParseState *s, BOOL is_get_var) {
  uint64_t result;
  int64_t column_number = 0;

  const uint8_t *buf_ptr = (is_get_var ? s->last_last_ptr : s->last_ptr);
  int adapte_size =
      (is_get_var ? s->last_utf8_adapte_size : s->utf8_adapte_size);

  int64_t line_number = s->debugger_last_line_num;

  const uint8_t *line_begin =
      buf_ptr < s->line_begin_ptr ? s->last_line_begin_ptr : s->line_begin_ptr;
  if (buf_ptr) {
    column_number = buf_ptr - line_begin - adapte_size + 1;
  }
  if (column_number < 0) {
    column_number = 0;
  }

  if (line_number >= ((uint64_t)1 << LINE_NUMBER_BITS_COUNT) ||
      column_number >= ((uint64_t)1 << COLUMN_NUMBER_BITS_COUNT)) {
    // even 64 bit is not enough
    result = line_number;
  } else {
    // for compatibility
    result = (uint64_t)((uint64_t)line_number |
                        ((uint64_t)column_number << LINE_NUMBER_BITS_COUNT));
    // set type 1
    result = (uint64_t)(result | (uint64_t)1 << LINE_COLUMN_TYPE_SHIFT);
  }
  return result;
}
// <ByteDance end>

QJS_STATIC int __attribute__((format(printf, 2, 3)))
lepus_parse_error(LEPUSParseState *s, const char *fmt, ...) {
  LEPUSContext *ctx = s->ctx;
  va_list ap;

  va_start(ap, fmt);
  LEPUS_ThrowError(ctx, LEPUS_SYNTAX_ERROR, fmt, ap);
  va_end(ap);

  // <ByteDance begin>
  uint64_t line_column = compute_column(s, FALSE);
  build_backtrace(ctx, ctx->rt->current_exception, s->filename, line_column,
                  NULL, 0, 1);
  // <ByteDance end>
  return -1;
}

QJS_STATIC int lepus_parse_expect(LEPUSParseState *s, int tok) {
  if (s->token.val != tok) {
    /* XXX: dump token correctly in all cases */
    return lepus_parse_error(s, "expecting '%c'", tok);
  }
  return next_token(s);
}

QJS_STATIC int lepus_parse_expect_semi(LEPUSParseState *s) {
  if (s->token.val != ';') {
    /* automatic insertion of ';' */
    if (s->token.val == TOK_EOF || s->token.val == '}' || s->got_lf) {
      return 0;
    }
    return lepus_parse_error(s, "expecting '%c'", ';');
  }
  return next_token(s);
}

QJS_STATIC int lepus_parse_error_reserved_identifier(LEPUSParseState *s) {
  char buf1[ATOM_GET_STR_BUF_SIZE];
  return lepus_parse_error(
      s, "'%s' is a reserved identifier",
      LEPUS_AtomGetStr(s->ctx, buf1, sizeof(buf1), s->token.u.ident.atom));
}

QJS_STATIC __exception int lepus_parse_template_part(LEPUSParseState *s,
                                                     const uint8_t *p) {
  uint32_t c;
  StringBuffer b_s, *b = &b_s;

  /* p points to the first byte of the template part */
  if (string_buffer_init(s->ctx, b, 32)) goto fail;
  for (;;) {
    if (p >= s->buf_end) goto unexpected_eof;
    c = *p++;
    if (c == '`') {
      /* template end part */
      break;
    }
    if (c == '$' && *p == '{') {
      /* template start or middle part */
      p++;
      break;
    }
    if (c == '\\') {
      if (string_buffer_putc8(b, c)) goto fail;
      if (p >= s->buf_end) goto unexpected_eof;
      c = *p++;
    }
    /* newline sequences are normalized as single '\n' bytes */
    if (c == '\r') {
      if (*p == '\n') p++;
      c = '\n';
    }
    if (c == '\n') {
      // <ByteDance begin>
      s->last_line_begin_ptr = s->line_begin_ptr;
      s->line_begin_ptr = p;
      s->func_call_adapte_size = -1;
      s->last_utf8_adapte_size = 0;
      s->utf8_adapte_size = 0;
      // <ByteDance end>
      s->line_num++;
    } else if (c >= 0x80) {
      const uint8_t *p_next;
      c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
      if (c > 0x10FFFF) {
        lepus_parse_error(s, "invalid UTF-8 sequence");
        goto fail;
      }
      p = p_next;
    }
    if (string_buffer_putc(b, c)) goto fail;
  }
  s->token.val = TOK_TEMPLATE;
  s->token.u.str.sep = c;
  s->token.u.str.str = string_buffer_end(b);
  s->buf_ptr = p;
  return 0;

unexpected_eof:
  lepus_parse_error(s, "unexpected end of string");
fail:
  string_buffer_free(b);
  return -1;
}

QJS_STATIC __exception int lepus_parse_string(LEPUSParseState *s, int sep,
                                              BOOL do_throw, const uint8_t *p,
                                              LEPUSToken *token,
                                              const uint8_t **pp) {
  int ret;
  uint32_t c;
  StringBuffer b_s, *b = &b_s;

  // <ByteDance begin>
  int utf8_parsed = 0;
  // <ByteDance end>
  /* string */
  if (string_buffer_init(s->ctx, b, 32)) goto fail;
  for (;;) {
    if (p >= s->buf_end) goto invalid_char;
    c = *p;
    if (c < 0x20) {
      if (!s->cur_func) {
        if (do_throw)
          lepus_parse_error(s, "invalid character in a JSON string");
        goto fail;
      }
      if (sep == '`') {
        if (c == '\r') {
          if (p[1] == '\n') p++;
          c = '\n';
        }
        /* do not update s->line_num */
      } else if (c == '\n' || c == '\r')
        goto invalid_char;
    }
    p++;
    if (c == sep) break;
    if (c == '$' && *p == '{' && sep == '`') {
      /* template start or middle part */
      p++;
      break;
    }
    if (c == '\\') {
      c = *p;
      switch (c) {
        case '\0':
          if (p >= s->buf_end) goto invalid_char;
          p++;
          break;
        case '\'':
        case '\"':
        case '\\':
          p++;
          break;
        case '\r': /* accept DOS and MAC newline sequences */
          if (p[1] == '\n') {
            p++;
          }
          /* fall thru */
        case '\n':
          /* ignore escaped newline sequence */
          p++;
          if (sep != '`') {
            // <ByteDance begin>
            s->last_line_begin_ptr = s->line_begin_ptr;
            s->line_begin_ptr = p;
            s->func_call_adapte_size = -1;
            s->last_utf8_adapte_size = 0;
            s->utf8_adapte_size = 0;
            // <ByteDance end>
            s->line_num++;
          }
          continue;
        default:
          if (c >= '0' && c <= '7') {
            if (!s->cur_func) goto invalid_octal; /* JSON case */
            if (!(s->cur_func->lepus_mode & LEPUS_MODE_STRICT) && sep != '`')
              goto parse_escape;
            if (c == '0' && !(p[1] >= '0' && p[1] <= '9')) {
              p++;
              c = '\0';
            } else {
            invalid_octal:
              if (do_throw)
                lepus_parse_error(s, "invalid octal syntax in strict mode");
              goto fail;
            }
          } else if (c >= 0x80) {
            const uint8_t *p_next;
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
            // <ByteDance begin>
            if (p > s->utf8_parse_front) {
              utf8_parsed += p_next - p;
              s->last_utf8_adapte_size = s->utf8_adapte_size;
              s->utf8_adapte_size += p_next - p;
              s->utf8_parse_front = p_next;
            }
            // <ByteDance end>
            if (c > 0x10FFFF) {
              goto invalid_utf8;
            }
            p = p_next;
            /* LS or PS are skipped */
            if (c == CP_LS || c == CP_PS) continue;
          } else {
          parse_escape:
            ret = lre_parse_escape(&p, TRUE);
            if (ret == -1) {
              if (do_throw)
                lepus_parse_error(
                    s, "malformed escape sequence in string literal");
              goto fail;
            } else if (ret < 0) {
              /* ignore the '\' (could output a warning) */
              p++;
            } else {
              c = ret;
            }
          }
          break;
      }
    } else if (c >= 0x80) {
      const uint8_t *p_next;
      c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
      // <ByteDance begin>
      if (p > s->utf8_parse_front) {
        utf8_parsed += p_next - p;
        s->utf8_adapte_size += p_next - p;
        s->utf8_parse_front = p_next;
      }
      // <ByteDance end
      if (c > 0x10FFFF) goto invalid_utf8;
      p = p_next;
    }
    if (string_buffer_putc(b, c)) goto fail;
  }
  // <ByteDance begin>
  s->last_utf8_adapte_size += utf8_parsed;
  // <ByteDance end>
  token->val = TOK_STRING;
  token->u.str.sep = c;
  token->u.str.str = string_buffer_end(b);
  *pp = p;
  return 0;

invalid_utf8:
  if (do_throw) lepus_parse_error(s, "invalid UTF-8 sequence");
  goto fail;
invalid_char:
  if (do_throw) lepus_parse_error(s, "unexpected end of string");
fail:
  string_buffer_free(b);
  return -1;
}

QJS_STATIC inline BOOL token_is_pseudo_keyword(LEPUSParseState *s,
                                               LEPUSAtom atom) {
  return s->token.val == TOK_IDENT && s->token.u.ident.atom == atom &&
         !s->token.u.ident.has_escape;
}

QJS_STATIC __exception int lepus_parse_regexp(LEPUSParseState *s) {
  const uint8_t *p;
  BOOL in_class;
  StringBuffer b_s, *b = &b_s;
  StringBuffer b2_s, *b2 = &b2_s;
  uint32_t c;

  p = s->buf_ptr;
  p++;
  in_class = FALSE;
  if (string_buffer_init(s->ctx, b, 32)) return -1;
  if (string_buffer_init(s->ctx, b2, 1)) goto fail;
  for (;;) {
    if (p >= s->buf_end) {
    eof_error:
      lepus_parse_error(s, "unexpected end of regexp");
      goto fail;
    }
    c = *p++;
    if (c == '\n' || c == '\r') {
      goto eol_error;
    } else if (c == '/') {
      if (!in_class) break;
    } else if (c == '[') {
      in_class = TRUE;
    } else if (c == ']') {
      /* XXX: incorrect as the first character in a class */
      in_class = FALSE;
    } else if (c == '\\') {
      if (string_buffer_putc8(b, c)) goto fail;
      c = *p++;
      if (c == '\n' || c == '\r')
        goto eol_error;
      else if (c == '\0' && p >= s->buf_end)
        goto eof_error;
      else if (c >= 0x80) {
        const uint8_t *p_next;
        c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
        if (c > 0x10FFFF) {
          goto invalid_utf8;
        }
        p = p_next;
        if (c == CP_LS || c == CP_PS) goto eol_error;
      }
    } else if (c >= 0x80) {
      const uint8_t *p_next;
      c = unicode_from_utf8(p - 1, UTF8_CHAR_LEN_MAX, &p_next);
      if (c > 0x10FFFF) {
      invalid_utf8:
        lepus_parse_error(s, "invalid UTF-8 sequence");
        goto fail;
      }
      p = p_next;
      /* LS or PS are considered as line terminator */
      if (c == CP_LS || c == CP_PS) {
      eol_error:
        lepus_parse_error(s, "unexpected line terminator in regexp");
        goto fail;
      }
    }
    if (string_buffer_putc(b, c)) goto fail;
  }

  /* flags */
  for (;;) {
    const uint8_t *p_next = p;
    c = *p_next++;
    if (c >= 0x80) {
      c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
      if (c > 0x10FFFF) {
        goto invalid_utf8;
      }
    }
    if (!lre_js_is_ident_next(c)) break;
    if (string_buffer_putc(b2, c)) goto fail;
    p = p_next;
  }

  s->token.val = TOK_REGEXP;
  s->token.u.regexp.body = string_buffer_end(b);
  s->token.u.regexp.flags = string_buffer_end(b2);
  s->buf_ptr = p;
  return 0;
fail:
  string_buffer_free(b);
  string_buffer_free(b2);
  return -1;
}

#ifdef ENABLE_QUICKJS_STEP_STATEMENT
QJS_STATIC void lepus_gen_debugger_statement(LEPUSParseState *s,
                                             LEPUSContext *ctx);
#endif

QJS_STATIC __exception int next_token(LEPUSParseState *s) {
  const uint8_t *p;
  int c;
  char buf[4096], *q;
  BOOL ident_has_escape;

  // <ByteDance begin>
  int utf8_parsed = 0;
  // <ByteDance end>
#ifdef QJS_UNITTEST
  if (unlikely(lepus_check_stack_overflow(s->ctx, 0))) {
    return lepus_parse_error(s, "stack overflow");
  }
#endif
  free_token(s, &s->token);

  // <ByteDance begin>
  if (s->last_ptr > s->last_last_ptr) {
    s->last_last_ptr = s->last_ptr;
  }
  // <ByteDance end>

  p = s->last_ptr = s->buf_ptr;
  s->got_lf = FALSE;
  s->last_line_num = s->token.line_num;
  s->debugger_last_line_num = s->last_line_num;
redo:
  s->token.line_num = s->line_num;
  s->token.ptr = p;
  c = *p;
  switch (c) {
    case 0:
      s->token.val = TOK_EOF;
      break;
    case '`':
      if (!s->cur_func) {
        /* JSON does not accept templates */
        goto def_token;
      }
      if (lepus_parse_template_part(s, p + 1)) goto fail;
      p = s->buf_ptr;
      break;
    case '\'':
      if (!s->cur_func) {
        /* JSON does not accept single quoted strings */
        goto def_token;
      }
      /* fall through */
    case '\"':
      if (lepus_parse_string(s, c, TRUE, p + 1, &s->token, &p)) goto fail;
      break;
    case '\r': /* accept DOS and MAC newline sequences */
      if (p[1] == '\n') {
        p++;
      }
      /* fall thru */
    case '\n':
      p++;
      // <ByteDance begin>
      s->last_last_ptr = s->last_ptr;
      s->last_ptr = p;
      // <ByteDance end>
    line_terminator:
      s->got_lf = TRUE;
      // <ByteDance begin>
      s->last_line_begin_ptr = s->line_begin_ptr;
      s->line_begin_ptr = p;
      s->utf8_adapte_size = 0;
      s->func_call_adapte_size = -1;
      s->last_utf8_adapte_size = 0;
      // <ByteDance end>
      s->line_num++;
      s->debugger_last_line_num = s->line_num;
      goto redo;
    case '\f':
    case '\v':
      if (!s->cur_func) {
        /* JSONWhitespace does not match <VT>, nor <FF> */
        goto def_token;
      }
      /* fall through */
    case ' ':
    case '\t':
      p++;
      // <ByteDance begin>
      s->last_ptr = p;
      // <ByteDance end>
      goto redo;
    case '/':
      if (p[1] == '*') {
        /* comment */
        p += 2;
        for (;;) {
          if (*p == '\0' && p >= s->buf_end) {
            lepus_parse_error(s, "unexpected end of comment");
            goto fail;
          }
          if (p[0] == '*' && p[1] == '/') {
            p += 2;
            break;
          }
          if (*p == '\n') {
            s->line_num++;
            s->got_lf = TRUE; /* considered as LF for ASI */
            p++;
            // <ByteDance begin>
            s->utf8_adapte_size = 0;
            s->func_call_adapte_size = -1;
            s->last_utf8_adapte_size = 0;
            s->last_line_begin_ptr = s->line_begin_ptr;
            s->line_begin_ptr = p;
            // <ByteDance end>
          } else if (*p == '\r') {
            s->got_lf = TRUE; /* considered as LF for ASI */
            p++;
          } else if (*p >= 0x80) {
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
            if (c == CP_LS || c == CP_PS) {
              s->got_lf = TRUE; /* considered as LF for ASI */
            } else if (c == -1) {
              p++;
            }
          } else {
            p++;
          }
        }
        goto redo;
      } else if (p[1] == '/') {
        /* line comment */
        p += 2;
      skip_line_comment:
        for (;;) {
          if (*p == '\0' && p >= s->buf_end) break;
          if (*p == '\r' || *p == '\n') break;
          if (*p >= 0x80) {
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
            /* LS or PS are considered as line terminator */
            if (c == CP_LS || c == CP_PS) {
              break;
            } else if (c == -1) {
              p++;
            }
          } else {
            p++;
          }
        }
        goto redo;
      } else if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_DIV_ASSIGN;
      } else {
        p++;
        s->token.val = c;
      }
      break;
    case '\\':
      if (p[1] == 'u') {
        const uint8_t *p1 = p + 1;
        int c1 = lre_parse_escape(&p1, TRUE);
        if (c1 >= 0 && lre_js_is_ident_first(c1)) {
          c = c1;
          p = p1;
          ident_has_escape = TRUE;
          goto has_ident;
        } else {
          /* XXX: syntax error? */
        }
      }
      goto def_token;
    case 'a' ... 'z':
    case 'A' ... 'Z':
    case '_':
    case '$':
      /* identifier */
      p++;
      ident_has_escape = FALSE;
    has_ident:
      q = buf;

      if (p == nullptr) {
        lepus_parse_error(
            s, "internal error in function next_token: p is nullptr!");
        goto fail;
      }

      for (;;) {
        const uint8_t *p1 = p;

        if (c < 128) {
          *q++ = c;
        } else {
          q += unicode_to_utf8((uint8_t *)q, c);
        }
        c = *p1++;
        if (c == '\\' && *p1 == 'u') {
          c = lre_parse_escape(&p1, TRUE);
          ident_has_escape = TRUE;
        } else if (c >= 128) {
          c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
          // <ByteDance begin>
          if (p >= s->utf8_parse_front) {
            s->utf8_adapte_size += p1 - p - 1;
            s->utf8_parse_front = p1;
          }
          // <ByteDance end>
        }
        /* XXX: check if c >= 0 and c <= 0x10FFFF */
        if (!lre_js_is_ident_next(c)) break;
        p = p1;
        if ((q - buf) >= sizeof(buf) - UTF8_CHAR_LEN_MAX) {
          lepus_parse_error(s, "identifier too long");
          goto fail;
        }
      }
      *q = '\0';
      s->token.u.ident.atom = LEPUS_NewAtomLen(s->ctx, buf, q - buf);
      s->token.u.ident.has_escape = ident_has_escape;
      s->token.u.ident.is_reserved = FALSE;
      if (s->token.u.ident.atom <= LEPUS_ATOM_LAST_KEYWORD ||
          (s->token.u.ident.atom <= LEPUS_ATOM_LAST_STRICT_KEYWORD &&
           s->cur_func && (s->cur_func->lepus_mode & LEPUS_MODE_STRICT)) ||
          (s->token.u.ident.atom == LEPUS_ATOM_yield && s->cur_func &&
           ((s->cur_func->func_kind & LEPUS_FUNC_GENERATOR) ||
            (s->cur_func->func_type == LEPUS_PARSE_FUNC_ARROW &&
             !s->cur_func->in_function_body && s->cur_func->parent &&
             (s->cur_func->parent->func_kind & LEPUS_FUNC_GENERATOR)))) ||
          (s->token.u.ident.atom == LEPUS_ATOM_await &&
           (s->is_module ||
            (s->cur_func &&
             ((s->cur_func->func_kind & LEPUS_FUNC_ASYNC) ||
              (s->cur_func->func_type == LEPUS_PARSE_FUNC_ARROW &&
               !s->cur_func->in_function_body && s->cur_func->parent &&
               (s->cur_func->parent->func_kind & LEPUS_FUNC_ASYNC))))))) {
        if (ident_has_escape) {
          s->token.u.ident.is_reserved = TRUE;
          s->token.val = TOK_IDENT;
        } else {
          /* The keywords atoms are pre allocated */
          s->token.val = s->token.u.ident.atom - 1 + TOK_FIRST_KEYWORD;
        }
      } else {
        s->token.val = TOK_IDENT;
      }
      break;
    case '#':
      /* private name */
      {
        const uint8_t *p1;
        p++;
        q = buf;
        *q++ = '#';
        p1 = p;
        c = *p1++;
        if (c == '\\' && *p1 == 'u') {
          c = lre_parse_escape(&p1, TRUE);
        } else if (c >= 128) {
          c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
        }
        if (!lre_js_is_ident_first(c)) {
          lepus_parse_error(s, "invalid first character of private name");
          goto fail;
        }
        p = p1;
        for (;;) {
          if (c < 128) {
            *q++ = c;
          } else {
            q += unicode_to_utf8((uint8_t *)q, c);
          }
          p1 = p;
          c = *p1++;
          if (c == '\\' && *p1 == 'u') {
            c = lre_parse_escape(&p1, TRUE);
            ident_has_escape = TRUE;
          } else if (c >= 128) {
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
          }
          /* XXX: check if c >= 0 and c <= 0x10FFFF */
          if (!lre_js_is_ident_next(c)) break;
          p = p1;
          if ((q - buf) >= sizeof(buf) - UTF8_CHAR_LEN_MAX) {
            lepus_parse_error(s, "private name too long");
            goto fail;
          }
        }
        *q = '\0';
        s->token.u.ident.atom = LEPUS_NewAtomLen(s->ctx, buf, q - buf);
        s->token.val = TOK_PRIVATE_NAME;
      }
      break;
    case '.':
      if (p[1] == '.' && p[2] == '.') {
        p += 3;
        s->token.val = TOK_ELLIPSIS;
        break;
      }
      if (p[1] >= '0' && p[1] <= '9') {
        goto parse_number;
      } else {
        goto def_token;
      }
      break;
    case '0':
      /* in strict or JSON parsing mode, octal literals are not accepted */
      if (is_digit(p[1]) &&
          (!s->cur_func || (s->cur_func->lepus_mode & LEPUS_MODE_STRICT))) {
        lepus_parse_error(s, "octal literals are deprecated in strict mode");
        goto fail;
      }
      goto parse_number;
    case '1' ... '9':
      /* number */
    parse_number :
#ifdef CONFIG_BIGNUM
    {
      const uint8_t *p1;
      int flags;
      slimb_t exponent;
      LEPUSValue val;

      s->token.val = TOK_NUMBER;
      s->token.u.num.val = LEPUS_UNDEFINED;
      s->token.u.num.exponent = 0;
      if (!s->cur_func) {
        /* JSON: use current float precision */
        flags = BF_ATOF_THROW;
        if (is_bignum_mode(s->ctx))
          flags |= BF_ATOF_INT_PREC_INF;
        else
          flags |= BF_ATOF_FLOAT64;
        val = lepus_atof(s->ctx, (const char *)p, (const char **)&p, 10, flags);
        if (LEPUS_IsException(val)) goto bad_number;
      } else {
        bf_t r_s, *r = &r_s;
        BOOL bigint_mode, is_bigint, is_bigfloat;
        int res;

        bigint_mode = (s->cur_func->lepus_mode & LEPUS_MODE_BIGINT) != 0;
        flags = BF_ATOF_BIN_OCT | BF_ATOF_LEGACY_OCTAL |
                BF_ATOF_UNDERSCORE_SEP | BF_ATOF_INT_PREC_INF | BF_RNDZ;
        if (!bigint_mode) flags |= BF_ATOF_ONLY_DEC_FLOAT;
        p += skip_spaces((char *)p);
        bf_init(s->ctx->bf_ctx, r);
        res = bf_atof2(r, &exponent, (const char *)p, (const char **)&p, 0,
                       BF_PREC_INF, flags);
        if (bf_is_nan(r)) {
          bf_delete(r);
          goto bad_number;
        }
        is_bigint = FALSE;
        is_bigfloat = FALSE;
        if (*p == 'n') {
          if (!(res & BF_ATOF_ST_INTEGER) || (res & BF_ATOF_ST_LEGACY_OCTAL)) {
            bf_delete(r);
            goto bad_number;
          }
          p++;
          is_bigint = TRUE;
        } else if (*p == 'l') {
          p++;
          is_bigfloat = TRUE;
        }
        if ((res & BF_ATOF_ST_INTEGER) && !is_bigfloat &&
            (bigint_mode || is_bigint)) {
          /* in bigint mode: small integer or bigint
             in legacy mode: always a bigint */
          val = LEPUS_NewBigInt2(s->ctx, r, bigint_mode ^ 1);
        } else {
          /* `n` suffix is implied in math mode */
          if (s->cur_func->lepus_mode & LEPUS_MODE_MATH) is_bigfloat = TRUE;
          if (is_bigfloat) {
            /* infinite precision */
            val = LEPUS_NewBigFloat(s->ctx, r);
            s->token.u.num.exponent = exponent;
          } else {
            double d;
            d = bf_mul_pow10_to_float64(s->ctx, r, exponent);
            bf_delete(r);
            val = LEPUS_NewFloat64(s->ctx, d);
          }
        }
      }
      s->token.u.num.val = val;
      if (lre_js_is_ident_next(unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1))) {
      bad_number:
        lepus_parse_error(s, "invalid number literal");
        goto fail;
      }
    }
#else
    {
      LEPUSValue ret;
      const uint8_t *p1;
      int flags, radix;
      if (!s->cur_func) {
        flags = ATOD_THROW;
        radix = 10;
      } else {
        flags = ATOD_ACCEPT_BIN_OCT | ATOD_THROW | ATOD_ACCEPT_LEGACY_OCTAL |
                ATOD_ACCEPT_UNDERSCORES;
        radix = 0;
      }
      ret =
          lepus_atod(s->ctx, (const char *)p, (const char **)&p, radix, flags);
      /* reject `10instanceof Number` */
      if (LEPUS_IsException(ret) ||
          lre_js_is_ident_next(unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1))) {
        lepus_parse_error(s, "invalid number literal");
        goto fail;
      }
      s->token.val = TOK_NUMBER;
      s->token.u.num.val = ret;
    }
#endif
    break;
    case '*':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_MUL_ASSIGN;
      } else if (p[1] == '*') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_POW_ASSIGN;
        } else {
          p += 2;
          s->token.val = TOK_POW;
        }
      } else {
        goto def_token;
      }
      break;
    case '%':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_MOD_ASSIGN;
      } else {
        goto def_token;
      }
      break;
    case '+':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_PLUS_ASSIGN;
      } else if (p[1] == '+') {
        p += 2;
        s->token.val = TOK_INC;
      } else {
        goto def_token;
      }
      break;
    case '-':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_MINUS_ASSIGN;
      } else if (p[1] == '-') {
        if (s->allow_html_comments && p[2] == '>' &&
            s->last_line_num != s->line_num) {
          /* Annex B: `-->` at beginning of line is an html comment end.
             It extends to the end of the line.
           */
          goto skip_line_comment;
        }
        p += 2;
        s->token.val = TOK_DEC;
      } else {
        goto def_token;
      }
      break;
    case '<':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_LTE;
      } else if (p[1] == '<') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_SHL_ASSIGN;
        } else {
          p += 2;
          s->token.val = TOK_SHL;
        }
      } else if (s->allow_html_comments && p[1] == '!' && p[2] == '-' &&
                 p[3] == '-') {
        /* Annex B: handle `<!--` single line html comments */
        goto skip_line_comment;
      } else {
        goto def_token;
      }
      break;
    case '>':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_GTE;
      } else if (p[1] == '>') {
        if (p[2] == '>') {
          if (p[3] == '=') {
            p += 4;
            s->token.val = TOK_SHR_ASSIGN;
          } else {
            p += 3;
            s->token.val = TOK_SHR;
          }
        } else if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_SAR_ASSIGN;
        } else {
          p += 2;
          s->token.val = TOK_SAR;
        }
      } else {
        goto def_token;
      }
      break;
    case '=':
      if (p[1] == '=') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_STRICT_EQ;
        } else {
          p += 2;
          s->token.val = TOK_EQ;
        }
      } else if (p[1] == '>') {
        p += 2;
        s->token.val = TOK_ARROW;
      } else {
        goto def_token;
      }
      break;
    case '!':
      if (p[1] == '=') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_STRICT_NEQ;
        } else {
          p += 2;
          s->token.val = TOK_NEQ;
        }
      } else {
        goto def_token;
      }
      break;
    case '&':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_AND_ASSIGN;
      } else if (p[1] == '&') {
        p += 2;
        s->token.val = TOK_LAND;
      } else {
        goto def_token;
      }
      break;
#ifdef CONFIG_BIGNUM
      /* in math mode, '^' is the power operator. '^^' is always the
         xor operator and '**' is always the power operator */
    case '^':
      if (p[1] == '=') {
        p += 2;
        if (s->cur_func && (s->cur_func->lepus_mode & LEPUS_MODE_MATH))
          s->token.val = TOK_MATH_POW_ASSIGN;
        else
          s->token.val = TOK_XOR_ASSIGN;
      } else if (p[1] == '^') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_XOR_ASSIGN;
        } else {
          p += 2;
          s->token.val = '^';
        }
      } else {
        p++;
        if (s->cur_func && (s->cur_func->lepus_mode & LEPUS_MODE_MATH))
          s->token.val = TOK_MATH_POW;
        else
          s->token.val = '^';
      }
      break;
#else
    case '^':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_XOR_ASSIGN;
      } else {
        goto def_token;
      }
      break;
#endif
    case '|':
      if (p[1] == '=') {
        p += 2;
        s->token.val = TOK_OR_ASSIGN;
      } else if (p[1] == '|') {
        p += 2;
        s->token.val = TOK_LOR;
      } else {
        goto def_token;
      }
      break;
    case '?':
      if (p[1] == '?') {
        if (p[2] == '=') {
          p += 3;
          s->token.val = TOK_DOUBLE_QUESTION_MARK_ASSIGN;
        } else {
          p += 2;
          s->token.val = TOK_DOUBLE_QUESTION_MARK;
        }
      } else if (p[1] == '.' && !(p[2] >= '0' && p[2] <= '9')) {
        p += 2;
        s->token.val = TOK_QUESTION_MARK_DOT;
      } else {
        goto def_token;
      }
      break;
    default:
      if (c >= 128) {
        /* unicode value */
        // <ByteDance begin>
        const uint8_t *p_next;
        c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p_next);
        if (p >= s->utf8_parse_front) {
          s->last_utf8_adapte_size = s->utf8_adapte_size;
          s->utf8_adapte_size += p_next - p - 1;
          s->utf8_parse_front = p_next;
        }
        p = p_next;
        // <ByteDance end>
        switch (c) {
          case CP_PS:
          case CP_LS:
            if (!s->cur_func) {
              /* <PS> and <LS> are not JSONWhitespace */
              goto def_token;
            } else {
              /* XXX: should avoid incrementing line_number, but
                 needed to handle HTML comments */
              goto line_terminator;
            }
          default:
            if (lre_is_space(c)) {
              if (!s->cur_func) {
                /* category z spaces are not JSONWhitespace */
                goto def_token;
              } else {
                goto redo;
              }
            } else if (lre_js_is_ident_first(c)) {
              ident_has_escape = FALSE;
              goto has_ident;
            } else {
              lepus_parse_error(s, "unexpected character");
              goto fail;
            }
        }
      }
    def_token:
      s->token.val = c;
      p++;
      break;
  }
  s->buf_ptr = p;
  //    dump_token(s, &s->token);
  return 0;

fail:
  s->token.val = TOK_ERROR;
  return -1;
}

/* only used for ':' and '=>', 'let' or 'function' look-ahead */
/* XXX: handle all unicode cases */
QJS_STATIC int peek_token(LEPUSParseState *s, BOOL no_line_terminator) {
  const uint8_t *p;
  uint32_t c;

  /* skip spaces and comments */
  for (p = s->buf_ptr;;) {
    switch (c = *p++) {
      case '\r':
      case '\n':
        if (no_line_terminator) return '\n';
        continue;
      case ' ':
      case '\t':
      case '\v':
      case '\f':
        continue;
      case '/':
        if (*p == '/') {
          if (no_line_terminator) return '\n';
          while (*p && *p != '\r' && *p != '\n') p++;
          continue;
        }
        if (*p == '*') {
          while (*++p) {
            if ((*p == '\r' || *p == '\n') && no_line_terminator) return '\n';
            if (*p == '*' && p[1] == '/') {
              p += 2;
              break;
            }
          }
          continue;
        }
        break;
      case '=':
        if (*p == '>') return TOK_ARROW;
        break;
      default:
        if (lre_js_is_ident_first(c)) {
          if (c == 'i' && *p == 'n' && !lre_js_is_ident_next(p[1]))
            return TOK_IN;
          if (c == 'o' && *p == 'f' && !lre_js_is_ident_next(p[1]))
            return TOK_OF;
          else if (c == 'f' && p[0] == 'u' && p[1] == 'n' && p[2] == 'c' &&
                   p[3] == 't' && p[4] == 'i' && p[5] == 'o' && p[6] == 'n' &&
                   !lre_js_is_ident_next(p[7]))
            return TOK_FUNCTION;
          else
            return TOK_IDENT;
        }
        break;
    }
    return c;
  }
}

QJS_STATIC inline int get_prev_opcode(LEPUSFunctionDef *fd) {
  if (fd->last_opcode_pos < 0)
    return OP_invalid;
  else
    return fd->byte_code.buf[fd->last_opcode_pos];
}

QJS_STATIC BOOL lepus_is_live_code(LEPUSParseState *s) {
  switch (get_prev_opcode(s->cur_func)) {
    case OP_tail_call:
    case OP_tail_call_method:
    case OP_return:
    case OP_return_undef:
    case OP_return_async:
    case OP_throw:
    case OP_throw_var:
    case OP_goto:
#if SHORT_OPCODES
    case OP_goto8:
    case OP_goto16:
#endif
    case OP_ret:
      return FALSE;
    default:
      return TRUE;
  }
}

QJS_STATIC void emit_u8(LEPUSParseState *s, uint8_t val) {
  dbuf_putc(&s->cur_func->byte_code, val);
}

QJS_STATIC void emit_u16(LEPUSParseState *s, uint16_t val) {
  dbuf_put_u16(&s->cur_func->byte_code, val);
}

QJS_STATIC void emit_u32(LEPUSParseState *s, uint32_t val) {
  dbuf_put_u32(&s->cur_func->byte_code, val);
}

#ifdef ENABLE_PRIMJS_IC
QJS_STATIC void emit_u64(LEPUSParseState *s, uint64_t val) {
  dbuf_put_u64(&s->cur_func->byte_code, val);
}
#endif

QJS_STATIC void emit_type_get_feedback(LEPUSParseState *s) {
#ifdef ENABLE_PRIMJS_IC
  LEPUSFunctionDef *fd = s->cur_func;

  // We will change this placeholder to real feedback vector index in
  // resolve_ic.
  emit_u64(s, 0);
  fd->get_feedback_vec_size++;
#endif
}

QJS_STATIC void emit_type_set_feedback(LEPUSParseState *s) {
#ifdef ENABLE_PRIMJS_IC
  LEPUSFunctionDef *fd = s->cur_func;
  // We will change this placeholder to real feedback vector index in
  // resolve_ic.
  emit_u64(s, 0);
  fd->set_feedback_vec_size++;
#endif
}

QJS_STATIC void emit_op(LEPUSParseState *s, uint8_t val) {
  LEPUSFunctionDef *fd = s->cur_func;
  DynBuf *bc = &fd->byte_code;

  /* Use the line number of the last token used, not the next token,
     nor the current offset in the source file.
   */
  // <ByteDance begin>
  if (unlikely(s->last_emit_ptr != s->last_ptr)) {
    int64_t result = compute_column(s, val == OP_scope_get_var);
    dbuf_putc(bc, OP_line_num);
    dbuf_put_u64(bc, result);
    s->last_emit_ptr = s->last_ptr;
    fd->last_opcode_line_num = s->last_line_num;
  }
  // <ByteDance end>
  fd->last_opcode_pos = bc->size;
  dbuf_putc(bc, val);
}

QJS_STATIC void emit_atom(LEPUSParseState *s, LEPUSAtom name) {
  emit_u32(s, LEPUS_DupAtom(s->ctx, name));
}

QJS_STATIC int update_label(LEPUSFunctionDef *s, int label, int delta) {
  LabelSlot *ls;

  assert(label >= 0 && label < s->label_count);
  ls = &s->label_slots[label];
  ls->ref_count += delta;
  assert(ls->ref_count >= 0);
  return ls->ref_count;
}

QJS_STATIC int new_label_fd(LEPUSFunctionDef *fd, int label) {
  LabelSlot *ls;

  if (label < 0) {
    if (fd->label_count >= fd->label_size) {
      int new_size;
      size_t slack;
      LabelSlot *new_tab;

      /* XXX: potential arithmetic overflow */
      new_size = fd->label_size * 3 / 2 + 4;
      new_tab = static_cast<LabelSlot *>(lepus_realloc2(
          fd->ctx, fd->label_slots, new_size * sizeof(*new_tab), &slack));
      if (!new_tab) return -1;
      new_size += slack / sizeof(*new_tab);
      fd->label_slots = new_tab;
      fd->label_size = new_size;
    }
    label = fd->label_count++;
    ls = &fd->label_slots[label];
    ls->ref_count = 0;
    ls->pos = -1;
    ls->pos2 = -1;
    ls->addr = -1;
    ls->first_reloc = NULL;
  }
  return label;
}

QJS_STATIC int new_label(LEPUSParseState *s) {
  return new_label_fd(s->cur_func, -1);
}

/* return the label ID offset */
QJS_STATIC int emit_label(LEPUSParseState *s, int label) {
  if (label >= 0) {
    emit_op(s, OP_label);
    emit_u32(s, label);
    s->cur_func->label_slots[label].pos = s->cur_func->byte_code.size;
    return s->cur_func->byte_code.size - 4;
  } else {
    return -1;
  }
}

/* return label or -1 if dead code */
QJS_STATIC int emit_goto(LEPUSParseState *s, int opcode, int label) {
  if (lepus_is_live_code(s)) {
    if (label < 0) label = new_label(s);
    emit_op(s, opcode);
    emit_u32(s, label);
    s->cur_func->label_slots[label].ref_count++;
    return label;
  }
  return -1;
}

/* return the constant pool index. 'val' is not duplicated. */
QJS_STATIC int cpool_add(LEPUSParseState *s, LEPUSValue val) {
  LEPUSFunctionDef *fd = s->cur_func;
  if (fd->cpool_count >= fd->cpool_size) {
    int new_size;
    size_t slack;
    LEPUSValue *new_tab;
    /* XXX: potential arithmetic overflow */
    new_size = max_int(fd->cpool_count + 1, fd->cpool_size * 3 / 2);
    new_tab = static_cast<LEPUSValue *>(lepus_realloc2(
        s->ctx, fd->cpool, new_size * sizeof(LEPUSValue), &slack));
    if (!new_tab) return -1;
    new_size += slack / sizeof(*new_tab);
    fd->cpool = new_tab;
    fd->cpool_size = new_size;
  }
  fd->cpool[fd->cpool_count++] = val;
  return fd->cpool_count - 1;
}

QJS_STATIC __exception int emit_push_const(LEPUSParseState *s,
                                           LEPUSValueConst val, BOOL as_atom) {
  int idx;

  if (LEPUS_VALUE_IS_STRING(val) && as_atom) {
    LEPUSAtom atom;
    /* warning: LEPUS_NewAtomStr frees the string value */
    LEPUS_DupValue(s->ctx, val);
    atom = LEPUS_NewAtomStr(s->ctx, LEPUS_VALUE_GET_STRING(val));
    if (atom != LEPUS_ATOM_NULL && !__JS_AtomIsTaggedInt(atom)) {
      emit_op(s, OP_push_atom_value);
      emit_u32(s, atom);
      return 0;
    }
  }

  idx = cpool_add(s, LEPUS_DupValue(s->ctx, val));
  if (idx < 0) return -1;
  emit_op(s, OP_push_const);
  emit_u32(s, idx);
  return 0;
}

/* return the variable index or -1 if not found,
   add ARGUMENT_VAR_OFFSET for argument variables */
QJS_STATIC int find_arg(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                        LEPUSAtom name) {
  int i;
  for (i = fd->arg_count; i-- > 0;) {
    if (fd->args[i].var_name == name) return i | ARGUMENT_VAR_OFFSET;
  }
  return -1;
}

QJS_STATIC int find_var(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                        LEPUSAtom name) {
  int i;
  for (i = fd->var_count; i-- > 0;) {
    if (fd->vars[i].var_name == name && fd->vars[i].scope_level == 0) return i;
  }
  return find_arg(ctx, fd, name);
}

/* find a variable declaration in a given scope */
QJS_STATIC int find_var_in_scope(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                                 LEPUSAtom name, int scope_level) {
  int scope_idx;
  for (scope_idx = fd->scopes[scope_level].first; scope_idx >= 0;
       scope_idx = fd->vars[scope_idx].scope_next) {
    if (fd->vars[scope_idx].scope_level != scope_level) break;
    if (fd->vars[scope_idx].var_name == name) return scope_idx;
  }
  return -1;
}

/* return true if scope == parent_scope or if scope is a child of
   parent_scope */
QJS_STATIC BOOL is_child_scope(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                               int scope, int parent_scope) {
  while (scope >= 0) {
    if (scope == parent_scope) return TRUE;
    scope = fd->scopes[scope].parent;
  }
  return FALSE;
}

/* find a 'var' declaration in the same scope or a child scope */
QJS_STATIC int find_var_in_child_scope(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                                       LEPUSAtom name, int scope_level) {
  int i;
  for (i = 0; i < fd->var_count; i++) {
    LEPUSVarDef *vd = &fd->vars[i];
    if (vd->var_name == name && vd->scope_level == 0) {
      if (is_child_scope(ctx, fd, vd->scope_next, scope_level)) return i;
    }
  }
  return -1;
}

QJS_STATIC LEPUSHoistedDef *find_hoisted_def(LEPUSFunctionDef *fd,
                                             LEPUSAtom name) {
  int i;
  for (i = 0; i < fd->hoisted_def_count; i++) {
    LEPUSHoistedDef *hf = &fd->hoisted_def[i];
    if (hf->var_name == name) return hf;
  }
  return NULL;
}

QJS_STATIC LEPUSHoistedDef *find_lexical_hoisted_def(LEPUSFunctionDef *fd,
                                                     LEPUSAtom name) {
  LEPUSHoistedDef *hf = find_hoisted_def(fd, name);
  if (hf && hf->is_lexical)
    return hf;
  else
    return NULL;
}

QJS_STATIC int find_lexical_decl(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                                 LEPUSAtom name, int scope_idx,
                                 BOOL check_catch_var) {
  while (scope_idx >= 0) {
    LEPUSVarDef *vd = &fd->vars[scope_idx];
    if (vd->var_name == name &&
        (vd->is_lexical ||
         (vd->var_kind == LEPUS_VAR_CATCH && check_catch_var)))
      return scope_idx;
    scope_idx = vd->scope_next;
  }

  if (fd->is_eval && fd->eval_type == LEPUS_EVAL_TYPE_GLOBAL) {
    if (find_lexical_hoisted_def(fd, name)) return GLOBAL_VAR_OFFSET;
  }
  return -1;
}

QJS_STATIC int push_scope(LEPUSParseState *s) {
  if (s->cur_func) {
    LEPUSFunctionDef *fd = s->cur_func;
    int scope = fd->scope_count;
    /* XXX: should check for scope overflow */
    if ((fd->scope_count + 1) > fd->scope_size) {
      int new_size;
      size_t slack;
      LEPUSVarScope *new_buf;
      /* XXX: potential arithmetic overflow */
      new_size = max_int(fd->scope_count + 1, fd->scope_size * 3 / 2);
      if (fd->scopes == fd->def_scope_array) {
        new_buf = static_cast<LEPUSVarScope *>(lepus_realloc2(
            s->ctx, NULL, new_size * sizeof(*fd->scopes), &slack));
        if (!new_buf) return -1;
        memcpy(new_buf, fd->scopes, fd->scope_count * sizeof(*fd->scopes));
      } else {
        new_buf = static_cast<LEPUSVarScope *>(lepus_realloc2(
            s->ctx, fd->scopes, new_size * sizeof(*fd->scopes), &slack));
        if (!new_buf) return -1;
      }
      new_size += slack / sizeof(*new_buf);
      fd->scopes = new_buf;
      fd->scope_size = new_size;
    }
    fd->scope_count++;
    fd->scopes[scope].parent = fd->scope_level;
    fd->scopes[scope].first = fd->scope_first;
    emit_op(s, OP_enter_scope);
    emit_u16(s, scope);
    return fd->scope_level = scope;
  }
  return 0;
}

QJS_STATIC int get_first_lexical_var(LEPUSFunctionDef *fd, int scope) {
  while (scope >= 0) {
    int scope_idx = fd->scopes[scope].first;
    if (scope_idx >= 0) return scope_idx;
    scope = fd->scopes[scope].parent;
  }
  return -1;
}

QJS_STATIC void pop_scope(LEPUSParseState *s) {
  if (s->cur_func) {
    /* disable scoped variables */
    LEPUSFunctionDef *fd = s->cur_func;
    int scope = fd->scope_level;
    emit_op(s, OP_leave_scope);
    emit_u16(s, scope);
    fd->scope_level = fd->scopes[scope].parent;
    fd->scope_first = get_first_lexical_var(fd, fd->scope_level);
  }
}

QJS_STATIC void close_scopes(LEPUSParseState *s, int scope, int scope_stop) {
  while (scope > scope_stop) {
    emit_op(s, OP_leave_scope);
    emit_u16(s, scope);
    scope = s->cur_func->scopes[scope].parent;
  }
}

/* return the variable index or -1 if error */
QJS_STATIC int add_var(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                       LEPUSAtom name) {
  LEPUSVarDef *vd;

  /* the local variable indexes are currently stored on 16 bits */
  if (fd->var_count >= LEPUS_MAX_LOCAL_VARS) {
    LEPUS_ThrowInternalError(ctx, "too many local variables");
    return -1;
  }
  if ((fd->var_count + 1) > fd->var_size) {
    int new_size;
    size_t slack;
    LEPUSVarDef *new_buf;
    new_size =
        fd->var_count == 0 ? 4 : max_int(fd->var_count + 1, fd->var_size * 2);
    new_buf = static_cast<LEPUSVarDef *>(
        lepus_realloc2(ctx, fd->vars, new_size * sizeof(*fd->vars), &slack));
    if (!new_buf) return -1;
    new_size += slack / sizeof(*new_buf);
    fd->vars = new_buf;
    fd->var_size = new_size;
  }
  vd = &fd->vars[fd->var_count++];
  memset(vd, 0, sizeof(*vd));
  vd->var_name = LEPUS_DupAtom(ctx, name);
  vd->func_pool_idx = -1;
  return fd->var_count - 1;
}

QJS_STATIC int add_scope_var(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                             LEPUSAtom name, LEPUSVarKindEnum var_kind) {
  int idx = add_var(ctx, fd, name);
  if (idx >= 0) {
    LEPUSVarDef *vd = &fd->vars[idx];
    vd->var_kind = var_kind;
    vd->scope_level = fd->scope_level;
    vd->scope_next = fd->scope_first;
    fd->scopes[fd->scope_level].first = idx;
    fd->scope_first = idx;
  }
  return idx;
}

QJS_STATIC int add_func_var(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                            LEPUSAtom name) {
  int idx = fd->func_var_idx;
  if (idx < 0 && (idx = add_var(ctx, fd, name)) >= 0) {
    fd->func_var_idx = idx;
    fd->vars[idx].var_kind = LEPUS_VAR_FUNCTION_NAME;
    if (fd->lepus_mode & LEPUS_MODE_STRICT) fd->vars[idx].is_const = TRUE;
  }
  return idx;
}

QJS_STATIC int add_arguments_var(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                                 LEPUSAtom name) {
  int idx = fd->arguments_var_idx;
  if (idx < 0 && (idx = add_var(ctx, fd, name)) >= 0) {
    fd->arguments_var_idx = idx;
  }
  return idx;
}

/* add an argument definition in the argument scope. Only needed when
   "eval()" may be called in the argument scope. Return 0 if OK. */
QJS_STATIC int add_arguments_arg(LEPUSContext *ctx, LEPUSFunctionDef *fd) {
  int idx;
  if (fd->arguments_arg_idx < 0) {
    idx = find_var_in_scope(ctx, fd, LEPUS_ATOM_arguments, ARG_SCOPE_INDEX);
    if (idx < 0) {
      /* XXX: the scope links are not fully updated. May be an
         issue if there are child scopes of the argument
         scope */
      idx = add_var(ctx, fd, LEPUS_ATOM_arguments);
      if (idx < 0) return -1;
      fd->vars[idx].scope_next = fd->scopes[ARG_SCOPE_INDEX].first;
      fd->scopes[ARG_SCOPE_INDEX].first = idx;
      fd->vars[idx].scope_level = ARG_SCOPE_INDEX;
      fd->vars[idx].is_lexical = TRUE;

      fd->arguments_arg_idx = idx;
    }
  }
  return 0;
}

QJS_STATIC int add_arg(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                       LEPUSAtom name) {
  LEPUSVarDef *vd;

  /* the local variable indexes are currently stored on 16 bits */
  if (fd->arg_count >= LEPUS_MAX_LOCAL_VARS) {
    LEPUS_ThrowInternalError(ctx, "too many arguments");
    return -1;
  }
  if ((fd->arg_count + 1) > fd->arg_size) {
    int new_size;
    size_t slack;
    LEPUSVarDef *new_buf;
    new_size = max_int(fd->arg_count + 1, fd->arg_size * 3 / 2);
    new_buf = static_cast<LEPUSVarDef *>(
        lepus_realloc2(ctx, fd->args, new_size * sizeof(*fd->args), &slack));
    if (!new_buf) return -1;
    new_size += slack / sizeof(*new_buf);
    fd->args = new_buf;
    fd->arg_size = new_size;
  }
  vd = &fd->args[fd->arg_count++];
  memset(vd, 0, sizeof(*vd));
  vd->var_name = LEPUS_DupAtom(ctx, name);
  vd->func_pool_idx = -1;
  return fd->arg_count - 1;
}

/* add a Hoisted definition for a function (cpool_idx >= 0) or a
   global variable (cpool_idx = -1) */
QJS_STATIC LEPUSHoistedDef *add_hoisted_def(LEPUSContext *ctx,
                                            LEPUSFunctionDef *s, int cpool_idx,
                                            LEPUSAtom name, int var_idx,
                                            BOOL is_lexical) {
  LEPUSHoistedDef *hf;

  if (s->hoisted_def_count >= s->hoisted_def_size) {
    int new_size;
    size_t slack;
    LEPUSHoistedDef *new_tab;
    new_size = max_int(s->hoisted_def_count + 1, s->hoisted_def_size * 3 / 2);
    new_tab = static_cast<LEPUSHoistedDef *>(lepus_realloc2(
        ctx, s->hoisted_def, new_size * sizeof(s->hoisted_def[0]), &slack));
    if (!new_tab) return NULL;
    new_size += slack / sizeof(*new_tab);
    s->hoisted_def = new_tab;
    s->hoisted_def_size = new_size;
  }
  hf = &s->hoisted_def[s->hoisted_def_count++];
  hf->cpool_idx = cpool_idx;
  hf->force_init = 0;
  hf->is_lexical = is_lexical;
  hf->is_const = FALSE;
  hf->var_idx = var_idx;
  hf->scope_level = s->scope_level;
  hf->var_name = LEPUS_DupAtom(ctx, name);
  return hf;
}

typedef enum {
  LEPUS_VAR_DEF_WITH,
  LEPUS_VAR_DEF_LET,
  LEPUS_VAR_DEF_CONST,
  LEPUS_VAR_DEF_FUNCTION_DECL,     /* function declaration */
  LEPUS_VAR_DEF_NEW_FUNCTION_DECL, /* async/generator function declaration */
  LEPUS_VAR_DEF_CATCH,
  LEPUS_VAR_DEF_VAR,
} LEPUSVarDefEnum;

QJS_STATIC int define_var(LEPUSParseState *s, LEPUSFunctionDef *fd,
                          LEPUSAtom name, LEPUSVarDefEnum var_def_type) {
  LEPUSContext *ctx = s->ctx;
  LEPUSVarDef *vd;
  int idx;

  switch (var_def_type) {
    case LEPUS_VAR_DEF_WITH:
      idx = add_scope_var(ctx, fd, name, LEPUS_VAR_NORMAL);
      break;

    case LEPUS_VAR_DEF_LET:
    case LEPUS_VAR_DEF_CONST:
    case LEPUS_VAR_DEF_FUNCTION_DECL:
    case LEPUS_VAR_DEF_NEW_FUNCTION_DECL:
      idx = find_lexical_decl(ctx, fd, name, fd->scope_first, TRUE);
      if (idx >= 0) {
        if (idx < GLOBAL_VAR_OFFSET) {
          if (fd->vars[idx].scope_level == fd->scope_level) {
            /* same scope: in non strict mode, functions can be redefined (annex
             * B.3.3.4). */
            if (!(!(fd->lepus_mode & LEPUS_MODE_STRICT) &&
                  var_def_type == LEPUS_VAR_DEF_FUNCTION_DECL &&
                  fd->vars[idx].var_kind == LEPUS_VAR_FUNCTION_DECL)) {
              goto redef_lex_error;
            }
          } else if (fd->vars[idx].var_kind == LEPUS_VAR_CATCH &&
                     (fd->vars[idx].scope_level + 2) == fd->scope_level) {
            goto redef_lex_error;
          }
        } else {
          if (fd->scope_level == fd->body_scope) {
          redef_lex_error:
            /* redefining a scoped var in the same scope: error */
            return lepus_parse_error(
                s, "invalid redefinition of lexical identifier");
          }
        }
      }
      if (var_def_type != LEPUS_VAR_DEF_FUNCTION_DECL &&
          var_def_type != LEPUS_VAR_DEF_NEW_FUNCTION_DECL &&
          fd->scope_level == fd->body_scope && find_arg(ctx, fd, name) >= 0) {
        /* lexical variable redefines a parameter name */
        return lepus_parse_error(s, "invalid redefinition of parameter name");
      }

      if (find_var_in_child_scope(ctx, fd, name, fd->scope_level) >= 0) {
        return lepus_parse_error(s, "invalid redefinition of a variable");
      }

      if (fd->is_global_var) {
        LEPUSHoistedDef *hf;
        hf = find_hoisted_def(fd, name);
        /* XXX: should check scope chain */
        if (hf && is_child_scope(ctx, fd, hf->scope_level, fd->scope_level)) {
          return lepus_parse_error(s,
                                   "invalid redefinition of global identifier");
        }
      }

      if (fd->is_eval &&
          (fd->eval_type == LEPUS_EVAL_TYPE_GLOBAL ||
           fd->eval_type == LEPUS_EVAL_TYPE_MODULE) &&
          fd->scope_level == fd->body_scope) {
        LEPUSHoistedDef *hf;
        hf = add_hoisted_def(s->ctx, fd, -1, name, -1, TRUE);
        if (!hf) return -1;
        hf->is_lexical = TRUE;
        hf->is_const = (var_def_type == LEPUS_VAR_DEF_CONST);
        idx = GLOBAL_VAR_OFFSET;
      } else {
        LEPUSVarKindEnum var_kind;
        if (var_def_type == LEPUS_VAR_DEF_FUNCTION_DECL)
          var_kind = LEPUS_VAR_FUNCTION_DECL;
        else if (var_def_type == LEPUS_VAR_DEF_NEW_FUNCTION_DECL)
          var_kind = LEPUS_VAR_NEW_FUNCTION_DECL;
        else
          var_kind = LEPUS_VAR_NORMAL;
        idx = add_scope_var(ctx, fd, name, var_kind);
        if (idx >= 0) {
          vd = &fd->vars[idx];
          vd->is_lexical = 1;
          vd->is_const = (var_def_type == LEPUS_VAR_DEF_CONST);
        }
      }
      break;

    case LEPUS_VAR_DEF_CATCH:
      idx = add_scope_var(ctx, fd, name, LEPUS_VAR_CATCH);
      break;

    case LEPUS_VAR_DEF_VAR:
      if (find_lexical_decl(ctx, fd, name, fd->scope_first, FALSE) >= 0) {
      invalid_lexical_redefinition:
        /* error to redefine a var that inside a lexical scope */
        return lepus_parse_error(s,
                                 "invalid redefinition of lexical identifier");
      }
      if (fd->is_global_var) {
        LEPUSHoistedDef *hf;
        hf = find_hoisted_def(fd, name);
        if (hf && hf->is_lexical && hf->scope_level == fd->scope_level &&
            fd->eval_type == LEPUS_EVAL_TYPE_MODULE) {
          goto invalid_lexical_redefinition;
        }
        hf = add_hoisted_def(s->ctx, fd, -1, name, -1, FALSE);
        if (!hf) return -1;
        idx = GLOBAL_VAR_OFFSET;
      } else {
        /* if the variable already exists, don't add it again  */
        idx = find_var(ctx, fd, name);
        if (idx >= 0) break;
        idx = add_var(ctx, fd, name);
        if (idx >= 0) {
          if (name == LEPUS_ATOM_arguments && fd->has_arguments_binding)
            fd->arguments_var_idx = idx;
          fd->vars[idx].scope_next = fd->scope_level;
        }
      }
      break;
    default:
      abort();
  }
  return idx;
}

QJS_STATIC __exception int lepus_parse_expr(LEPUSParseState *s);
QJS_STATIC __exception int lepus_parse_function_decl(
    LEPUSParseState *s, LEPUSParseFunctionEnum func_type,
    LEPUSFunctionKindEnum func_kind, LEPUSAtom func_name, const uint8_t *ptr,
    int start_line);
QJS_STATIC LEPUSFunctionDef *lepus_parse_function_class_fields_init(
    LEPUSParseState *s);
QJS_STATIC __exception int lepus_parse_function_decl2(
    LEPUSParseState *s, LEPUSParseFunctionEnum func_type,
    LEPUSFunctionKindEnum func_kind, LEPUSAtom func_name, const uint8_t *ptr,
    int function_line_num, LEPUSParseExportEnum export_flag,
    LEPUSFunctionDef **pfd);
QJS_STATIC __exception int lepus_parse_assign_expr(LEPUSParseState *s,
                                                   int parse_flags);
QJS_STATIC __exception int lepus_parse_unary(LEPUSParseState *s,
                                             int exponentiation_flag);
QJS_STATIC void push_break_entry(LEPUSFunctionDef *fd, BlockEnv *be,
                                 LEPUSAtom label_name, int label_break,
                                 int label_cont, int drop_count);
QJS_STATIC void pop_break_entry(LEPUSFunctionDef *fd);
QJS_STATIC LEPUSExportEntry *add_export_entry(LEPUSParseState *s,
                                              LEPUSModuleDef *m,
                                              LEPUSAtom local_name,
                                              LEPUSAtom export_name,
                                              LEPUSExportTypeEnum export_type);

/* Note: all the fields are already sealed except length */
QJS_STATIC int seal_template_obj(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSObject *p;
  LEPUSShapeProperty *prs;

  p = LEPUS_VALUE_GET_OBJ(obj);
  prs = find_own_property1(p, LEPUS_ATOM_length);
  if (prs) {
    if (lepus_update_property_flags(
            ctx, p, &prs,
            prs->flags & ~(LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE)))
      return -1;
  }
  p->extensible = FALSE;
  return 0;
}

/* allow the 'in' binary operator */
#define PF_IN_ACCEPTED (1 << 0)
/* allow function calls parsing in lepus_parse_postfix_expr() */
#define PF_POSTFIX_CALL (1 << 1)
/* allow arrow functions parsing in lepus_parse_postfix_expr() */
#define PF_ARROW_FUNC (1 << 2)
/* allow the exponentiation operator in lepus_parse_unary() */
#define PF_POW_ALLOWED (1 << 3)
/* forbid the exponentiation operator in lepus_parse_unary() */
#define PF_POW_FORBIDDEN (1 << 4)

QJS_STATIC __exception int lepus_parse_template(LEPUSParseState *s, int call,
                                                int *argc) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue raw_array, template_object;
  LEPUSToken cooked;
  int depth, ret;

  raw_array = LEPUS_UNDEFINED;       /* avoid warning */
  template_object = LEPUS_UNDEFINED; /* avoid warning */
  if (call) {
    /* Create a template object: an array of cooked strings */
    /* Create an array of raw strings and store it to the raw property */
    template_object = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(template_object)) return -1;
    //        pool_idx = s->cur_func->cpool_count;
    ret = emit_push_const(s, template_object, 0);
    LEPUS_FreeValue(ctx, template_object);
    if (ret) return -1;
    raw_array = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(raw_array)) return -1;
    if (LEPUS_DefinePropertyValue(ctx, template_object, LEPUS_ATOM_raw,
                                  raw_array, LEPUS_PROP_THROW) < 0) {
      return -1;
    }
  }

  depth = 0;
  while (s->token.val == TOK_TEMPLATE) {
    const uint8_t *p = s->token.ptr + 1;
    cooked = s->token;
    if (call) {
      if (LEPUS_DefinePropertyValueUint32(
              ctx, raw_array, depth, LEPUS_DupValue(ctx, s->token.u.str.str),
              LEPUS_PROP_ENUMERABLE | LEPUS_PROP_THROW) < 0) {
        return -1;
      }
      /* re-parse the string with escape sequences but do not throw a
         syntax error if it contains invalid sequences
       */
      if (lepus_parse_string(s, '`', FALSE, p, &cooked, &p)) {
        cooked.u.str.str = LEPUS_UNDEFINED;
      }
      if (LEPUS_DefinePropertyValueUint32(
              ctx, template_object, depth, cooked.u.str.str,
              LEPUS_PROP_ENUMERABLE | LEPUS_PROP_THROW) < 0) {
        return -1;
      }
    } else {
      LEPUSString *str;
      /* re-parse the string with escape sequences and throw a
         syntax error if it contains invalid sequences
       */
      LEPUS_FreeValue(ctx, s->token.u.str.str);
      s->token.u.str.str = LEPUS_UNDEFINED;
      if (lepus_parse_string(s, '`', TRUE, p, &cooked, &p)) return -1;
      str = LEPUS_VALUE_GET_STRING(cooked.u.str.str);
      if (str->len != 0 || depth == 0) {
        ret = emit_push_const(s, cooked.u.str.str, 1);
        LEPUS_FreeValue(s->ctx, cooked.u.str.str);
        if (ret) return -1;
        if (depth == 0) {
          if (s->token.u.str.sep == '`') goto done1;
          emit_op(s, OP_get_field2);
          emit_atom(s, LEPUS_ATOM_concat);
          emit_type_get_feedback(s);
        }
        depth++;
      } else {
        LEPUS_FreeValue(s->ctx, cooked.u.str.str);
      }
    }
    if (s->token.u.str.sep == '`') goto done;
    if (next_token(s)) return -1;
    if (lepus_parse_expr(s)) return -1;
    depth++;
    if (s->token.val != '}') {
      return lepus_parse_error(s, "expected '}' after template expression");
    }
    /* XXX: should convert to string at this stage? */
    free_token(s, &s->token);
    /* Resume TOK_TEMPLATE parsing (s->token.line_num and s->token.ptr are OK)
     */
    s->got_lf = FALSE;
    s->last_line_num = s->token.line_num;
    s->debugger_last_line_num = s->last_line_num;
    if (lepus_parse_template_part(s, s->buf_ptr)) return -1;
  }
  return lepus_parse_expect(s, TOK_TEMPLATE);

done:
  if (call) {
    /* Seal the objects */
    seal_template_obj(ctx, raw_array);
    seal_template_obj(ctx, template_object);
    *argc = depth + 1;
  } else {
    emit_op(s, OP_call_method);
    emit_u16(s, depth - 1);
  }
done1:
  return next_token(s);
}

#define PROP_TYPE_IDENT 0
#define PROP_TYPE_VAR 1
#define PROP_TYPE_GET 2
#define PROP_TYPE_SET 3
#define PROP_TYPE_STAR 4
#define PROP_TYPE_ASYNC 5
#define PROP_TYPE_ASYNC_STAR 6

#define PROP_TYPE_PRIVATE (1 << 4)

QJS_STATIC BOOL token_is_ident(int tok) {
  /* Accept keywords and reserved words as property names */
  return (tok == TOK_IDENT ||
          (tok >= TOK_FIRST_KEYWORD && tok <= TOK_LAST_KEYWORD));
}

/* if the property is an expression, name = LEPUS_ATOM_NULL */
QJS_STATIC int __exception lepus_parse_property_name(LEPUSParseState *s,
                                                     LEPUSAtom *pname,
                                                     BOOL allow_method,
                                                     BOOL allow_var,
                                                     BOOL allow_private) {
  int is_private = 0;
  LEPUSAtom name;
  int prop_type;

  prop_type = PROP_TYPE_IDENT;
  if (allow_method) {
    if ((token_is_pseudo_keyword(s, LEPUS_ATOM_get) ||
         token_is_pseudo_keyword(s, LEPUS_ATOM_set)) &&
        peek_token(s, FALSE) != ',' && peek_token(s, FALSE) != '}') {
      /* get x(), set x() */
      name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
      if (next_token(s)) goto fail1;
      if (s->token.val == ':' || s->token.val == ',' || s->token.val == '}' ||
          s->token.val == '(')
        goto done;
      prop_type = PROP_TYPE_GET + (name == LEPUS_ATOM_set);
      LEPUS_FreeAtom(s->ctx, name);
    } else if (s->token.val == '*') {
      if (next_token(s)) goto fail;
      prop_type = PROP_TYPE_STAR;
    } else if (token_is_pseudo_keyword(s, LEPUS_ATOM_async) &&
               peek_token(s, TRUE) != '\n') {
      name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
      if (next_token(s)) goto fail1;
      if (s->token.val == ':' || s->token.val == ',' || s->token.val == '}' ||
          s->token.val == '(')
        goto done;
      LEPUS_FreeAtom(s->ctx, name);
      if (s->token.val == '*') {
        if (next_token(s)) goto fail;
        prop_type = PROP_TYPE_ASYNC_STAR;
      } else {
        prop_type = PROP_TYPE_ASYNC;
      }
    }
  }

  if (token_is_ident(s->token.val)) {
    /* variable can only be a non-reserved identifier */
    if (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
        prop_type == PROP_TYPE_IDENT && allow_var) {
      int tok = peek_token(s, FALSE);
      if (!(tok == ':' || (tok == '(' && allow_method))) {
        prop_type = PROP_TYPE_VAR;
      }
    }
    /* keywords and reserved words have a valid atom */
    name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
    if (next_token(s)) goto fail1;
  } else if (s->token.val == TOK_STRING) {
    name = lepus_value_to_atom(s->ctx, s->token.u.str.str);
    if (name == LEPUS_ATOM_NULL) goto fail;
    if (next_token(s)) goto fail1;
  } else if (s->token.val == TOK_NUMBER) {
    LEPUSValue val;
    val = s->token.u.num.val;
#ifdef CONFIG_BIGNUM
    if (LEPUS_VALUE_GET_TAG(val) == LEPUS_TAG_BIG_FLOAT) {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      double d;
      d = bf_mul_pow10_to_float64(s->ctx, &p->num, s->token.u.num.exponent);
      val = __JS_NewFloat64(s->ctx, d);
      name = lepus_value_to_atom(s->ctx, val);
      LEPUS_FreeValue(s->ctx, val);
    } else
#endif
    {
      name = lepus_value_to_atom(s->ctx, val);
    }
    if (name == LEPUS_ATOM_NULL) goto fail;
    if (next_token(s)) goto fail1;
  } else if (s->token.val == '[') {
    if (next_token(s)) goto fail;
    if (lepus_parse_expr(s)) goto fail;
    if (lepus_parse_expect(s, ']')) goto fail;
    name = LEPUS_ATOM_NULL;
  } else if (s->token.val == TOK_PRIVATE_NAME && allow_private) {
    name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
    if (next_token(s)) goto fail1;
    is_private = PROP_TYPE_PRIVATE;
  } else {
    goto invalid_prop;
  }
  if (prop_type != PROP_TYPE_IDENT && prop_type != PROP_TYPE_VAR &&
      s->token.val != '(') {
    LEPUS_FreeAtom(s->ctx, name);
  invalid_prop:
    lepus_parse_error(s, "invalid property name");
    goto fail;
  }
done:
  *pname = name;
  return prop_type | is_private;
fail1:
  LEPUS_FreeAtom(s->ctx, name);
fail:
  *pname = LEPUS_ATOM_NULL;
  return -1;
}

typedef struct LEPUSParsePos {
  int last_line_num;
  int line_num;
  BOOL got_lf;
  const uint8_t *ptr;
  // <ByteDance begin>
  const uint8_t *last_line_begin_ptr;
  const uint8_t *line_begin_ptr;
  const uint8_t *utf8_parse_front;
  int utf8_adapte_size;
  int last_utf8_adapte_size;
  // <ByteDance end>
} LEPUSParsePos;

QJS_STATIC int lepus_parse_get_pos(LEPUSParseState *s, LEPUSParsePos *sp) {
  sp->last_line_num = s->last_line_num;
  sp->line_num = s->token.line_num;
  sp->ptr = s->token.ptr;
  sp->got_lf = s->got_lf;
  // <ByteDance begin>
  sp->last_line_begin_ptr = s->last_line_begin_ptr;
  sp->line_begin_ptr = s->line_begin_ptr;
  sp->utf8_adapte_size = s->utf8_adapte_size;
  sp->last_utf8_adapte_size = s->last_utf8_adapte_size;
  sp->utf8_parse_front = s->utf8_parse_front;
  // <ByteDance end>
  return 0;
}

QJS_STATIC __exception int lepus_parse_seek_token(LEPUSParseState *s,
                                                  const LEPUSParsePos *sp) {
  s->token.line_num = sp->last_line_num;
  s->line_num = sp->line_num;
  s->buf_ptr = sp->ptr;
  // <ByteDance begin>
  s->utf8_parse_front = sp->ptr;
  s->last_utf8_adapte_size = sp->last_utf8_adapte_size;
  s->utf8_adapte_size = sp->utf8_adapte_size;
  s->line_begin_ptr = sp->line_begin_ptr;
  // <ByteDance end>
  s->got_lf = sp->got_lf;
  return next_token(s);
}

/* return TRUE if a regexp literal is allowed after this token */
QJS_STATIC BOOL is_regexp_allowed(int tok) {
  switch (tok) {
    case TOK_NUMBER:
    case TOK_STRING:
    case TOK_REGEXP:
    case TOK_DEC:
    case TOK_INC:
    case TOK_NULL:
    case TOK_FALSE:
    case TOK_TRUE:
    case TOK_THIS:
    case ')':
    case ']':
    case '}': /* XXX: regexp may occur after */
    case TOK_IDENT:
      return FALSE;
    default:
      return TRUE;
  }
}

#define SKIP_HAS_SEMI (1 << 0)
#define SKIP_HAS_ELLIPSIS (1 << 1)
#define SKIP_HAS_ASSIGNMENT (1 << 2)

/* XXX: improve speed with early bailout */
/* XXX: no longer works if regexps are present. Could use previous
   regexp parsing heuristics to handle most cases */
QJS_STATIC int lepus_parse_skip_parens_token(LEPUSParseState *s, int *pbits,
                                             BOOL no_line_terminator) {
  char state[256];
  size_t level = 0;
  LEPUSParsePos pos;
  int last_tok, tok = TOK_EOF;
  int c, tok_len, bits = 0;

  /* protect from underflow */
  state[level++] = 0;

  lepus_parse_get_pos(s, &pos);
  last_tok = 0;
  for (;;) {
    switch (s->token.val) {
      case '(':
      case '[':
      case '{':
        if (level >= sizeof(state)) goto done;
        state[level++] = s->token.val;
        break;
      case ')':
        if (state[--level] != '(') goto done;
        break;
      case ']':
        if (state[--level] != '[') goto done;
        break;
      case '}':
        c = state[--level];
        if (c == '`') {
          /* continue the parsing of the template */
          free_token(s, &s->token);
          /* Resume TOK_TEMPLATE parsing (s->token.line_num and
           * s->token.ptr are OK) */
          s->got_lf = FALSE;
          s->last_line_num = s->token.line_num;
          if (lepus_parse_template_part(s, s->buf_ptr)) goto done;
          goto handle_template;
        } else if (c != '{') {
          goto done;
        }
        break;
      case TOK_TEMPLATE:
      handle_template:
        if (s->token.u.str.sep != '`') {
          /* '${' inside the template : closing '}' and continue
             parsing the template */
          if (level >= sizeof(state)) goto done;
          state[level++] = '`';
        }
        break;
      case TOK_EOF:
        goto done;
      case ';':
        if (level == 2) {
          bits |= SKIP_HAS_SEMI;
        }
        break;
      case TOK_ELLIPSIS:
        if (level == 2) {
          bits |= SKIP_HAS_ELLIPSIS;
        }
        break;
      case '=':
        bits |= SKIP_HAS_ASSIGNMENT;
        break;
      case TOK_DIV_ASSIGN:
      case '/':
        if (s->token.val == TOK_DIV_ASSIGN) {
          tok_len = 2;
        } else if (s->token.val == '/') {
          tok_len = 1;
        }
        if (is_regexp_allowed(last_tok)) {
          s->buf_ptr -= tok_len;
          if (lepus_parse_regexp(s)) {
            /* XXX: should clear the exception */
            goto done;
          }
        }
        break;
    }
    /* last_ok is only used to recognize regexps */
    if (s->token.val == TOK_IDENT &&
        (token_is_pseudo_keyword(s, LEPUS_ATOM_of) ||
         token_is_pseudo_keyword(s, LEPUS_ATOM_yield))) {
      last_tok = TOK_OF;
    } else {
      last_tok = s->token.val;
    }
    if (next_token(s)) {
      /* XXX: should clear the exception generated by next_token() */
      break;
    }
    if (level <= 1) {
      tok = s->token.val;
      if (token_is_pseudo_keyword(s, LEPUS_ATOM_of)) tok = TOK_OF;
      if (no_line_terminator && s->last_line_num != s->token.line_num)
        tok = '\n';
      break;
    }
  }
done:
  if (pbits) {
    *pbits = bits;
  }
  if (lepus_parse_seek_token(s, &pos)) return -1;
  return tok;
}

QJS_STATIC BOOL set_object_name(LEPUSParseState *s, LEPUSAtom name) {
  LEPUSFunctionDef *fd = s->cur_func;

  if (get_prev_opcode(fd) == OP_set_name) {
    /* XXX: should free atom after OP_set_name? */
    fd->byte_code.size = fd->last_opcode_pos;
    fd->last_opcode_pos = -1;
    emit_op(s, OP_set_name);
    emit_atom(s, name);
    return TRUE;
  }
  return FALSE;
}

QJS_STATIC void set_object_name_computed(LEPUSParseState *s) {
  LEPUSFunctionDef *fd = s->cur_func;

  if (get_prev_opcode(fd) == OP_set_name) {
    /* XXX: should free atom after OP_set_name? */
    fd->byte_code.size = fd->last_opcode_pos;
    fd->last_opcode_pos = -1;
    emit_op(s, OP_set_name_computed);
  }
}

QJS_STATIC __exception int lepus_parse_object_literal(LEPUSParseState *s) {
  LEPUSAtom name = LEPUS_ATOM_NULL;
  const uint8_t *start_ptr;
  int start_line, prop_type;
  BOOL has_proto;

  if (next_token(s)) goto fail;
  /* XXX: add an initial length that will be patched back */
  emit_op(s, OP_object);
  has_proto = FALSE;
  while (s->token.val != '}') {
    /* specific case for getter/setter */
    start_ptr = s->token.ptr;
    start_line = s->token.line_num;

    if (s->token.val == TOK_ELLIPSIS) {
      if (next_token(s)) return -1;
      if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
      emit_op(s, OP_null); /* dummy excludeList */
      emit_op(s, OP_copy_data_properties);
      emit_u8(s, 2 | (1 << 2) | (0 << 5));
      emit_op(s, OP_drop); /* pop excludeList */
      emit_op(s, OP_drop); /* pop src object */
      goto next;
    }

    prop_type = lepus_parse_property_name(s, &name, TRUE, TRUE, FALSE);
    if (prop_type < 0) goto fail;

    if (prop_type == PROP_TYPE_VAR) {
      /* shortcut for x: x */
      emit_op(s, OP_scope_get_var);
      emit_atom(s, name);
      emit_u16(s, s->cur_func->scope_level);
      emit_op(s, OP_define_field);
      emit_atom(s, name);
    } else if (s->token.val == '(') {
      BOOL is_getset =
          (prop_type == PROP_TYPE_GET || prop_type == PROP_TYPE_SET);
      LEPUSParseFunctionEnum func_type;
      LEPUSFunctionKindEnum func_kind;
      int op_flags;

      func_kind = LEPUS_FUNC_NORMAL;
      if (is_getset) {
        func_type = static_cast<LEPUSParseFunctionEnum>(
            LEPUS_PARSE_FUNC_GETTER + prop_type - PROP_TYPE_GET);
      } else {
        func_type = LEPUS_PARSE_FUNC_METHOD;
        if (prop_type == PROP_TYPE_STAR)
          func_kind = LEPUS_FUNC_GENERATOR;
        else if (prop_type == PROP_TYPE_ASYNC)
          func_kind = LEPUS_FUNC_ASYNC;
        else if (prop_type == PROP_TYPE_ASYNC_STAR)
          func_kind = LEPUS_FUNC_ASYNC_GENERATOR;
      }
      if (lepus_parse_function_decl(s, func_type, func_kind, LEPUS_ATOM_NULL,
                                    start_ptr, start_line))
        goto fail;
      if (name == LEPUS_ATOM_NULL) {
        emit_op(s, OP_define_method_computed);
      } else {
        emit_op(s, OP_define_method);
        emit_atom(s, name);
      }
      if (is_getset) {
        op_flags = OP_DEFINE_METHOD_GETTER + prop_type - PROP_TYPE_GET;
      } else {
        op_flags = OP_DEFINE_METHOD_METHOD;
      }
      emit_u8(s, op_flags | OP_DEFINE_METHOD_ENUMERABLE);
    } else {
      if (lepus_parse_expect(s, ':')) goto fail;
      if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) goto fail;
      if (name == LEPUS_ATOM_NULL) {
        set_object_name_computed(s);
        emit_op(s, OP_define_array_el);
        emit_op(s, OP_drop);
      } else if (name == LEPUS_ATOM___proto__) {
        if (has_proto) {
          lepus_parse_error(s, "duplicate __proto__ property name");
          goto fail;
        }
        emit_op(s, OP_set_proto);
        has_proto = TRUE;
      } else {
        set_object_name(s, name);
        emit_op(s, OP_define_field);
        emit_atom(s, name);
      }
    }
    LEPUS_FreeAtom(s->ctx, name);
  next:
    name = LEPUS_ATOM_NULL;
    if (s->token.val != ',') break;
    if (next_token(s)) goto fail;
  }
  if (lepus_parse_expect(s, '}')) goto fail;
  return 0;
fail:
  LEPUS_FreeAtom(s->ctx, name);
  return -1;
}

QJS_STATIC void optional_chain_test(LEPUSParseState *s,
                                    int *poptional_chaining_label,
                                    int drop_count) {
  int label_next_1, label_next_2, i;
  if (*poptional_chaining_label < 0) *poptional_chaining_label = new_label(s);
  /* XXX: could be more efficient with a specific opcode */
  emit_op(s, OP_dup);
  emit_op(s, OP_is_undefined);
  label_next_1 = emit_goto(s, OP_if_true, -1);

  emit_op(s, OP_dup);
  emit_op(s, OP_is_null);
  label_next_2 = emit_goto(s, OP_if_false, -1);

  emit_label(s, label_next_1);
  for (i = 0; i < drop_count; i++) emit_op(s, OP_drop);
  emit_op(s, OP_undefined);
  emit_goto(s, OP_goto, *poptional_chaining_label);
  emit_label(s, label_next_2);
}

QJS_STATIC __exception int lepus_parse_postfix_expr(LEPUSParseState *s,
                                                    int parse_flags);

QJS_STATIC __exception int lepus_parse_left_hand_side_expr(LEPUSParseState *s) {
  return lepus_parse_postfix_expr(s, PF_POSTFIX_CALL);
}

/* XXX: is there is nicer solution ? */
QJS_STATIC __exception int lepus_parse_class_default_ctor(
    LEPUSParseState *s, BOOL has_super, LEPUSFunctionDef **pfd) {
  LEPUSParsePos pos;
  const char *str;
  int ret, line_num;
  LEPUSParseFunctionEnum func_type;
  const uint8_t *saved_buf_end;

  lepus_parse_get_pos(s, &pos);
  if (has_super) {
    /* spec change: no argument evaluation */
    str = "(){super(...arguments);}";
    func_type = LEPUS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;
  } else {
    str = "(){}";
    func_type = LEPUS_PARSE_FUNC_CLASS_CONSTRUCTOR;
  }
  line_num = s->token.line_num;
  saved_buf_end = s->buf_end;
  s->buf_ptr = (uint8_t *)str;
  s->buf_end = (uint8_t *)(str + strlen(str));
  ret = next_token(s);
  if (!ret) {
    ret = lepus_parse_function_decl2(s, func_type, LEPUS_FUNC_NORMAL,
                                     LEPUS_ATOM_NULL, (uint8_t *)str, line_num,
                                     LEPUS_PARSE_EXPORT_NONE, pfd);
  }
  s->buf_end = saved_buf_end;
  ret |= lepus_parse_seek_token(s, &pos);
  return ret;
}

/* find field in the current scope */
QJS_STATIC int find_private_class_field(LEPUSContext *ctx, LEPUSFunctionDef *fd,
                                        LEPUSAtom name, int scope_level) {
  int idx;
  idx = fd->scopes[scope_level].first;
  while (idx != -1) {
    if (fd->vars[idx].scope_level != scope_level) break;
    if (fd->vars[idx].var_name == name) return idx;
    idx = fd->vars[idx].scope_next;
  }
  return -1;
}

/* add field in the current scope */
QJS_STATIC int add_private_class_field(LEPUSParseState *s, LEPUSFunctionDef *fd,
                                       LEPUSAtom name,
                                       LEPUSVarKindEnum var_kind) {
  LEPUSContext *ctx = s->ctx;
  LEPUSVarDef *vd;
  int idx;

  idx = add_scope_var(ctx, fd, name, var_kind);
  if (idx < 0) return idx;
  vd = &fd->vars[idx];
  vd->is_lexical = 1;
  vd->is_const = 1;
  return idx;
}

/* initialize the class fields, called by the constructor. Note:
   super() can be called in an arrow function, so <this> and
   <class_fields_init> can be variable references */
QJS_STATIC void emit_class_field_init(LEPUSParseState *s) {
  int label_next;

  emit_op(s, OP_scope_get_var);
  emit_atom(s, LEPUS_ATOM_class_fields_init);
  emit_u16(s, s->cur_func->scope_level);

  /* no need to call the class field initializer if not defined */
  emit_op(s, OP_dup);
  label_next = emit_goto(s, OP_if_false, -1);

  emit_op(s, OP_scope_get_var);
  emit_atom(s, LEPUS_ATOM_this);
  emit_u16(s, 0);

  emit_op(s, OP_swap);

  emit_op(s, OP_call_method);
  emit_u16(s, 0);

  emit_label(s, label_next);
  emit_op(s, OP_drop);
}

/* build a private setter function name from the private getter name */
QJS_STATIC LEPUSAtom get_private_setter_name(LEPUSContext *ctx,
                                             LEPUSAtom name) {
  return lepus_atom_concat_str(ctx, name, "<set>");
}

typedef struct {
  LEPUSFunctionDef *fields_init_fd;
  int computed_fields_count;
  BOOL has_brand;
  int brand_push_pos;
} ClassFieldsDef;

QJS_STATIC __exception int emit_class_init_start(LEPUSParseState *s,
                                                 ClassFieldsDef *cf) {
  int label_add_brand;

  cf->fields_init_fd = lepus_parse_function_class_fields_init(s);
  if (!cf->fields_init_fd) return -1;

  s->cur_func = cf->fields_init_fd;

  /* XXX: would be better to add the code only if needed, maybe in a
     later pass */
  emit_op(s, OP_push_false); /* will be patched later */
  cf->brand_push_pos = cf->fields_init_fd->last_opcode_pos;
  label_add_brand = emit_goto(s, OP_if_false, -1);

  emit_op(s, OP_scope_get_var);
  emit_atom(s, LEPUS_ATOM_this);
  emit_u16(s, 0);

  emit_op(s, OP_scope_get_var);
  emit_atom(s, LEPUS_ATOM_home_object);
  emit_u16(s, 0);

  emit_op(s, OP_add_brand);

  emit_label(s, label_add_brand);

  s->cur_func = s->cur_func->parent;
  return 0;
}

QJS_STATIC __exception int add_brand(LEPUSParseState *s, ClassFieldsDef *cf) {
  if (!cf->has_brand) {
    /* define the brand field in 'this' of the initializer */
    if (!cf->fields_init_fd) {
      if (emit_class_init_start(s, cf)) return -1;
    }
    /* patch the start of the function to enable the OP_add_brand code */
    cf->fields_init_fd->byte_code.buf[cf->brand_push_pos] = OP_push_true;

    cf->has_brand = TRUE;
  }
  return 0;
}

QJS_STATIC void emit_class_init_end(LEPUSParseState *s, ClassFieldsDef *cf) {
  int cpool_idx;

  s->cur_func = cf->fields_init_fd;
  emit_op(s, OP_return_undef);
  s->cur_func = s->cur_func->parent;

  cpool_idx = cpool_add(s, LEPUS_NULL);
  cf->fields_init_fd->parent_cpool_idx = cpool_idx;
  emit_op(s, OP_fclosure);
  emit_u32(s, cpool_idx);
  emit_op(s, OP_set_home_object);
}

QJS_STATIC __exception int lepus_parse_class(LEPUSParseState *s,
                                             BOOL is_class_expr,
                                             LEPUSParseExportEnum export_flag) {
  LEPUSContext *ctx = s->ctx;
  LEPUSFunctionDef *fd = s->cur_func;
  LEPUSAtom name = LEPUS_ATOM_NULL, class_name = LEPUS_ATOM_NULL, class_name1;
  LEPUSAtom class_var_name = LEPUS_ATOM_NULL;
  LEPUSFunctionDef *method_fd, *ctor_fd;
  int saved_js_mode, class_name_var_idx, prop_type, ctor_cpool_offset;
  int class_flags = 0, i;
  BOOL is_static, is_private;
  const uint8_t *class_start_ptr = s->token.ptr;
  const uint8_t *start_ptr;
  ClassFieldsDef class_fields[2];

  /* classes are parsed and executed in strict mode */
  saved_js_mode = fd->lepus_mode;
  fd->lepus_mode |= LEPUS_MODE_STRICT;
  if (next_token(s)) goto fail;
  if (s->token.val == TOK_IDENT) {
    if (s->token.u.ident.is_reserved) {
      lepus_parse_error_reserved_identifier(s);
      goto fail;
    }
    class_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
    if (next_token(s)) goto fail;
  } else if (!is_class_expr && export_flag != LEPUS_PARSE_EXPORT_DEFAULT) {
    lepus_parse_error(s, "class statement requires a name");
    goto fail;
  }
  if (!is_class_expr) {
    if (class_name == LEPUS_ATOM_NULL)
      class_var_name = LEPUS_ATOM__default_; /* export default */
    else
      class_var_name = class_name;
    class_var_name = LEPUS_DupAtom(ctx, class_var_name);
  }

  push_scope(s);

  if (s->token.val == TOK_EXTENDS) {
    class_flags = LEPUS_DEFINE_CLASS_HAS_HERITAGE;
    if (next_token(s)) goto fail;
    /* XXX: the grammar only allows LeftHandSideExpression */
    if (lepus_parse_left_hand_side_expr(s)) goto fail;
  } else {
    emit_op(s, OP_undefined);
  }

  /* add a 'const' definition for the class name */
  if (class_name != LEPUS_ATOM_NULL) {
    class_name_var_idx = define_var(s, fd, class_name, LEPUS_VAR_DEF_CONST);
    if (class_name_var_idx < 0) goto fail;
  }

  if (lepus_parse_expect(s, '{')) goto fail;

  /* this scope contains the private fields */
  push_scope(s);

  emit_op(s, OP_push_const);
  ctor_cpool_offset = fd->byte_code.size;
  emit_u32(s, 0); /* will be patched at the end of the class parsing */

  if (class_var_name != LEPUS_ATOM_NULL && class_name == LEPUS_ATOM_NULL)
    class_name1 = LEPUS_ATOM_default;
  else
    class_name1 = class_name;

  emit_op(s, OP_define_class);
  emit_atom(s, class_name1);
  emit_u8(s, class_flags);

  for (i = 0; i < 2; i++) {
    ClassFieldsDef *cf = &class_fields[i];
    cf->fields_init_fd = NULL;
    cf->computed_fields_count = 0;
    cf->has_brand = FALSE;
  }

  ctor_fd = NULL;
  while (s->token.val != '}') {
    if (s->token.val == ';') {
      if (next_token(s)) goto fail;
      continue;
    }
    is_static = (s->token.val == TOK_STATIC);
    prop_type = -1;
    if (is_static) {
      if (next_token(s)) goto fail;
      /* allow "static" field name */
      if (s->token.val == ';' || s->token.val == '=') {
        is_static = FALSE;
        name = LEPUS_DupAtom(ctx, LEPUS_ATOM_static);
        prop_type = PROP_TYPE_IDENT;
      }
    }
    if (is_static) emit_op(s, OP_swap);
    start_ptr = s->token.ptr;
    if (prop_type < 0) {
      prop_type = lepus_parse_property_name(s, &name, TRUE, FALSE, TRUE);
      if (prop_type < 0) goto fail;
    }
    is_private = prop_type & PROP_TYPE_PRIVATE;
    prop_type &= ~PROP_TYPE_PRIVATE;

    if ((name == LEPUS_ATOM_constructor && !is_static &&
         prop_type != PROP_TYPE_IDENT) ||
        (name == LEPUS_ATOM_prototype && is_static) ||
        name == LEPUS_ATOM_hash_constructor) {
      lepus_parse_error(s, "invalid method name");
      goto fail;
    }
    if (prop_type == PROP_TYPE_GET || prop_type == PROP_TYPE_SET) {
      BOOL is_set = prop_type - PROP_TYPE_GET;
      LEPUSFunctionDef *method_fd;

      if (is_private) {
        int idx, var_kind;
        idx = find_private_class_field(ctx, fd, name, fd->scope_level);
        if (idx >= 0) {
          var_kind = fd->vars[idx].var_kind;
          if (var_kind == LEPUS_VAR_PRIVATE_FIELD ||
              var_kind == LEPUS_VAR_PRIVATE_METHOD ||
              var_kind == LEPUS_VAR_PRIVATE_GETTER_SETTER ||
              var_kind == (LEPUS_VAR_PRIVATE_GETTER + is_set)) {
            goto private_field_already_defined;
          }
          fd->vars[idx].var_kind = LEPUS_VAR_PRIVATE_GETTER_SETTER;
        } else {
          if (add_private_class_field(s, fd, name,
                                      static_cast<LEPUSVarKindEnum>(
                                          LEPUS_VAR_PRIVATE_GETTER + is_set)) <
              0)
            goto fail;
        }
        if (add_brand(s, &class_fields[is_static]) < 0) goto fail;
      }

      if (lepus_parse_function_decl2(s,
                                     static_cast<LEPUSParseFunctionEnum>(
                                         LEPUS_PARSE_FUNC_GETTER + is_set),
                                     LEPUS_FUNC_NORMAL, LEPUS_ATOM_NULL,
                                     start_ptr, s->token.line_num,
                                     LEPUS_PARSE_EXPORT_NONE, &method_fd))
        goto fail;
      if (is_private) {
        method_fd->need_home_object = TRUE; /* needed for brand check */
        emit_op(s, OP_set_home_object);
        /* XXX: missing function name */
        emit_op(s, OP_scope_put_var_init);
        if (is_set) {
          LEPUSAtom setter_name;
          int ret;

          setter_name = get_private_setter_name(ctx, name);
          if (setter_name == LEPUS_ATOM_NULL) goto fail;
          emit_atom(s, setter_name);
          ret = add_private_class_field(s, fd, setter_name,
                                        LEPUS_VAR_PRIVATE_SETTER);
          LEPUS_FreeAtom(ctx, setter_name);
          if (ret < 0) goto fail;
        } else {
          emit_atom(s, name);
        }
        emit_u16(s, s->cur_func->scope_level);
      } else {
        if (name == LEPUS_ATOM_NULL) {
          emit_op(s, OP_define_method_computed);
        } else {
          emit_op(s, OP_define_method);
          emit_atom(s, name);
        }
        emit_u8(s, OP_DEFINE_METHOD_GETTER + is_set);
      }
    } else if (prop_type == PROP_TYPE_IDENT && s->token.val != '(') {
      ClassFieldsDef *cf = &class_fields[is_static];
      LEPUSAtom field_var_name = LEPUS_ATOM_NULL;

      /* class field */

      /* XXX: spec: not consistent with method name checks */
      if (name == LEPUS_ATOM_constructor || name == LEPUS_ATOM_prototype) {
        lepus_parse_error(s, "invalid field name");
        goto fail;
      }

      if (is_private) {
        if (find_private_class_field(ctx, fd, name, fd->scope_level) >= 0) {
          goto private_field_already_defined;
        }
        if (add_private_class_field(s, fd, name, LEPUS_VAR_PRIVATE_FIELD) < 0)
          goto fail;
        emit_op(s, OP_private_symbol);
        emit_atom(s, name);
        emit_op(s, OP_scope_put_var_init);
        emit_atom(s, name);
        emit_u16(s, s->cur_func->scope_level);
      }

      if (!cf->fields_init_fd) {
        if (emit_class_init_start(s, cf)) goto fail;
      }
      if (name == LEPUS_ATOM_NULL) {
        /* save the computed field name into a variable */
        field_var_name =
            lepus_atom_concat_num(ctx, LEPUS_ATOM_computed_field + is_static,
                                  cf->computed_fields_count);
        if (field_var_name == LEPUS_ATOM_NULL) goto fail;
        if (define_var(s, fd, field_var_name, LEPUS_VAR_DEF_CONST) < 0) {
          LEPUS_FreeAtom(ctx, field_var_name);
          goto fail;
        }
        emit_op(s, OP_to_propkey);
        emit_op(s, OP_scope_put_var_init);
        emit_atom(s, field_var_name);
        emit_u16(s, s->cur_func->scope_level);
      }
      s->cur_func = cf->fields_init_fd;
      emit_op(s, OP_scope_get_var);
      emit_atom(s, LEPUS_ATOM_this);
      emit_u16(s, 0);

      if (name == LEPUS_ATOM_NULL) {
        emit_op(s, OP_scope_get_var);
        emit_atom(s, field_var_name);
        emit_u16(s, s->cur_func->scope_level);
        cf->computed_fields_count++;
        LEPUS_FreeAtom(ctx, field_var_name);
      } else if (is_private) {
        emit_op(s, OP_scope_get_var);
        emit_atom(s, name);
        emit_u16(s, s->cur_func->scope_level);
      }

      if (s->token.val == '=') {
        if (next_token(s)) goto fail;
        if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) goto fail;
      } else {
        emit_op(s, OP_undefined);
      }
      if (is_private) {
        set_object_name_computed(s);
        emit_op(s, OP_define_private_field);
      } else if (name == LEPUS_ATOM_NULL) {
        set_object_name_computed(s);
        emit_op(s, OP_define_array_el);
        emit_op(s, OP_drop);
      } else {
        set_object_name(s, name);
        emit_op(s, OP_define_field);
        emit_atom(s, name);
      }
      s->cur_func = s->cur_func->parent;
      if (lepus_parse_expect_semi(s)) goto fail;
    } else {
      LEPUSParseFunctionEnum func_type;
      LEPUSFunctionKindEnum func_kind;

      func_type = LEPUS_PARSE_FUNC_METHOD;
      func_kind = LEPUS_FUNC_NORMAL;
      if (prop_type == PROP_TYPE_STAR) {
        func_kind = LEPUS_FUNC_GENERATOR;
      } else if (prop_type == PROP_TYPE_ASYNC) {
        func_kind = LEPUS_FUNC_ASYNC;
      } else if (prop_type == PROP_TYPE_ASYNC_STAR) {
        func_kind = LEPUS_FUNC_ASYNC_GENERATOR;
      } else if (name == LEPUS_ATOM_constructor && !is_static) {
        if (ctor_fd) {
          lepus_parse_error(s, "property constructor appears more than once");
          goto fail;
        }
        if (class_flags & LEPUS_DEFINE_CLASS_HAS_HERITAGE)
          func_type = LEPUS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR;
        else
          func_type = LEPUS_PARSE_FUNC_CLASS_CONSTRUCTOR;
      }
      if (is_private) {
        if (add_brand(s, &class_fields[is_static]) < 0) goto fail;
      }
      if (lepus_parse_function_decl2(s, func_type, func_kind, LEPUS_ATOM_NULL,
                                     start_ptr, s->token.line_num,
                                     LEPUS_PARSE_EXPORT_NONE, &method_fd))
        goto fail;
      if (func_type == LEPUS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR ||
          func_type == LEPUS_PARSE_FUNC_CLASS_CONSTRUCTOR) {
        ctor_fd = method_fd;
      } else if (is_private) {
        method_fd->need_home_object = TRUE; /* needed for brand check */
        if (find_private_class_field(ctx, fd, name, fd->scope_level) >= 0) {
        private_field_already_defined:
          lepus_parse_error(s, "private class field is already defined");
          goto fail;
        }
        if (add_private_class_field(s, fd, name, LEPUS_VAR_PRIVATE_METHOD) < 0)
          goto fail;
        emit_op(s, OP_set_home_object);
        emit_op(s, OP_set_name);
        emit_atom(s, name);
        emit_op(s, OP_scope_put_var_init);
        emit_atom(s, name);
        emit_u16(s, s->cur_func->scope_level);
      } else {
        if (name == LEPUS_ATOM_NULL) {
          emit_op(s, OP_define_method_computed);
        } else {
          emit_op(s, OP_define_method);
          emit_atom(s, name);
        }
        emit_u8(s, OP_DEFINE_METHOD_METHOD);
      }
    }
    if (is_static) emit_op(s, OP_swap);
    LEPUS_FreeAtom(ctx, name);
    name = LEPUS_ATOM_NULL;
  }

  if (s->token.val != '}') {
    lepus_parse_error(s, "expecting '%c'", '}');
    goto fail;
  }

  if (!ctor_fd) {
    if (lepus_parse_class_default_ctor(
            s, class_flags & LEPUS_DEFINE_CLASS_HAS_HERITAGE, &ctor_fd))
      goto fail;
  }
  /* patch the constant pool index for the constructor */
  put_u32(fd->byte_code.buf + ctor_cpool_offset, ctor_fd->parent_cpool_idx);

  /* store the class source code in the constructor. */
  if (!(fd->lepus_mode & LEPUS_MODE_STRIP)) {
    lepus_free(ctx, ctor_fd->source);
    ctor_fd->source_len = s->buf_ptr - class_start_ptr;
    ctor_fd->source =
        lepus_strndup(ctx, (const char *)class_start_ptr, ctor_fd->source_len);
    if (!ctor_fd->source) goto fail;
  }

  /* consume the '}' */
  if (next_token(s)) goto fail;

  /* store the function to initialize the fields to that it can be
     referenced by the constructor */
  {
    ClassFieldsDef *cf = &class_fields[0];
    int var_idx;

    var_idx =
        define_var(s, fd, LEPUS_ATOM_class_fields_init, LEPUS_VAR_DEF_CONST);
    if (var_idx < 0) goto fail;
    if (cf->fields_init_fd) {
      emit_class_init_end(s, cf);
    } else {
      emit_op(s, OP_undefined);
    }
    emit_op(s, OP_scope_put_var_init);
    emit_atom(s, LEPUS_ATOM_class_fields_init);
    emit_u16(s, s->cur_func->scope_level);
  }

  /* drop the prototype */
  emit_op(s, OP_drop);

  /* initialize the static fields */
  if (class_fields[1].fields_init_fd != NULL) {
    ClassFieldsDef *cf = &class_fields[1];
    emit_op(s, OP_dup);
    emit_class_init_end(s, cf);
    emit_op(s, OP_call_method);
    emit_u16(s, 0);
    emit_op(s, OP_drop);
  }

  if (class_name != LEPUS_ATOM_NULL) {
    /* store the class name in the scoped class name variable (it
       is independent from the class statement variable
       definition) */
    emit_op(s, OP_dup);
    emit_op(s, OP_scope_put_var_init);
    emit_atom(s, class_name);
    emit_u16(s, fd->scope_level);
  }
  pop_scope(s);
  pop_scope(s);

  /* the class statements have a block level scope */
  if (class_var_name != LEPUS_ATOM_NULL) {
    if (define_var(s, fd, class_var_name, LEPUS_VAR_DEF_LET) < 0) goto fail;
    emit_op(s, OP_scope_put_var_init);
    emit_atom(s, class_var_name);
    emit_u16(s, fd->scope_level);
  } else {
    if (class_name == LEPUS_ATOM_NULL) {
      /* XXX: should be done before calling the initializers. It
         could be done with a specific opcode to patch the code
         before */
      emit_op(s, OP_set_name);
      emit_atom(s, class_name); /* will be patched by assignment */
    }
  }

  if (export_flag != LEPUS_PARSE_EXPORT_NONE) {
    if (!add_export_entry(s, fd->module, class_var_name,
                          export_flag == LEPUS_PARSE_EXPORT_NAMED
                              ? class_var_name
                              : LEPUS_ATOM_default,
                          LEPUS_EXPORT_TYPE_LOCAL))
      goto fail;
  }

  LEPUS_FreeAtom(ctx, class_name);
  LEPUS_FreeAtom(ctx, class_var_name);
  fd->lepus_mode = saved_js_mode;
  return 0;
fail:
  LEPUS_FreeAtom(ctx, name);
  LEPUS_FreeAtom(ctx, class_name);
  LEPUS_FreeAtom(ctx, class_var_name);
  fd->lepus_mode = saved_js_mode;
  return -1;
}

QJS_STATIC __exception int lepus_parse_array_literal(LEPUSParseState *s) {
  uint32_t idx;
  BOOL need_length;

  if (next_token(s)) return -1;
  /* small regular arrays are created on the stack */
  idx = 0;
  while (s->token.val != ']' && idx < 32) {
    if (s->token.val == ',' || s->token.val == TOK_ELLIPSIS) break;
    if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
    idx++;
    /* accept trailing comma */
    if (s->token.val == ',') {
      if (next_token(s)) return -1;
    } else if (s->token.val != ']')
      goto done;
  }
  emit_op(s, OP_array_from);
  emit_u16(s, idx);

  /* larger arrays and holes are handled with explicit indices */
  need_length = FALSE;
  while (s->token.val != ']' && idx < 0x7fffffff) {
    if (s->token.val == TOK_ELLIPSIS) break;
    need_length = TRUE;
    if (s->token.val != ',') {
      if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
      emit_op(s, OP_define_field);
      emit_u32(s, __JS_AtomFromUInt32(idx));
      need_length = FALSE;
    }
    idx++;
    /* accept trailing comma */
    if (s->token.val == ',') {
      if (next_token(s)) return -1;
    }
  }
  if (s->token.val == ']') {
    if (need_length) {
      /* Set the length: Cannot use OP_define_field because
         length is not configurable */
      emit_op(s, OP_dup);
      emit_op(s, OP_push_i32);
      emit_u32(s, idx);
      emit_op(s, OP_put_field);
      emit_atom(s, LEPUS_ATOM_length);
      emit_type_set_feedback(s);
    }
    goto done;
  }

  /* huge arrays and spread elements require a dynamic index on the stack */
  emit_op(s, OP_push_i32);
  emit_u32(s, idx);

  /* stack has array, index */
  while (s->token.val != ']') {
    if (s->token.val == TOK_ELLIPSIS) {
      if (next_token(s)) return -1;
      if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
#if 1
      emit_op(s, OP_append);
#else
      int label_next, label_done;
      label_next = new_label(s);
      label_done = new_label(s);
      /* enumerate object */
      emit_op(s, OP_for_of_start);
      emit_op(s, OP_rot5l);
      emit_op(s, OP_rot5l);
      emit_label(s, label_next);
      /* on stack: enum_rec array idx */
      emit_op(s, OP_for_of_next);
      emit_u8(s, 2);
      emit_goto(s, OP_if_true, label_done);
      /* append element */
      /* enum_rec array idx val -> enum_rec array new_idx */
      emit_op(s, OP_define_array_el);
      emit_op(s, OP_inc);
      emit_goto(s, OP_goto, label_next);
      emit_label(s, label_done);
      /* close enumeration */
      emit_op(s, OP_drop); /* drop undef val */
      emit_op(s, OP_nip1); /* drop enum_rec */
      emit_op(s, OP_nip1);
      emit_op(s, OP_nip1);
#endif
    } else {
      need_length = TRUE;
      if (s->token.val != ',') {
        if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
        /* a idx val */
        emit_op(s, OP_define_array_el);
        need_length = FALSE;
      }
      emit_op(s, OP_inc);
    }
    if (s->token.val != ',') break;
    if (next_token(s)) return -1;
  }
  if (need_length) {
    /* Set the length: cannot use OP_define_field because
       length is not configurable */
    emit_op(s, OP_dup1); /* array length - array array length */
    emit_op(s, OP_put_field);
    emit_atom(s, LEPUS_ATOM_length);
    emit_type_set_feedback(s);
  } else {
    emit_op(s, OP_drop); /* array length - array */
  }
done:
  return lepus_parse_expect(s, ']');
}

/* XXX: remove */
QJS_STATIC BOOL has_with_scope(LEPUSFunctionDef *s, int scope_level) {
  /* check if scope chain contains a with statement */
  while (s) {
    int scope_idx = s->scopes[scope_level].first;
    while (scope_idx >= 0) {
      LEPUSVarDef *vd = &s->vars[scope_idx];

      if (vd->var_name == LEPUS_ATOM__with_) return TRUE;
      scope_idx = vd->scope_next;
    }
    /* check parent scopes */
    scope_level = s->parent_scope_level;
    s = s->parent;
  }
  return FALSE;
}

typedef struct LEPUSLValue {
  int opcode;
  int scope;
  int label;
  int depth;
  int tok;
  LEPUSAtom name;
} LEPUSLValue;

QJS_STATIC __exception int get_lvalue(LEPUSParseState *s, int *popcode,
                                      int *pscope, LEPUSAtom *pname,
                                      int *plabel, int *pdepth, BOOL keep,
                                      int tok) {
  LEPUSFunctionDef *fd;
  int opcode, scope, label, depth;
  LEPUSAtom name;

  /* we check the last opcode to get the lvalue type */
  fd = s->cur_func;
  scope = 0;
  name = LEPUS_ATOM_NULL;
  label = -1;
  depth = 0;
  switch (opcode = get_prev_opcode(fd)) {
    case OP_scope_get_var:
      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
      if ((name == LEPUS_ATOM_arguments || name == LEPUS_ATOM_eval) &&
          (fd->lepus_mode & LEPUS_MODE_STRICT)) {
        return lepus_parse_error(s, "invalid lvalue in strict mode");
      }
      if (name == LEPUS_ATOM_this || name == LEPUS_ATOM_new_target)
        goto invalid_lvalue;
      depth = 2; /* will generate OP_get_ref_value */
      break;
    case OP_get_field:
      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      depth = 1;
      break;
    case OP_scope_get_private_field:
      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
      depth = 1;
      break;
    case OP_get_array_el:
      depth = 2;
      break;
    case OP_get_super_value:
      depth = 3;
      break;
    default:
    invalid_lvalue:
      if (tok == TOK_FOR) {
        return lepus_parse_error(s, "invalid for in/of left hand-side");
      } else if (tok == TOK_INC || tok == TOK_DEC) {
        return lepus_parse_error(s, "invalid increment/decrement operand");
      } else if (tok == '[' || tok == '{') {
        return lepus_parse_error(s, "invalid destructuring target");
      } else {
        return lepus_parse_error(s, "invalid assignment left-hand side");
      }
  }
  /* remove the last opcode */
  fd->byte_code.size = fd->last_opcode_pos;
  fd->last_opcode_pos = -1;

  if (keep) {
    /* get the value but keep the object/fields on the stack */
    switch (opcode) {
      case OP_scope_get_var:
        label = new_label(s);
        emit_op(s, OP_scope_make_ref);
        emit_atom(s, name);
        emit_u32(s, label);
        emit_u16(s, scope);
        update_label(fd, label, 1);
        emit_op(s, OP_get_ref_value);
        opcode = OP_get_ref_value;
        break;
      case OP_get_field:
        emit_op(s, OP_get_field2);
        emit_atom(s, name);
        emit_type_get_feedback(s);
        break;
      case OP_scope_get_private_field:
        emit_op(s, OP_scope_get_private_field2);
        emit_atom(s, name);
        emit_u16(s, scope);
        break;
      case OP_get_array_el:
        /* XXX: replace by a single opcode ? */
        emit_op(s, OP_to_propkey2);
        emit_op(s, OP_dup2);
        emit_op(s, OP_get_array_el);
        break;
      case OP_get_super_value:
        emit_op(s, OP_to_propkey);
        emit_op(s, OP_dup3);
        emit_op(s, OP_get_super_value);
        break;
      default:
        abort();
    }
  } else {
    switch (opcode) {
      case OP_scope_get_var:
        label = new_label(s);
        emit_op(s, OP_scope_make_ref);
        emit_atom(s, name);
        emit_u32(s, label);
        emit_u16(s, scope);
        update_label(fd, label, 1);
        opcode = OP_get_ref_value;
        break;
      case OP_get_array_el:
        emit_op(s, OP_to_propkey2);
        break;
      case OP_get_super_value:
        emit_op(s, OP_to_propkey);
        break;
    }
  }

  *popcode = opcode;
  *pscope = scope;
  /* name has refcount for OP_get_field and OP_get_ref_value,
     and LEPUS_ATOM_NULL for other opcodes */
  *pname = name;
  *plabel = label;
  if (pdepth) *pdepth = depth;
  return 0;
}

typedef enum {
  PUT_LVALUE_NOKEEP,        /* [depth] v -> */
  PUT_LVALUE_NOKEEP_DEPTH,  /* [depth] v -> , keep depth (currently
                               just disable optimizations) */
  PUT_LVALUE_KEEP_TOP,      /* [depth] v -> v */
  PUT_LVALUE_KEEP_SECOND,   /* [depth] v0 v -> v0 */
  PUT_LVALUE_NOKEEP_BOTTOM, /* v [depth] -> */
} PutLValueEnum;

/* name has a live reference. 'is_let' is only used with opcode =
   OP_scope_get_var which is never generated by get_lvalue(). */
QJS_STATIC void put_lvalue(LEPUSParseState *s, int opcode, int scope,
                           LEPUSAtom name, int label, PutLValueEnum special,
                           BOOL is_let) {
  switch (opcode) {
    case OP_get_field:
    case OP_scope_get_private_field:
      /* depth = 1 */
      switch (special) {
        case PUT_LVALUE_NOKEEP:
        case PUT_LVALUE_NOKEEP_DEPTH:
          break;
        case PUT_LVALUE_KEEP_TOP:
          emit_op(s, OP_insert2); /* obj v -> v obj v */
          break;
        case PUT_LVALUE_KEEP_SECOND:
          emit_op(s, OP_perm3); /* obj v0 v -> v0 obj v */
          break;
        case PUT_LVALUE_NOKEEP_BOTTOM:
          emit_op(s, OP_swap);
          break;
        default:
          abort();
      }
      break;
    case OP_get_array_el:
    case OP_get_ref_value:
      /* depth = 2 */
      if (opcode == OP_get_ref_value) {
        LEPUS_FreeAtom(s->ctx, name);
        emit_label(s, label);
      }
      switch (special) {
        case PUT_LVALUE_NOKEEP:
          emit_op(s, OP_nop); /* will trigger optimization */
          break;
        case PUT_LVALUE_NOKEEP_DEPTH:
          break;
        case PUT_LVALUE_KEEP_TOP:
          emit_op(s, OP_insert3); /* obj prop v -> v obj prop v */
          break;
        case PUT_LVALUE_KEEP_SECOND:
          emit_op(s, OP_perm4); /* obj prop v0 v -> v0 obj prop v */
          break;
        case PUT_LVALUE_NOKEEP_BOTTOM:
          emit_op(s, OP_rot3l);
          break;
        default:
          abort();
      }
      break;
    case OP_get_super_value:
      /* depth = 3 */
      switch (special) {
        case PUT_LVALUE_NOKEEP:
        case PUT_LVALUE_NOKEEP_DEPTH:
          break;
        case PUT_LVALUE_KEEP_TOP:
          emit_op(s, OP_insert4); /* this obj prop v -> v this obj prop v */
          break;
        case PUT_LVALUE_KEEP_SECOND:
          emit_op(s, OP_perm5); /* this obj prop v0 v -> v0 this obj prop v */
          break;
        case PUT_LVALUE_NOKEEP_BOTTOM:
          emit_op(s, OP_rot4l);
          break;
        default:
          abort();
      }
      break;
    default:
      break;
  }

  switch (opcode) {
    case OP_scope_get_var: /* val -- */
      assert(special == PUT_LVALUE_NOKEEP ||
             special == PUT_LVALUE_NOKEEP_DEPTH);
      emit_op(s, is_let ? OP_scope_put_var_init : OP_scope_put_var);
      emit_u32(s, name); /* has refcount */
      emit_u16(s, scope);
      break;
    case OP_get_field:
      emit_op(s, OP_put_field);
      emit_u32(s, name); /* name has refcount */
      emit_type_set_feedback(s);
      break;
    case OP_scope_get_private_field:
      emit_op(s, OP_scope_put_private_field);
      emit_u32(s, name); /* name has refcount */
      emit_u16(s, scope);
      break;
    case OP_get_array_el:
      emit_op(s, OP_put_array_el);
      break;
    case OP_get_ref_value:
      emit_op(s, OP_put_ref_value);
      break;
    case OP_get_super_value:
      emit_op(s, OP_put_super_value);
      break;
    default:
      abort();
  }
}

QJS_STATIC __exception int lepus_parse_expr_paren(LEPUSParseState *s) {
  if (lepus_parse_expect(s, '(')) return -1;
  if (lepus_parse_expr(s)) return -1;
  if (lepus_parse_expect(s, ')')) return -1;
  return 0;
}

QJS_STATIC int lepus_unsupported_keyword(LEPUSParseState *s, LEPUSAtom atom) {
  char buf[ATOM_GET_STR_BUF_SIZE];
  return lepus_parse_error(s, "unsupported keyword: %s",
                           LEPUS_AtomGetStr(s->ctx, buf, sizeof(buf), atom));
}

QJS_STATIC __exception int lepus_define_var(LEPUSParseState *s, LEPUSAtom name,
                                            int tok) {
  LEPUSFunctionDef *fd = s->cur_func;

  if (name == LEPUS_ATOM_yield && fd->func_kind == LEPUS_FUNC_GENERATOR) {
    return lepus_parse_error(s, "yield is a reserved identifier");
  }
  if ((name == LEPUS_ATOM_arguments || name == LEPUS_ATOM_eval) &&
      (fd->lepus_mode & LEPUS_MODE_STRICT)) {
    return lepus_parse_error(s, "invalid variable name in strict mode");
  }
  if ((name == LEPUS_ATOM_let || name == LEPUS_ATOM_undefined) &&
      (tok == TOK_LET || tok == TOK_CONST)) {
    return lepus_parse_error(s, "invalid lexical variable name");
  }
  LEPUSVarDefEnum var_def_type;
  switch (tok) {
    case TOK_LET:
      var_def_type = LEPUS_VAR_DEF_LET;
      break;
    case TOK_CONST:
      var_def_type = LEPUS_VAR_DEF_CONST;
      break;
    case TOK_VAR:
      var_def_type = LEPUS_VAR_DEF_VAR;
      break;
    case TOK_CATCH:
      var_def_type = LEPUS_VAR_DEF_CATCH;
      break;
    default:
      abort();
  }
  if (define_var(s, fd, name, var_def_type) < 0) return -1;
  return 0;
}

QJS_STATIC void lepus_emit_spread_code(LEPUSParseState *s, int depth) {
  int label_rest_next, label_rest_done;

  /* XXX: could check if enum object is an actual array and optimize
     slice extraction. enumeration record and target array are in a
     different order from OP_append case. */
  /* enum_rec xxx -- enum_rec xxx array 0 */
  emit_op(s, OP_array_from);
  emit_u16(s, 0);
  emit_op(s, OP_push_i32);
  emit_u32(s, 0);
  emit_label(s, label_rest_next = new_label(s));
  emit_op(s, OP_for_of_next);
  emit_u8(s, 2 + depth);
  label_rest_done = emit_goto(s, OP_if_true, -1);
  /* array idx val -- array idx */
  emit_op(s, OP_define_array_el);
  emit_op(s, OP_inc);
  emit_goto(s, OP_goto, label_rest_next);
  emit_label(s, label_rest_done);
  /* enum_rec xxx array idx undef -- enum_rec xxx array */
  emit_op(s, OP_drop);
  emit_op(s, OP_drop);
}

QJS_STATIC int lepus_parse_check_duplicate_parameter(LEPUSParseState *s,
                                                     LEPUSAtom name) {
  /* Check for duplicate parameter names */
  LEPUSFunctionDef *fd = s->cur_func;
  int i;
  for (i = 0; i < fd->arg_count; i++) {
    if (fd->args[i].var_name == name) goto duplicate;
  }
  for (i = 0; i < fd->var_count; i++) {
    if (fd->vars[i].var_name == name) goto duplicate;
  }
  return 0;

duplicate:
  return lepus_parse_error(
      s, "duplicate parameter names not allowed in this context");
}

QJS_STATIC LEPUSAtom lepus_parse_destructing_var(LEPUSParseState *s, int tok,
                                                 int is_arg) {
  LEPUSAtom name;

  if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved) ||
      ((s->cur_func->lepus_mode & LEPUS_MODE_STRICT) &&
       (s->token.u.ident.atom == LEPUS_ATOM_eval ||
        s->token.u.ident.atom == LEPUS_ATOM_arguments))) {
    lepus_parse_error(s, "invalid destructuring target");
    return LEPUS_ATOM_NULL;
  }
  name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
  if (is_arg && lepus_parse_check_duplicate_parameter(s, name)) goto fail;
  if (next_token(s)) goto fail;

  return name;
fail:
  LEPUS_FreeAtom(s->ctx, name);
  return LEPUS_ATOM_NULL;
}

/* Return -1 if error, 0 if no initializer, 1 if an initializer is
   present at the top level. */
QJS_STATIC int lepus_parse_destructing_element(LEPUSParseState *s, int tok,
                                               int is_arg, int hasval,
                                               int has_ellipsis,
                                               BOOL allow_initializer) {
  int label_parse, label_assign, label_done, label_lvalue, depth_lvalue;
  int start_addr, assign_addr;
  LEPUSAtom prop_name, var_name;
  int opcode, scope, tok1, skip_bits;
  BOOL has_initializer;

  if (has_ellipsis < 0) {
    /* pre-parse destructuration target for spread detection */
    lepus_parse_skip_parens_token(s, &skip_bits, FALSE);
    has_ellipsis = skip_bits & SKIP_HAS_ELLIPSIS;
  }

  label_parse = new_label(s);
  label_assign = new_label(s);

  start_addr = s->cur_func->byte_code.size;
  if (hasval) {
    /* consume value from the stack */
    emit_op(s, OP_dup);
    emit_op(s, OP_undefined);
    emit_op(s, OP_strict_eq);
    emit_goto(s, OP_if_true, label_parse);
    emit_label(s, label_assign);
  } else {
    emit_goto(s, OP_goto, label_parse);
    emit_label(s, label_assign);
    /* leave value on the stack */
    emit_op(s, OP_dup);
  }
  assign_addr = s->cur_func->byte_code.size;
  if (s->token.val == '{') {
    if (next_token(s)) return -1;
    /* throw an exception if the value cannot be converted to an object */
    emit_op(s, OP_to_object);
    if (has_ellipsis) {
      /* add excludeList on stack just below src object */
      emit_op(s, OP_object);
      emit_op(s, OP_swap);
    }
    while (s->token.val != '}') {
      int prop_type;
      if (s->token.val == TOK_ELLIPSIS) {
        if (!has_ellipsis) {
          LEPUS_ThrowInternalError(s->ctx, "unexpected ellipsis token");
          return -1;
        }
        if (next_token(s)) return -1;
        if (tok) {
          var_name = lepus_parse_destructing_var(s, tok, is_arg);
          if (var_name == LEPUS_ATOM_NULL) return -1;
          opcode = OP_scope_get_var;
          scope = s->cur_func->scope_level;
          label_lvalue = -1;
          depth_lvalue = 0;
        } else {
          if (lepus_parse_left_hand_side_expr(s)) return -1;

          if (get_lvalue(s, &opcode, &scope, &var_name, &label_lvalue,
                         &depth_lvalue, FALSE, '{'))
            return -1;
        }
        if (s->token.val != '}') {
          lepus_parse_error(s, "assignment rest property must be last");
          goto var_error;
        }
        emit_op(s, OP_object); /* target */
        emit_op(s, OP_copy_data_properties);
        emit_u8(s, 0 | ((depth_lvalue + 1) << 2) | ((depth_lvalue + 2) << 5));
        goto set_val;
      }
      prop_type = lepus_parse_property_name(s, &prop_name, FALSE, TRUE, FALSE);
      if (prop_type < 0) return -1;
      var_name = LEPUS_ATOM_NULL;
      opcode = OP_scope_get_var;
      scope = s->cur_func->scope_level;
      label_lvalue = -1;
      depth_lvalue = 0;
      if (prop_type == PROP_TYPE_IDENT) {
        if (next_token(s)) goto prop_error;
        if ((s->token.val == '[' || s->token.val == '{') &&
            ((tok1 = lepus_parse_skip_parens_token(s, &skip_bits, FALSE)) ==
                 ',' ||
             tok1 == '=' || tok1 == '}')) {
          if (prop_name == LEPUS_ATOM_NULL) {
            /* computed property name on stack */
            if (has_ellipsis) {
              /* define the property in excludeList */
              emit_op(s, OP_to_propkey); /* avoid calling ToString twice */
              emit_op(s, OP_perm3);      /* TOS: src excludeList prop */
              emit_op(s, OP_null);       /* TOS: src excludeList prop null */
              emit_op(s, OP_define_array_el); /* TOS: src excludeList prop */
              emit_op(s, OP_perm3);           /* TOS: excludeList src prop */
            }
            /* get the computed property from the source object */
            emit_op(s, OP_get_array_el2);
          } else {
            /* named property */
            if (has_ellipsis) {
              /* define the property in excludeList */
              emit_op(s, OP_swap);         /* TOS: src excludeList */
              emit_op(s, OP_null);         /* TOS: src excludeList null */
              emit_op(s, OP_define_field); /* TOS: src excludeList */
              emit_atom(s, prop_name);
              emit_op(s, OP_swap); /* TOS: excludeList src */
            }
            /* get the named property from the source object */
            emit_op(s, OP_get_field2);
            emit_u32(s, prop_name);
            emit_type_get_feedback(s);
          }
          if (lepus_parse_destructing_element(s, tok, is_arg, TRUE, -1, TRUE) <
              0)
            return -1;
          if (s->token.val == '}') break;
          /* accept a trailing comma before the '}' */
          if (lepus_parse_expect(s, ',')) return -1;
          continue;
        }
        if (prop_name == LEPUS_ATOM_NULL) {
          emit_op(s, OP_to_propkey2);
          if (has_ellipsis) {
            /* define the property in excludeList */
            emit_op(s, OP_perm3);
            emit_op(s, OP_null);
            emit_op(s, OP_define_array_el);
            emit_op(s, OP_perm3);
          }
          /* source prop -- source source prop */
          emit_op(s, OP_dup1);
        } else {
          if (has_ellipsis) {
            /* define the property in excludeList */
            emit_op(s, OP_swap);
            emit_op(s, OP_null);
            emit_op(s, OP_define_field);
            emit_atom(s, prop_name);
            emit_op(s, OP_swap);
          }
          /* source -- source source */
          emit_op(s, OP_dup);
        }
        if (tok) {
          var_name = lepus_parse_destructing_var(s, tok, is_arg);
          if (var_name == LEPUS_ATOM_NULL) goto prop_error;
        } else {
          if (lepus_parse_left_hand_side_expr(s)) goto prop_error;
        lvalue:
          if (get_lvalue(s, &opcode, &scope, &var_name, &label_lvalue,
                         &depth_lvalue, FALSE, '{'))
            goto prop_error;
          /* swap ref and lvalue object if any */
          if (prop_name == LEPUS_ATOM_NULL) {
            switch (depth_lvalue) {
              case 1:
                /* source prop x -> x source prop */
                emit_op(s, OP_rot3r);
                break;
              case 2:
                /* source prop x y -> x y source prop */
                emit_op(s, OP_swap2); /* t p2 s p1 */
                break;
              case 3:
                /* source prop x y z -> x y z source prop */
                emit_op(s, OP_rot5l);
                emit_op(s, OP_rot5l);
                break;
            }
          } else {
            switch (depth_lvalue) {
              case 1:
                /* source x -> x source */
                emit_op(s, OP_swap);
                break;
              case 2:
                /* source x y -> x y source */
                emit_op(s, OP_rot3l);
                break;
              case 3:
                /* source x y z -> x y z source */
                emit_op(s, OP_rot4l);
                break;
            }
          }
        }
        if (prop_name == LEPUS_ATOM_NULL) {
          /* computed property name on stack */
          /* XXX: should have OP_get_array_el2x with depth */
          /* source prop -- val */
          emit_op(s, OP_get_array_el);
        } else {
          /* named property */
          /* XXX: should have OP_get_field2x with depth */
          /* source -- val */
          emit_op(s, OP_get_field);
          emit_u32(s, prop_name);
          emit_type_get_feedback(s);
        }
      } else {
        /* prop_type = PROP_TYPE_VAR, cannot be a computed property */
        if (is_arg && lepus_parse_check_duplicate_parameter(s, prop_name))
          goto prop_error;
        if ((s->cur_func->lepus_mode & LEPUS_MODE_STRICT) &&
            (prop_name == LEPUS_ATOM_eval ||
             prop_name == LEPUS_ATOM_arguments)) {
          lepus_parse_error(s, "invalid destructuring target");
          goto prop_error;
        }
        if (has_ellipsis) {
          /* define the property in excludeList */
          emit_op(s, OP_swap);
          emit_op(s, OP_null);
          emit_op(s, OP_define_field);
          emit_atom(s, prop_name);
          emit_op(s, OP_swap);
        }
        if (!tok || tok == TOK_VAR) {
          /* generate reference */
          /* source -- source source */
          emit_op(s, OP_dup);
          emit_op(s, OP_scope_get_var);
          emit_atom(s, prop_name);
          emit_u16(s, s->cur_func->scope_level);
          goto lvalue;
        }
        var_name = LEPUS_DupAtom(s->ctx, prop_name);
        /* source -- source val */
        emit_op(s, OP_get_field2);
        emit_u32(s, prop_name);
        emit_type_get_feedback(s);
      }
    set_val:
      if (tok) {
        if (lepus_define_var(s, var_name, tok)) goto var_error;
        scope = s->cur_func->scope_level;
      }
      if (s->token.val == '=') { /* handle optional default value */
        int label_hasval;
        emit_op(s, OP_dup);
        emit_op(s, OP_undefined);
        emit_op(s, OP_strict_eq);
        label_hasval = emit_goto(s, OP_if_false, -1);
        if (next_token(s)) goto var_error;
        emit_op(s, OP_drop);
        if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) goto var_error;
        if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)
          set_object_name(s, var_name);
        emit_label(s, label_hasval);
      }
      /* store value into lvalue object */
      put_lvalue(s, opcode, scope, var_name, label_lvalue,
                 PUT_LVALUE_NOKEEP_DEPTH, (tok == TOK_CONST || tok == TOK_LET));
      if (s->token.val == '}') break;
      /* accept a trailing comma before the '}' */
      if (lepus_parse_expect(s, ',')) return -1;
    }
    /* drop the source object */
    emit_op(s, OP_drop);
    if (has_ellipsis) {
      emit_op(s, OP_drop); /* pop excludeList */
    }
    if (next_token(s)) return -1;
  } else if (s->token.val == '[') {
    BOOL has_spread;
    int enum_depth;
    BlockEnv block_env;

    if (next_token(s)) return -1;
    /* the block environment is only needed in generators in case
       'yield' triggers a 'return' */
    push_break_entry(s->cur_func, &block_env, LEPUS_ATOM_NULL, -1, -1, 2);
    block_env.has_iterator = TRUE;
    emit_op(s, OP_for_of_start);
    has_spread = FALSE;
    while (s->token.val != ']') {
      /* get the next value */
      if (s->token.val == TOK_ELLIPSIS) {
        if (next_token(s)) return -1;
        if (s->token.val == ',' || s->token.val == ']')
          return lepus_parse_error(s, "missing binding pattern...");
        has_spread = TRUE;
      }
      if (s->token.val == ',') {
        /* do nothing, skip the value, has_spread is false */
        emit_op(s, OP_for_of_next);
        emit_u8(s, 0);
        emit_op(s, OP_drop);
        emit_op(s, OP_drop);
      } else if ((s->token.val == '[' || s->token.val == '{') &&
                 ((tok1 = lepus_parse_skip_parens_token(s, &skip_bits,
                                                        FALSE)) == ',' ||
                  tok1 == '=' || tok1 == ']')) {
        if (has_spread) {
          if (tok1 == '=')
            return lepus_parse_error(
                s, "rest element cannot have a default value");
          lepus_emit_spread_code(s, 0);
        } else {
          emit_op(s, OP_for_of_next);
          emit_u8(s, 0);
          emit_op(s, OP_drop);
        }
        if (lepus_parse_destructing_element(
                s, tok, is_arg, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
          return -1;
      } else {
        var_name = LEPUS_ATOM_NULL;
        enum_depth = 0;
        if (tok) {
          var_name = lepus_parse_destructing_var(s, tok, is_arg);
          if (var_name == LEPUS_ATOM_NULL) goto var_error;
          if (lepus_define_var(s, var_name, tok)) goto var_error;
          opcode = OP_scope_get_var;
          scope = s->cur_func->scope_level;
        } else {
          if (lepus_parse_left_hand_side_expr(s)) return -1;
          if (get_lvalue(s, &opcode, &scope, &var_name, &label_lvalue,
                         &enum_depth, FALSE, '[')) {
            return -1;
          }
        }
        if (has_spread) {
          lepus_emit_spread_code(s, enum_depth);
        } else {
          emit_op(s, OP_for_of_next);
          emit_u8(s, enum_depth);
          emit_op(s, OP_drop);
        }
        if (s->token.val == '=' && !has_spread) {
          /* handle optional default value */
          int label_hasval;
          emit_op(s, OP_dup);
          emit_op(s, OP_undefined);
          emit_op(s, OP_strict_eq);
          label_hasval = emit_goto(s, OP_if_false, -1);
          if (next_token(s)) goto var_error;
          emit_op(s, OP_drop);
          if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) goto var_error;
          if (opcode == OP_scope_get_var || opcode == OP_get_ref_value)
            set_object_name(s, var_name);
          emit_label(s, label_hasval);
        }
        /* store value into lvalue object */
        put_lvalue(s, opcode, scope, var_name, label_lvalue,
                   PUT_LVALUE_NOKEEP_DEPTH,
                   (tok == TOK_CONST || tok == TOK_LET));
      }
      if (s->token.val == ']') break;
      if (has_spread)
        return lepus_parse_error(s, "rest element must be the last one");
      /* accept a trailing comma before the ']' */
      if (lepus_parse_expect(s, ',')) return -1;
    }
    /* close iterator object:
       if completed, enum_obj has been replaced by undefined */
    emit_op(s, OP_iterator_close);
    pop_break_entry(s->cur_func);
    if (next_token(s)) return -1;
  } else {
    return lepus_parse_error(s, "invalid assignment syntax");
  }
  if (s->token.val == '=' && allow_initializer) {
    label_done = emit_goto(s, OP_goto, -1);
    if (next_token(s)) return -1;
    emit_label(s, label_parse);
    if (hasval) emit_op(s, OP_drop);
    if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
    emit_goto(s, OP_goto, label_assign);
    emit_label(s, label_done);
    has_initializer = TRUE;
  } else {
    /* normally hasval is true except if
      lepus_parse_skip_parens_token() was wrong in the parsing */
    //        assert(hasval);
    if (!hasval) {
      lepus_parse_error(s, "too complicated destructuring expression");
      return -1;
    }
    /* remove test and decrement label ref count */
    memset(s->cur_func->byte_code.buf + start_addr, OP_nop,
           assign_addr - start_addr);
    s->cur_func->label_slots[label_parse].ref_count--;
    has_initializer = FALSE;
  }
  return has_initializer;

prop_error:
  LEPUS_FreeAtom(s->ctx, prop_name);
var_error:
  LEPUS_FreeAtom(s->ctx, var_name);
  return -1;
}

typedef enum FuncCallType {
  FUNC_CALL_NORMAL,
  FUNC_CALL_NEW,
  FUNC_CALL_SUPER_CTOR,
  FUNC_CALL_TEMPLATE,
} FuncCallType;

/* allowed parse_flags: PF_POSTFIX_CALL, PF_ARROW_FUNC */
QJS_STATIC __exception int lepus_parse_postfix_expr(LEPUSParseState *s,
                                                    int parse_flags) {
  FuncCallType call_type;
  int optional_chaining_label;
  BOOL accept_lparen = (parse_flags & PF_POSTFIX_CALL) != 0;

  call_type = FUNC_CALL_NORMAL;
  switch (s->token.val) {
    case TOK_NUMBER: {
      LEPUSValue val;
      val = s->token.u.num.val;

      if (LEPUS_VALUE_IS_INT(val)) {
        emit_op(s, OP_push_i32);
        emit_u32(s, LEPUS_VALUE_GET_INT(val));
      } else
#ifdef CONFIG_BIGNUM
          if (LEPUS_VALUE_GET_TAG(val) == LEPUS_TAG_BIG_FLOAT) {
        bf_t r_s, *r = &r_s;
        slimb_t e;
        int ret;

        /* need a runtime conversion */
        /* XXX: could add a cache and/or do it once at
           the start of the function */
        if (emit_push_const(s, val, 0) < 0) return -1;
        e = s->token.u.num.exponent;
        if (e == (int32_t)e) {
          emit_op(s, OP_push_i32);
          emit_u32(s, e);
        } else {
          bf_init(s->ctx->bf_ctx, r);
          bf_set_si(r, e);
          val = LEPUS_NewBigInt(s->ctx, r);
          ret = emit_push_const(s, val, 0);
          LEPUS_FreeValue(s->ctx, val);
          if (ret < 0) return -1;
        }
        emit_op(s, OP_mul_pow10);
      } else
#endif
      {
        if (emit_push_const(s, val, 0) < 0) return -1;
      }
    }
      if (next_token(s)) return -1;
      break;
    case TOK_TEMPLATE:
      if (lepus_parse_template(s, 0, NULL)) return -1;
      break;
    case TOK_STRING:
      if (emit_push_const(s, s->token.u.str.str, 1)) return -1;
      if (next_token(s)) return -1;
      break;

    case TOK_DIV_ASSIGN:
      s->buf_ptr -= 2;
      goto parse_regexp;
    case '/':
      s->buf_ptr--;
    parse_regexp : {
      LEPUSValue str;
      int ret;
      if (!s->ctx->compile_regexp)
        return lepus_parse_error(s, "RegExp are not supported");
      /* the previous token is '/' or '/=', so no need to free */
      if (lepus_parse_regexp(s)) return -1;
      ret = emit_push_const(s, s->token.u.regexp.body, 0);
      str = s->ctx->compile_regexp(s->ctx, s->token.u.regexp.body,
                                   s->token.u.regexp.flags);
      if (LEPUS_IsException(str)) {
        /* add the line number info */
        build_backtrace(s->ctx, s->ctx->rt->current_exception, s->filename,
                        s->token.line_num, NULL, 0);
        return -1;
      }
      ret = emit_push_const(s, str, 0);
      LEPUS_FreeValue(s->ctx, str);
      if (ret) return -1;
      /* we use a specific opcode to be sure the correct
         function is called (otherwise the bytecode would have
         to be verified by the RegExp constructor) */
      emit_op(s, OP_regexp);
      if (next_token(s)) return -1;
    } break;
    case '(':
      if ((parse_flags & PF_ARROW_FUNC) &&
          lepus_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) {
        if (lepus_parse_function_decl(s, LEPUS_PARSE_FUNC_ARROW,
                                      LEPUS_FUNC_NORMAL, LEPUS_ATOM_NULL,
                                      s->token.ptr, s->token.line_num))
          return -1;
      } else {
        if (lepus_parse_expr_paren(s)) return -1;
      }
      break;
    case TOK_FUNCTION:
      if (lepus_parse_function_decl(s, LEPUS_PARSE_FUNC_EXPR, LEPUS_FUNC_NORMAL,
                                    LEPUS_ATOM_NULL, s->token.ptr,
                                    s->token.line_num))
        return -1;
      break;
    case TOK_CLASS:
      if (lepus_parse_class(s, TRUE, LEPUS_PARSE_EXPORT_NONE)) return -1;
      break;
    case TOK_NULL:
      if (next_token(s)) return -1;
      emit_op(s, OP_null);
      break;
    case TOK_THIS:
      if (next_token(s)) return -1;
      emit_op(s, OP_scope_get_var);
      emit_atom(s, LEPUS_ATOM_this);
      emit_u16(s, 0);
      break;
    case TOK_FALSE:
      if (next_token(s)) return -1;
      emit_op(s, OP_push_false);
      break;
    case TOK_TRUE:
      if (next_token(s)) return -1;
      emit_op(s, OP_push_true);
      break;
    case TOK_IDENT: {
      LEPUSAtom name;
      if (s->token.u.ident.is_reserved) {
        return lepus_parse_error_reserved_identifier(s);
      }
      if ((parse_flags & PF_ARROW_FUNC) && peek_token(s, TRUE) == TOK_ARROW) {
        if (lepus_parse_function_decl(s, LEPUS_PARSE_FUNC_ARROW,
                                      LEPUS_FUNC_NORMAL, LEPUS_ATOM_NULL,
                                      s->token.ptr, s->token.line_num))
          return -1;
      } else if (token_is_pseudo_keyword(s, LEPUS_ATOM_async) &&
                 peek_token(s, TRUE) != '\n') {
        const uint8_t *source_ptr;
        int source_line_num;

        source_ptr = s->token.ptr;
        source_line_num = s->token.line_num;
        if (next_token(s)) return -1;
        if (s->token.val == TOK_FUNCTION) {
          if (lepus_parse_function_decl(s, LEPUS_PARSE_FUNC_EXPR,
                                        LEPUS_FUNC_ASYNC, LEPUS_ATOM_NULL,
                                        source_ptr, source_line_num))
            return -1;
        } else if ((parse_flags & PF_ARROW_FUNC) &&
                   ((s->token.val == '(' && lepus_parse_skip_parens_token(
                                                s, NULL, TRUE) == TOK_ARROW) ||
                    (s->token.val == TOK_IDENT &&
                     !s->token.u.ident.is_reserved &&
                     peek_token(s, TRUE) == TOK_ARROW))) {
          if (lepus_parse_function_decl(s, LEPUS_PARSE_FUNC_ARROW,
                                        LEPUS_FUNC_ASYNC, LEPUS_ATOM_NULL,
                                        source_ptr, source_line_num))
            return -1;
        } else {
          name = LEPUS_DupAtom(s->ctx, LEPUS_ATOM_async);
          goto do_get_var;
        }
      } else {
        if (s->token.u.ident.atom == LEPUS_ATOM_arguments &&
            !s->cur_func->arguments_allowed) {
          lepus_parse_error(
              s,
              "'arguments' identifier is not allowed in class field "
              "initializer");
          return -1;
        }
        name = LEPUS_DupAtom(s->ctx, s->token.u.ident.atom);
        if (next_token(s)) /* update line number before emitting code */
          return -1;
      do_get_var:
        emit_op(s, OP_scope_get_var);
        emit_u32(s, name);
        emit_u16(s, s->cur_func->scope_level);
      }
    } break;
    case '{':
    case '[': {
      int skip_bits;
      if (lepus_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {
        if (lepus_parse_destructing_element(
                s, 0, 0, FALSE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
          return -1;
      } else {
        if (s->token.val == '{') {
          if (lepus_parse_object_literal(s)) return -1;
        } else {
          if (lepus_parse_array_literal(s)) return -1;
        }
      }
    } break;
    case TOK_NEW:
      if (next_token(s)) return -1;
      if (s->token.val == '.') {
        if (next_token(s)) return -1;
        if (!token_is_pseudo_keyword(s, LEPUS_ATOM_target))
          return lepus_parse_error(s, "expecting target");
        if (!s->cur_func->new_target_allowed)
          return lepus_parse_error(s,
                                   "new.target only allowed within functions");
        if (next_token(s)) return -1;
        emit_op(s, OP_scope_get_var);
        emit_atom(s, LEPUS_ATOM_new_target);
        emit_u16(s, 0);
      } else {
        if (lepus_parse_postfix_expr(s, FALSE)) return -1;
        accept_lparen = TRUE;
        if (s->token.val != '(') {
          /* new operator on an object */
          emit_op(s, OP_dup);
          emit_op(s, OP_call_constructor);
          emit_u16(s, 0);
        } else {
          call_type = FUNC_CALL_NEW;
        }
      }
      break;
    case TOK_SUPER:
      if (next_token(s)) return -1;
      if (s->token.val == '(') {
        if (!s->cur_func->super_call_allowed)
          return lepus_parse_error(
              s, "super() is only valid in a derived class constructor");
        call_type = FUNC_CALL_SUPER_CTOR;
      } else if (s->token.val == '.' || s->token.val == '[') {
        if (!s->cur_func->super_allowed)
          return lepus_parse_error(s, "'super' is only valid in a method");
        emit_op(s, OP_scope_get_var);
        emit_atom(s, LEPUS_ATOM_this);
        emit_u16(s, 0);
        emit_op(s, OP_scope_get_var);
        emit_atom(s, LEPUS_ATOM_home_object);
        emit_u16(s, 0);
        emit_op(s, OP_get_super);
      } else {
        return lepus_parse_error(s, "invalid use of 'super'");
      }
      break;
    case TOK_IMPORT:
      if (!accept_lparen)
        return lepus_parse_error(s, "invalid use of 'import'");
      if (next_token(s)) return -1;
      if (lepus_parse_expect(s, '(')) return -1;
      if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
      if (lepus_parse_expect(s, ')')) return -1;
      emit_op(s, OP_import);
      break;
    default:
      return lepus_parse_error(s, "unexpected token in expression: '%.*s'",
                               (int)(s->buf_ptr - s->token.ptr), s->token.ptr);
  }

  optional_chaining_label = -1;
  for (;;) {
    LEPUSFunctionDef *fd = s->cur_func;
    BOOL has_optional_chain = FALSE;

    if (s->token.val == TOK_QUESTION_MARK_DOT) {
      /* optional chaining */
      if (next_token(s)) return -1;
      has_optional_chain = TRUE;
      if (s->token.val == '(' && accept_lparen) {
        goto parse_func_call;
      } else if (s->token.val == '[') {
        goto parse_array_access;
      } else {
        goto parse_property;
      }
    } else if (s->token.val == TOK_TEMPLATE && call_type == FUNC_CALL_NORMAL) {
      if (optional_chaining_label >= 0) {
        return lepus_parse_error(
            s, "template literal cannot appear in an optional chain");
      }
      call_type = FUNC_CALL_TEMPLATE;
      goto parse_func_call2;
    }
    if (s->token.val == '(' && accept_lparen) {
      int opcode;
      int arg_count;
      int drop_count;
      // <ByeDance begin>
      s->func_call_ptr = s->token.ptr;
      if (s->func_call_ptr < s->utf8_parse_front) {
        s->func_call_adapte_size =
            s->utf8_adapte_size - s->last_utf8_adapte_size;
      } else {
        s->func_call_adapte_size = s->utf8_adapte_size;
      }
      // <ByteDance end>

      /* function call */
    parse_func_call:
      if (next_token(s)) return -1;

      if (call_type == FUNC_CALL_NORMAL) {
      parse_func_call2:
        switch (opcode = get_prev_opcode(fd)) {
          case OP_get_field:
            /* keep the object on the stack */
            fd->byte_code.buf[fd->last_opcode_pos] = OP_get_field2;
            drop_count = 2;
            break;
          case OP_scope_get_private_field:
            /* keep the object on the stack */
            fd->byte_code.buf[fd->last_opcode_pos] =
                OP_scope_get_private_field2;
            drop_count = 2;
            break;
          case OP_get_array_el:
            /* keep the object on the stack */
            fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el2;
            drop_count = 2;
            break;
          case OP_scope_get_var: {
            LEPUSAtom name;
            int scope;
            name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
            scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
            if (name == LEPUS_ATOM_eval && call_type == FUNC_CALL_NORMAL &&
                !has_optional_chain) {
              /* direct 'eval' */
              LEPUS_FreeAtom(s->ctx, name);
              fd->byte_code.size = fd->last_opcode_pos;
              fd->last_opcode_pos = -1;
              opcode = OP_eval;
            } else {
              /* verify if function name resolves to a simple
                 get_loc/get_arg: a function call inside a `with`
                 statement can resolve to a method call of the
                 `with` context object
               */
              /* XXX: always generate the OP_scope_get_ref
                 and remove it in variable resolution
                 pass ? */
              if (has_with_scope(fd, scope)) {
                opcode = OP_scope_get_ref;
                fd->byte_code.buf[fd->last_opcode_pos] = opcode;
              }
            }
            drop_count = 1;
          } break;
          case OP_get_super_value:
            fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el;
            /* on stack: this func_obj */
            opcode = OP_get_array_el;
            drop_count = 2;
            break;
          default:
            opcode = OP_invalid;
            drop_count = 1;
            break;
        }
        if (has_optional_chain) {
          optional_chain_test(s, &optional_chaining_label, drop_count);
        }
      } else {
        opcode = OP_invalid;
      }

      if (call_type == FUNC_CALL_TEMPLATE) {
        if (lepus_parse_template(s, 1, &arg_count)) return -1;
        goto emit_func_call;
      } else if (call_type == FUNC_CALL_SUPER_CTOR) {
        emit_op(s, OP_scope_get_var);
        emit_atom(s, LEPUS_ATOM_this_active_func);
        emit_u16(s, 0);

        emit_op(s, OP_get_super_ctor);

        emit_op(s, OP_scope_get_var);
        emit_atom(s, LEPUS_ATOM_new_target);
        emit_u16(s, 0);
      } else if (call_type == FUNC_CALL_NEW) {
        emit_op(s, OP_dup); /* new.target = function */
      }

      /* parse arguments */
      arg_count = 0;
      while (s->token.val != ')') {
        if (arg_count >= 65535) {
          return lepus_parse_error(s, "Too many call arguments");
        }
        if (s->token.val == TOK_ELLIPSIS) break;
        if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
        arg_count++;
        if (s->token.val == ')') break;
        /* accept a trailing comma before the ')' */
        if (lepus_parse_expect(s, ',')) return -1;
      }
      if (s->token.val == TOK_ELLIPSIS) {
        emit_op(s, OP_array_from);
        emit_u16(s, arg_count);
        emit_op(s, OP_push_i32);
        emit_u32(s, arg_count);

        /* on stack: array idx */
        while (s->token.val != ')') {
          if (s->token.val == TOK_ELLIPSIS) {
            if (next_token(s)) return -1;
            if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
#if 1
            /* XXX: could pass is_last indicator? */
            emit_op(s, OP_append);
#else
            int label_next, label_done;
            label_next = new_label(s);
            label_done = new_label(s);
            /* push enumerate object below array/idx pair */
            emit_op(s, OP_for_of_start);
            emit_op(s, OP_rot5l);
            emit_op(s, OP_rot5l);
            emit_label(s, label_next);
            /* on stack: enum_rec array idx */
            emit_op(s, OP_for_of_next);
            emit_u8(s, 2);
            emit_goto(s, OP_if_true, label_done);
            /* append element */
            /* enum_rec array idx val -> enum_rec array new_idx */
            emit_op(s, OP_define_array_el);
            emit_op(s, OP_inc);
            emit_goto(s, OP_goto, label_next);
            emit_label(s, label_done);
            /* close enumeration, drop enum_rec and idx */
            emit_op(s, OP_drop); /* drop undef */
            emit_op(s, OP_nip1); /* drop enum_rec */
            emit_op(s, OP_nip1);
            emit_op(s, OP_nip1);
#endif
          } else {
            if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
            /* array idx val */
            emit_op(s, OP_define_array_el);
            emit_op(s, OP_inc);
          }
          if (s->token.val == ')') break;
          /* accept a trailing comma before the ')' */
          if (lepus_parse_expect(s, ',')) return -1;
        }
        if (next_token(s)) return -1;
        /* drop the index */
        emit_op(s, OP_drop);

        /* apply function call */
        switch (opcode) {
          case OP_get_field:
          case OP_scope_get_private_field:
          case OP_get_array_el:
          case OP_scope_get_ref:
            /* obj func array -> func obj array */
            emit_op(s, OP_perm3);
            emit_op(s, OP_apply);
            emit_u16(s, call_type == FUNC_CALL_NEW);
            break;
          case OP_eval:
            /* eval needs a single argument */
            emit_op(s, OP_get_field);
            emit_atom(s, __JS_AtomFromUInt32(0));
            emit_type_get_feedback(s);
            emit_op(s, OP_eval);
            emit_u16(s, fd->scope_level);
            fd->has_eval_call = TRUE;
            break;
          default:
            if (call_type == FUNC_CALL_SUPER_CTOR) {
              emit_op(s, OP_apply);
              emit_u16(s, 1);
              /* set the 'this' value */
              emit_op(s, OP_dup);
              emit_op(s, OP_scope_put_var_init);
              emit_atom(s, LEPUS_ATOM_this);
              emit_u16(s, 0);

              emit_class_field_init(s);
            } else if (call_type == FUNC_CALL_NEW) {
              /* obj func array -> func obj array */
              emit_op(s, OP_perm3);
              emit_op(s, OP_apply);
              emit_u16(s, 1);
            } else {
              /* func array -> func undef array */
              emit_op(s, OP_undefined);
              emit_op(s, OP_swap);
              emit_op(s, OP_apply);
              emit_u16(s, 0);
            }
            break;
        }
      } else {
        if (next_token(s)) return -1;
      emit_func_call:
        switch (opcode) {
          case OP_get_field:
          case OP_scope_get_private_field:
          case OP_get_array_el:
          case OP_scope_get_ref:
            emit_op(s, OP_call_method);
            emit_u16(s, arg_count);
            break;
          case OP_eval:
            /* eval needs a single argument */
            if (arg_count == 0) {
              /* no actual eval call is needed? */
              emit_op(s, OP_undefined);
            } else {
              int i;
              /* pop extra arguments. Contrary to ECMA spec,
                 browsers seem to evaluate extra arguments
                 to direct eval */
              for (i = 1; i < arg_count; i++) emit_op(s, OP_drop);
              emit_op(s, OP_eval);
              emit_u16(s, fd->scope_level);
              fd->has_eval_call = TRUE;
            }
            break;
          default:
            if (call_type == FUNC_CALL_SUPER_CTOR) {
              emit_op(s, OP_call_constructor);
              emit_u16(s, arg_count);

              /* set the 'this' value */
              emit_op(s, OP_dup);
              emit_op(s, OP_scope_put_var_init);
              emit_atom(s, LEPUS_ATOM_this);
              emit_u16(s, 0);

              emit_class_field_init(s);
            } else if (call_type == FUNC_CALL_NEW) {
              emit_op(s, OP_call_constructor);
              emit_u16(s, arg_count);
            } else {
              emit_op(s, OP_call);
              emit_u16(s, arg_count);
            }
            break;
        }
      }
      // <ByeDance begin>
      s->func_call_ptr = NULL;
      s->func_call_adapte_size = -1;
      // <ByteDance end>
      call_type = FUNC_CALL_NORMAL;
    } else if (s->token.val == '.') {
      if (next_token(s)) return -1;
    parse_property:
      if (s->token.val == TOK_PRIVATE_NAME) {
        /* private class field */
        if (get_prev_opcode(fd) == OP_get_super) {
          return lepus_parse_error(s,
                                   "private class field forbidden after super");
        }
        if (has_optional_chain) {
          optional_chain_test(s, &optional_chaining_label, 1);
        }
        emit_op(s, OP_scope_get_private_field);
        emit_atom(s, s->token.u.ident.atom);
        emit_u16(s, s->cur_func->scope_level);
      } else {
        if (!token_is_ident(s->token.val)) {
          return lepus_parse_error(s, "expecting field name");
        }
        if (get_prev_opcode(fd) == OP_get_super) {
          LEPUSValue val;
          int ret;
          val = LEPUS_AtomToValue(s->ctx, s->token.u.ident.atom);
          ret = emit_push_const(s, val, 1);
          LEPUS_FreeValue(s->ctx, val);
          if (ret) return -1;
          emit_op(s, OP_get_super_value);
        } else {
          if (has_optional_chain) {
            optional_chain_test(s, &optional_chaining_label, 1);
          }
          emit_op(s, OP_get_field);
          emit_atom(s, s->token.u.ident.atom);
          emit_type_get_feedback(s);
        }
      }
      if (next_token(s)) return -1;
    } else if (s->token.val == '[') {
      int prev_op;
    parse_array_access:
      prev_op = get_prev_opcode(fd);
      if (has_optional_chain) {
        optional_chain_test(s, &optional_chaining_label, 1);
      }
      if (next_token(s)) return -1;
      if (lepus_parse_expr(s)) return -1;
      if (lepus_parse_expect(s, ']')) return -1;
      if (prev_op == OP_get_super) {
        emit_op(s, OP_get_super_value);
      } else {
        emit_op(s, OP_get_array_el);
      }
    } else {
      break;
    }
  }
  if (optional_chaining_label >= 0) emit_label(s, optional_chaining_label);
  return 0;
}

QJS_STATIC __exception int lepus_parse_delete(LEPUSParseState *s) {
  LEPUSFunctionDef *fd = s->cur_func;
  LEPUSAtom name;
  int opcode;

  if (next_token(s)) return -1;
  if (lepus_parse_unary(s, -1)) return -1;
  switch (opcode = get_prev_opcode(fd)) {
    case OP_get_field: {
      LEPUSValue val;
      int ret;

      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      fd->byte_code.size = fd->last_opcode_pos;
      fd->last_opcode_pos = -1;
      val = LEPUS_AtomToValue(s->ctx, name);
      ret = emit_push_const(s, val, 1);
      LEPUS_FreeValue(s->ctx, val);
      LEPUS_FreeAtom(s->ctx, name);
      if (ret) return ret;
    }
      goto do_delete;
    case OP_get_array_el:
      fd->byte_code.size = fd->last_opcode_pos;
      fd->last_opcode_pos = -1;
    do_delete:
      emit_op(s, OP_delete);
      break;
    case OP_scope_get_var:
      /* 'delete this': this is not a reference */
      name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
      if (name == LEPUS_ATOM_this || name == LEPUS_ATOM_new_target)
        goto ret_true;
      if (fd->lepus_mode & LEPUS_MODE_STRICT) {
        return lepus_parse_error(
            s, "cannot delete a direct reference in strict mode");
      } else {
        fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_delete_var;
      }
      break;
    case OP_scope_get_private_field:
      return lepus_parse_error(s, "cannot delete a private class field");
    case OP_get_super_value:
      emit_op(s, OP_throw_var);
      emit_atom(s, LEPUS_ATOM_NULL);
      emit_u8(s, LEPUS_THROW_ERROR_DELETE_SUPER);
      break;
    default:
    ret_true:
      emit_op(s, OP_drop);
      emit_op(s, OP_push_true);
      break;
  }
  return 0;
}

/* allowed parse_flags: PF_ARROW_FUNC, PF_POW_ALLOWED, PF_POW_FORBIDDEN */
QJS_STATIC __exception int lepus_parse_unary(LEPUSParseState *s,
                                             int parse_flags) {
  int op;

  switch (s->token.val) {
    case '+':
    case '-':
    case '!':
    case '~':
    case TOK_VOID:
      op = s->token.val;
      if (next_token(s)) return -1;
      if (lepus_parse_unary(s, PF_POW_FORBIDDEN)) return -1;
      switch (op) {
        case '-':
          emit_op(s, OP_neg);
          break;
        case '+':
          emit_op(s, OP_plus);
          break;
        case '!':
          emit_op(s, OP_lnot);
          break;
        case '~':
          emit_op(s, OP_not);
          break;
        case TOK_VOID:
          emit_op(s, OP_drop);
          emit_op(s, OP_undefined);
          break;
        default:
          abort();
      }
      parse_flags = 0;
      break;
    case TOK_DEC:
    case TOK_INC: {
      int opcode, op, scope, label;
      LEPUSAtom name;
      op = s->token.val;
      if (next_token(s)) return -1;
      /* XXX: should parse LeftHandSideExpression */
      if (lepus_parse_unary(s, 0)) return -1;
      if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
        return -1;
      emit_op(s, OP_dec + op - TOK_DEC);
      put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP, FALSE);
    } break;
    case TOK_TYPEOF: {
      LEPUSFunctionDef *fd;
      if (next_token(s)) return -1;
      if (lepus_parse_unary(s, -1)) return -1;
      /* reference access should not return an exception, so we
         patch the get_var */
      fd = s->cur_func;
      if (get_prev_opcode(fd) == OP_scope_get_var) {
        fd->byte_code.buf[fd->last_opcode_pos] = OP_scope_get_var_undef;
      }
      emit_op(s, OP_typeof);
      parse_flags = 0;
    } break;
    case TOK_DELETE:
      if (lepus_parse_delete(s)) return -1;
      parse_flags = 0;
      break;
    case TOK_AWAIT:
      if (!(s->cur_func->func_kind & LEPUS_FUNC_ASYNC))
        return lepus_parse_error(s, "unexpected 'await' keyword");
      if (!s->cur_func->in_function_body)
        return lepus_parse_error(s, "await in default expression");
      if (next_token(s)) return -1;
      if (lepus_parse_unary(s, -1)) return -1;
      emit_op(s, OP_await);
      parse_flags = 0;
      break;
    default:
      if (lepus_parse_postfix_expr(
              s, (parse_flags & PF_ARROW_FUNC) | PF_POSTFIX_CALL))
        return -1;
      if (!s->got_lf && (s->token.val == TOK_DEC || s->token.val == TOK_INC)) {
        int opcode, op, scope, label;
        LEPUSAtom name;
        op = s->token.val;
        if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, TRUE, op))
          return -1;
        emit_op(s, OP_post_dec + op - TOK_DEC);
        put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_SECOND,
                   FALSE);
        if (next_token(s)) return -1;
      }
      break;
  }
  if (parse_flags & (PF_POW_ALLOWED | PF_POW_FORBIDDEN)) {
#ifdef CONFIG_BIGNUM
    if (s->token.val == TOK_POW || s->token.val == TOK_MATH_POW) {
      /* Extended exponentiation syntax rules: we extend the ES7
         grammar in order to have more intuitive semantics:
         -2**2 evaluates to -4. */
      if (!(s->cur_func->lepus_mode & LEPUS_MODE_MATH)) {
        if ((parse_flags & PF_POW_FORBIDDEN) < 0) {
          LEPUS_ThrowSyntaxError(
              s->ctx,
              "unparenthesized unary expression can't appear "
              "on the left-hand side of '**'");
          return -1;
        }
      }
      if (next_token(s)) return -1;
      if (lepus_parse_unary(s, PF_POW_ALLOWED)) return -1;
      if (s->cur_func->lepus_mode & LEPUS_MODE_MATH)
        emit_op(s, OP_math_pow);
      else
        emit_op(s, OP_pow);
    }
#else
    if (s->token.val == TOK_POW) {
      /* Strict ES7 exponentiation syntax rules: To solve
         conficting semantics between different implementations
         regarding the precedence of prefix operators and the
         postifx exponential, ES7 specifies that -2**2 is a
         syntax error. */
      if (parse_flags & PF_POW_FORBIDDEN) {
        LEPUS_ThrowSyntaxError(
            s->ctx,
            "unparenthesized unary expression can't appear on "
            "the left-hand side of '**'");
        return -1;
      }
      if (next_token(s)) return -1;
      if (lepus_parse_unary(s, PF_POW_ALLOWED)) return -1;
      emit_op(s, OP_pow);
    }
#endif
  }
  return 0;
}

/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
QJS_STATIC __exception int lepus_parse_expr_binary(LEPUSParseState *s,
                                                   int level, int parse_flags) {
  int op, opcode;

  if (level == 0) {
    return lepus_parse_unary(s, (parse_flags & PF_ARROW_FUNC) | PF_POW_ALLOWED);
  }
  if (lepus_parse_expr_binary(s, level - 1, parse_flags)) return -1;
  for (;;) {
    op = s->token.val;
    switch (level) {
      case 1:
        switch (op) {
          case '*':
            opcode = OP_mul;
            break;
          case '/':
#ifdef CONFIG_BIGNUM
            if (s->cur_func->lepus_mode & LEPUS_MODE_MATH)
              opcode = OP_math_div;
            else
#endif
              opcode = OP_div;
            break;
          case '%':
#ifdef CONFIG_BIGNUM
            if (s->cur_func->lepus_mode & LEPUS_MODE_MATH)
              opcode = OP_math_mod;
            else
#endif
              opcode = OP_mod;
            break;
          default:
            return 0;
        }
        break;
      case 2:
        switch (op) {
          case '+':
            opcode = OP_add;
            break;
          case '-':
            opcode = OP_sub;
            break;
          default:
            return 0;
        }
        break;
      case 3:
        switch (op) {
          case TOK_SHL:
            opcode = OP_shl;
            break;
          case TOK_SAR:
            opcode = OP_sar;
            break;
          case TOK_SHR:
            opcode = OP_shr;
            break;
          default:
            return 0;
        }
        break;
      case 4:
        switch (op) {
          case '<':
            opcode = OP_lt;
            break;
          case '>':
            opcode = OP_gt;
            break;
          case TOK_LTE:
            opcode = OP_lte;
            break;
          case TOK_GTE:
            opcode = OP_gte;
            break;
          case TOK_INSTANCEOF:
            opcode = OP_instanceof;
            break;
          case TOK_IN:
            if (parse_flags & PF_IN_ACCEPTED) {
              opcode = OP_in;
            } else {
              return 0;
            }
            break;
          default:
            return 0;
        }
        break;
      case 5:
        switch (op) {
          case TOK_EQ:
            opcode = OP_eq;
            break;
          case TOK_NEQ:
            opcode = OP_neq;
            break;
          case TOK_STRICT_EQ:
            opcode = OP_strict_eq;
            break;
          case TOK_STRICT_NEQ:
            opcode = OP_strict_neq;
            break;
          default:
            return 0;
        }
        break;
      case 6:
        switch (op) {
          case '&':
            opcode = OP_and;
            break;
          default:
            return 0;
        }
        break;
      case 7:
        switch (op) {
          case '^':
            opcode = OP_xor;
            break;
          default:
            return 0;
        }
        break;
      case 8:
        switch (op) {
          case '|':
            opcode = OP_or;
            break;
          default:
            return 0;
        }
        break;
      default:
        abort();
    }
    if (next_token(s)) return -1;
    if (lepus_parse_expr_binary(s, level - 1, parse_flags & ~PF_ARROW_FUNC))
      return -1;
    emit_op(s, opcode);
  }
  return 0;
}

/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
QJS_STATIC __exception int lepus_parse_logical_and_or(LEPUSParseState *s,
                                                      int op, int parse_flags) {
  int label1;

  if (op == TOK_LAND) {
    if (lepus_parse_expr_binary(s, 8, parse_flags)) return -1;
  } else {
    if (lepus_parse_logical_and_or(s, TOK_LAND, parse_flags)) return -1;
  }
  if (s->token.val == op) {
    label1 = new_label(s);

    for (;;) {
      if (next_token(s)) return -1;
      emit_op(s, OP_dup);
      emit_goto(s, op == TOK_LAND ? OP_if_false : OP_if_true, label1);
      emit_op(s, OP_drop);

      if (op == TOK_LAND) {
        if (lepus_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC))
          return -1;
      } else {
        if (lepus_parse_logical_and_or(s, TOK_LAND,
                                       parse_flags & ~PF_ARROW_FUNC))
          return -1;
      }
      if (s->token.val != op) {
        if (s->token.val == TOK_DOUBLE_QUESTION_MARK)
          return lepus_parse_error(s, "cannot mix ?? with && or ||");
        break;
      }
    }

    emit_label(s, label1);
  }
  return 0;
}

/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
QJS_STATIC __exception int lepus_parse_cond_expr(LEPUSParseState *s,
                                                 int parse_flags) {
  int label1, label2;

  if (lepus_parse_logical_and_or(s, TOK_LOR, parse_flags)) return -1;
  if (s->token.val == TOK_DOUBLE_QUESTION_MARK) {
    label1 = new_label(s);
    for (;;) {
      if (next_token(s)) return -1;

      emit_op(s, OP_dup);
      emit_op(s, OP_is_undefined);
      emit_goto(s, OP_if_false, label1);
      emit_op(s, OP_drop);

      if (lepus_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC))
        return -1;
      if (s->token.val != TOK_DOUBLE_QUESTION_MARK) break;
    }
    emit_label(s, label1);
  }
  if (s->token.val == '?') {
    if (next_token(s)) return -1;
    label1 = emit_goto(s, OP_if_false, -1);

    if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
    if (lepus_parse_expect(s, ':')) return -1;

    label2 = emit_goto(s, OP_goto, -1);

    emit_label(s, label1);

    if (lepus_parse_assign_expr(s, parse_flags & PF_IN_ACCEPTED)) return -1;

    emit_label(s, label2);
  }
  return 0;
}

QJS_STATIC void emit_return(LEPUSParseState *s, BOOL hasval);

/* allowed parse_flags: PF_IN_ACCEPTED */
QJS_STATIC __exception int lepus_parse_assign_expr(LEPUSParseState *s,
                                                   int parse_flags) {
  int opcode, op, scope;
  LEPUSAtom name0 = LEPUS_ATOM_NULL;
  LEPUSAtom name;

  if (s->token.val == TOK_YIELD) {
    BOOL is_star = FALSE;
    if (!(s->cur_func->func_kind & LEPUS_FUNC_GENERATOR))
      return lepus_parse_error(s, "unexpected 'yield' keyword");
    if (!s->cur_func->in_function_body)
      return lepus_parse_error(s, "yield in default expression");
    if (next_token(s)) return -1;
    /* XXX: is there a better method to detect 'yield' without
       parameters ? */
    if (s->token.val != ';' && s->token.val != ')' && s->token.val != ']' &&
        s->token.val != '}' && s->token.val != ',' && s->token.val != ':' &&
        !s->got_lf) {
      if (s->token.val == '*') {
        is_star = TRUE;
        if (next_token(s)) return -1;
      }
      if (lepus_parse_assign_expr(s, parse_flags)) return -1;
    } else {
      emit_op(s, OP_undefined);
    }
    if (s->cur_func->func_kind == LEPUS_FUNC_ASYNC_GENERATOR) {
      int label_loop, label_return, label_next;
      int label_return1, label_yield, label_throw, label_throw1;
      int label_throw2;

      if (is_star) {
        label_loop = new_label(s);
        label_yield = new_label(s);

        emit_op(s, OP_for_await_of_start);

        /* remove the catch offset (XXX: could avoid pushing back
           undefined) */
        emit_op(s, OP_drop);
        emit_op(s, OP_undefined);

        emit_op(s, OP_undefined); /* initial value */

        emit_label(s, label_loop);
        emit_op(s, OP_async_iterator_next);
        emit_op(s, OP_await);
        emit_op(s, OP_iterator_get_value_done);
        label_next = emit_goto(s, OP_if_true, -1); /* end of loop */
        emit_op(s, OP_await);
        emit_label(s, label_yield);
        emit_op(s, OP_async_yield_star);
        emit_op(s, OP_dup);
        label_return = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_drop);
        emit_goto(s, OP_goto, label_loop);

        emit_label(s, label_return);
        emit_op(s, OP_push_i32);
        emit_u32(s, 2);
        emit_op(s, OP_strict_eq);
        label_throw = emit_goto(s, OP_if_true, -1);

        /* return handling */
        emit_op(s, OP_await);
        emit_op(s, OP_async_iterator_get);
        emit_u8(s, 0);
        label_return1 = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_await);
        emit_op(s, OP_iterator_get_value_done);
        /* XXX: the spec does not indicate that an await should be
           performed in case done = true, but the tests assume it */
        emit_goto(s, OP_if_false, label_yield);

        emit_label(s, label_return1);
        emit_op(s, OP_nip);
        emit_op(s, OP_nip);
        emit_op(s, OP_nip);
        emit_return(s, TRUE);

        /* throw handling */
        emit_label(s, label_throw);
        emit_op(s, OP_async_iterator_get);
        emit_u8(s, 1);
        label_throw1 = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_await);
        emit_op(s, OP_iterator_get_value_done);
        emit_goto(s, OP_if_false, label_yield);
        /* XXX: the spec does not indicate that an await should be
           performed in case done = true, but the tests assume it */
        emit_op(s, OP_await);
        emit_goto(s, OP_goto, label_next);
        /* close the iterator and throw a type error exception */
        emit_label(s, label_throw1);
        emit_op(s, OP_async_iterator_get);
        emit_u8(s, 0);
        label_throw2 = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_await);
        emit_label(s, label_throw2);
        emit_op(s, OP_async_iterator_get);
        emit_u8(s, 2);       /* throw the type error exception */
        emit_op(s, OP_drop); /* never reached */

        emit_label(s, label_next);
        emit_op(s, OP_nip); /* keep the value associated with
                               done = true */
        emit_op(s, OP_nip);
        emit_op(s, OP_nip);
      } else {
        emit_op(s, OP_await);
        emit_op(s, OP_yield);
        label_next = emit_goto(s, OP_if_false, -1);
        emit_return(s, TRUE);
        emit_label(s, label_next);
      }
    } else {
      int label_next;
      if (is_star) {
        emit_op(s, OP_for_of_start);
        emit_op(s, OP_drop); /* drop the catch offset */
        emit_op(s, OP_yield_star);
      } else {
        emit_op(s, OP_yield);
      }
      label_next = emit_goto(s, OP_if_false, -1);
      emit_return(s, TRUE);
      emit_label(s, label_next);
    }
    return 0;
  }
  if (s->token.val == TOK_IDENT) {
    /* name0 is used to check for OP_set_name pattern, not duplicated */
    name0 = s->token.u.ident.atom;
  }
  if (lepus_parse_cond_expr(s, parse_flags | PF_ARROW_FUNC)) return -1;

  op = s->token.val;
  if (op == '=' || (op >= TOK_MUL_ASSIGN && op <= TOK_POW_ASSIGN)) {
    int label;
    if (next_token(s)) return -1;
    if (get_lvalue(s, &opcode, &scope, &name, &label, NULL, (op != '='), op) <
        0)
      return -1;

    if (lepus_parse_assign_expr(s, parse_flags)) {
      LEPUS_FreeAtom(s->ctx, name);
      return -1;
    }

    if (op == '=') {
      if (opcode == OP_get_ref_value && name == name0) {
        set_object_name(s, name);
      }
    } else {
      static const uint8_t assign_opcodes[] = {
          OP_mul, OP_div, OP_mod, OP_add, OP_sub, OP_shl,
          OP_sar, OP_shr, OP_and, OP_xor, OP_or,
#ifdef CONFIG_BIGNUM
          OP_pow,
#endif
          OP_pow,
      };
      op = assign_opcodes[op - TOK_MUL_ASSIGN];
#ifdef CONFIG_BIGNUM
      if (s->cur_func->lepus_mode & LEPUS_MODE_MATH) {
        if (op == OP_div)
          op = OP_math_div;
        else if (op == OP_mod)
          op = OP_math_mod;
        else if (op == OP_pow)
          op = OP_math_pow;
      }
#endif
      emit_op(s, op);
    }
    put_lvalue(s, opcode, scope, name, label, PUT_LVALUE_KEEP_TOP, FALSE);
  }
  return 0;
}

/* allowed parse_flags: PF_IN_ACCEPTED */
QJS_STATIC __exception int lepus_parse_expr2(LEPUSParseState *s,
                                             int parse_flags) {
  BOOL comma = FALSE;
  for (;;) {
    if (lepus_parse_assign_expr(s, parse_flags)) return -1;
    if (comma) {
      /* prevent get_lvalue from using the last expression
         as an lvalue. This also prevents the conversion of
         of get_var to get_ref for method lookup in function
         call inside `with` statement.
       */
      s->cur_func->last_opcode_pos = -1;
    }
    if (s->token.val != ',') break;
    comma = TRUE;
    if (next_token(s)) return -1;
    emit_op(s, OP_drop);
  }
  return 0;
}

QJS_STATIC __exception int lepus_parse_expr(LEPUSParseState *s) {
  return lepus_parse_expr2(s, PF_IN_ACCEPTED);
}

QJS_STATIC void push_break_entry(LEPUSFunctionDef *fd, BlockEnv *be,
                                 LEPUSAtom label_name, int label_break,
                                 int label_cont, int drop_count) {
  be->prev = fd->top_break;
  fd->top_break = be;
  be->label_name = label_name;
  be->label_break = label_break;
  be->label_cont = label_cont;
  be->drop_count = drop_count;
  be->label_finally = -1;
  be->scope_level = fd->scope_level;
  be->has_iterator = FALSE;
}

QJS_STATIC void pop_break_entry(LEPUSFunctionDef *fd) {
  BlockEnv *be;
  be = fd->top_break;
  fd->top_break = be->prev;
}

QJS_STATIC __exception int emit_break(LEPUSParseState *s, LEPUSAtom name,
                                      int is_cont) {
  BlockEnv *top;
  int i, scope_level;

  scope_level = s->cur_func->scope_level;
  top = s->cur_func->top_break;
  while (top != NULL) {
    close_scopes(s, scope_level, top->scope_level);
    scope_level = top->scope_level;
    if (is_cont && top->label_cont != -1 &&
        (name == LEPUS_ATOM_NULL || top->label_name == name)) {
      /* continue stays inside the same block */
      emit_goto(s, OP_goto, top->label_cont);
      return 0;
    }
    if (!is_cont && top->label_break != -1 &&
        (name == LEPUS_ATOM_NULL || top->label_name == name)) {
      emit_goto(s, OP_goto, top->label_break);
      return 0;
    }
    i = 0;
    if (top->has_iterator) {
      emit_op(s, OP_iterator_close);
      i += 3;
    }
    for (; i < top->drop_count; i++) emit_op(s, OP_drop);
    if (top->label_finally != -1) {
      /* must push dummy value to keep same stack depth */
      emit_op(s, OP_undefined);
      emit_goto(s, OP_gosub, top->label_finally);
      emit_op(s, OP_drop);
    }
    top = top->prev;
  }
  if (name == LEPUS_ATOM_NULL) {
    if (is_cont)
      return lepus_parse_error(s, "continue must be inside loop");
    else
      return lepus_parse_error(s, "break must be inside loop or switch");
  } else {
    return lepus_parse_error(s, "break/continue label not found");
  }
}

/* execute the finally blocks before return */
QJS_STATIC void emit_return(LEPUSParseState *s, BOOL hasval) {
  BlockEnv *top;
  int drop_count;

  drop_count = 0;
  top = s->cur_func->top_break;
  while (top != NULL) {
    /* XXX: emit the appropriate OP_leave_scope opcodes? Probably not
       required as all local variables will be closed upon returning
       from LEPUS_CallInternal, but not in the same order. */
    if (top->has_iterator) {
      /* with 'yield', the exact number of OP_drop to emit is
         unknown, so we use a specific operation to look for
         the catch offset */
      if (!hasval) {
        emit_op(s, OP_undefined);
        hasval = TRUE;
      }
      emit_op(s, OP_iterator_close_return);
      if (s->cur_func->func_kind == LEPUS_FUNC_ASYNC_GENERATOR) {
        int label_next;
        emit_op(s, OP_async_iterator_close);
        label_next = emit_goto(s, OP_if_true, -1);
        emit_op(s, OP_await);
        emit_label(s, label_next);
        emit_op(s, OP_drop);
      } else {
        emit_op(s, OP_iterator_close);
      }
      drop_count = -3;
    }
    drop_count += top->drop_count;
    if (top->label_finally != -1) {
      while (drop_count) {
        /* must keep the stack top if hasval */
        emit_op(s, hasval ? OP_nip : OP_drop);
        drop_count--;
      }
      if (!hasval) {
        /* must push return value to keep same stack size */
        emit_op(s, OP_undefined);
        hasval = TRUE;
      }
      emit_goto(s, OP_gosub, top->label_finally);
    }
    top = top->prev;
  }
  if (s->cur_func->is_derived_class_constructor) {
    int label_return;

    /* 'this' can be uninitialized, so it may be accessed only if
       the derived class constructor does not return an object */
    if (hasval) {
      emit_op(s, OP_check_ctor_return);
      label_return = emit_goto(s, OP_if_false, -1);
      emit_op(s, OP_drop);
    } else {
      label_return = -1;
    }

    emit_op(s, OP_scope_get_var);
    emit_atom(s, LEPUS_ATOM_this);
    emit_u16(s, 0);

    emit_label(s, label_return);
    emit_op(s, OP_return);
  } else if (s->cur_func->func_kind != LEPUS_FUNC_NORMAL) {
    if (!hasval) {
      emit_op(s, OP_undefined);
    } else if (s->cur_func->func_kind == LEPUS_FUNC_ASYNC_GENERATOR) {
      emit_op(s, OP_await);
    }
    emit_op(s, OP_return_async);
  } else {
    emit_op(s, hasval ? OP_return : OP_return_undef);
  }
}

#define DECL_MASK_FUNC (1 << 0) /* allow normal function declaration */
/* ored with DECL_MASK_FUNC if function declarations are allowed with a label */
#define DECL_MASK_FUNC_WITH_LABEL (1 << 1)
#define DECL_MASK_OTHER (1 << 2) /* all other declarations */
#define DECL_MASK_ALL \
  (DECL_MASK_FUNC | DECL_MASK_FUNC_WITH_LABEL | DECL_MASK_OTHER)

QJS_STATIC __exception int lepus_parse_statement_or_decl(LEPUSParseState *s,
                                                         int decl_mask);

QJS_STATIC __exception int lepus_parse_statement(LEPUSParseState *s) {
  return lepus_parse_statement_or_decl(s, 0);
}

QJS_STATIC __exception int lepus_parse_block(LEPUSParseState *s) {
  if (lepus_parse_expect(s, '{')) return -1;
  if (s->token.val != '}') {
    push_scope(s);
    for (;;) {
      if (lepus_parse_statement_or_decl(s, DECL_MASK_ALL)) return -1;
      if (s->token.val == '}') break;
    }
    pop_scope(s);
  }
  if (next_token(s)) return -1;
  return 0;
}

/* allowed parse_flags: PF_IN_ACCEPTED */
QJS_STATIC __exception int lepus_parse_var(LEPUSParseState *s, int parse_flags,
                                           int tok, BOOL export_flag) {
  LEPUSContext *ctx = s->ctx;
  LEPUSFunctionDef *fd = s->cur_func;
  LEPUSAtom name = LEPUS_ATOM_NULL;

  for (;;) {
    if (s->token.val == TOK_IDENT) {
      if (s->token.u.ident.is_reserved) {
        return lepus_parse_error_reserved_identifier(s);
      }
      name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
      if (name == LEPUS_ATOM_let && (tok == TOK_LET || tok == TOK_CONST)) {
        lepus_parse_error(s, "'let' is not a valid lexical identifier");
        goto var_error;
      }
      if (next_token(s)) goto var_error;
      if (lepus_define_var(s, name, tok)) goto var_error;
      if (export_flag) {
        if (!add_export_entry(s, s->cur_func->module, name, name,
                              LEPUS_EXPORT_TYPE_LOCAL))
          goto var_error;
      }

      if (s->token.val == '=') {
        if (next_token(s)) goto var_error;
        if (tok == TOK_VAR) {
          /* Must make a reference for proper `with` semantics */
          int opcode, scope, label;
          LEPUSAtom name1;

          emit_op(s, OP_scope_get_var);
          emit_atom(s, name);
          emit_u16(s, fd->scope_level);
          if (get_lvalue(s, &opcode, &scope, &name1, &label, NULL, FALSE, '=') <
              0)
            goto var_error;
          if (lepus_parse_assign_expr(s, parse_flags)) {
            LEPUS_FreeAtom(ctx, name1);
            goto var_error;
          }
          set_object_name(s, name);
          put_lvalue(s, opcode, scope, name1, label, PUT_LVALUE_NOKEEP, FALSE);
        } else {
          if (lepus_parse_assign_expr(s, parse_flags)) goto var_error;
          set_object_name(s, name);
          emit_op(s, (tok == TOK_CONST || tok == TOK_LET)
                         ? OP_scope_put_var_init
                         : OP_scope_put_var);
          emit_atom(s, name);
          emit_u16(s, fd->scope_level);
        }
      } else {
        if (tok == TOK_CONST) {
          lepus_parse_error(s, "missing initializer for const variable");
          goto var_error;
        }
        if (tok == TOK_LET) {
          /* initialize lexical variable upon entering its scope */
          emit_op(s, OP_undefined);
          emit_op(s, OP_scope_put_var_init);
          emit_atom(s, name);
          emit_u16(s, fd->scope_level);
        }
      }
      LEPUS_FreeAtom(ctx, name);
    } else {
      int skip_bits;
      if ((s->token.val == '[' || s->token.val == '{') &&
          lepus_parse_skip_parens_token(s, &skip_bits, FALSE) == '=') {
        emit_op(s, OP_undefined);
        if (lepus_parse_destructing_element(
                s, tok, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
          return -1;
      } else {
        return lepus_parse_error(s, "variable name expected");
      }
    }
    if (s->token.val != ',') break;
    if (next_token(s)) return -1;
  }
  return 0;

var_error:
  LEPUS_FreeAtom(ctx, name);
  return -1;
}

/* test if the current token is a label. Use simplistic look-ahead scanner */
QJS_STATIC BOOL is_label(LEPUSParseState *s) {
  return (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
          peek_token(s, FALSE) == ':');
}

/* test if the current token is a let keyword. Use simplistic look-ahead scanner
 */
QJS_STATIC int is_let(LEPUSParseState *s, int decl_mask) {
  int res = FALSE;

  if (token_is_pseudo_keyword(s, LEPUS_ATOM_let)) {
#if 1
    LEPUSParsePos pos;
    lepus_parse_get_pos(s, &pos);
    for (;;) {
      if (next_token(s)) {
        res = -1;
        break;
      }
      if (s->token.val == '[') {
        /* let [ is a syntax restriction:
           it never introduces an ExpressionStatement */
        res = TRUE;
        break;
      }
      if (s->token.val == '{' ||
          (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved) ||
          s->token.val == TOK_LET || s->token.val == TOK_YIELD ||
          s->token.val == TOK_AWAIT) {
        /* Check for possible ASI if not scanning for Declaration */
        /* XXX: should also check that `{` introduces a BindingPattern,
           but Firefox does not and rejects eval("let=1;let\n{if(1)2;}") */
        if (s->last_line_num == s->token.line_num ||
            (decl_mask & DECL_MASK_OTHER)) {
          res = TRUE;
          break;
        }
        break;
      }
      break;
    }
    if (lepus_parse_seek_token(s, &pos)) {
      res = -1;
    }
#else
    int tok = peek_token(s, TRUE);
    if (tok == '{' || tok == TOK_IDENT || peek_token(s, FALSE) == '[') {
      res = TRUE;
    }
#endif
  }
  return res;
}

/* XXX: handle IteratorClose when exiting the loop before the
   enumeration is done */
QJS_STATIC __exception int lepus_parse_for_in_of(LEPUSParseState *s,
                                                 int label_name,
                                                 BOOL is_async) {
  LEPUSContext *ctx = s->ctx;
  LEPUSFunctionDef *fd = s->cur_func;
  LEPUSAtom var_name;
  BOOL has_initializer, is_for_of, has_destructuring;
  int tok, tok1, opcode, scope, block_scope_level;
  int label_next, label_expr, label_cont, label_body, label_break;
  int pos_next, pos_expr;
  BlockEnv break_entry;

  has_initializer = FALSE;
  has_destructuring = FALSE;
  is_for_of = FALSE;
  block_scope_level = fd->scope_level;
  label_cont = new_label(s);
  label_body = new_label(s);
  label_break = new_label(s);
  label_next = new_label(s);

  /* create scope for the lexical variables declared in the enumeration
     expressions. XXX: Not completely correct because of weird capturing
     semantics in `for (i of o) a.push(function(){return i})` */
  push_scope(s);

  /* local for_in scope starts here so individual elements
     can be closed in statement. */
  push_break_entry(s->cur_func, &break_entry, label_name, label_break,
                   label_cont, 1);
  break_entry.scope_level = block_scope_level;

  label_expr = emit_goto(s, OP_goto, -1);

  pos_next = s->cur_func->byte_code.size;
  emit_label(s, label_next);

  tok = s->token.val;
  switch (is_let(s, DECL_MASK_OTHER)) {
    case TRUE:
      tok = TOK_LET;
      break;
    case FALSE:
      break;
    default:
      return -1;
  }
  if (tok == TOK_VAR || tok == TOK_LET || tok == TOK_CONST) {
    if (next_token(s)) return -1;

    if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {
      if (s->token.val == '[' || s->token.val == '{') {
        if (lepus_parse_destructing_element(s, tok, 0, TRUE, -1, FALSE) < 0)
          return -1;
        has_destructuring = TRUE;
      } else {
        return lepus_parse_error(s, "variable name expected");
      }
      var_name = LEPUS_ATOM_NULL;
    } else {
      var_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
      if (next_token(s)) {
        LEPUS_FreeAtom(s->ctx, var_name);
        return -1;
      }
      if (lepus_define_var(s, var_name, tok)) {
        LEPUS_FreeAtom(s->ctx, var_name);
        return -1;
      }
      emit_op(s, (tok == TOK_CONST || tok == TOK_LET) ? OP_scope_put_var_init
                                                      : OP_scope_put_var);
      emit_atom(s, var_name);
      emit_u16(s, fd->scope_level);
    }
  } else {
    int skip_bits;
    if ((s->token.val == '[' || s->token.val == '{') &&
        ((tok1 = lepus_parse_skip_parens_token(s, &skip_bits, FALSE)) ==
             TOK_IN ||
         tok1 == TOK_OF)) {
      if (lepus_parse_destructing_element(
              s, 0, 0, TRUE, skip_bits & SKIP_HAS_ELLIPSIS, TRUE) < 0)
        return -1;
    } else {
      int lvalue_label, depth;
      if (lepus_parse_left_hand_side_expr(s)) return -1;
      if (get_lvalue(s, &opcode, &scope, &var_name, &lvalue_label, &depth,
                     FALSE, TOK_FOR))
        return -1;
      put_lvalue(s, opcode, scope, var_name, lvalue_label,
                 PUT_LVALUE_NOKEEP_BOTTOM, FALSE);
    }
    var_name = LEPUS_ATOM_NULL;
  }
  emit_goto(s, OP_goto, label_body);

  pos_expr = s->cur_func->byte_code.size;
  emit_label(s, label_expr);
  if (s->token.val == '=') {
    /* XXX: potential scoping issue if inside `with` statement */
    has_initializer = TRUE;
    /* parse and evaluate initializer prior to evaluating the
       object (only used with "for in" with a non lexical variable
       in non strict mode */
    if (next_token(s) || lepus_parse_assign_expr(s, 0)) {
      LEPUS_FreeAtom(ctx, var_name);
      return -1;
    }
    if (var_name != LEPUS_ATOM_NULL) {
      emit_op(s, OP_scope_put_var);
      emit_atom(s, var_name);
      emit_u16(s, fd->scope_level);
    }
  }
  LEPUS_FreeAtom(ctx, var_name);

  if (token_is_pseudo_keyword(s, LEPUS_ATOM_of)) {
    break_entry.has_iterator = is_for_of = TRUE;
    break_entry.drop_count += 2;
    if (has_initializer) goto initializer_error;
  } else if (s->token.val == TOK_IN) {
    if (is_async)
      return lepus_parse_error(s, "'for await' loop should be used with 'of'");
    if (has_initializer &&
        (tok != TOK_VAR || (fd->lepus_mode & LEPUS_MODE_STRICT) ||
         has_destructuring)) {
    initializer_error:
      return lepus_parse_error(
          s,
          "a declaration in the head of a for-%s loop can't "
          "have an initializer",
          is_for_of ? "of" : "in");
    }
  } else {
    return lepus_parse_error(s,
                             "expected 'of' or 'in' in for control expression");
  }
  if (next_token(s)) return -1;
  if (is_for_of) {
    if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
  } else {
    if (lepus_parse_expr(s)) return -1;
  }
  /* close the scope after having evaluated the expression so that
     the TDZ values are in the closures */
  close_scopes(s, s->cur_func->scope_level, block_scope_level);
  if (is_for_of) {
    if (is_async)
      emit_op(s, OP_for_await_of_start);
    else
      emit_op(s, OP_for_of_start);
    /* on stack: enum_rec */
  } else {
    emit_op(s, OP_for_in_start);
    /* on stack: enum_obj */
  }
  emit_goto(s, OP_goto, label_cont);

  if (lepus_parse_expect(s, ')')) return -1;

  if (OPTIMIZE) {
    /* move the `next` code here */
    DynBuf *bc = &s->cur_func->byte_code;
    int chunk_size = pos_expr - pos_next;
    int offset = bc->size - pos_next;
    int i;
    dbuf_realloc(bc, bc->size + chunk_size);
    dbuf_put(bc, bc->buf + pos_next, chunk_size);
    memset(bc->buf + pos_next, OP_nop, chunk_size);
    /* `next` part ends with a goto */
    s->cur_func->last_opcode_pos = bc->size - 5;
    /* relocate labels */
    for (i = label_cont; i < s->cur_func->label_count; i++) {
      LabelSlot *ls = &s->cur_func->label_slots[i];
      if (ls->pos >= pos_next && ls->pos < pos_expr) ls->pos += offset;
    }
  }

  emit_label(s, label_body);
  if (lepus_parse_statement(s)) return -1;

  close_scopes(s, s->cur_func->scope_level, block_scope_level);

  emit_label(s, label_cont);
  if (is_for_of) {
    if (is_async) {
      /* call the next method */
      emit_op(s, OP_dup3);
      emit_op(s, OP_drop);
      emit_op(s, OP_call_method);
      emit_u16(s, 0);
      /* get the result of the promise */
      emit_op(s, OP_await);
      /* unwrap the value and done values */
      emit_op(s, OP_iterator_get_value_done);
    } else {
      emit_op(s, OP_for_of_next);
      emit_u8(s, 0);
    }
  } else {
    emit_op(s, OP_for_in_next);
  }
  /* on stack: enum_rec / enum_obj value bool */
  emit_goto(s, OP_if_false, label_next);
  /* drop the undefined value from for_xx_next */
  emit_op(s, OP_drop);

  emit_label(s, label_break);
  if (is_for_of) {
    /* close and drop enum_rec */
    emit_op(s, OP_iterator_close);
  } else {
    emit_op(s, OP_drop);
  }
  pop_break_entry(s->cur_func);
  pop_scope(s);
  return 0;
}

QJS_STATIC void set_eval_ret_undefined(LEPUSParseState *s) {
  if (s->cur_func->eval_ret_idx >= 0) {
    emit_op(s, OP_undefined);
    emit_op(s, OP_put_loc);
    emit_u16(s, s->cur_func->eval_ret_idx);
  }
}

#ifdef ENABLE_QUICKJS_STEP_STATEMENT
QJS_STATIC void lepus_gen_debugger_statement(LEPUSParseState *s,
                                             LEPUSContext *ctx) {
  LEPUSValue statement = LEPUS_NewString(ctx, "statement");
  if (LEPUS_IsException(statement)) return;
  if (emit_push_const(s, statement, 0) < 0) {
    LEPUS_FreeValue(ctx, statement);
    return;
  }
  LEPUS_FreeValue(ctx, statement);
  emit_op(s, OP_drop);
}
#endif

QJS_STATIC __exception int lepus_parse_statement_or_decl(LEPUSParseState *s,
                                                         int decl_mask) {
  LEPUSContext *ctx = s->ctx;
  LEPUSAtom label_name;
  int tok;

  /* specific label handling */
  /* XXX: support multiple labels on loop statements */
  label_name = LEPUS_ATOM_NULL;
  if (is_label(s)) {
    BlockEnv *be;

    label_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);

    for (be = s->cur_func->top_break; be; be = be->prev) {
      if (be->label_name == label_name) {
        lepus_parse_error(s, "duplicate label name");
        goto fail;
      }
    }

    if (next_token(s)) goto fail;
    if (lepus_parse_expect(s, ':')) goto fail;
    if (s->token.val != TOK_FOR && s->token.val != TOK_DO &&
        s->token.val != TOK_WHILE) {
      /* labelled regular statement */
      int label_break, mask;
      BlockEnv break_entry;

      label_break = new_label(s);
      push_break_entry(s->cur_func, &break_entry, label_name, label_break, -1,
                       0);
      if (!(s->cur_func->lepus_mode & LEPUS_MODE_STRICT) &&
          (decl_mask & DECL_MASK_FUNC_WITH_LABEL)) {
        mask = DECL_MASK_FUNC | DECL_MASK_FUNC_WITH_LABEL;
      } else {
        mask = 0;
      }
      if (lepus_parse_statement_or_decl(s, mask)) goto fail;
      emit_label(s, label_break);
      pop_break_entry(s->cur_func);
      goto done;
    }
  }

  switch (tok = s->token.val) {
    case '{':
      if (lepus_parse_block(s)) goto fail;
      break;
    case TOK_RETURN:
      if (s->cur_func->is_eval) {
        lepus_parse_error(s, "return not in a function");
        goto fail;
      }
      if (next_token(s)) goto fail;
      if (s->token.val != ';' && s->token.val != '}' && !s->got_lf) {
        if (lepus_parse_expr(s)) goto fail;
        emit_return(s, TRUE);
      } else {
        emit_return(s, FALSE);
      }
      if (lepus_parse_expect_semi(s)) goto fail;
      break;
    case TOK_THROW:
      if (next_token(s)) goto fail;
      if (s->got_lf) {
        lepus_parse_error(s, "line terminator not allowed after throw");
        goto fail;
      }
      if (lepus_parse_expr(s)) goto fail;
      emit_op(s, OP_throw);
      if (lepus_parse_expect_semi(s)) goto fail;
      break;
    case TOK_LET:
    case TOK_CONST:
    haslet:
      if (!(decl_mask & DECL_MASK_OTHER)) {
        lepus_parse_error(
            s, "lexical declarations can't appear in single-statement context");
        goto fail;
      }
      /* fall thru */
    case TOK_VAR:
      if (next_token(s)) goto fail;
      if (lepus_parse_var(s, TRUE, tok, FALSE)) goto fail;
      if (lepus_parse_expect_semi(s)) goto fail;
      break;
    case TOK_IF: {
      int label1, label2, mask;
      if (next_token(s)) goto fail;
      /* create a new scope for `let f;if(1) function f(){}` */
      push_scope(s);
      set_eval_ret_undefined(s);
      if (lepus_parse_expr_paren(s)) goto fail;
      label1 = emit_goto(s, OP_if_false, -1);
      if (s->cur_func->lepus_mode & LEPUS_MODE_STRICT)
        mask = 0;
      else
        mask = DECL_MASK_FUNC; /* Annex B.3.4 */

      if (lepus_parse_statement_or_decl(s, mask)) goto fail;

      if (s->token.val == TOK_ELSE) {
        label2 = emit_goto(s, OP_goto, -1);
        if (next_token(s)) goto fail;

        emit_label(s, label1);
        if (lepus_parse_statement_or_decl(s, mask)) goto fail;

        label1 = label2;
      }
      emit_label(s, label1);
      pop_scope(s);
    } break;
    case TOK_WHILE: {
      int label_cont, label_break;
      BlockEnv break_entry;

      label_cont = new_label(s);
      label_break = new_label(s);

      push_break_entry(s->cur_func, &break_entry, label_name, label_break,
                       label_cont, 0);

      if (next_token(s)) goto fail;

      set_eval_ret_undefined(s);

      emit_label(s, label_cont);
      if (lepus_parse_expr_paren(s)) goto fail;
      emit_goto(s, OP_if_false, label_break);

      if (lepus_parse_statement(s)) goto fail;
      emit_goto(s, OP_goto, label_cont);

      emit_label(s, label_break);

      pop_break_entry(s->cur_func);
    } break;
    case TOK_DO: {
      int label_cont, label_break, label1;
      BlockEnv break_entry;

      label_cont = new_label(s);
      label_break = new_label(s);
      label1 = new_label(s);

      push_break_entry(s->cur_func, &break_entry, label_name, label_break,
                       label_cont, 0);

      if (next_token(s)) goto fail;

      emit_label(s, label1);

      set_eval_ret_undefined(s);

      if (lepus_parse_statement(s)) goto fail;

      emit_label(s, label_cont);
      if (lepus_parse_expect(s, TOK_WHILE)) goto fail;
      if (lepus_parse_expr_paren(s)) goto fail;
      /* Insert semicolon if missing */
      if (s->token.val == ';') {
        if (next_token(s)) goto fail;
      }
      emit_goto(s, OP_if_true, label1);

      emit_label(s, label_break);

      pop_break_entry(s->cur_func);
    } break;
    case TOK_FOR: {
      int label_cont, label_break, label_body, label_test;
      int pos_cont, pos_body, block_scope_level;
      BlockEnv break_entry;
      int tok, bits;
      BOOL is_async;

      if (next_token(s)) goto fail;

      set_eval_ret_undefined(s);
      bits = 0;
      is_async = FALSE;
      if (s->token.val == '(') {
        lepus_parse_skip_parens_token(s, &bits, FALSE);
      } else if (s->token.val == TOK_AWAIT) {
        if (!(s->cur_func->func_kind & LEPUS_FUNC_ASYNC)) {
          lepus_parse_error(
              s, "for await is only valid in asynchronous functions");
          goto fail;
        }
        is_async = TRUE;
        if (next_token(s)) goto fail;
      }
      if (lepus_parse_expect(s, '(')) goto fail;

      if (!(bits & SKIP_HAS_SEMI)) {
        /* parse for/in or for/of */
        if (lepus_parse_for_in_of(s, label_name, is_async)) goto fail;
        break;
      }
      block_scope_level = s->cur_func->scope_level;

      /* create scope for the lexical variables declared in the initial,
         test and increment expressions */
      push_scope(s);
      /* initial expression */
      tok = s->token.val;
      if (tok != ';') {
        switch (is_let(s, DECL_MASK_OTHER)) {
          case TRUE:
            tok = TOK_LET;
            break;
          case FALSE:
            break;
          default:
            goto fail;
        }
        if (tok == TOK_VAR || tok == TOK_LET || tok == TOK_CONST) {
          if (next_token(s)) goto fail;
          if (lepus_parse_var(s, FALSE, tok, FALSE)) goto fail;
        } else {
          if (lepus_parse_expr2(s, FALSE)) goto fail;
          emit_op(s, OP_drop);
        }

        /* close the closures before the first iteration */
        close_scopes(s, s->cur_func->scope_level, block_scope_level);
      }
      if (lepus_parse_expect(s, ';')) goto fail;

      label_test = new_label(s);
      label_cont = new_label(s);
      label_body = new_label(s);
      label_break = new_label(s);

      push_break_entry(s->cur_func, &break_entry, label_name, label_break,
                       label_cont, 0);

      /* test expression */
      if (s->token.val == ';') {
        /* no test expression */
        label_test = label_body;
      } else {
        emit_label(s, label_test);
        if (lepus_parse_expr(s)) goto fail;
        emit_goto(s, OP_if_false, label_break);
      }
      if (lepus_parse_expect(s, ';')) goto fail;

      if (s->token.val == ')') {
        /* no end expression */
        break_entry.label_cont = label_cont = label_test;
        pos_cont = 0; /* avoid warning */
      } else {
        /* skip the end expression */
        emit_goto(s, OP_goto, label_body);

        pos_cont = s->cur_func->byte_code.size;
        emit_label(s, label_cont);
        if (lepus_parse_expr(s)) goto fail;
        emit_op(s, OP_drop);
        if (label_test != label_body) emit_goto(s, OP_goto, label_test);
      }
      if (lepus_parse_expect(s, ')')) goto fail;

      pos_body = s->cur_func->byte_code.size;
      emit_label(s, label_body);
      if (lepus_parse_statement(s)) goto fail;

      /* close the closures before the next iteration */
      /* XXX: check continue case */
      close_scopes(s, s->cur_func->scope_level, block_scope_level);

      if (OPTIMIZE && label_test != label_body && label_cont != label_test) {
        /* move the increment code here */
        DynBuf *bc = &s->cur_func->byte_code;
        int chunk_size = pos_body - pos_cont;
        int offset = bc->size - pos_cont;
        int i;
        dbuf_realloc(bc, bc->size + chunk_size);
        dbuf_put(bc, bc->buf + pos_cont, chunk_size);
        memset(bc->buf + pos_cont, OP_nop, chunk_size);
        /* increment part ends with a goto */
        s->cur_func->last_opcode_pos = bc->size - 5;
        /* relocate labels */
        for (i = label_cont; i < s->cur_func->label_count; i++) {
          LabelSlot *ls = &s->cur_func->label_slots[i];
          if (ls->pos >= pos_cont && ls->pos < pos_body) ls->pos += offset;
        }
      } else {
        emit_goto(s, OP_goto, label_cont);
      }

      emit_label(s, label_break);

      pop_break_entry(s->cur_func);
      pop_scope(s);
    } break;
    case TOK_BREAK:
    case TOK_CONTINUE: {
      int is_cont = s->token.val - TOK_BREAK;
      int label;

      if (next_token(s)) goto fail;
      if (!s->got_lf && s->token.val == TOK_IDENT &&
          !s->token.u.ident.is_reserved)
        label = s->token.u.ident.atom;
      else
        label = LEPUS_ATOM_NULL;
      if (emit_break(s, label, is_cont)) goto fail;
      if (label != LEPUS_ATOM_NULL) {
        if (next_token(s)) goto fail;
      }
      if (lepus_parse_expect_semi(s)) goto fail;
    } break;
    case TOK_SWITCH: {
      int label_case, label_break, label1;
      int default_label_pos;
      BlockEnv break_entry;

      if (next_token(s)) goto fail;

      set_eval_ret_undefined(s);
      if (lepus_parse_expr_paren(s)) goto fail;

      push_scope(s);
      label_break = new_label(s);
      push_break_entry(s->cur_func, &break_entry, label_name, label_break, -1,
                       1);

      if (lepus_parse_expect(s, '{')) goto fail;

      default_label_pos = -1;
      label_case = -1;
      while (s->token.val != '}') {
        if (s->token.val == TOK_CASE) {
          label1 = -1;
          if (label_case >= 0) {
            /* skip the case if needed */
            label1 = emit_goto(s, OP_goto, -1);
          }
          emit_label(s, label_case);
          label_case = -1;
          for (;;) {
            /* parse a sequence of case clauses */
            if (next_token(s)) goto fail;
            emit_op(s, OP_dup);
            if (lepus_parse_expr(s)) goto fail;
            if (lepus_parse_expect(s, ':')) goto fail;
            emit_op(s, OP_strict_eq);
            if (s->token.val == TOK_CASE) {
              label1 = emit_goto(s, OP_if_true, label1);
            } else {
              label_case = emit_goto(s, OP_if_false, -1);
              emit_label(s, label1);
              break;
            }
          }
        } else if (s->token.val == TOK_DEFAULT) {
          if (next_token(s)) goto fail;
          if (lepus_parse_expect(s, ':')) goto fail;
          if (default_label_pos >= 0) {
            lepus_parse_error(s, "duplicate default");
            goto fail;
          }
          if (label_case < 0) {
            /* falling thru direct from switch expression */
            label_case = emit_goto(s, OP_goto, -1);
          }
          /* Emit a dummy label opcode. Label will be patched after
             the end of the switch body. Do not use emit_label(s, 0)
             because it would clobber label 0 address, preventing
             proper optimizer operation.
           */
          emit_op(s, OP_label);
          emit_u32(s, 0);
          default_label_pos = s->cur_func->byte_code.size - 4;
        } else {
          if (label_case < 0) {
            /* falling thru direct from switch expression */
            lepus_parse_error(s, "invalid switch statement");
            goto fail;
          }
          if (lepus_parse_statement_or_decl(s, DECL_MASK_ALL)) goto fail;
        }
      }
      if (lepus_parse_expect(s, '}')) goto fail;
      if (default_label_pos >= 0) {
        /* Ugly patch for the the `default` label, shameful and risky */
        put_u32(s->cur_func->byte_code.buf + default_label_pos, label_case);
        s->cur_func->label_slots[label_case].pos = default_label_pos + 4;
      } else {
        emit_label(s, label_case);
      }
      emit_label(s, label_break);
      emit_op(s, OP_drop); /* drop the switch expression */

      pop_break_entry(s->cur_func);
      pop_scope(s);
    } break;
    case TOK_TRY: {
      int label_catch, label_catch2, label_finally, label_end;
      LEPUSAtom name;
      BlockEnv block_env;

      set_eval_ret_undefined(s);
      if (next_token(s)) goto fail;
      label_catch = new_label(s);
      label_catch2 = new_label(s);
      label_finally = new_label(s);
      label_end = new_label(s);

      emit_goto(s, OP_catch, label_catch);

      push_break_entry(s->cur_func, &block_env, LEPUS_ATOM_NULL, -1, -1, 1);
      block_env.label_finally = label_finally;

      if (lepus_parse_block(s)) goto fail;

      pop_break_entry(s->cur_func);

      if (lepus_is_live_code(s)) {
        /* drop the catch offset */
        emit_op(s, OP_drop);
        /* must push dummy value to keep same stack size */
        emit_op(s, OP_undefined);
        emit_goto(s, OP_gosub, label_finally);
        emit_op(s, OP_drop);

        emit_goto(s, OP_goto, label_end);
      }

      if (s->token.val == TOK_CATCH) {
        if (next_token(s)) goto fail;

        push_scope(s); /* catch variable */
        emit_label(s, label_catch);

        if (s->token.val == '{') {
          /* support optional-catch-binding feature */
          emit_op(s, OP_drop); /* pop the exception object */
        } else {
          if (lepus_parse_expect(s, '(')) goto fail;
          if (!(s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved)) {
            if (s->token.val == '[' || s->token.val == '{') {
              /* XXX: TOK_LET is not completely correct */
              if (lepus_parse_destructing_element(s, TOK_LET, 0, TRUE, -1,
                                                  TRUE) < 0)
                goto fail;
            } else {
              lepus_parse_error(s, "identifier expected");
              goto fail;
            }
          } else {
            name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
            if (next_token(s) || lepus_define_var(s, name, TOK_CATCH) < 0) {
              LEPUS_FreeAtom(ctx, name);
              goto fail;
            }
            /* store the exception value in the catch variable */
            emit_op(s, OP_scope_put_var);
            emit_u32(s, name);
            emit_u16(s, s->cur_func->scope_level);
          }
          if (lepus_parse_expect(s, ')')) goto fail;
        }
        /* XXX: should keep the address to nop it out if there is no finally
         * block */
        emit_goto(s, OP_catch, label_catch2);

        push_scope(s); /* catch block */
        push_break_entry(s->cur_func, &block_env, LEPUS_ATOM_NULL, -1, -1, 1);
        block_env.label_finally = label_finally;

        if (lepus_parse_block(s)) goto fail;

        pop_break_entry(s->cur_func);
        pop_scope(s); /* catch block */
        pop_scope(s); /* catch variable */

        if (lepus_is_live_code(s)) {
          /* drop the catch2 offset */
          emit_op(s, OP_drop);
          /* XXX: should keep the address to nop it out if there is no finally
           * block */
          /* must push dummy value to keep same stack size */
          emit_op(s, OP_undefined);
          emit_goto(s, OP_gosub, label_finally);
          emit_op(s, OP_drop);
          emit_goto(s, OP_goto, label_end);
        }
        /* catch exceptions thrown in the catch block to execute the
         * finally clause and rethrow the exception */
        emit_label(s, label_catch2);
        /* catch value is at TOS, no need to push undefined */
        emit_goto(s, OP_gosub, label_finally);
        emit_op(s, OP_throw);

      } else if (s->token.val == TOK_FINALLY) {
        /* finally without catch : execute the finally clause
         * and rethrow the exception */
        emit_label(s, label_catch);
        /* catch value is at TOS, no need to push undefined */
        emit_goto(s, OP_gosub, label_finally);
        emit_op(s, OP_throw);
      } else {
        lepus_parse_error(s, "expecting catch or finally");
        goto fail;
      }
      emit_label(s, label_finally);
      if (s->token.val == TOK_FINALLY) {
        int saved_eval_ret_idx;
        if (next_token(s)) goto fail;
        /* on the stack: ret_value gosub_ret_value */
        push_break_entry(s->cur_func, &block_env, LEPUS_ATOM_NULL, -1, -1, 2);
        if (s->cur_func->eval_ret_idx >= 0) {
          /* 'finally' updates eval_ret only if not a normal
             termination */
          saved_eval_ret_idx = add_var(s->ctx, s->cur_func, LEPUS_ATOM__ret_);
          if (saved_eval_ret_idx < 0) goto fail;
          emit_op(s, OP_get_loc);
          emit_u16(s, s->cur_func->eval_ret_idx);
          emit_op(s, OP_put_loc);
          emit_u16(s, saved_eval_ret_idx);
          set_eval_ret_undefined(s);
        }

        if (lepus_parse_block(s)) goto fail;

        if (s->cur_func->eval_ret_idx >= 0) {
          emit_op(s, OP_get_loc);
          emit_u16(s, saved_eval_ret_idx);
          emit_op(s, OP_put_loc);
          emit_u16(s, s->cur_func->eval_ret_idx);
        }
        pop_break_entry(s->cur_func);
      }
      emit_op(s, OP_ret);
      emit_label(s, label_end);
    } break;
    case ';':
      /* empty statement */
      if (next_token(s)) goto fail;
      break;
    case TOK_WITH:
      if (s->cur_func->lepus_mode & LEPUS_MODE_STRICT) {
        lepus_parse_error(s, "invalid keyword: with");
        goto fail;
      } else {
        int with_idx;

        if (next_token(s)) goto fail;

        if (lepus_parse_expr_paren(s)) goto fail;

        push_scope(s);
        with_idx =
            define_var(s, s->cur_func, LEPUS_ATOM__with_, LEPUS_VAR_DEF_WITH);
        if (with_idx < 0) goto fail;
        emit_op(s, OP_to_object);
        emit_op(s, OP_put_loc);
        emit_u16(s, with_idx);

        set_eval_ret_undefined(s);
        if (lepus_parse_statement(s)) goto fail;

        /* Popping scope drops lexical context for the with object variable */
        pop_scope(s);
      }
      break;
    case TOK_FUNCTION:
      /* ES6 Annex B.3.2 and B.3.3 semantics */
      if (!(decl_mask & DECL_MASK_FUNC)) goto func_decl_error;
      if (!(decl_mask & DECL_MASK_OTHER) && peek_token(s, FALSE) == '*')
        goto func_decl_error;
      goto parse_func_var;
    case TOK_IDENT:
      if (s->token.u.ident.is_reserved) {
        lepus_parse_error_reserved_identifier(s);
        goto fail;
      }
      /* Determine if `let` introduces a Declaration or an ExpressionStatement
       */
      switch (is_let(s, decl_mask)) {
        case TRUE:
          tok = TOK_LET;
          goto haslet;
        case FALSE:
          break;
        default:
          goto fail;
      }
      if (token_is_pseudo_keyword(s, LEPUS_ATOM_async) &&
          peek_token(s, TRUE) == TOK_FUNCTION) {
        if (!(decl_mask & DECL_MASK_OTHER)) {
        func_decl_error:
          lepus_parse_error(
              s,
              "function declarations can't appear in single-statement context");
          goto fail;
        }
      parse_func_var:
        if (lepus_parse_function_decl(s, LEPUS_PARSE_FUNC_VAR,
                                      LEPUS_FUNC_NORMAL, LEPUS_ATOM_NULL,
                                      s->token.ptr, s->token.line_num))
          goto fail;
        break;
      }
      goto hasexpr;

    case TOK_CLASS:
      if (!(decl_mask & DECL_MASK_OTHER)) {
        lepus_parse_error(
            s, "class declarations can't appear in single-statement context");
        goto fail;
      }
      if (lepus_parse_class(s, FALSE, LEPUS_PARSE_EXPORT_NONE)) return -1;
      break;

    case TOK_DEBUGGER:
#ifdef ENABLE_QUICKJS_DEBUGGER
      if (next_token(s)) goto fail;
      // generate opcode: op_push_const
      LEPUSValue debugger;
      debugger = LEPUS_NewString(ctx, "debugger");
      if (LEPUS_IsException(debugger)) goto fail;
      if (emit_push_const(s, debugger, 0) < 0) {
        LEPUS_FreeValue(ctx, debugger);
        goto fail;
      }
      LEPUS_FreeValue(ctx, debugger);
      emit_op(s, OP_drop);
      break;
#endif
    case TOK_ENUM:
    case TOK_EXPORT:
    case TOK_EXTENDS:
      lepus_unsupported_keyword(s, s->token.u.ident.atom);
      goto fail;

    default:
    hasexpr:
      if (lepus_parse_expr(s)) goto fail;
      if (s->cur_func->eval_ret_idx >= 0) {
        /* store the expression value so that it can be returned
           by eval() */
        emit_op(s, OP_put_loc);
        emit_u16(s, s->cur_func->eval_ret_idx);
      } else {
        emit_op(s, OP_drop); /* drop the result */
      }
      if (lepus_parse_expect_semi(s)) goto fail;
      break;
  }
done:
  LEPUS_FreeAtom(ctx, label_name);
#ifdef ENABLE_QUICKJS_STEP_STATEMENT
  if (ctx->debugger_mode) {
    lepus_gen_debugger_statement(s, s->ctx);
  }
#endif
  return 0;
fail:
  LEPUS_FreeAtom(ctx, label_name);
  return -1;
}
#endif

/* 'name' is freed */
QJS_STATIC LEPUSModuleDef *lepus_new_module_def(LEPUSContext *ctx,
                                                LEPUSAtom name) {
  LEPUSModuleDef *m;
  m = static_cast<LEPUSModuleDef *>(lepus_mallocz(ctx, sizeof(*m)));
  if (!m) {
    LEPUS_FreeAtom(ctx, name);
    return NULL;
  }
  m->header.ref_count = 1;
  m->module_name = name;
  m->module_ns = LEPUS_UNDEFINED;
  m->func_obj = LEPUS_UNDEFINED;
  m->eval_exception = LEPUS_UNDEFINED;
  list_add_tail(&m->link, &ctx->loaded_modules);
  return m;
}

QJS_STATIC void lepus_free_module_def(LEPUSContext *ctx, LEPUSModuleDef *m) {
  int i;

  LEPUS_FreeAtom(ctx, m->module_name);

  for (i = 0; i < m->req_module_entries_count; i++) {
    LEPUSReqModuleEntry *rme = &m->req_module_entries[i];
    LEPUS_FreeAtom(ctx, rme->module_name);
  }
  lepus_free(ctx, m->req_module_entries);

  for (i = 0; i < m->export_entries_count; i++) {
    LEPUSExportEntry *me = &m->export_entries[i];
    if (me->export_type == LEPUS_EXPORT_TYPE_LOCAL)
      free_var_ref(ctx->rt, me->u.local.var_ref);
    LEPUS_FreeAtom(ctx, me->export_name);
    LEPUS_FreeAtom(ctx, me->local_name);
  }
  lepus_free(ctx, m->export_entries);

  lepus_free(ctx, m->star_export_entries);

  for (i = 0; i < m->import_entries_count; i++) {
    LEPUSImportEntry *mi = &m->import_entries[i];
    LEPUS_FreeAtom(ctx, mi->import_name);
  }
  lepus_free(ctx, m->import_entries);

  LEPUS_FreeValue(ctx, m->module_ns);
  LEPUS_FreeValue(ctx, m->func_obj);
  LEPUS_FreeValue(ctx, m->eval_exception);
  list_del(&m->link);
  lepus_free(ctx, m);
}

#ifndef NO_QUICKJS_COMPILER
QJS_STATIC int lepus_resize_array(LEPUSContext *ctx, void **parray,
                                  int elem_size, int *psize, int *pcount,
                                  int new_count) {
  if (unlikely(new_count > *psize)) {
    int new_size;
    size_t slack;
    void *new_array;
    /* XXX: potential arithmetic overflow */
    new_size = max_int(new_count, *psize * 3 / 2);
    new_array = lepus_realloc2(ctx, *parray, new_size * elem_size, &slack);
    if (!new_array) return -1;
    new_size += slack / elem_size;
    *psize = new_size;
    *parray = new_array;
  }
  *pcount = new_count;
  return 0;
}

QJS_STATIC int add_req_module_entry(LEPUSContext *ctx, LEPUSModuleDef *m,
                                    LEPUSAtom module_name) {
  LEPUSReqModuleEntry *rme;
  int i;

  /* no need to add the module request if it is already present */
  for (i = 0; i < m->req_module_entries_count; i++) {
    rme = &m->req_module_entries[i];
    if (rme->module_name == module_name) return i;
  }

  if (lepus_resize_array(
          ctx, (void **)&m->req_module_entries, sizeof(LEPUSReqModuleEntry),
          &m->req_module_entries_size, &m->req_module_entries_count,
          m->req_module_entries_count + 1))
    return -1;
  i = m->req_module_entries_count - 1;
  rme = &m->req_module_entries[i];
  rme->module_name = LEPUS_DupAtom(ctx, module_name);
  rme->module = NULL;
  return i;
}

QJS_STATIC LEPUSExportEntry *find_export_entry(LEPUSContext *ctx,
                                               LEPUSModuleDef *m,
                                               LEPUSAtom export_name) {
  LEPUSExportEntry *me;
  int i;
  for (i = 0; i < m->export_entries_count; i++) {
    me = &m->export_entries[i];
    if (me->export_name == export_name) return me;
  }
  return NULL;
}

QJS_STATIC LEPUSExportEntry *add_export_entry2(
    LEPUSContext *ctx, LEPUSParseState *s, LEPUSModuleDef *m,
    LEPUSAtom local_name, LEPUSAtom export_name,
    LEPUSExportTypeEnum export_type) {
  LEPUSExportEntry *me;

  if (find_export_entry(ctx, m, export_name)) {
    char buf1[ATOM_GET_STR_BUF_SIZE];
    if (s) {
      lepus_parse_error(s, "duplicate exported name '%s'",
                        LEPUS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name));
    } else {
#ifdef LYNX_DEV
      LEPUS_ThrowSyntaxErrorAtom(ctx, "duplicate exported name '%s'",
                                 export_name);
#endif
    }
    return NULL;
  }

  if (lepus_resize_array(ctx, (void **)&m->export_entries,
                         sizeof(LEPUSExportEntry), &m->export_entries_size,
                         &m->export_entries_count, m->export_entries_count + 1))
    return NULL;
  me = &m->export_entries[m->export_entries_count - 1];
  memset(me, 0, sizeof(*me));
  me->local_name = LEPUS_DupAtom(ctx, local_name);
  me->export_name = LEPUS_DupAtom(ctx, export_name);
  me->export_type = export_type;
  return me;
}

QJS_STATIC LEPUSExportEntry *add_export_entry(LEPUSParseState *s,
                                              LEPUSModuleDef *m,
                                              LEPUSAtom local_name,
                                              LEPUSAtom export_name,
                                              LEPUSExportTypeEnum export_type) {
  return add_export_entry2(s->ctx, s, m, local_name, export_name, export_type);
}

QJS_STATIC int add_star_export_entry(LEPUSContext *ctx, LEPUSModuleDef *m,
                                     int req_module_idx) {
  LEPUSStarExportEntry *se;

  if (lepus_resize_array(
          ctx, (void **)&m->star_export_entries, sizeof(LEPUSStarExportEntry),
          &m->star_export_entries_size, &m->star_export_entries_count,
          m->star_export_entries_count + 1))
    return -1;
  se = &m->star_export_entries[m->star_export_entries_count - 1];
  se->req_module_idx = req_module_idx;
  return 0;
}

/* create a C module */
LEPUSModuleDef *LEPUS_NewCModule(LEPUSContext *ctx, const char *name_str,
                                 LEPUSModuleInitFunc *func) {
  LEPUSModuleDef *m;
  LEPUSAtom name;
  name = LEPUS_NewAtom(ctx, name_str);
  if (name == LEPUS_ATOM_NULL) return NULL;
  m = lepus_new_module_def(ctx, name);
  m->init_func = func;
  return m;
}

int LEPUS_AddModuleExport(LEPUSContext *ctx, LEPUSModuleDef *m,
                          const char *export_name) {
  LEPUSExportEntry *me;
  LEPUSAtom name;
  name = LEPUS_NewAtom(ctx, export_name);
  if (name == LEPUS_ATOM_NULL) return -1;
  me = add_export_entry2(ctx, NULL, m, LEPUS_ATOM_NULL, name,
                         LEPUS_EXPORT_TYPE_LOCAL);
  LEPUS_FreeAtom(ctx, name);
  if (!me)
    return -1;
  else
    return 0;
}

int LEPUS_SetModuleExport(LEPUSContext *ctx, LEPUSModuleDef *m,
                          const char *export_name, LEPUSValue val) {
  LEPUSExportEntry *me;
  LEPUSAtom name;
  name = LEPUS_NewAtom(ctx, export_name);
  if (name == LEPUS_ATOM_NULL) goto fail;
  me = find_export_entry(ctx, m, name);
  LEPUS_FreeAtom(ctx, name);
  if (!me) goto fail;
  set_value(ctx, me->u.local.var_ref->pvalue, val);
  return 0;
fail:
  LEPUS_FreeValue(ctx, val);
  return -1;
}

void LEPUS_SetModuleLoaderFunc(LEPUSRuntime *rt,
                               LEPUSModuleNormalizeFunc *module_normalize,
                               LEPUSModuleLoaderFunc *module_loader,
                               void *opaque) {
  rt->module_normalize_func = module_normalize;
  rt->module_loader_func = module_loader;
  rt->module_loader_opaque = opaque;
}

/* default module filename normalizer */
QJS_STATIC char *lepus_default_module_normalize_name(LEPUSContext *ctx,
                                                     const char *base_name,
                                                     const char *name) {
  char *filename, *p;
  const char *r;
  int len;

  if (name[0] != '.') {
    /* if no initial dot, the module name is not modified */
    return lepus_strdup(ctx, name);
  }

  p = const_cast<char *>(strrchr(base_name, '/'));
  if (p)
    len = p - base_name;
  else
    len = 0;

  filename = static_cast<char *>(lepus_malloc(ctx, len + strlen(name) + 1 + 1));
  if (!filename) return NULL;
  memcpy(filename, base_name, len);
  filename[len] = '\0';

  /* we only normalize the leading '..' or '.' */
  r = name;
  for (;;) {
    if (r[0] == '.' && r[1] == '/') {
      r += 2;
    } else if (r[0] == '.' && r[1] == '.' && r[2] == '/') {
      if (filename[0] == '\0') break;
      p = strrchr(filename, '/');
      if (!p) p = filename;
      *p = '\0';
      r += 3;
    } else {
      break;
    }
  }
  if (filename[0] != '\0') strcat(filename, "/");
  strcat(filename, r);
  //    printf("normalize: %s %s -> %s\n", base_name, name, filename);
  return filename;
}

/* return NULL in case of exception (e.g. module could not be loaded) */
QJS_STATIC LEPUSModuleDef *lepus_host_resolve_imported_module(
    LEPUSContext *ctx, LEPUSAtom base_module_name, LEPUSAtom module_name1) {
  LEPUSRuntime *rt = ctx->rt;
  struct list_head *el;
  LEPUSModuleDef *m;
  char *cname;
  const char *base_cname, *cname1;
  LEPUSAtom module_name;

  base_cname = LEPUS_AtomToCString(ctx, base_module_name);
  if (!base_cname) return NULL;
  cname1 = LEPUS_AtomToCString(ctx, module_name1);
  if (!cname1) {
    LEPUS_FreeCString(ctx, base_cname);
    return NULL;
  }

  if (!rt->module_normalize_func) {
    cname = lepus_default_module_normalize_name(ctx, base_cname, cname1);
  } else {
    cname = rt->module_normalize_func(ctx, base_cname, cname1,
                                      rt->module_loader_opaque);
  }
  LEPUS_FreeCString(ctx, base_cname);
  LEPUS_FreeCString(ctx, cname1);
  if (!cname) return NULL;

  module_name = LEPUS_NewAtom(ctx, cname);
  if (module_name == LEPUS_ATOM_NULL) {
    lepus_free(ctx, cname);
    return NULL;
  }

  /* first look at the loaded modules */
  list_for_each(el, &ctx->loaded_modules) {
    m = list_entry(el, LEPUSModuleDef, link);
    if (m->module_name == module_name) {
      lepus_free(ctx, cname);
      LEPUS_FreeAtom(ctx, module_name);
      return m;
    }
  }

  LEPUS_FreeAtom(ctx, module_name);

  /* load the module */
  if (!rt->module_loader_func) {
    /* XXX: use a syntax error ? */
    LEPUS_ThrowReferenceError(ctx, "could not load module '%s'", cname);
    lepus_free(ctx, cname);
    return NULL;
  }

  m = rt->module_loader_func(ctx, cname, rt->module_loader_opaque);
  lepus_free(ctx, cname);
  return m;
}

typedef struct LEPUSResolveEntry {
  LEPUSModuleDef *module;
  LEPUSAtom name;
} LEPUSResolveEntry;

typedef struct LEPUSResolveState {
  LEPUSResolveEntry *array;
  int size;
  int count;
} LEPUSResolveState;

QJS_STATIC int find_resolve_entry(LEPUSResolveState *s, LEPUSModuleDef *m,
                                  LEPUSAtom name) {
  int i;
  for (i = 0; i < s->count; i++) {
    LEPUSResolveEntry *re = &s->array[i];
    if (re->module == m && re->name == name) return i;
  }
  return -1;
}

QJS_STATIC int add_resolve_entry(LEPUSContext *ctx, LEPUSResolveState *s,
                                 LEPUSModuleDef *m, LEPUSAtom name) {
  LEPUSResolveEntry *re;

  if (lepus_resize_array(ctx, (void **)&s->array, sizeof(LEPUSResolveEntry),
                         &s->size, &s->count, s->count + 1))
    return -1;
  re = &s->array[s->count - 1];
  re->module = m;
  re->name = LEPUS_DupAtom(ctx, name);
  return 0;
}

typedef enum LEPUSResolveResultEnum {
  LEPUS_RESOLVE_RES_EXCEPTION = -1, /* memory alloc error */
  LEPUS_RESOLVE_RES_FOUND = 0,
  LEPUS_RESOLVE_RES_NOT_FOUND,
  LEPUS_RESOLVE_RES_CIRCULAR,
  LEPUS_RESOLVE_RES_AMBIGUOUS,
} LEPUSResolveResultEnum;

QJS_STATIC LEPUSResolveResultEnum lepus_resolve_export1(
    LEPUSContext *ctx, LEPUSModuleDef **pmodule, LEPUSExportEntry **pme,
    LEPUSModuleDef *m, LEPUSAtom export_name, LEPUSResolveState *s) {
  LEPUSExportEntry *me;

  *pmodule = NULL;
  *pme = NULL;
  if (find_resolve_entry(s, m, export_name) >= 0)
    return LEPUS_RESOLVE_RES_CIRCULAR;
  if (add_resolve_entry(ctx, s, m, export_name) < 0)
    return LEPUS_RESOLVE_RES_EXCEPTION;
  me = find_export_entry(ctx, m, export_name);
  if (me) {
    if (me->export_type == LEPUS_EXPORT_TYPE_LOCAL) {
      /* local export */
      *pmodule = m;
      *pme = me;
      return LEPUS_RESOLVE_RES_FOUND;
    } else {
      /* indirect export */
      LEPUSModuleDef *m1;
      m1 = m->req_module_entries[me->u.req_module_idx].module;
      if (me->local_name == LEPUS_ATOM__star_) {
        /* export ns from */
        *pmodule = m;
        *pme = me;
        return LEPUS_RESOLVE_RES_FOUND;
      } else {
        return lepus_resolve_export1(ctx, pmodule, pme, m1, me->local_name, s);
      }
    }
  } else {
    if (export_name != LEPUS_ATOM_default) {
      /* not found in direct or indirect exports: try star exports */
      int i;

      for (i = 0; i < m->star_export_entries_count; i++) {
        LEPUSStarExportEntry *se = &m->star_export_entries[i];
        LEPUSModuleDef *m1, *res_m;
        LEPUSExportEntry *res_me;
        LEPUSResolveResultEnum ret;

        m1 = m->req_module_entries[se->req_module_idx].module;
        ret = lepus_resolve_export1(ctx, &res_m, &res_me, m1, export_name, s);
        if (ret == LEPUS_RESOLVE_RES_AMBIGUOUS ||
            ret == LEPUS_RESOLVE_RES_EXCEPTION) {
          return ret;
        } else if (ret == LEPUS_RESOLVE_RES_FOUND) {
          if (*pme != NULL) {
            if (*pmodule != res_m || res_me->local_name != (*pme)->local_name) {
              *pmodule = NULL;
              *pme = NULL;
              return LEPUS_RESOLVE_RES_AMBIGUOUS;
            }
          } else {
            *pmodule = res_m;
            *pme = res_me;
          }
        }
      }
      if (*pme != NULL) return LEPUS_RESOLVE_RES_FOUND;
    }
    return LEPUS_RESOLVE_RES_NOT_FOUND;
  }
}

/* If the return value is LEPUS_RESOLVE_RES_FOUND, return the module
  (*pmodule) and the corresponding local export entry
  (*pme). Otherwise return (NULL, NULL) */
QJS_STATIC LEPUSResolveResultEnum lepus_resolve_export(LEPUSContext *ctx,
                                                       LEPUSModuleDef **pmodule,
                                                       LEPUSExportEntry **pme,
                                                       LEPUSModuleDef *m,
                                                       LEPUSAtom export_name) {
  LEPUSResolveState ss, *s = &ss;
  int i;
  LEPUSResolveResultEnum ret;

  s->array = NULL;
  s->size = 0;
  s->count = 0;

  ret = lepus_resolve_export1(ctx, pmodule, pme, m, export_name, s);

  for (i = 0; i < s->count; i++) LEPUS_FreeAtom(ctx, s->array[i].name);
  lepus_free(ctx, s->array);

  return ret;
}

QJS_STATIC void lepus_resolve_export_throw_error(LEPUSContext *ctx,
                                                 LEPUSResolveResultEnum res,
                                                 LEPUSModuleDef *m,
                                                 LEPUSAtom export_name) {
  char buf1[ATOM_GET_STR_BUF_SIZE];
  char buf2[ATOM_GET_STR_BUF_SIZE];
  switch (res) {
    case LEPUS_RESOLVE_RES_EXCEPTION:
      break;
    default:
    case LEPUS_RESOLVE_RES_NOT_FOUND:
      LEPUS_ThrowSyntaxError(
          ctx, "export '%s' in module '%s' is ambiguous",
          LEPUS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
          LEPUS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
      break;
    case LEPUS_RESOLVE_RES_CIRCULAR:
      LEPUS_ThrowSyntaxError(
          ctx, "Could not find export '%s' in module '%s'",
          LEPUS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
          LEPUS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
      break;
    case LEPUS_RESOLVE_RES_AMBIGUOUS:
      LEPUS_ThrowSyntaxError(
          ctx, "circular reference when looking for export '%s' in module '%s'",
          LEPUS_AtomGetStr(ctx, buf1, sizeof(buf1), export_name),
          LEPUS_AtomGetStr(ctx, buf2, sizeof(buf2), m->module_name));
      break;
  }
}

typedef enum {
  EXPORTED_NAME_AMBIGUOUS,
  EXPORTED_NAME_NORMAL,
  EXPORTED_NAME_NS,
} ExportedNameEntryEnum;

typedef struct ExportedNameEntry {
  LEPUSAtom export_name;
  ExportedNameEntryEnum export_type;
  union {
    LEPUSExportEntry *me;   /* using when the list is built */
    LEPUSVarRef *var_ref;   /* EXPORTED_NAME_NORMAL */
    LEPUSModuleDef *module; /* for EXPORTED_NAME_NS */
  } u;
} ExportedNameEntry;

typedef struct GetExportNamesState {
  LEPUSModuleDef **modules;
  int modules_size;
  int modules_count;

  ExportedNameEntry *exported_names;
  int exported_names_size;
  int exported_names_count;
} GetExportNamesState;

QJS_STATIC int find_exported_name(GetExportNamesState *s, LEPUSAtom name) {
  int i;
  for (i = 0; i < s->exported_names_count; i++) {
    if (s->exported_names[i].export_name == name) return i;
  }
  return -1;
}

QJS_STATIC __exception int get_exported_names(LEPUSContext *ctx,
                                              GetExportNamesState *s,
                                              LEPUSModuleDef *m,
                                              BOOL from_star) {
  ExportedNameEntry *en;
  int i, j;

  /* check circular reference */
  for (i = 0; i < s->modules_count; i++) {
    if (s->modules[i] == m) return 0;
  }
  if (lepus_resize_array(ctx, (void **)&s->modules, sizeof(s->modules[0]),
                         &s->modules_size, &s->modules_count,
                         s->modules_count + 1))
    return -1;
  s->modules[s->modules_count - 1] = m;

  for (i = 0; i < m->export_entries_count; i++) {
    LEPUSExportEntry *me = &m->export_entries[i];
    if (from_star && me->export_name == LEPUS_ATOM_default) continue;
    j = find_exported_name(s, me->export_name);
    if (j < 0) {
      if (lepus_resize_array(ctx, (void **)&s->exported_names,
                             sizeof(s->exported_names[0]),
                             &s->exported_names_size, &s->exported_names_count,
                             s->exported_names_count + 1))
        return -1;
      en = &s->exported_names[s->exported_names_count - 1];
      en->export_name = me->export_name;
      /* avoid a second lookup for simple module exports */
      if (from_star || me->export_type != LEPUS_EXPORT_TYPE_LOCAL)
        en->u.me = NULL;
      else
        en->u.me = me;
    } else {
      en = &s->exported_names[j];
      en->u.me = NULL;
    }
  }
  for (i = 0; i < m->star_export_entries_count; i++) {
    LEPUSStarExportEntry *se = &m->star_export_entries[i];
    LEPUSModuleDef *m1;
    m1 = m->req_module_entries[se->req_module_idx].module;
    if (get_exported_names(ctx, s, m1, TRUE)) return -1;
  }
  return 0;
}

/* Unfortunately, the spec gives a different behavior from GetOwnProperty ! */
QJS_STATIC int lepus_module_ns_has(LEPUSContext *ctx, LEPUSValueConst obj,
                                   LEPUSAtom atom) {
  return (find_own_property1(LEPUS_VALUE_GET_OBJ(obj), atom) != NULL);
}

QJS_STATIC int exported_names_cmp(const void *p1, const void *p2,
                                  void *opaque) {
  LEPUSContext *ctx = static_cast<LEPUSContext *>(opaque);
  const ExportedNameEntry *me1 = static_cast<const ExportedNameEntry *>(p1);
  const ExportedNameEntry *me2 = static_cast<const ExportedNameEntry *>(p2);
  LEPUSValue str1, str2;
  int ret;

  /* XXX: should avoid allocation memory in atom comparison */
  str1 = LEPUS_AtomToString(ctx, me1->export_name);
  str2 = LEPUS_AtomToString(ctx, me2->export_name);
  if (LEPUS_IsException(str1) || LEPUS_IsException(str2)) {
    /* XXX: raise an error ? */
    ret = 0;
  } else {
    ret = lepus_string_compare(ctx, LEPUS_VALUE_GET_STRING(str1),
                               LEPUS_VALUE_GET_STRING(str2));
  }
  LEPUS_FreeValue(ctx, str1);
  LEPUS_FreeValue(ctx, str2);
  return ret;
}

QJS_STATIC LEPUSValue lepus_get_module_ns(LEPUSContext *ctx, LEPUSModuleDef *m);

QJS_STATIC LEPUSValue lepus_module_ns_autoinit(LEPUSContext *ctx,
                                               LEPUSObject *p, LEPUSAtom atom,
                                               void *opaque) {
  LEPUSModuleDef *m = static_cast<LEPUSModuleDef *>(opaque);
  return lepus_get_module_ns(ctx, m);
}

QJS_STATIC LEPUSValue lepus_build_module_ns(LEPUSContext *ctx,
                                            LEPUSModuleDef *m) {
  LEPUSValue obj;
  LEPUSObject *p;
  GetExportNamesState s_s, *s = &s_s;
  int i, ret;
  LEPUSProperty *pr;

  obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_MODULE_NS);
  if (LEPUS_IsException(obj)) return obj;
  p = LEPUS_VALUE_GET_OBJ(obj);

  memset(s, 0, sizeof(*s));
  ret = get_exported_names(ctx, s, m, FALSE);
  lepus_free(ctx, s->modules);
  if (ret) goto fail;

  /* Resolve the exported names. The ambiguous exports are removed */
  for (i = 0; i < s->exported_names_count; i++) {
    ExportedNameEntry *en = &s->exported_names[i];
    LEPUSResolveResultEnum res;
    LEPUSExportEntry *res_me;
    LEPUSModuleDef *res_m;

    if (en->u.me) {
      res_me = en->u.me; /* fast case: no resolution needed */
      res_m = m;
      res = LEPUS_RESOLVE_RES_FOUND;
    } else {
      res = lepus_resolve_export(ctx, &res_m, &res_me, m, en->export_name);
    }
    if (res != LEPUS_RESOLVE_RES_FOUND) {
      if (res != LEPUS_RESOLVE_RES_AMBIGUOUS) {
        lepus_resolve_export_throw_error(ctx, res, m, en->export_name);
        goto fail;
      }
      en->export_type = EXPORTED_NAME_AMBIGUOUS;
    } else {
      if (res_me->local_name == LEPUS_ATOM__star_) {
        en->export_type = EXPORTED_NAME_NS;
        en->u.module =
            res_m->req_module_entries[res_me->u.req_module_idx].module;
      } else {
        en->export_type = EXPORTED_NAME_NORMAL;
        if (res_me->u.local.var_ref) {
          en->u.var_ref = res_me->u.local.var_ref;
        } else {
          LEPUSObject *p1 = LEPUS_VALUE_GET_OBJ(res_m->func_obj);
          p1 = LEPUS_VALUE_GET_OBJ(res_m->func_obj);
          en->u.var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];
        }
      }
    }
  }

  /* sort the exported names */
  rqsort(s->exported_names, s->exported_names_count,
         sizeof(s->exported_names[0]), exported_names_cmp, ctx);

  for (i = 0; i < s->exported_names_count; i++) {
    ExportedNameEntry *en = &s->exported_names[i];
    switch (en->export_type) {
      case EXPORTED_NAME_NORMAL: {
        LEPUSVarRef *var_ref = en->u.var_ref;
        pr = add_property(
            ctx, p, en->export_name,
            LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE | LEPUS_PROP_VARREF);
        if (!pr) goto fail;
        var_ref->header.ref_count++;
        pr->u.var_ref = var_ref;
      } break;
      case EXPORTED_NAME_NS:
        /* the exported namespace must be created on demand */
        if (LEPUS_DefineAutoInitProperty(
                ctx, obj, en->export_name, lepus_module_ns_autoinit,
                en->u.module, LEPUS_PROP_ENUMERABLE | LEPUS_PROP_WRITABLE) < 0)
          goto fail;
        break;
      default:
        break;
    }
  }

  lepus_free(ctx, s->exported_names);

  LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_Symbol_toStringTag,
                            LEPUS_AtomToString(ctx, LEPUS_ATOM_Module), 0);

  p->extensible = FALSE;
  return obj;
fail:
  lepus_free(ctx, s->exported_names);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_get_module_ns(LEPUSContext *ctx,
                                          LEPUSModuleDef *m) {
  if (LEPUS_IsUndefined(m->module_ns)) {
    LEPUSValue val;
    val = lepus_build_module_ns(ctx, m);
    if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
    m->module_ns = val;
  }
  return LEPUS_DupValue(ctx, m->module_ns);
}

/* Load all the required modules for module 'm' */
QJS_STATIC int lepus_resolve_module(LEPUSContext *ctx, LEPUSModuleDef *m) {
  int i;
  LEPUSModuleDef *m1;

  if (m->resolved) return 0;
#ifdef DUMP_MODULE_RESOLVE
  {
    char buf1[ATOM_GET_STR_BUF_SIZE];
    printf("resolving module '%s':\n",
           LEPUS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
  }
#endif
  m->resolved = TRUE;
  /* resolve each requested module */
  for (i = 0; i < m->req_module_entries_count; i++) {
    LEPUSReqModuleEntry *rme = &m->req_module_entries[i];
    m1 = lepus_host_resolve_imported_module(ctx, m->module_name,
                                            rme->module_name);
    if (!m1) return -1;
    rme->module = m1;
    /* already done in lepus_host_resolve_imported_module() except if
       the module was loaded with LEPUS_EvalBinary() */
    if (lepus_resolve_module(ctx, m1) < 0) return -1;
  }
  return 0;
}

QJS_STATIC LEPUSVarRef *lepus_create_module_var(LEPUSContext *ctx,
                                                BOOL is_lexical) {
  LEPUSVarRef *var_ref;
  var_ref = static_cast<LEPUSVarRef *>(lepus_malloc(ctx, sizeof(LEPUSVarRef)));
  if (!var_ref) return NULL;
  var_ref->header.ref_count = 1;
  var_ref->gc_header.mark = 0;
  var_ref->link.prev = NULL;
  var_ref->link.next = NULL;
  if (is_lexical)
    var_ref->value = LEPUS_UNINITIALIZED;
  else
    var_ref->value = LEPUS_UNDEFINED;
  var_ref->pvalue = &var_ref->value;
  return var_ref;
}

/* Create the <eval> function associated with the module */
QJS_STATIC int lepus_create_module_function(LEPUSContext *ctx,
                                            LEPUSModuleDef *m) {
  LEPUSFunctionBytecode *b;
  int i;
  LEPUSVarRef **var_refs;
  LEPUSValue func_obj, bfunc;
  LEPUSObject *p;

  bfunc = m->func_obj;
  func_obj = LEPUS_NewObjectProtoClass(ctx, ctx->function_proto,
                                       LEPUS_CLASS_BYTECODE_FUNCTION);

  if (LEPUS_IsException(func_obj)) return -1;
  b = static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(bfunc));

  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->u.func.function_bytecode = b;
  b->header.ref_count++;
  p->u.func.home_object = NULL;
  p->u.func.var_refs = NULL;
  if (b->closure_var_count) {
    var_refs = static_cast<LEPUSVarRef **>(
        lepus_mallocz(ctx, sizeof(var_refs[0]) * b->closure_var_count));
    if (!var_refs) goto fail;
    p->u.func.var_refs = var_refs;

    /* create the global variables. The other variables are
       imported from other modules */
    for (i = 0; i < b->closure_var_count; i++) {
      LEPUSClosureVar *cv = &b->closure_var[i];
      LEPUSVarRef *var_ref;
      if (cv->is_local) {
        var_ref = lepus_create_module_var(ctx, cv->is_lexical);
        if (!var_ref) goto fail;
#ifdef DUMP_MODULE_RESOLVE
        printf("local %d: %p\n", i, var_ref);
#endif
        var_refs[i] = var_ref;
      }
    }
  }
  m->func_obj = func_obj;
  LEPUS_FreeValue(ctx, bfunc);
  return 0;
fail:
  LEPUS_FreeValue(ctx, func_obj);
  return -1;
}

/* Prepare a module to be executed by resolving all the imported
   variables. */
QJS_STATIC int lepus_link_module(LEPUSContext *ctx, LEPUSModuleDef *m) {
  int i;
  LEPUSImportEntry *mi;
  LEPUSModuleDef *m1;
  LEPUSVarRef **var_refs, *var_ref;
  LEPUSObject *p;
  BOOL is_c_module;
  LEPUSValue ret_val;

  if (m->instantiated) return 0;
  m->instantiated = TRUE;

  is_c_module = (m->init_func != NULL);

  if (is_c_module) {
    /* initialize the exported variables */
    for (i = 0; i < m->export_entries_count; i++) {
      LEPUSExportEntry *me = &m->export_entries[i];
      if (me->export_type == LEPUS_EXPORT_TYPE_LOCAL) {
        var_ref = lepus_create_module_var(ctx, FALSE);
        if (!var_ref) goto fail;
        me->u.local.var_ref = var_ref;
      }
    }
  } else {
    if (lepus_create_module_function(ctx, m) < 0) goto fail;
  }

  for (i = 0; i < m->req_module_entries_count; i++) {
    LEPUSReqModuleEntry *rme = &m->req_module_entries[i];
    if (lepus_link_module(ctx, rme->module) < 0) goto fail;
  }

#ifdef DUMP_MODULE_RESOLVE
  {
    char buf1[ATOM_GET_STR_BUF_SIZE];
    printf("instantiating module '%s':\n",
           LEPUS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
  }
#endif
  /* check the indirect exports */
  for (i = 0; i < m->export_entries_count; i++) {
    LEPUSExportEntry *me = &m->export_entries[i];
    if (me->export_type == LEPUS_EXPORT_TYPE_INDIRECT &&
        me->local_name != LEPUS_ATOM__star_) {
      LEPUSResolveResultEnum ret;
      LEPUSExportEntry *res_me;
      LEPUSModuleDef *res_m, *m1;
      m1 = m->req_module_entries[me->u.req_module_idx].module;
      ret = lepus_resolve_export(ctx, &res_m, &res_me, m1, me->local_name);
      if (ret != LEPUS_RESOLVE_RES_FOUND) {
        lepus_resolve_export_throw_error(ctx, ret, m, me->export_name);
        goto fail;
      }
    }
  }

#ifdef DUMP_MODULE_RESOLVE
  {
    printf("exported bindings:\n");
    for (i = 0; i < m->export_entries_count; i++) {
      LEPUSExportEntry *me = &m->export_entries[i];
      printf(" name=");
      print_atom(ctx, me->export_name);
      printf(" local=");
      print_atom(ctx, me->local_name);
      printf(" type=%d idx=%d\n", me->export_type, me->u.local.var_idx);
    }
  }
#endif

  if (!is_c_module) {
    p = LEPUS_VALUE_GET_OBJ(m->func_obj);
    var_refs = p->u.func.var_refs;

    for (i = 0; i < m->import_entries_count; i++) {
      mi = &m->import_entries[i];
#ifdef DUMP_MODULE_RESOLVE
      printf("import var_idx=%d name=", mi->var_idx);
      print_atom(ctx, mi->import_name);
      printf(": ");
#endif
      m1 = m->req_module_entries[mi->req_module_idx].module;
      if (mi->import_name == LEPUS_ATOM__star_) {
        LEPUSValue val;
        /* name space import */
        val = lepus_get_module_ns(ctx, m1);
        if (LEPUS_IsException(val)) goto fail;
        set_value(ctx, &var_refs[mi->var_idx]->value, val);
#ifdef DUMP_MODULE_RESOLVE
        printf("namespace\n");
#endif
      } else {
        LEPUSResolveResultEnum ret;
        LEPUSExportEntry *res_me;
        LEPUSModuleDef *res_m;
        LEPUSObject *p1;

        ret = lepus_resolve_export(ctx, &res_m, &res_me, m1, mi->import_name);
        if (ret != LEPUS_RESOLVE_RES_FOUND) {
          lepus_resolve_export_throw_error(ctx, ret, m1, mi->import_name);
          goto fail;
        }
        if (res_me->local_name == LEPUS_ATOM__star_) {
          LEPUSValue val;
          LEPUSModuleDef *m2;
          /* name space import from */
          m2 = res_m->req_module_entries[res_me->u.req_module_idx].module;
          val = lepus_get_module_ns(ctx, m2);
          if (LEPUS_IsException(val)) goto fail;
          var_ref = lepus_create_module_var(ctx, TRUE);
          if (!var_ref) {
            LEPUS_FreeValue(ctx, val);
            goto fail;
          }
          set_value(ctx, &var_ref->value, val);
          var_refs[mi->var_idx] = var_ref;
#ifdef DUMP_MODULE_RESOLVE
          printf("namespace from\n");
#endif
        } else {
          var_ref = res_me->u.local.var_ref;
          if (!var_ref) {
            p1 = LEPUS_VALUE_GET_OBJ(res_m->func_obj);
            var_ref = p1->u.func.var_refs[res_me->u.local.var_idx];
          }
          var_ref->header.ref_count++;
          var_refs[mi->var_idx] = var_ref;
#ifdef DUMP_MODULE_RESOLVE
          printf("local export (var_ref=%p)\n", var_ref);
#endif
        }
      }
    }

    /* keep the exported variables in the module export entries (they
       are used when the eval function is deleted and cannot be
       initialized before in case imports are exported) */
    for (i = 0; i < m->export_entries_count; i++) {
      LEPUSExportEntry *me = &m->export_entries[i];
      if (me->export_type == LEPUS_EXPORT_TYPE_LOCAL) {
        var_ref = var_refs[me->u.local.var_idx];
        var_ref->header.ref_count++;
        me->u.local.var_ref = var_ref;
      }
    }
  }

#ifdef DUMP_MODULE_RESOLVE
  printf("done instantiate\n");
#endif
  return 0;
fail:
  return -1;
}

LEPUSValue lepus_dynamic_import(LEPUSContext *ctx, LEPUSValueConst specifier) {
  LEPUSStackFrame *sf;
  LEPUSFunctionBytecode *b;
  LEPUSObject *p;
  LEPUSModuleDef *m;
  LEPUSAtom basename, filename;
  LEPUSValue promise, resolving_funcs[2];
  LEPUSValue specifierString, ret, func_obj, err, ns;

  promise = LEPUS_NewPromiseCapability(ctx, resolving_funcs);
  if (LEPUS_IsException(promise)) return promise;

  /* XXX: currently we just use the filename of the englobing
     function. It does not work for eval(). Need to add a
     ScriptOrModule info in LEPUSFunctionBytecode */
  sf = ctx->rt->current_stack_frame;
  assert(sf != NULL);
  assert(LEPUS_VALUE_IS_OBJECT(sf->cur_func));
  p = LEPUS_VALUE_GET_OBJ(sf->cur_func);
  assert(lepus_class_has_bytecode(p->class_id));
  b = p->u.func.function_bytecode;
  if (!b->has_debug) {
    LEPUS_ThrowTypeError(ctx, "no function filename for import()");
    goto exception;
  }
  basename = b->debug.filename;

  specifierString = LEPUS_ToString(ctx, specifier);
  if (LEPUS_IsException(specifierString)) goto exception;
  filename = lepus_value_to_atom(ctx, specifierString);
  LEPUS_FreeValue(ctx, specifierString);
  if (filename == LEPUS_ATOM_NULL) goto exception;

  m = lepus_host_resolve_imported_module(ctx, basename, filename);
  LEPUS_FreeAtom(ctx, filename);
  if (!m) {
    goto exception;
  }

  if (lepus_resolve_module(ctx, m) < 0) {
    lepus_free_modules(ctx, LEPUS_FREE_MODULE_NOT_RESOLVED);
    goto exception;
  }

  /* Evaluate the module code */
  func_obj = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_MODULE, m));
  ret = LEPUS_EvalFunction(ctx, func_obj, ctx->global_obj);
  if (LEPUS_IsException(ret)) goto exception;
  LEPUS_FreeValue(ctx, ret);

  /* return the module namespace */
  ns = lepus_get_module_ns(ctx, m);
  if (LEPUS_IsException(ret)) goto exception;

  ret = LEPUS_Call(ctx, resolving_funcs[0], LEPUS_UNDEFINED, 1,
                   (LEPUSValueConst *)&ns);
  LEPUS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
  LEPUS_FreeValue(ctx, ns);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  return promise;

exception:
  err = LEPUS_GetException(ctx);
  ret = LEPUS_Call(ctx, resolving_funcs[1], LEPUS_UNDEFINED, 1,
                   (LEPUSValueConst *)&err);
  LEPUS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
  LEPUS_FreeValue(ctx, err);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  return promise;
}

/* Run the <eval> function of the module and of all its requested
   modules. */
QJS_STATIC LEPUSValue lepus_evaluate_module(LEPUSContext *ctx,
                                            LEPUSModuleDef *m) {
  LEPUSModuleDef *m1;
  int i;
  LEPUSValue ret_val;

  if (m->eval_mark) return LEPUS_UNDEFINED; /* avoid cycles */

  if (m->evaluated) {
    /* if the module was already evaluated, rethrow the exception
       it raised */
    if (m->eval_has_exception) {
      return LEPUS_Throw(ctx, LEPUS_DupValue(ctx, m->eval_exception));
    } else {
      return LEPUS_UNDEFINED;
    }
  }

  m->eval_mark = TRUE;

  for (i = 0; i < m->req_module_entries_count; i++) {
    LEPUSReqModuleEntry *rme = &m->req_module_entries[i];
    m1 = rme->module;
    if (!m1->eval_mark) {
      ret_val = lepus_evaluate_module(ctx, m1);
      if (LEPUS_IsException(ret_val)) {
        m->eval_mark = FALSE;
        return ret_val;
      }
      LEPUS_FreeValue(ctx, ret_val);
    }
  }

  if (m->init_func) {
    /* C module init */
    if (m->init_func(ctx, m) < 0)
      ret_val = LEPUS_EXCEPTION;
    else
      ret_val = LEPUS_UNDEFINED;
  } else {
    ret_val = LEPUS_CallFree(ctx, m->func_obj, LEPUS_UNDEFINED, 0, NULL);
    m->func_obj = LEPUS_UNDEFINED;
  }
  if (LEPUS_IsException(ret_val)) {
    /* save the thrown exception value */
    m->eval_has_exception = TRUE;
    m->eval_exception = LEPUS_DupValue(ctx, ctx->rt->current_exception);
  }
  m->eval_mark = FALSE;
  m->evaluated = TRUE;
  return ret_val;
}

QJS_STATIC __exception LEPUSAtom lepus_parse_from_clause(LEPUSParseState *s) {
  LEPUSAtom module_name;
  if (!token_is_pseudo_keyword(s, LEPUS_ATOM_from)) {
    lepus_parse_error(s, "from clause expected");
    return LEPUS_ATOM_NULL;
  }
  if (next_token(s)) return LEPUS_ATOM_NULL;
  if (s->token.val != TOK_STRING) {
    lepus_parse_error(s, "string expected");
    return LEPUS_ATOM_NULL;
  }
  module_name = lepus_value_to_atom(s->ctx, s->token.u.str.str);
  if (module_name == LEPUS_ATOM_NULL) return LEPUS_ATOM_NULL;
  if (next_token(s)) {
    LEPUS_FreeAtom(s->ctx, module_name);
    return LEPUS_ATOM_NULL;
  }
  return module_name;
}

QJS_STATIC __exception int lepus_parse_export(LEPUSParseState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSModuleDef *m = s->cur_func->module;
  LEPUSAtom local_name, export_name;
  int first_export, idx, i, tok;
  LEPUSAtom module_name;
  LEPUSExportEntry *me;

  if (next_token(s)) return -1;

  tok = s->token.val;
  if (tok == TOK_CLASS) {
    return lepus_parse_class(s, FALSE, LEPUS_PARSE_EXPORT_NAMED);
  } else if (tok == TOK_FUNCTION ||
             (token_is_pseudo_keyword(s, LEPUS_ATOM_async) &&
              peek_token(s, TRUE) == TOK_FUNCTION)) {
    return lepus_parse_function_decl2(
        s, LEPUS_PARSE_FUNC_STATEMENT, LEPUS_FUNC_NORMAL, LEPUS_ATOM_NULL,
        s->token.ptr, s->token.line_num, LEPUS_PARSE_EXPORT_NAMED, NULL);
  }

  if (next_token(s)) return -1;

  switch (tok) {
    case '{':
      first_export = m->export_entries_count;
      while (s->token.val != '}') {
        if (!token_is_ident(s->token.val)) {
          lepus_parse_error(s, "identifier expected");
          return -1;
        }
        local_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
        export_name = LEPUS_ATOM_NULL;
        if (next_token(s)) goto fail;
        if (token_is_pseudo_keyword(s, LEPUS_ATOM_as)) {
          if (next_token(s)) goto fail;
          if (!token_is_ident(s->token.val)) {
            lepus_parse_error(s, "identifier expected");
            goto fail;
          }
          export_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
          if (next_token(s)) {
          fail:
            LEPUS_FreeAtom(ctx, local_name);
          fail1:
            LEPUS_FreeAtom(ctx, export_name);
            return -1;
          }
        } else {
          export_name = LEPUS_DupAtom(ctx, local_name);
        }
        me = add_export_entry(s, m, local_name, export_name,
                              LEPUS_EXPORT_TYPE_LOCAL);
        LEPUS_FreeAtom(ctx, local_name);
        LEPUS_FreeAtom(ctx, export_name);
        if (!me) return -1;
        if (s->token.val != ',') break;
        if (next_token(s)) return -1;
      }
      if (lepus_parse_expect(s, '}')) return -1;
      if (token_is_pseudo_keyword(s, LEPUS_ATOM_from)) {
        module_name = lepus_parse_from_clause(s);
        if (module_name == LEPUS_ATOM_NULL) return -1;
        idx = add_req_module_entry(ctx, m, module_name);
        LEPUS_FreeAtom(ctx, module_name);
        if (idx < 0) return -1;
        for (i = first_export; i < m->export_entries_count; i++) {
          me = &m->export_entries[i];
          me->export_type = LEPUS_EXPORT_TYPE_INDIRECT;
          me->u.req_module_idx = idx;
        }
      }
      break;
    case '*':
      if (token_is_pseudo_keyword(s, LEPUS_ATOM_as)) {
        /* export ns from */
        if (next_token(s)) return -1;
        if (!token_is_ident(s->token.val)) {
          lepus_parse_error(s, "identifier expected");
          return -1;
        }
        export_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
        if (next_token(s)) goto fail1;
        module_name = lepus_parse_from_clause(s);
        if (module_name == LEPUS_ATOM_NULL) goto fail1;
        idx = add_req_module_entry(ctx, m, module_name);
        LEPUS_FreeAtom(ctx, module_name);
        if (idx < 0) goto fail1;
        me = add_export_entry(s, m, LEPUS_ATOM__star_, export_name,
                              LEPUS_EXPORT_TYPE_INDIRECT);
        LEPUS_FreeAtom(ctx, export_name);
        if (!me) return -1;
        me->u.req_module_idx = idx;
      } else {
        module_name = lepus_parse_from_clause(s);
        if (module_name == LEPUS_ATOM_NULL) return -1;
        idx = add_req_module_entry(ctx, m, module_name);
        LEPUS_FreeAtom(ctx, module_name);
        if (idx < 0) return -1;
        if (add_star_export_entry(ctx, m, idx) < 0) return -1;
      }
      break;
    case TOK_DEFAULT:
      if (s->token.val == TOK_CLASS) {
        return lepus_parse_class(s, FALSE, LEPUS_PARSE_EXPORT_DEFAULT);
      } else if (s->token.val == TOK_FUNCTION ||
                 (token_is_pseudo_keyword(s, LEPUS_ATOM_async) &&
                  peek_token(s, TRUE) == TOK_FUNCTION)) {
        return lepus_parse_function_decl2(
            s, LEPUS_PARSE_FUNC_STATEMENT, LEPUS_FUNC_NORMAL, LEPUS_ATOM_NULL,
            s->token.ptr, s->token.line_num, LEPUS_PARSE_EXPORT_DEFAULT, NULL);
      } else {
        if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) return -1;
      }
      /* set the name of anonymous functions */
      set_object_name(s, LEPUS_ATOM_default);

      /* store the value in the _default_ global variable and export
         it */
      local_name = LEPUS_ATOM__default_;
      if (define_var(s, s->cur_func, local_name, LEPUS_VAR_DEF_LET) < 0)
        return -1;
      emit_op(s, OP_scope_put_var_init);
      emit_atom(s, local_name);
      emit_u16(s, 0);

      if (!add_export_entry(s, m, local_name, LEPUS_ATOM_default,
                            LEPUS_EXPORT_TYPE_LOCAL))
        return -1;
      break;
    case TOK_VAR:
    case TOK_LET:
    case TOK_CONST:
      return lepus_parse_var(s, TRUE, tok, TRUE);
    default:
      return lepus_parse_error(s, "invalid export syntax");
  }
  return lepus_parse_expect_semi(s);
}

QJS_STATIC int add_closure_var(LEPUSContext *ctx, LEPUSFunctionDef *s,
                               BOOL is_local, BOOL is_arg, int var_idx,
                               LEPUSAtom var_name, BOOL is_const,
                               BOOL is_lexical, LEPUSVarKindEnum var_kind);

QJS_STATIC int add_import(LEPUSParseState *s, LEPUSModuleDef *m,
                          LEPUSAtom local_name, LEPUSAtom import_name) {
  LEPUSContext *ctx = s->ctx;
  int i, var_idx;
  LEPUSImportEntry *mi;
  BOOL is_local;

  if (local_name == LEPUS_ATOM_arguments || local_name == LEPUS_ATOM_eval)
    return lepus_parse_error(s, "invalid import binding");

  if (local_name != LEPUS_ATOM_default) {
    for (i = 0; i < s->cur_func->closure_var_count; i++) {
      if (s->cur_func->closure_var[i].var_name == local_name)
        return lepus_parse_error(s, "duplicate import binding");
    }
  }

  is_local = (import_name == LEPUS_ATOM__star_);
  var_idx = add_closure_var(ctx, s->cur_func, is_local, FALSE,
                            m->import_entries_count, local_name, TRUE, TRUE,
                            static_cast<LEPUSVarKindEnum>(FALSE));
  if (var_idx < 0) return -1;
  if (lepus_resize_array(ctx, (void **)&m->import_entries,
                         sizeof(LEPUSImportEntry), &m->import_entries_size,
                         &m->import_entries_count, m->import_entries_count + 1))
    return -1;
  mi = &m->import_entries[m->import_entries_count - 1];
  mi->import_name = LEPUS_DupAtom(ctx, import_name);
  mi->var_idx = var_idx;
  return 0;
}

QJS_STATIC __exception int lepus_parse_import(LEPUSParseState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSModuleDef *m = s->cur_func->module;
  LEPUSAtom local_name, import_name, module_name;
  int first_import, i, idx;

  if (next_token(s)) return -1;

  first_import = m->import_entries_count;
  if (s->token.val == TOK_STRING) {
    module_name = lepus_value_to_atom(ctx, s->token.u.str.str);
    if (module_name == LEPUS_ATOM_NULL) return -1;
    if (next_token(s)) {
      LEPUS_FreeAtom(ctx, module_name);
      return -1;
    }
  } else {
    if (s->token.val == TOK_IDENT) {
      if (s->token.u.ident.is_reserved) {
        return lepus_parse_error_reserved_identifier(s);
      }
      /* "default" import */
      local_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
      import_name = LEPUS_ATOM_default;
      if (next_token(s)) goto fail;
      if (add_import(s, m, local_name, import_name)) goto fail;
      LEPUS_FreeAtom(ctx, local_name);

      if (s->token.val != ',') goto end_import_clause;
      if (next_token(s)) return -1;
    }

    if (s->token.val == '*') {
      /* name space import */
      if (next_token(s)) return -1;
      if (!token_is_pseudo_keyword(s, LEPUS_ATOM_as))
        return lepus_parse_error(s, "expecting 'as'");
      if (next_token(s)) return -1;
      local_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
      import_name = LEPUS_ATOM__star_;
      if (next_token(s)) goto fail;
      if (add_import(s, m, local_name, import_name)) goto fail;
      LEPUS_FreeAtom(ctx, local_name);
    } else if (s->token.val == '{') {
      if (next_token(s)) return -1;

      while (s->token.val != '}') {
        if (!token_is_ident(s->token.val)) {
          lepus_parse_error(s, "identifier expected");
          return -1;
        }
        import_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
        local_name = LEPUS_ATOM_NULL;
        if (next_token(s)) goto fail;
        if (token_is_pseudo_keyword(s, LEPUS_ATOM_as)) {
          if (next_token(s)) goto fail;
          if (!token_is_ident(s->token.val)) {
            lepus_parse_error(s, "identifier expected");
            goto fail;
          }
          local_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
          if (next_token(s)) {
          fail:
            LEPUS_FreeAtom(ctx, local_name);
            LEPUS_FreeAtom(ctx, import_name);
            return -1;
          }
        } else {
          local_name = LEPUS_DupAtom(ctx, import_name);
        }
        if (add_import(s, m, local_name, import_name)) goto fail;
        LEPUS_FreeAtom(ctx, local_name);
        LEPUS_FreeAtom(ctx, import_name);
        if (s->token.val != ',') break;
        if (next_token(s)) return -1;
      }
      if (lepus_parse_expect(s, '}')) return -1;
    }
  end_import_clause:
    module_name = lepus_parse_from_clause(s);
    if (module_name == LEPUS_ATOM_NULL) return -1;
  }
  idx = add_req_module_entry(ctx, m, module_name);
  LEPUS_FreeAtom(ctx, module_name);
  if (idx < 0) return -1;
  for (i = first_import; i < m->import_entries_count; i++)
    m->import_entries[i].req_module_idx = idx;

  return lepus_parse_expect_semi(s);
}

QJS_STATIC __exception int lepus_parse_source_element(LEPUSParseState *s) {
  LEPUSFunctionDef *fd = s->cur_func;
  int tok;

  if (s->token.val == TOK_FUNCTION ||
      (token_is_pseudo_keyword(s, LEPUS_ATOM_async) &&
       peek_token(s, TRUE) == TOK_FUNCTION)) {
    if (lepus_parse_function_decl(s, LEPUS_PARSE_FUNC_STATEMENT,
                                  LEPUS_FUNC_NORMAL, LEPUS_ATOM_NULL,
                                  s->token.ptr, s->token.line_num))
      return -1;
  } else if (s->token.val == TOK_EXPORT && fd->module) {
    if (lepus_parse_export(s)) return -1;
  } else if (s->token.val == TOK_IMPORT && fd->module &&
             ((tok = peek_token(s, FALSE)) != '(' && tok != '.')) {
    /* the peek_token is needed to avoid confusion with ImportCall
       (dynamic import) */
    if (lepus_parse_import(s)) return -1;
  } else {
    if (lepus_parse_statement_or_decl(s, DECL_MASK_ALL)) return -1;
  }
  return 0;
}

QJS_STATIC LEPUSFunctionDef *lepus_new_function_def(
    LEPUSContext *ctx, LEPUSFunctionDef *parent, BOOL is_eval,
    BOOL is_func_expr, const char *filename, int line_num) {
  LEPUSFunctionDef *fd;

  fd = static_cast<LEPUSFunctionDef *>(lepus_mallocz(ctx, sizeof(*fd)));
  if (!fd) return NULL;

  fd->ctx = ctx;
  init_list_head(&fd->child_list);

  /* insert in parent list */
  fd->parent = parent;
  fd->parent_cpool_idx = -1;
  if (parent) {
    list_add_tail(&fd->link, &parent->child_list);
    fd->lepus_mode = parent->lepus_mode;
    fd->parent_scope_level = parent->scope_level;
  }

  fd->is_eval = is_eval;
  fd->is_func_expr = is_func_expr;
  lepus_dbuf_init(ctx, &fd->byte_code);
  fd->last_opcode_pos = -1;
  fd->func_name = LEPUS_ATOM_NULL;
  fd->var_object_idx = -1;
  fd->arg_var_object_idx = -1;
  fd->arguments_var_idx = -1;
  fd->arguments_arg_idx = -1;
  fd->func_var_idx = -1;
  fd->eval_ret_idx = -1;
  fd->this_var_idx = -1;
  fd->new_target_var_idx = -1;
  fd->this_active_func_var_idx = -1;
  fd->home_object_var_idx = -1;

  /* XXX: should distinguish arg, var and var object and body scopes */
  fd->scope_level = 0; /* 0: var/arg scope, 1:body scope */
  fd->scope_first = -1;
  fd->body_scope = -1;
  fd->scopes = fd->def_scope_array;
  fd->scope_size = countof(fd->def_scope_array);
  fd->scope_count = 1;
  fd->scopes[0].first = -1;
  fd->scopes[0].parent = -1;

  fd->filename = LEPUS_NewAtom(ctx, filename);
  fd->line_num = line_num;

  lepus_dbuf_init(ctx, &fd->pc2line);
  // fd->pc2line_last_line_num = line_num;
  // fd->pc2line_last_pc = 0;
  fd->last_opcode_line_num = line_num;

  return fd;
}
#endif

QJS_STATIC void free_bytecode_atoms(LEPUSRuntime *rt, const uint8_t *bc_buf,
                                    int bc_len, BOOL use_short_opcodes) {
  int pos, len, op;
  LEPUSAtom atom;
  const LEPUSOpCode *oi;

  pos = 0;
  while (pos < bc_len) {
    op = bc_buf[pos];
    if (use_short_opcodes)
      oi = &short_opcode_info(op);
    else
      oi = &opcode_info[op];

    len = oi->size;
    switch (oi->fmt) {
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
      case OP_FMT_atom_u16:
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        atom = get_u32(bc_buf + pos + 1);
        LEPUS_FreeAtomRT(rt, atom);
        break;
      default:
        break;
    }
    pos += len;
  }
}

#ifndef NO_QUICKJS_COMPILER
QJS_STATIC void lepus_free_function_def(LEPUSContext *ctx,
                                        LEPUSFunctionDef *fd) {
  int i;
  struct list_head *el, *el1;

  /* free the child functions */
  list_for_each_safe(el, el1, &fd->child_list) {
    LEPUSFunctionDef *fd1;
    fd1 = list_entry(el, LEPUSFunctionDef, link);
    lepus_free_function_def(ctx, fd1);
  }

  free_bytecode_atoms(ctx->rt, fd->byte_code.buf, fd->byte_code.size,
                      fd->use_short_opcodes);
  dbuf_free(&fd->byte_code);
  lepus_free(ctx, fd->jump_slots);
  lepus_free(ctx, fd->label_slots);
  lepus_free(ctx, fd->line_number_slots);

  for (i = 0; i < fd->cpool_count; i++) {
    LEPUS_FreeValue(ctx, fd->cpool[i]);
  }
  lepus_free(ctx, fd->cpool);

  LEPUS_FreeAtom(ctx, fd->func_name);

  for (i = 0; i < fd->var_count; i++) {
    LEPUS_FreeAtom(ctx, fd->vars[i].var_name);
  }
  lepus_free(ctx, fd->vars);
  for (i = 0; i < fd->arg_count; i++) {
    LEPUS_FreeAtom(ctx, fd->args[i].var_name);
  }
  lepus_free(ctx, fd->args);

  for (i = 0; i < fd->hoisted_def_count; i++) {
    LEPUS_FreeAtom(ctx, fd->hoisted_def[i].var_name);
  }
  lepus_free(ctx, fd->hoisted_def);

  for (i = 0; i < fd->closure_var_count; i++) {
    LEPUSClosureVar *cv = &fd->closure_var[i];
    LEPUS_FreeAtom(ctx, cv->var_name);
  }
  lepus_free(ctx, fd->closure_var);

  if (fd->scopes != fd->def_scope_array) lepus_free(ctx, fd->scopes);

  LEPUS_FreeAtom(ctx, fd->filename);
  dbuf_free(&fd->pc2line);

  lepus_free(ctx, fd->source);

  if (fd->parent) {
    /* remove in parent list */
    list_del(&fd->link);
  }
  lepus_free(ctx, fd);
}

#ifdef DUMP_BYTECODE
static const char *skip_lines(const char *p, int n) {
  while (n-- > 0 && *p) {
    while (*p && *p++ != '\n') continue;
  }
  return p;
}

static void print_lines(const char *source, int line, int line1) {
  const char *s = source;
  const char *p = skip_lines(s, line);
  if (*p) {
    while (line++ < line1) {
      p = skip_lines(s = p, 1);
      printf(";; %.*s", (int)(p - s), s);
      if (!*p) {
        if (p[-1] != '\n') printf("\n");
        break;
      }
    }
  }
}

static void dump_byte_code(LEPUSContext *ctx, int pass, const uint8_t *tab,
                           int len, const LEPUSVarDef *args, int arg_count,
                           const LEPUSVarDef *vars, int var_count,
                           const LEPUSClosureVar *closure_var,
                           int closure_var_count, const LEPUSValue *cpool,
                           uint32_t cpool_count, const char *source,
                           int line_num, const LabelSlot *label_slots,
                           LEPUSFunctionBytecode *b) {
  const LEPUSOpCode *oi;
  int pos, pos_next, op, size, idx, addr, line, line1, in_source;
  uint8_t *bits =
      static_cast<uint8_t *>(lepus_mallocz(ctx, len * sizeof(*bits)));
  BOOL use_short_opcodes = (b != NULL);

  /* scan for jump targets */
  for (pos = 0; pos < len; pos = pos_next) {
    op = tab[pos];
    if (use_short_opcodes)
      oi = &short_opcode_info(op);
    else
      oi = &opcode_info[op];
    pos_next = pos + oi->size;
    if (op < OP_COUNT) {
      switch (oi->fmt) {
#if SHORT_OPCODES
        case OP_FMT_label8:
          pos++;
          addr = (int8_t)tab[pos];
          goto has_addr;
        case OP_FMT_label16:
          pos++;
          addr = (int16_t)get_u16(tab + pos);
          goto has_addr;
#endif
        case OP_FMT_atom_label_u8:
        case OP_FMT_atom_label_u16:
          pos += 4;
          /* fall thru */
        case OP_FMT_label:
        case OP_FMT_label_u16:
          pos++;
          addr = get_u32(tab + pos);
          goto has_addr;
        has_addr:
          if (pass == 1) addr = label_slots[addr].pos;
          if (pass == 2) addr = label_slots[addr].pos2;
          if (pass == 3) addr += pos;
          if (addr >= 0 && addr < len) bits[addr] |= 1;
          break;
      }
    }
  }
  in_source = 0;
  if (source) {
    /* Always print first line: needed if single line */
    print_lines(source, 0, 1);
    in_source = 1;
  }
  line1 = line = 1;
  pos = 0;
  while (pos < len) {
    op = tab[pos];
    if (source) {
      if (b) {
        line1 = find_line_num(ctx, b, pos) - line_num + 1;
      }
      // <ByteDance begin>
      else if (op == OP_line_num) {
        line1 = get_u64(tab + pos + 1) - line_num + 1;
      }
      // <ByteDance end>
      if (line1 > line) {
        if (!in_source) printf("\n");
        in_source = 1;
        print_lines(source, line, line1);
        line = line1;
        // bits[pos] |= 2;
      }
    }
    if (in_source) printf("\n");
    in_source = 0;
    if (op >= OP_COUNT) {
      printf("invalid opcode (0x%02x)\n", op);
      pos++;
      continue;
    }
    if (use_short_opcodes)
      oi = &short_opcode_info(op);
    else
      oi = &opcode_info[op];
    size = oi->size;
    if (pos + size > len) {
      printf("truncated opcode (0x%02x)\n", op);
      break;
    }
#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 16)
    {
      int i, x, x0;
      x = x0 = printf("%5d ", pos);
      for (i = 0; i < size; i++) {
        if (i == 6) {
          printf("\n%*s", x = x0, "");
        }
        x += printf(" %02X", tab[pos + i]);
      }
      printf("%*s", x0 + 20 - x, "");
    }
#endif
    if (bits[pos]) {
      printf("%5d:  ", pos);
    } else {
      printf("        ");
    }
    printf("%s", oi->name);
    pos++;
    switch (oi->fmt) {
      case OP_FMT_none_int:
        printf(" %d", op - OP_push_0);
        break;
      case OP_FMT_npopx:
        printf(" %d", op - OP_call0);
        break;
      case OP_FMT_u8:
        printf(" %u", get_u8(tab + pos));
        break;
      case OP_FMT_i8:
        printf(" %d", get_i8(tab + pos));
        break;
      case OP_FMT_u16:
      case OP_FMT_npop:
        printf(" %u", get_u16(tab + pos));
        break;
      case OP_FMT_i16:
        printf(" %d", get_i16(tab + pos));
        break;
      case OP_FMT_i32:
        printf(" %d", get_i32(tab + pos));
        break;
      case OP_FMT_u32:
        printf(" %u", get_u32(tab + pos));
        break;
      // <ByteDance begin>
      case OP_FMT_u64:
        printf(" %llu", get_u64(tab + pos));
        break;
        // <ByteDance end>
#if SHORT_OPCODES
      case OP_FMT_label8:
        addr = get_i8(tab + pos);
        goto has_addr1;
      case OP_FMT_label16:
        addr = get_i16(tab + pos);
        goto has_addr1;
#endif
      case OP_FMT_label:
        addr = get_u32(tab + pos);
        goto has_addr1;
      has_addr1:
        if (pass == 1) printf(" %u:%u", addr, label_slots[addr].pos);
        if (pass == 2) printf(" %u:%u", addr, label_slots[addr].pos2);
        if (pass == 3) printf(" %u", addr + pos);
        break;
      case OP_FMT_label_u16:
        addr = get_u32(tab + pos);
        if (pass == 1) printf(" %u:%u", addr, label_slots[addr].pos);
        if (pass == 2) printf(" %u:%u", addr, label_slots[addr].pos2);
        if (pass == 3) printf(" %u", addr + pos);
        printf(",%u", get_u16(tab + pos + 4));
        break;
#if SHORT_OPCODES
      case OP_FMT_const8:
        idx = get_u8(tab + pos);
        goto has_pool_idx;
#endif
      case OP_FMT_const:
        idx = get_u32(tab + pos);
        goto has_pool_idx;
      has_pool_idx:
        printf(" %u: ", idx);
        if (idx < cpool_count) {
          LEPUS_DumpValue(ctx, cpool[idx]);
        }
        break;
      case OP_FMT_atom:
        printf(" ");
        print_atom(ctx, get_u32(tab + pos));
        break;
      case OP_FMT_atom_u8:
        printf(" ");
        print_atom(ctx, get_u32(tab + pos));
        printf(",%d", get_u8(tab + pos + 4));
        break;
      case OP_FMT_atom_u16:
        printf(" ");
        print_atom(ctx, get_u32(tab + pos));
        printf(",%d", get_u16(tab + pos + 4));
        break;
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        printf(" ");
        print_atom(ctx, get_u32(tab + pos));
        addr = get_u32(tab + pos + 4);
        if (pass == 1) printf(",%u:%u", addr, label_slots[addr].pos);
        if (pass == 2) printf(",%u:%u", addr, label_slots[addr].pos2);
        if (pass == 3) printf(",%u", addr + pos + 4);
        if (oi->fmt == OP_FMT_atom_label_u8) {
          printf(",%u", get_u8(tab + pos + 8));
        } else {
          printf(",%u", get_u16(tab + pos + 8));
        }
        break;
      case OP_FMT_none_loc:
        idx = (op - OP_get_loc0) % 4;
        goto has_loc;
      case OP_FMT_loc8:
        idx = get_u8(tab + pos);
        goto has_loc;
      case OP_FMT_loc:
        idx = get_u16(tab + pos);
      has_loc:
        printf(" %d: ", idx);
        if (idx < var_count) {
          print_atom(ctx, vars[idx].var_name);
        }
        break;
      case OP_FMT_none_arg:
        idx = (op - OP_get_arg0) % 4;
        goto has_arg;
      case OP_FMT_arg:
        idx = get_u16(tab + pos);
      has_arg:
        printf(" %d: ", idx);
        if (idx < arg_count) {
          print_atom(ctx, args[idx].var_name);
        }
        break;
      case OP_FMT_none_var_ref:
        idx = (op - OP_get_var_ref0) % 4;
        goto has_var_ref;
      case OP_FMT_var_ref:
        idx = get_u16(tab + pos);
      has_var_ref:
        printf(" %d: ", idx);
        if (idx < closure_var_count) {
          print_atom(ctx, closure_var[idx].var_name);
        }
        break;
      default:
        break;
    }
    printf("\n");
    pos += oi->size - 1;
  }
  if (source) {
    if (!in_source) printf("\n");
    print_lines(source, line, INT32_MAX);
  }
  lepus_free(ctx, bits);
}

static __attribute__((unused)) void dump_pc2line(LEPUSContext *ctx,
                                                 const uint8_t *buf, int len,
                                                 int line_num) {
  const uint8_t *p_end, *p_next, *p;
  int pc, v;
  unsigned int op;

  if (len <= 0) return;

  printf("%5s %5s\n", "PC", "LINE");

  p = buf;
  p_end = buf + len;
  pc = 0;
  while (p < p_end) {
    op = *p++;
    if (op == 0) {
      v = unicode_from_utf8(p, p_end - p, &p_next);
      if (v < 0) goto fail;
      pc += v;
      p = p_next;
      v = unicode_from_utf8(p, p_end - p, &p_next);
      if (v < 0) {
      fail:
        printf("invalid pc2line encode pos=%d\n", (int)(p - buf));
        return;
      }
      if (!(v & 1)) {
        v = v >> 1;
      } else {
        v = -(v >> 1) - 1;
      }
      line_num += v;
      p = p_next;
    } else {
      op -= PC2LINE_OP_FIRST;
      pc += (op / PC2LINE_RANGE);
      line_num += (op % PC2LINE_RANGE) + PC2LINE_BASE;
    }
    printf("%5d %5d\n", pc, line_num);
  }
}

static __attribute__((unused)) void lepus_dump_function_bytecode(
    LEPUSContext *ctx, LEPUSFunctionBytecode *b) {
  int i;
  char atom_buf[ATOM_GET_STR_BUF_SIZE];
  const char *str;

  if (b->has_debug && b->debug.filename != LEPUS_ATOM_NULL) {
    str = LEPUS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->debug.filename);
    printf("%s:%d: ", str, b->debug.line_num);
  }

  str = LEPUS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), b->func_name);
  printf("function: %s%s\n", &"*"[b->func_kind != LEPUS_FUNC_GENERATOR], str);
  if (b->lepus_mode) {
    printf("  mode:");
    if (b->lepus_mode & LEPUS_MODE_STRICT) printf(" strict");
#ifdef CONFIG_BIGNUM
    if (b->lepus_mode & LEPUS_MODE_MATH) printf(" math");
#endif
    printf("\n");
  }
  if (b->arg_count && b->vardefs) {
    printf("  args:");
    for (i = 0; i < b->arg_count; i++) {
      printf(" %s", LEPUS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf),
                                     b->vardefs[i].var_name));
    }
    printf("\n");
  }
  if (b->var_count && b->vardefs) {
    printf("  locals:\n");
    for (i = 0; i < b->var_count; i++) {
      LEPUSVarDef *vd = &b->vardefs[b->arg_count + i];
      printf(
          "%5d: %s %s", i,
          vd->var_kind == LEPUS_VAR_CATCH
              ? "catch"
              : (vd->var_kind == LEPUS_VAR_FUNCTION_DECL ||
                 vd->var_kind == LEPUS_VAR_NEW_FUNCTION_DECL)
                    ? "function"
                    : vd->is_const ? "const" : vd->is_lexical ? "let" : "var",
          LEPUS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), vd->var_name));
      if (vd->scope_level)
        printf(" [level:%d next:%d]", vd->scope_level, vd->scope_next);
      printf("\n");
    }
  }
  if (b->closure_var_count) {
    printf("  closure vars:\n");
    for (i = 0; i < b->closure_var_count; i++) {
      LEPUSClosureVar *cv = &b->closure_var[i];
      printf("%5d: %s %s:%s%d %s\n", i,
             LEPUS_AtomGetStr(ctx, atom_buf, sizeof(atom_buf), cv->var_name),
             cv->is_local ? "local" : "parent", cv->is_arg ? "arg" : "loc",
             cv->var_idx,
             cv->is_const ? "const" : cv->is_lexical ? "let" : "var");
    }
  }
  printf("  stack_size: %d\n", b->stack_size);
  printf("  opcodes:\n");
  dump_byte_code(ctx, 3, b->byte_code_buf, b->byte_code_len, b->vardefs,
                 b->arg_count, b->vardefs ? b->vardefs + b->arg_count : NULL,
                 b->var_count, b->closure_var, b->closure_var_count, b->cpool,
                 b->cpool_count, b->has_debug ? b->debug.source : NULL,
                 b->has_debug ? b->debug.line_num : -1, NULL, b);
#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 32)
  if (b->has_debug)
    dump_pc2line(ctx, b->debug.pc2line_buf, b->debug.pc2line_len,
                 b->debug.line_num);
#endif
  printf("\n");
}
#endif

QJS_STATIC int add_closure_var(LEPUSContext *ctx, LEPUSFunctionDef *s,
                               BOOL is_local, BOOL is_arg, int var_idx,
                               LEPUSAtom var_name, BOOL is_const,
                               BOOL is_lexical, LEPUSVarKindEnum var_kind) {
  LEPUSClosureVar *cv;

  /* the closure variable indexes are currently stored on 16 bits */
  if (s->closure_var_count >= LEPUS_MAX_LOCAL_VARS) {
    LEPUS_ThrowInternalError(ctx, "too many closure variables");
    return -1;
  }

  if (s->closure_var_count >= s->closure_var_size) {
    LEPUSClosureVar *new_tab;
    int new_size;
    size_t slack;
    new_size = max_int(s->closure_var_count + 1, s->closure_var_size * 3 / 2);
    new_tab = static_cast<LEPUSClosureVar *>(lepus_realloc2(
        ctx, s->closure_var, new_size * sizeof(LEPUSClosureVar), &slack));
    if (!new_tab) return -1;
    new_size += slack / sizeof(*new_tab);
    s->closure_var = new_tab;
    s->closure_var_size = new_size;
  }
  cv = &s->closure_var[s->closure_var_count++];
  cv->is_local = is_local;
  cv->is_arg = is_arg;
  cv->is_const = is_const;
  cv->is_lexical = is_lexical;
  cv->var_kind = var_kind;
  cv->var_idx = var_idx;
  cv->var_name = LEPUS_DupAtom(ctx, var_name);
  return s->closure_var_count - 1;
}

QJS_STATIC int find_closure_var(LEPUSContext *ctx, LEPUSFunctionDef *s,
                                LEPUSAtom var_name) {
  int i;
  for (i = 0; i < s->closure_var_count; i++) {
    LEPUSClosureVar *cv = &s->closure_var[i];
    if (cv->var_name == var_name) return i;
  }
  return -1;
}

/* 'fd' must be a parent of 's'. Create in 's' a closure referencing a
   local variable (is_local = TRUE) or a closure (is_local = FALSE) in
   'fd' */
QJS_STATIC int get_closure_var2(LEPUSContext *ctx, LEPUSFunctionDef *s,
                                LEPUSFunctionDef *fd, BOOL is_local,
                                BOOL is_arg, int var_idx, LEPUSAtom var_name,
                                BOOL is_const, BOOL is_lexical,
                                LEPUSVarKindEnum var_kind) {
  int i;

  if (fd != s->parent) {
    var_idx = get_closure_var2(ctx, s->parent, fd, is_local, is_arg, var_idx,
                               var_name, is_const, is_lexical, var_kind);
    if (var_idx < 0) return -1;
    is_local = FALSE;
  }
  for (i = 0; i < s->closure_var_count; i++) {
    LEPUSClosureVar *cv = &s->closure_var[i];
    if (cv->var_idx == var_idx && cv->is_arg == is_arg &&
        cv->is_local == is_local)
      return i;
  }
  return add_closure_var(ctx, s, is_local, is_arg, var_idx, var_name, is_const,
                         is_lexical, var_kind);
}

QJS_STATIC int get_closure_var(LEPUSContext *ctx, LEPUSFunctionDef *s,
                               LEPUSFunctionDef *fd, BOOL is_arg, int var_idx,
                               LEPUSAtom var_name, BOOL is_const,
                               BOOL is_lexical, LEPUSVarKindEnum var_kind) {
  return get_closure_var2(ctx, s, fd, TRUE, is_arg, var_idx, var_name, is_const,
                          is_lexical, var_kind);
}

QJS_STATIC int get_with_scope_opcode(int op) {
  if (op == OP_scope_get_var_undef)
    return OP_with_get_var;
  else
    return OP_with_get_var + (op - OP_scope_get_var);
}

QJS_STATIC BOOL can_opt_put_ref_value(const uint8_t *bc_buf, int pos) {
  int opcode = bc_buf[pos];
  return (bc_buf[pos + 1] == OP_put_ref_value &&
          (opcode == OP_insert3 || opcode == OP_perm4 || opcode == OP_nop ||
           opcode == OP_rot3l));
}

QJS_STATIC BOOL can_opt_put_global_ref_value(const uint8_t *bc_buf, int pos) {
  int opcode = bc_buf[pos];
  return (bc_buf[pos + 1] == OP_put_ref_value &&
          (opcode == OP_insert3 || opcode == OP_perm4 || opcode == OP_nop ||
           opcode == OP_rot3l));
}

QJS_STATIC int optimize_scope_make_ref(LEPUSContext *ctx, LEPUSFunctionDef *s,
                                       DynBuf *bc, uint8_t *bc_buf,
                                       LabelSlot *ls, int pos_next, int get_op,
                                       int var_idx) {
  int label_pos, end_pos, pos;

  /* XXX: should optimize `loc(a) += expr` as `expr add_loc(a)`
     but only if expr does not modify `a`.
     should scan the code between pos_next and label_pos
     for operations that can potentially change `a`:
     OP_scope_make_ref(a), function calls, jumps and gosub.
   */
  /* replace the reference get/put with normal variable
     accesses */
  if (bc_buf[pos_next] == OP_get_ref_value) {
    dbuf_putc(bc, get_op);
    dbuf_put_u16(bc, var_idx);
    pos_next++;
  }
  /* remove the OP_label to make room for replacement */
  /* label should have a refcount of 0 anyway */
  /* XXX: should avoid this patch by inserting nops in phase 1 */
  label_pos = ls->pos;
  pos = label_pos - 5;
  assert(bc_buf[pos] == OP_label);
  /* label points to an instruction pair:
     - insert3 / put_ref_value
     - perm4 / put_ref_value
     - rot3l / put_ref_value
     - nop / put_ref_value
   */
  end_pos = label_pos + 2;
  if (bc_buf[label_pos] == OP_insert3) bc_buf[pos++] = OP_dup;
  bc_buf[pos] = get_op + 1;
  put_u16(bc_buf + pos + 1, var_idx);
  pos += 3;
  /* pad with OP_nop */
  while (pos < end_pos) bc_buf[pos++] = OP_nop;
  return pos_next;
}

QJS_STATIC int optimize_scope_make_global_ref(LEPUSContext *ctx,
                                              LEPUSFunctionDef *s, DynBuf *bc,
                                              uint8_t *bc_buf, LabelSlot *ls,
                                              int pos_next,
                                              LEPUSAtom var_name) {
  int label_pos, end_pos, pos, op;
  BOOL is_strict;
  is_strict = ((s->lepus_mode & LEPUS_MODE_STRICT) != 0);

  /* replace the reference get/put with normal variable
     accesses */
  if (is_strict) {
    /* need to check if the variable exists before evaluating the right
       expression */
    /* XXX: need an extra OP_true if destructuring an array */
    dbuf_putc(bc, OP_check_var);
    dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
  } else {
    /* XXX: need 2 extra OP_true if destructuring an array */
  }
  if (bc_buf[pos_next] == OP_get_ref_value) {
    dbuf_putc(bc, OP_get_var);
    dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
// <primjs begin>
#ifdef ENABLE_PRIMJS_IC
    dbuf_put_u64(bc, s->get_feedback_vec_size);
    s->get_feedback_vec_size++;
#endif
    // <primjs end>
    pos_next++;
  }
  /* remove the OP_label to make room for replacement */
  /* label should have a refcount of 0 anyway */
  /* XXX: should have emitted several OP_nop to avoid this kludge */
  label_pos = ls->pos;
  pos = label_pos - 5;
  assert(bc_buf[pos] == OP_label);
  end_pos = label_pos + 2;
  op = bc_buf[label_pos];
  if (is_strict) {
    if (op != OP_nop) {
      switch (op) {
        case OP_insert3:
          op = OP_insert2;
          break;
        case OP_perm4:
          op = OP_perm3;
          break;
        case OP_rot3l:
          op = OP_swap;
          break;
        default:
          abort();
      }
      bc_buf[pos++] = op;
    }
  } else {
    if (op == OP_insert3) bc_buf[pos++] = OP_dup;
  }
  if (is_strict) {
    bc_buf[pos] = OP_put_var_strict;
    /* XXX: need 1 extra OP_drop if destructuring an array */
  } else {
    bc_buf[pos] = OP_put_var;
    /* XXX: need 2 extra OP_drop if destructuring an array */
  }
  put_u32(bc_buf + pos + 1, LEPUS_DupAtom(ctx, var_name));
  pos += 5;
  /* pad with OP_nop */
  while (pos < end_pos) bc_buf[pos++] = OP_nop;
  return pos_next;
}

QJS_STATIC int add_var_this(LEPUSContext *ctx, LEPUSFunctionDef *fd) {
  int idx;
  idx = add_var(ctx, fd, LEPUS_ATOM_this);
  if (idx >= 0 && fd->is_derived_class_constructor) {
    LEPUSVarDef *vd = &fd->vars[idx];
    /* XXX: should have is_this flag or var type */
    vd->is_lexical = 1; /* used to trigger 'uninitialized' checks
                           in a derived class constructor */
  }
  return idx;
}

QJS_STATIC int resolve_pseudo_var(LEPUSContext *ctx, LEPUSFunctionDef *s,
                                  LEPUSAtom var_name) {
  int var_idx;

  if (!s->has_this_binding) return -1;
  switch (var_name) {
    case LEPUS_ATOM_home_object:
      /* 'home_object' pseudo variable */
      var_idx = s->home_object_var_idx = add_var(ctx, s, var_name);
      break;
    case LEPUS_ATOM_this_active_func:
      /* 'this.active_func' pseudo variable */
      var_idx = s->this_active_func_var_idx = add_var(ctx, s, var_name);
      break;
    case LEPUS_ATOM_new_target:
      /* 'new.target' pseudo variable */
      var_idx = s->new_target_var_idx = add_var(ctx, s, var_name);
      break;
    case LEPUS_ATOM_this:
      /* 'this' pseudo variable */
      var_idx = s->this_var_idx = add_var_this(ctx, s);
      break;
    default:
      var_idx = -1;
      break;
  }
  return var_idx;
}

/* return the position of the next opcode */
QJS_STATIC int resolve_scope_var(LEPUSContext *ctx, LEPUSFunctionDef *s,
                                 LEPUSAtom var_name, int scope_level, int op,
                                 DynBuf *bc, uint8_t *bc_buf, LabelSlot *ls,
                                 int pos_next) {
  int idx, var_idx, is_put;
  int label_done;
  LEPUSFunctionDef *fd;
  LEPUSVarDef *vd;
  BOOL is_pseudo_var, is_arg_scope;
  LEPUSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");

  label_done = -1;

  /* XXX: could be simpler to use a specific function to
     resolve the pseudo variables */
  is_pseudo_var =
      (var_name == LEPUS_ATOM_home_object ||
       var_name == LEPUS_ATOM_this_active_func ||
       var_name == LEPUS_ATOM_new_target || var_name == LEPUS_ATOM_this);

  /* resolve local scoped variables */
  var_idx = -1;
  for (idx = s->scopes[scope_level].first; idx >= 0;) {
    vd = &s->vars[idx];
    if (vd->var_name == var_name) {
      if (op == OP_scope_put_var || op == OP_scope_make_ref) {
        if (vd->is_const) {
          dbuf_putc(bc, OP_throw_var);
          dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
          dbuf_putc(bc, LEPUS_THROW_VAR_RO);
          goto done;
        }
      }
      var_idx = idx;
      break;
    } else if (vd->var_name == LEPUS_ATOM__with_ && !is_pseudo_var) {
      dbuf_putc(bc, OP_get_loc);
      dbuf_put_u16(bc, idx);
      dbuf_putc(bc, get_with_scope_opcode(op));
      dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
      label_done = new_label_fd(s, label_done);
      dbuf_put_u32(bc, label_done);
      dbuf_putc(bc, 1);
      update_label(s, label_done, 1);
      s->jump_size++;
    }
    idx = vd->scope_next;
  }
  is_arg_scope = (idx == ARG_SCOPE_END);
  if (var_idx < 0) {
    /* XXX: scoping issues:
       should not resolve vars from the function body during argument parse,
       `arguments` and function-name should not be hidden by later vars.
     */
    var_idx = find_var(ctx, s, var_name);
    if (var_idx >= 0) {
      var_idx = find_var(ctx, s, var_name);
    }

    if (var_idx < 0 && is_pseudo_var)
      var_idx = resolve_pseudo_var(ctx, s, var_name);

    if (var_idx < 0 && var_name == LEPUS_ATOM_arguments &&
        s->has_arguments_binding) {
      /* 'arguments' pseudo variable */
      var_idx = add_arguments_var(ctx, s, var_name);
    }
    if (var_idx < 0 && s->is_func_expr && var_name == s->func_name) {
      /* add a new variable with the function name */
      var_idx = add_func_var(ctx, s, var_name);
    }
  }
  if (var_idx >= 0) {
    if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&
        !(var_idx & ARGUMENT_VAR_OFFSET) && s->vars[var_idx].is_const) {
      /* only happens when assigning a function expression name
         in strict mode */
      dbuf_putc(bc, OP_throw_var);
      dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
      dbuf_putc(bc, LEPUS_THROW_VAR_RO);
      goto done;
    }
    /* OP_scope_put_var_init is only used to initialize a
       lexical variable, so it is never used in a with or var object. It
       can be used with a closure (module global variable case). */
    switch (op) {
      case OP_scope_make_ref:
        if (!(var_idx & ARGUMENT_VAR_OFFSET) &&
            s->vars[var_idx].var_kind == LEPUS_VAR_FUNCTION_NAME) {
          /* Create a dummy object reference for the func_var */
          dbuf_putc(bc, OP_object);
          dbuf_putc(bc, OP_get_loc);
          dbuf_put_u16(bc, var_idx);
          dbuf_putc(bc, OP_define_field);
          dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
          dbuf_putc(bc, OP_push_atom_value);
          dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
        } else if (label_done == -1 && can_opt_put_ref_value(bc_buf, ls->pos)) {
          int get_op;
          if (var_idx & ARGUMENT_VAR_OFFSET) {
            get_op = OP_get_arg;
            var_idx -= ARGUMENT_VAR_OFFSET;
          } else {
            if (s->vars[var_idx].is_lexical)
              get_op = OP_get_loc_check;
            else
              get_op = OP_get_loc;
          }
          pos_next = optimize_scope_make_ref(ctx, s, bc, bc_buf, ls, pos_next,
                                             get_op, var_idx);
        } else {
          /* Create a dummy object with a named slot that is
             a reference to the local variable */
          if (var_idx & ARGUMENT_VAR_OFFSET) {
            dbuf_putc(bc, OP_make_arg_ref);
            dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
            dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);
          } else {
            dbuf_putc(bc, OP_make_loc_ref);
            dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
            dbuf_put_u16(bc, var_idx);
          }
        }
        break;
      case OP_scope_get_ref:
        dbuf_putc(bc, OP_undefined);
        /* fall thru */
      case OP_scope_get_var_undef:
      case OP_scope_get_var:
      case OP_scope_put_var:
      case OP_scope_put_var_init:
        is_put = (op == OP_scope_put_var || op == OP_scope_put_var_init);
        if (var_idx & ARGUMENT_VAR_OFFSET) {
          dbuf_putc(bc, OP_get_arg + is_put);
          dbuf_put_u16(bc, var_idx - ARGUMENT_VAR_OFFSET);
          /* XXX: should test if argument reference needs TDZ check */
        } else {
          if (is_put) {
            if (s->vars[var_idx].is_lexical) {
              if (op == OP_scope_put_var_init) {
                /* 'this' can only be initialized once */
                if (var_name == LEPUS_ATOM_this)
                  dbuf_putc(bc, OP_put_loc_check_init);
                else
                  dbuf_putc(bc, OP_put_loc);
              } else {
                dbuf_putc(bc, OP_put_loc_check);
              }
            } else {
              dbuf_putc(bc, OP_put_loc);
            }
          } else {
            if (s->vars[var_idx].is_lexical) {
              dbuf_putc(bc, OP_get_loc_check);
            } else {
              dbuf_putc(bc, OP_get_loc);
            }
          }
          dbuf_put_u16(bc, var_idx);
        }
        break;
      case OP_scope_delete_var:
        dbuf_putc(bc, OP_push_false);
        break;
    }
    goto done;
  }
  /* check eval object */
  if (!is_arg_scope && s->var_object_idx >= 0 && !is_pseudo_var) {
    dbuf_putc(bc, OP_get_loc);
    dbuf_put_u16(bc, s->var_object_idx);
    dbuf_putc(bc, get_with_scope_opcode(op));
    dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
    label_done = new_label_fd(s, label_done);
    dbuf_put_u32(bc, label_done);
    dbuf_putc(bc, 0);
    update_label(s, label_done, 1);
    s->jump_size++;
  }
  /* check eval object in argument scope */
  if (s->arg_var_object_idx >= 0 && !is_pseudo_var) {
    dbuf_putc(bc, OP_get_loc);
    dbuf_put_u16(bc, s->arg_var_object_idx);
    dbuf_putc(bc, get_with_scope_opcode(op));
    dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
    label_done = new_label_fd(s, label_done);
    dbuf_put_u32(bc, label_done);
    dbuf_putc(bc, 0);
    update_label(s, label_done, 1);
    s->jump_size++;
  }
  /* check parent scopes */
  for (fd = s; fd->parent;) {
    scope_level = fd->parent_scope_level;
    fd = fd->parent;
    for (idx = fd->scopes[scope_level].first; idx >= 0;) {
      vd = &fd->vars[idx];
      if (vd->var_name == var_name) {
        if (op == OP_scope_put_var || op == OP_scope_make_ref) {
          if (vd->is_const) {
            dbuf_putc(bc, OP_throw_var);
            dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
            dbuf_putc(bc, LEPUS_THROW_VAR_RO);
            goto done;
          }
        }
        var_idx = idx;
        break;
      } else if (vd->var_name == LEPUS_ATOM__with_ && !is_pseudo_var) {
        vd->is_captured = 1;
        idx = get_closure_var(ctx, s, fd, FALSE, idx, vd->var_name, FALSE,
                              FALSE, LEPUS_VAR_NORMAL);
        if (idx >= 0) {
          dbuf_putc(bc, OP_get_var_ref);
          dbuf_put_u16(bc, idx);
          dbuf_putc(bc, get_with_scope_opcode(op));
          dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
          label_done = new_label_fd(s, label_done);
          dbuf_put_u32(bc, label_done);
          dbuf_putc(bc, 1);
          update_label(s, label_done, 1);
          s->jump_size++;
        }
      }
      idx = vd->scope_next;
    }
    is_arg_scope = (idx == ARG_SCOPE_END);
    if (var_idx >= 0) break;

    if (!is_arg_scope) {
      var_idx = find_var(ctx, fd, var_name);
      if (var_idx >= 0) break;
    }

    if (is_pseudo_var) {
      var_idx = resolve_pseudo_var(ctx, fd, var_name);
      if (var_idx >= 0) break;
    }
    if (var_name == LEPUS_ATOM_arguments && fd->has_arguments_binding) {
      var_idx = add_arguments_var(ctx, fd, var_name);
      break;
    }
    if (fd->is_func_expr && fd->func_name == var_name) {
      /* add a new variable with the function name */
      var_idx = add_func_var(ctx, fd, var_name);
      break;
    }

    /* check eval object */
    if (!is_arg_scope && fd->var_object_idx >= 0 && !is_pseudo_var) {
      fd->vars[fd->var_object_idx].is_captured = 1;
      idx = get_closure_var(ctx, s, fd, FALSE, fd->var_object_idx,
                            LEPUS_ATOM__var_, FALSE, FALSE, LEPUS_VAR_NORMAL);
      dbuf_putc(bc, OP_get_var_ref);
      dbuf_put_u16(bc, idx);
      dbuf_putc(bc, get_with_scope_opcode(op));
      dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
      label_done = new_label_fd(s, label_done);
      dbuf_put_u32(bc, label_done);
      dbuf_putc(bc, 0);
      update_label(s, label_done, 1);
      s->jump_size++;
    }

    /* check eval object in argument scope */
    if (fd->arg_var_object_idx >= 0 && !is_pseudo_var) {
      vd = &fd->vars[fd->arg_var_object_idx];
      vd->is_captured = 1;
      idx = get_closure_var(ctx, s, fd, FALSE, fd->arg_var_object_idx,
                            vd->var_name, FALSE, FALSE, LEPUS_VAR_NORMAL);
      dbuf_putc(bc, OP_get_var_ref);
      dbuf_put_u16(bc, idx);
      dbuf_putc(bc, get_with_scope_opcode(op));
      dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
      label_done = new_label_fd(s, label_done);
      dbuf_put_u32(bc, label_done);
      dbuf_putc(bc, 0);
      update_label(s, label_done, 1);
      s->jump_size++;
    }

    if (fd->is_eval) break; /* it it necessarily the top level function */
  }

  /* check direct eval scope (in the closure of the eval function
     which is necessarily at the top level) */
  if (!fd) fd = s;
  if (var_idx < 0 && fd->is_eval) {
    int idx1;
    for (idx1 = 0; idx1 < fd->closure_var_count; idx1++) {
      LEPUSClosureVar *cv = &fd->closure_var[idx1];
      if (var_name == cv->var_name) {
        if (fd != s) {
          idx = get_closure_var2(ctx, s, fd, FALSE, cv->is_arg, idx1,
                                 cv->var_name, cv->is_const, cv->is_lexical,
                                 static_cast<LEPUSVarKindEnum>(cv->var_kind));
        } else {
          idx = idx1;
        }
        goto has_idx;
      } else if ((cv->var_name == LEPUS_ATOM__var_ ||
                  cv->var_name == atom_arg_var ||
                  cv->var_name == LEPUS_ATOM__with_) &&
                 !is_pseudo_var) {
        int is_with = (cv->var_name == LEPUS_ATOM__with_);
        if (fd != s) {
          idx = get_closure_var2(ctx, s, fd, FALSE, cv->is_arg, idx1,
                                 cv->var_name, FALSE, FALSE, LEPUS_VAR_NORMAL);
        } else {
          idx = idx1;
        }
        dbuf_putc(bc, OP_get_var_ref);
        dbuf_put_u16(bc, idx);
        dbuf_putc(bc, get_with_scope_opcode(op));
        dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
        label_done = new_label_fd(s, label_done);
        dbuf_put_u32(bc, label_done);
        dbuf_putc(bc, is_with);
        update_label(s, label_done, 1);
        s->jump_size++;
      }
    }
  }

  if (var_idx >= 0) {
    /* find the corresponding closure variable */
    if (var_idx & ARGUMENT_VAR_OFFSET) {
      fd->args[var_idx - ARGUMENT_VAR_OFFSET].is_captured = 1;
      idx = get_closure_var(ctx, s, fd, TRUE, var_idx - ARGUMENT_VAR_OFFSET,
                            var_name, FALSE, FALSE, LEPUS_VAR_NORMAL);
    } else {
      fd->vars[var_idx].is_captured = 1;
      idx = get_closure_var(
          ctx, s, fd, FALSE, var_idx, var_name, fd->vars[var_idx].is_const,
          fd->vars[var_idx].is_lexical,
          static_cast<LEPUSVarKindEnum>(fd->vars[var_idx].var_kind));
    }
    if (idx >= 0) {
    has_idx:
      if ((op == OP_scope_put_var || op == OP_scope_make_ref) &&
          s->closure_var[idx].is_const) {
        dbuf_putc(bc, OP_throw_var);
        dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
        dbuf_putc(bc, LEPUS_THROW_VAR_RO);
        goto done;
      }
      switch (op) {
        case OP_scope_make_ref:
          if (s->closure_var[idx].var_kind == LEPUS_VAR_FUNCTION_NAME) {
            /* Create a dummy object reference for the func_var */
            dbuf_putc(bc, OP_object);
            dbuf_putc(bc, OP_get_var_ref);
            dbuf_put_u16(bc, idx);
            dbuf_putc(bc, OP_define_field);
            dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
            dbuf_putc(bc, OP_push_atom_value);
            dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
          } else if (label_done == -1 &&
                     can_opt_put_ref_value(bc_buf, ls->pos)) {
            int get_op;
            if (s->closure_var[idx].is_lexical)
              get_op = OP_get_var_ref_check;
            else
              get_op = OP_get_var_ref;
            pos_next = optimize_scope_make_ref(ctx, s, bc, bc_buf, ls, pos_next,
                                               get_op, idx);
          } else {
            /* Create a dummy object with a named slot that is
               a reference to the closure variable */
            dbuf_putc(bc, OP_make_var_ref_ref);
            dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
            dbuf_put_u16(bc, idx);
          }
          break;
        case OP_scope_get_ref:
          /* XXX: should create a dummy object with a named slot that is
             a reference to the closure variable */
          dbuf_putc(bc, OP_undefined);
          /* fall thru */
        case OP_scope_get_var_undef:
        case OP_scope_get_var:
        case OP_scope_put_var:
        case OP_scope_put_var_init:
          is_put = (op == OP_scope_put_var || op == OP_scope_put_var_init);
          if (is_put) {
            if (s->closure_var[idx].is_lexical) {
              if (op == OP_scope_put_var_init) {
                /* 'this' can only be initialized once */
                if (var_name == LEPUS_ATOM_this)
                  dbuf_putc(bc, OP_put_var_ref_check_init);
                else
                  dbuf_putc(bc, OP_put_var_ref);
              } else {
                dbuf_putc(bc, OP_put_var_ref_check);
              }
            } else {
              dbuf_putc(bc, OP_put_var_ref);
            }
          } else {
            if (s->closure_var[idx].is_lexical) {
              dbuf_putc(bc, OP_get_var_ref_check);
            } else {
              dbuf_putc(bc, OP_get_var_ref);
            }
          }
          dbuf_put_u16(bc, idx);
          break;
        case OP_scope_delete_var:
          dbuf_putc(bc, OP_push_false);
          break;
      }
      goto done;
    }
  }

  /* global variable access */

  switch (op) {
    case OP_scope_make_ref:
      if (label_done == -1 && can_opt_put_global_ref_value(bc_buf, ls->pos)) {
        pos_next = optimize_scope_make_global_ref(ctx, s, bc, bc_buf, ls,
                                                  pos_next, var_name);
      } else {
        dbuf_putc(bc, OP_make_var_ref);
        dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
      }
      break;
    case OP_scope_get_ref:
      /* XXX: should create a dummy object with a named slot that is
         a reference to the global variable */
      dbuf_putc(bc, OP_undefined);
      dbuf_putc(bc, OP_get_var);
      dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
// <primjs begin>
#ifdef ENABLE_PRIMJS_IC
      dbuf_put_u64(bc, s->get_feedback_vec_size);
      s->get_feedback_vec_size++;
#endif
      // <primjs end>
      break;
    case OP_scope_get_var_undef:
    case OP_scope_get_var:
    case OP_scope_put_var:
      dbuf_putc(bc, OP_get_var_undef + (op - OP_scope_get_var_undef));
      dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
// <primjs begin>
#ifdef ENABLE_PRIMJS_IC
      if (op == OP_scope_get_var || op == OP_scope_get_var_undef) {
        dbuf_put_u64(bc, s->get_feedback_vec_size);
        s->get_feedback_vec_size++;
      }
#endif
      // <primjs end>
      break;
    case OP_scope_put_var_init:
      dbuf_putc(bc, OP_put_var_init);
      dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
      break;
    case OP_scope_delete_var:
      dbuf_putc(bc, OP_delete_var);
      dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
      break;
  }
done:
  LEPUS_FreeAtom(ctx, atom_arg_var);
  if (label_done >= 0) {
    dbuf_putc(bc, OP_label);
    dbuf_put_u32(bc, label_done);
    s->label_slots[label_done].pos2 = bc->size;
  }
  return pos_next;
}

/* search in all scopes */
QJS_STATIC int find_private_class_field_all(LEPUSContext *ctx,
                                            LEPUSFunctionDef *fd,
                                            LEPUSAtom name, int scope_level) {
  int idx;

  idx = fd->scopes[scope_level].first;
  while (idx >= 0) {
    if (fd->vars[idx].var_name == name) return idx;
    idx = fd->vars[idx].scope_next;
  }
  return -1;
}

QJS_STATIC void get_loc_or_ref(DynBuf *bc, BOOL is_ref, int idx) {
  if (is_ref)
    dbuf_putc(bc, OP_get_var_ref);
  else
    dbuf_putc(bc, OP_get_loc);
  dbuf_put_u16(bc, idx);
}

QJS_STATIC int resolve_scope_private_field1(LEPUSContext *ctx, BOOL *pis_ref,
                                            int *pvar_kind, LEPUSFunctionDef *s,
                                            LEPUSAtom var_name,
                                            int scope_level) {
  int idx, var_kind;
  LEPUSFunctionDef *fd;
  BOOL is_ref;

  fd = s;
  is_ref = FALSE;
  for (;;) {
    idx = find_private_class_field_all(ctx, fd, var_name, scope_level);
    if (idx >= 0) {
      var_kind = fd->vars[idx].var_kind;
      if (is_ref) {
        idx = get_closure_var(ctx, s, fd, FALSE, idx, var_name, TRUE, TRUE,
                              LEPUS_VAR_NORMAL);
        if (idx < 0) return -1;
      }
      break;
    }
    scope_level = fd->parent_scope_level;
    if (!fd->parent) {
      char buf[ATOM_GET_STR_BUF_SIZE];

      if (fd->is_eval) {
        /* closure of the eval function (top level) */
        for (idx = 0; idx < fd->closure_var_count; idx++) {
          LEPUSClosureVar *cv = &fd->closure_var[idx];
          if (cv->var_name == var_name) {
            var_kind = cv->var_kind;
            is_ref = TRUE;
            if (fd != s) {
              idx =
                  get_closure_var2(ctx, s, fd, FALSE, cv->is_arg, idx,
                                   cv->var_name, cv->is_const, cv->is_lexical,
                                   static_cast<LEPUSVarKindEnum>(cv->var_kind));
              if (idx < 0) return -1;
            }
            goto done;
          }
        }
      }
      /* XXX: no line number info */
#ifdef LYNX_DEV
      LEPUS_ThrowSyntaxErrorAtom(ctx, "undefined private field '%s'", var_name);
#endif
      return -1;
    } else {
      fd = fd->parent;
    }
    is_ref = TRUE;
  }
done:
  *pis_ref = is_ref;
  *pvar_kind = var_kind;
  return idx;
}

/* return 0 if OK or -1 if the private field could not be resolved */
QJS_STATIC int resolve_scope_private_field(LEPUSContext *ctx,
                                           LEPUSFunctionDef *s,
                                           LEPUSAtom var_name, int scope_level,
                                           int op, DynBuf *bc) {
  int idx, var_kind;
  BOOL is_ref;

  idx = resolve_scope_private_field1(ctx, &is_ref, &var_kind, s, var_name,
                                     scope_level);
  if (idx < 0) return -1;
  assert(var_kind != LEPUS_VAR_NORMAL);
  switch (op) {
    case OP_scope_get_private_field:
    case OP_scope_get_private_field2:
      switch (var_kind) {
        case LEPUS_VAR_PRIVATE_FIELD:
          if (op == OP_scope_get_private_field2) dbuf_putc(bc, OP_dup);
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_get_private_field);
          break;
        case LEPUS_VAR_PRIVATE_METHOD:
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_check_brand);
          if (op != OP_scope_get_private_field2) dbuf_putc(bc, OP_nip);
          break;
        case LEPUS_VAR_PRIVATE_GETTER:
        case LEPUS_VAR_PRIVATE_GETTER_SETTER:
          if (op == OP_scope_get_private_field2) dbuf_putc(bc, OP_dup);
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_check_brand);
          dbuf_putc(bc, OP_call_method);
          dbuf_put_u16(bc, 0);
          break;
        case LEPUS_VAR_PRIVATE_SETTER:
          /* XXX: add clearer error message */
          dbuf_putc(bc, OP_throw_var);
          dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
          dbuf_putc(bc, LEPUS_THROW_VAR_RO);
          break;
        default:
          abort();
      }
      break;
    case OP_scope_put_private_field:
      switch (var_kind) {
        case LEPUS_VAR_PRIVATE_FIELD:
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_put_private_field);
          break;
        case LEPUS_VAR_PRIVATE_METHOD:
        case LEPUS_VAR_PRIVATE_GETTER:
          /* XXX: add clearer error message */
          dbuf_putc(bc, OP_throw_var);
          dbuf_put_u32(bc, LEPUS_DupAtom(ctx, var_name));
          dbuf_putc(bc, LEPUS_THROW_VAR_RO);
          break;
        case LEPUS_VAR_PRIVATE_SETTER:
        case LEPUS_VAR_PRIVATE_GETTER_SETTER: {
          LEPUSAtom setter_name = get_private_setter_name(ctx, var_name);
          if (setter_name == LEPUS_ATOM_NULL) return -1;
          idx = resolve_scope_private_field1(ctx, &is_ref, &var_kind, s,
                                             setter_name, scope_level);
          LEPUS_FreeAtom(ctx, setter_name);
          if (idx < 0) return -1;
          assert(var_kind == LEPUS_VAR_PRIVATE_SETTER);
          get_loc_or_ref(bc, is_ref, idx);
          dbuf_putc(bc, OP_swap);
          /* obj func value */
          dbuf_putc(bc, OP_rot3r);
          /* value obj func */
          dbuf_putc(bc, OP_check_brand);
          dbuf_putc(bc, OP_rot3l);
          /* obj func value */
          dbuf_putc(bc, OP_call_method);
          dbuf_put_u16(bc, 1);
        } break;
        default:
          abort();
      }
      break;
    default:
      abort();
  }
  return 0;
}

QJS_STATIC void mark_eval_captured_variables(LEPUSContext *ctx,
                                             LEPUSFunctionDef *s,
                                             int scope_level) {
  int idx;
  LEPUSVarDef *vd;

  for (idx = s->scopes[scope_level].first; idx >= 0;) {
    vd = &s->vars[idx];
    vd->is_captured = 1;
    idx = vd->scope_next;
  }
}

QJS_STATIC BOOL is_var_in_arg_scope(LEPUSContext *ctx, const LEPUSVarDef *vd) {
  LEPUSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");
  BOOL ret = (vd->var_name == LEPUS_ATOM_home_object ||
              vd->var_name == LEPUS_ATOM_this_active_func ||
              vd->var_name == LEPUS_ATOM_new_target ||
              vd->var_name == LEPUS_ATOM_this || vd->var_name == atom_arg_var ||
              vd->var_kind == LEPUS_VAR_FUNCTION_NAME);
  LEPUS_FreeAtom(ctx, atom_arg_var);
  return ret;
}

QJS_STATIC void add_eval_variables(LEPUSContext *ctx, LEPUSFunctionDef *s) {
  LEPUSFunctionDef *fd;
  LEPUSVarDef *vd;
  int i, scope_level, scope_idx;
  BOOL has_arguments_binding, has_this_binding, is_arg_scope;

  /* in non strict mode, variables are created in the caller's
     environment object */
  if (!s->is_eval && !(s->lepus_mode & LEPUS_MODE_STRICT)) {
    s->var_object_idx = add_var(ctx, s, LEPUS_ATOM__var_);
    if (s->has_parameter_expressions) {
      /* an additional variable object is needed for the
         argument scope */
      LEPUSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");
      s->arg_var_object_idx = add_var(ctx, s, atom_arg_var);
      LEPUS_FreeAtom(ctx, atom_arg_var);
    }
  }

  /* eval can potentially use 'arguments' so we must define it */
  has_this_binding = s->has_this_binding;
  if (has_this_binding) {
    if (s->this_var_idx < 0) s->this_var_idx = add_var_this(ctx, s);
    if (s->new_target_var_idx < 0)
      s->new_target_var_idx = add_var(ctx, s, LEPUS_ATOM_new_target);
    if (s->is_derived_class_constructor && s->this_active_func_var_idx < 0)
      s->this_active_func_var_idx =
          add_var(ctx, s, LEPUS_ATOM_this_active_func);
    if (s->has_home_object && s->home_object_var_idx < 0)
      s->home_object_var_idx = add_var(ctx, s, LEPUS_ATOM_home_object);
  }
  has_arguments_binding = s->has_arguments_binding;
  if (has_arguments_binding) {
    add_arguments_var(ctx, s, LEPUS_ATOM_arguments);
    if (s->has_parameter_expressions && !(s->lepus_mode & LEPUS_MODE_STRICT))
      add_arguments_arg(ctx, s);
  }
  if (s->is_func_expr && s->func_name != LEPUS_ATOM_NULL)
    add_func_var(ctx, s, s->func_name);

  /* eval can use all the variables of the enclosing functions, so
     they must be all put in the closure. The closure variables are
     ordered by scope. It works only because no closure are created
     before. */
  assert(s->is_eval || s->closure_var_count == 0);

  /* XXX: inefficient, but eval performance is less critical */
  fd = s;
  for (;;) {
    scope_level = fd->parent_scope_level;
    fd = fd->parent;
    if (!fd) break;
    /* add 'this' if it was not previously added */
    if (!has_this_binding && fd->has_this_binding) {
      if (fd->this_var_idx < 0) fd->this_var_idx = add_var_this(ctx, fd);
      if (fd->new_target_var_idx < 0)
        fd->new_target_var_idx = add_var(ctx, fd, LEPUS_ATOM_new_target);
      if (fd->is_derived_class_constructor && fd->this_active_func_var_idx < 0)
        fd->this_active_func_var_idx =
            add_var(ctx, fd, LEPUS_ATOM_this_active_func);
      if (fd->has_home_object && fd->home_object_var_idx < 0)
        fd->home_object_var_idx = add_var(ctx, fd, LEPUS_ATOM_home_object);
      has_this_binding = TRUE;
    }
    /* add 'arguments' if it was not previously added */
    if (!has_arguments_binding && fd->has_arguments_binding) {
      add_arguments_var(ctx, fd, LEPUS_ATOM_arguments);
      has_arguments_binding = TRUE;
    }
    /* add function name */
    if (fd->is_func_expr && fd->func_name != LEPUS_ATOM_NULL)
      add_func_var(ctx, fd, fd->func_name);

    /* add lexical variables */
    scope_idx = fd->scopes[scope_level].first;
    while (scope_idx >= 0) {
      vd = &fd->vars[scope_idx];
      vd->is_captured = 1;
      get_closure_var(ctx, s, fd, FALSE, scope_idx, vd->var_name, vd->is_const,
                      vd->is_lexical,
                      static_cast<LEPUSVarKindEnum>(vd->var_kind));
      scope_idx = vd->scope_next;
    }
    is_arg_scope = (scope_idx == ARG_SCOPE_END);
    if (!is_arg_scope) {
      /* add unscoped variables */
      for (i = 0; i < fd->arg_count; i++) {
        vd = &fd->args[i];
        if (vd->var_name != LEPUS_ATOM_NULL) {
          get_closure_var(ctx, s, fd, TRUE, i, vd->var_name, FALSE, FALSE,
                          LEPUS_VAR_NORMAL);
        }
      }
      for (i = 0; i < fd->var_count; i++) {
        vd = &fd->vars[i];
        /* do not close top level last result */
        if (vd->scope_level == 0 && vd->var_name != LEPUS_ATOM__ret_ &&
            vd->var_name != LEPUS_ATOM_NULL) {
          get_closure_var(ctx, s, fd, FALSE, i, vd->var_name, FALSE, FALSE,
                          LEPUS_VAR_NORMAL);
        }
      }
    } else {
      for (i = 0; i < fd->var_count; i++) {
        vd = &fd->vars[i];
        /* do not close top level last result */
        if (vd->scope_level == 0 && is_var_in_arg_scope(ctx, vd)) {
          get_closure_var(ctx, s, fd, FALSE, i, vd->var_name, FALSE, FALSE,
                          LEPUS_VAR_NORMAL);
        }
      }
      if (fd->is_eval) {
        int idx;
        /* add direct eval variables (we are necessarily at the
          top level) */
        for (idx = 0; idx < fd->closure_var_count; idx++) {
          LEPUSClosureVar *cv = &fd->closure_var[idx];
          get_closure_var2(ctx, s, fd, FALSE, cv->is_arg, idx, cv->var_name,
                           cv->is_const, cv->is_lexical,
                           static_cast<LEPUSVarKindEnum>(cv->var_kind));
        }
      }
    }
  }
}

QJS_STATIC void set_closure_from_var(LEPUSContext *ctx, LEPUSClosureVar *cv,
                                     LEPUSVarDef *vd, int var_idx) {
  cv->is_local = TRUE;
  cv->is_arg = FALSE;
  cv->is_const = vd->is_const;
  cv->is_lexical = vd->is_lexical;
  cv->var_kind = vd->var_kind;
  cv->var_idx = var_idx;
  cv->var_name = LEPUS_DupAtom(ctx, vd->var_name);
}

/* for direct eval compilation: add references to the variables of the
   calling function */
QJS_STATIC __exception int add_closure_variables(LEPUSContext *ctx,
                                                 LEPUSFunctionDef *s,
                                                 LEPUSFunctionBytecode *b,
                                                 int scope_idx) {
  int i, count;
  LEPUSVarDef *vd;
  BOOL is_arg_scope;

  count = b->arg_count + b->var_count + b->closure_var_count;
  s->closure_var = NULL;
  s->closure_var_count = 0;
  s->closure_var_size = count;
  if (count == 0) return 0;
  s->closure_var = static_cast<LEPUSClosureVar *>(
      lepus_malloc(ctx, sizeof(s->closure_var[0]) * count));
  if (!s->closure_var) return -1;
  /* Add lexical variables in scope at the point of evaluation */
  if (scope_idx == DEBUG_SCOPE_INDEX) {
    for (i = 0; i < b->var_count; i++) {
      vd = &b->vardefs[b->arg_count + i];
      if (vd->scope_level > 0) {
        LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
        set_closure_from_var(ctx, cv, vd, i);
      }
    }
  } else {
    for (i = scope_idx; i >= 0;) {
      vd = &b->vardefs[b->arg_count + i];
      if (vd->scope_level > 0) {
        LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
        set_closure_from_var(ctx, cv, vd, i);
      }
      i = vd->scope_next;
    }
  }
  is_arg_scope = (i == ARG_SCOPE_END);
  if (!is_arg_scope) {
    /* Add argument variables */
    for (i = 0; i < b->arg_count; i++) {
      LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
      vd = &b->vardefs[i];
      cv->is_local = TRUE;
      cv->is_arg = TRUE;
      cv->is_const = FALSE;
      cv->is_lexical = FALSE;
      cv->var_kind = LEPUS_VAR_NORMAL;
      cv->var_idx = i;
      cv->var_name = LEPUS_DupAtom(ctx, vd->var_name);
    }
    /* Add local non lexical variables */
    for (i = 0; i < b->var_count; i++) {
      vd = &b->vardefs[b->arg_count + i];
      if (vd->scope_level == 0 && vd->var_name != LEPUS_ATOM__ret_) {
        LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
        set_closure_from_var(ctx, cv, vd, i);
      }
    }
  } else {
    /* only add pseudo variables */
    for (i = 0; i < b->var_count; i++) {
      vd = &b->vardefs[b->arg_count + i];
      if (vd->scope_level == 0 && is_var_in_arg_scope(ctx, vd)) {
        LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
        set_closure_from_var(ctx, cv, vd, i);
      }
    }
  }
  for (i = 0; i < b->closure_var_count; i++) {
    LEPUSClosureVar *cv0 = &b->closure_var[i];
    LEPUSClosureVar *cv = &s->closure_var[s->closure_var_count++];
    cv->is_local = FALSE;
    cv->is_arg = cv0->is_arg;
    cv->is_const = cv0->is_const;
    cv->is_lexical = cv0->is_lexical;
    cv->var_kind = cv0->var_kind;
    cv->var_idx = i;
    cv->var_name = LEPUS_DupAtom(ctx, cv0->var_name);
  }
  return 0;
}

typedef struct CodeContext {
  const uint8_t *bc_buf; /* code buffer */
  int bc_len;            /* length of the code buffer */
  int pos;               /* position past the matched code pattern */
  // <ByteDance begin>
  int64_t line_num; /* last visited OP_line_num parameter or -1 */
  // <ByteDance end>
  int op;
  int idx;
  int label;
  int val;
  LEPUSAtom atom;
} CodeContext;

#define M2(op1, op2) ((op1) | ((op2) << 8))
#define M3(op1, op2, op3) ((op1) | ((op2) << 8) | ((op3) << 16))
#define M4(op1, op2, op3, op4) \
  ((op1) | ((op2) << 8) | ((op3) << 16) | ((op4) << 24))

QJS_STATIC BOOL code_match(CodeContext *s, int pos, ...) {
  const uint8_t *tab = s->bc_buf;
  // <ByteDance begin>
  int op, len, op1, pos_next;
  int64_t line_num;
  // <ByteDance end>
  va_list ap;
  BOOL ret = FALSE;

  line_num = -1;
  va_start(ap, pos);

  for (;;) {
    op1 = va_arg(ap, int);
    if (op1 == -1) {
      s->pos = pos;
      s->line_num = line_num;
      ret = TRUE;
      break;
    }
    for (;;) {
      if (pos >= s->bc_len) goto done;
      op = tab[pos];
      len = opcode_info[op].size;
      pos_next = pos + len;
      if (pos_next > s->bc_len) goto done;
      // <ByteDance begin>
      if (op == OP_line_num) {
        line_num = get_u64(tab + pos + 1);
        pos = pos_next;
      }
      // <ByteDance end>
      else {
        break;
      }
    }
    if (op != op1) {
      if (op1 == (uint8_t)op1 || !op) break;
      if (op != (uint8_t)op1 && op != (uint8_t)(op1 >> 8) &&
          op != (uint8_t)(op1 >> 16) && op != (uint8_t)(op1 >> 24)) {
        break;
      }
      s->op = op;
    }

    pos++;
    switch (opcode_info[op].fmt) {
      case OP_FMT_loc8:
      case OP_FMT_u8: {
        int idx = tab[pos];
        int arg = va_arg(ap, int);
        if (arg == -1) {
          s->idx = idx;
        } else {
          if (arg != idx) goto done;
        }
        break;
      }
      case OP_FMT_u16:
      case OP_FMT_npop:
      case OP_FMT_loc:
      case OP_FMT_arg:
      case OP_FMT_var_ref: {
        int idx = get_u16(tab + pos);
        int arg = va_arg(ap, int);
        if (arg == -1) {
          s->idx = idx;
        } else {
          if (arg != idx) goto done;
        }
        break;
      }
      case OP_FMT_i32:
      case OP_FMT_u32:
      case OP_FMT_label:
      case OP_FMT_const: {
        s->label = get_u32(tab + pos);
        break;
      }
      // <ByteDance begin>
      case OP_FMT_u64: {
        s->label = get_u64(tab + pos);
        break;
      }
      // <ByteDance end>
      case OP_FMT_label_u16: {
        s->label = get_u32(tab + pos);
        s->val = get_u16(tab + pos + 4);
        break;
      }
      case OP_FMT_atom: {
        s->atom = get_u32(tab + pos);
        break;
      }
      case OP_FMT_atom_u8: {
        s->atom = get_u32(tab + pos);
        s->val = get_u8(tab + pos + 4);
        break;
      }
      case OP_FMT_atom_u16: {
        s->atom = get_u32(tab + pos);
        s->val = get_u16(tab + pos + 4);
        break;
      }
      case OP_FMT_atom_label_u8: {
        s->atom = get_u32(tab + pos);
        s->label = get_u32(tab + pos + 4);
        s->val = get_u8(tab + pos + 8);
        break;
      }
      default:
        break;
    }
    pos = pos_next;
  }
done:
  va_end(ap);
  return ret;
}

QJS_STATIC void instantiate_hoisted_definitions(LEPUSContext *ctx,
                                                LEPUSFunctionDef *s,
                                                DynBuf *bc) {
  int i, idx, var_idx, label_next;

  /* add the hoisted functions and variables */
  for (i = 0; i < s->arg_count; i++) {
    LEPUSVarDef *vd = &s->args[i];
    if (vd->func_pool_idx >= 0) {
      dbuf_putc(bc, OP_fclosure);
      dbuf_put_u32(bc, vd->func_pool_idx);
      dbuf_putc(bc, OP_put_arg);
      dbuf_put_u16(bc, i);
    }
  }
  for (i = 0; i < s->var_count; i++) {
    LEPUSVarDef *vd = &s->vars[i];
    if (vd->scope_level == 0 && vd->func_pool_idx >= 0) {
      dbuf_putc(bc, OP_fclosure);
      dbuf_put_u32(bc, vd->func_pool_idx);
      dbuf_putc(bc, OP_put_loc);
      dbuf_put_u16(bc, i);
    }
  }

  /* the module global variables must be initialized before
     evaluating the module so that the exported functions are
     visible if there are cyclic module references */
  if (s->module) {
    label_next = new_label_fd(s, -1);

    /* if 'this' is true, initialize the global variables and return */
    dbuf_putc(bc, OP_push_this);
    dbuf_putc(bc, OP_if_false);
    dbuf_put_u32(bc, label_next);
    update_label(s, label_next, 1);
    s->jump_size++;
  }
  /* add the global variables (only happens if s->is_global_var is
     true) */
  for (i = 0; i < s->hoisted_def_count; i++) {
    LEPUSHoistedDef *hf = &s->hoisted_def[i];
    int has_closure = 0;
    BOOL force_init = hf->force_init;
    // if (s->is_global_var && hf->var_name != LEPUS_ATOM_NULL) {
    /* we are in an eval, so the closure contains all the
       enclosing variables */
    /* If the outer function has a variable environment,
       create a property for the variable there */
    LEPUSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");
    for (idx = 0; idx < s->closure_var_count; idx++) {
      LEPUSClosureVar *cv = &s->closure_var[idx];
      if (cv->var_name == hf->var_name) {
        has_closure = 2;
        force_init = FALSE;
        break;
      }
      if (cv->var_name == LEPUS_ATOM__var_ || cv->var_name == atom_arg_var) {
        dbuf_putc(bc, OP_get_var_ref);
        dbuf_put_u16(bc, idx);
        has_closure = 1;
        force_init = TRUE;
        break;
      }
    }
    LEPUS_FreeAtom(ctx, atom_arg_var);
    if (!has_closure) {
      int flags;

      flags = 0;
      if (s->eval_type != LEPUS_EVAL_TYPE_GLOBAL)
        flags |= LEPUS_PROP_CONFIGURABLE;
      if (hf->cpool_idx >= 0 && !hf->is_lexical) {
        /* global function definitions need a specific handling */
        dbuf_putc(bc, OP_fclosure);
        dbuf_put_u32(bc, hf->cpool_idx);

        dbuf_putc(bc, OP_define_func);
        dbuf_put_u32(bc, LEPUS_DupAtom(ctx, hf->var_name));
        dbuf_putc(bc, flags);

        goto done_hoisted_def;
      } else {
        if (hf->is_lexical) {
          flags |= DEFINE_GLOBAL_LEX_VAR;
          if (!hf->is_const) flags |= LEPUS_PROP_WRITABLE;
        }
        dbuf_putc(bc, OP_define_var);
        dbuf_put_u32(bc, LEPUS_DupAtom(ctx, hf->var_name));
        dbuf_putc(bc, flags);
      }
    }
    // }
    if (hf->cpool_idx >= 0 || force_init) {
      if (hf->cpool_idx >= 0) {
        dbuf_putc(bc, OP_fclosure);
        dbuf_put_u32(bc, hf->cpool_idx);
        if (hf->var_name == LEPUS_ATOM__default_) {
          /* set default export function name */
          dbuf_putc(bc, OP_set_name);
          dbuf_put_u32(bc, LEPUS_DupAtom(ctx, LEPUS_ATOM_default));
        }
      } else {
        dbuf_putc(bc, OP_undefined);
      }
      // if (s->is_global_var) {
      if (has_closure == 2) {
        dbuf_putc(bc, OP_put_var_ref);
        dbuf_put_u16(bc, idx);
      } else if (has_closure == 1) {
        dbuf_putc(bc, OP_define_field);
        dbuf_put_u32(bc, LEPUS_DupAtom(ctx, hf->var_name));
        dbuf_putc(bc, OP_drop);
      } else {
        /* XXX: Check if variable is writable and enumerable */
        dbuf_putc(bc, OP_put_var);
        dbuf_put_u32(bc, LEPUS_DupAtom(ctx, hf->var_name));
      }
    }
  done_hoisted_def:
    LEPUS_FreeAtom(ctx, hf->var_name);
  }
  if (s->module) {
    dbuf_putc(bc, OP_return_undef);

    dbuf_putc(bc, OP_label);
    dbuf_put_u32(bc, label_next);
    s->label_slots[label_next].pos2 = bc->size;
  }

  lepus_free(ctx, s->hoisted_def);
  s->hoisted_def = NULL;
  s->hoisted_def_count = 0;
  s->hoisted_def_size = 0;
}

QJS_STATIC int skip_dead_code(
    LEPUSFunctionDef *s, const uint8_t *bc_buf, int bc_len, int pos,
    /* ByteDance begin */ int64_t *linep /*ByteDance end*/) {
  int op, len, label;

  for (; pos < bc_len; pos += len) {
    op = bc_buf[pos];
    len = opcode_info[op].size;
    // <ByteDance begin>
    if (op == OP_line_num) {
      *linep = get_u64(bc_buf + pos + 1);
    }
    // <ByteDance end>
    else if (op == OP_label) {
      label = get_u32(bc_buf + pos + 1);
      if (update_label(s, label, 0) > 0) break;
#if 0
            if (s->label_slots[label].first_reloc) {
                printf("line %d: unreferenced label %d:%d has relocations\n",
                       *linep, label, s->label_slots[label].pos2);
            }
#endif
      assert(s->label_slots[label].first_reloc == NULL);
    } else {
      /* XXX: output a warning for unreachable code? */
      LEPUSAtom atom;
      switch (opcode_info[op].fmt) {
        case OP_FMT_label:
        case OP_FMT_label_u16:
          label = get_u32(bc_buf + pos + 1);
          update_label(s, label, -1);
          break;
        case OP_FMT_atom_label_u8:
        case OP_FMT_atom_label_u16:
          label = get_u32(bc_buf + pos + 5);
          update_label(s, label, -1);
          /* fall thru */
        case OP_FMT_atom:
        case OP_FMT_atom_u8:
        case OP_FMT_atom_u16:
          atom = get_u32(bc_buf + pos + 1);
          LEPUS_FreeAtom(s->ctx, atom);
          break;
        default:
          break;
      }
    }
  }
  return pos;
}

QJS_STATIC int get_label_pos(LEPUSFunctionDef *s, int label) {
  int i, pos;
  for (i = 0; i < 20; i++) {
    pos = s->label_slots[label].pos;
    for (;;) {
      switch (s->byte_code.buf[pos]) {
        // <ByteDance begin>
        case OP_line_num:
          pos += 9;
          continue;
        // <ByteDance end>
        case OP_label:
          pos += 5;
          continue;
        case OP_goto:
          label = get_u32(s->byte_code.buf + pos + 1);
          break;
        default:
          return pos;
      }
      break;
    }
  }
  return pos;
}

/* convert global variable accesses to local variables or closure
   variables when necessary */
QJS_STATIC __exception int resolve_variables(LEPUSContext *ctx,
                                             LEPUSFunctionDef *s) {
  // <ByteDance begin>
  int pos, pos_next, bc_len, op, len, i, idx;
  int64_t line_num;
  // <ByteDance end>

  uint8_t *bc_buf;
  LEPUSAtom var_name;
  DynBuf bc_out;
  CodeContext cc;
  int scope;

  cc.bc_buf = bc_buf = s->byte_code.buf;
  cc.bc_len = bc_len = s->byte_code.size;
  lepus_dbuf_init(ctx, &bc_out);

  /* first pass for runtime checks (must be done before the
     variables are created) */
  LEPUSAtom atom_arg_var = LEPUS_NewAtom(ctx, "<arg_var>");
  for (i = 0; i < s->hoisted_def_count; i++) {
    LEPUSHoistedDef *hf = &s->hoisted_def[i];
    int flags;

    /* check if global variable (XXX: simplify) */
    for (idx = 0; idx < s->closure_var_count; idx++) {
      LEPUSClosureVar *cv = &s->closure_var[idx];
      if (cv->var_name == hf->var_name) {
        if (s->eval_type == LEPUS_EVAL_TYPE_DIRECT && cv->is_lexical) {
          /* Check if a lexical variable is
             redefined as 'var'. XXX: Could abort
             compilation here, but for consistency
             with the other checks, we delay the
             error generation. */
          dbuf_putc(&bc_out, OP_throw_var);
          dbuf_put_u32(&bc_out, LEPUS_DupAtom(ctx, hf->var_name));
          dbuf_putc(&bc_out, LEPUS_THROW_VAR_REDECL);
        }
        goto next;
      }
      if (cv->var_name == LEPUS_ATOM__var_ || cv->var_name == atom_arg_var)
        goto next;
    }

    dbuf_putc(&bc_out, OP_check_define_var);
    dbuf_put_u32(&bc_out, LEPUS_DupAtom(ctx, hf->var_name));
    flags = 0;
    if (hf->is_lexical) flags |= DEFINE_GLOBAL_LEX_VAR;
    if (hf->cpool_idx >= 0) flags |= DEFINE_GLOBAL_FUNC_VAR;
    dbuf_putc(&bc_out, flags);
  next:;
  }
  LEPUS_FreeAtom(ctx, atom_arg_var);

  line_num = 0; /* avoid warning */
  for (pos = 0; pos < bc_len; pos = pos_next) {
    op = bc_buf[pos];
    len = opcode_info[op].size;
    pos_next = pos + len;
    switch (op) {
      case OP_line_num:
        // <ByteDance begin>
        line_num = get_u64(bc_buf + pos + 1);
        // <ByteDance end>
        s->line_number_size++;
        goto no_change;

      case OP_eval: /* convert scope index to adjusted variable index */
        scope = get_u16(bc_buf + pos + 1);
        mark_eval_captured_variables(ctx, s, scope);
        dbuf_putc(&bc_out, op);
        dbuf_put_u16(&bc_out, s->scopes[scope].first + 1);
        break;
      case OP_scope_get_var_undef:
      case OP_scope_get_var:
      case OP_scope_put_var:
      case OP_scope_delete_var:
      case OP_scope_get_ref:
      case OP_scope_put_var_init:
        var_name = get_u32(bc_buf + pos + 1);
        scope = get_u16(bc_buf + pos + 5);
        pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out, NULL,
                                     NULL, pos_next);
        LEPUS_FreeAtom(ctx, var_name);
        break;
      case OP_scope_make_ref: {
        int label;
        LabelSlot *ls;
        var_name = get_u32(bc_buf + pos + 1);
        label = get_u32(bc_buf + pos + 5);
        scope = get_u16(bc_buf + pos + 9);
        ls = &s->label_slots[label];
        ls->ref_count--; /* always remove label reference */
        pos_next = resolve_scope_var(ctx, s, var_name, scope, op, &bc_out,
                                     bc_buf, ls, pos_next);
        LEPUS_FreeAtom(ctx, var_name);
      } break;
      case OP_scope_get_private_field:
      case OP_scope_get_private_field2:
      case OP_scope_put_private_field: {
        int ret;
        var_name = get_u32(bc_buf + pos + 1);
        scope = get_u16(bc_buf + pos + 5);
        ret = resolve_scope_private_field(ctx, s, var_name, scope, op, &bc_out);
        if (ret < 0) goto fail;
        LEPUS_FreeAtom(ctx, var_name);
      } break;
      case OP_gosub:
        s->jump_size++;
        if (OPTIMIZE) {
          /* remove calls to empty finalizers  */
          int label;
          LabelSlot *ls;

          label = get_u32(bc_buf + pos + 1);
          assert(label >= 0 && label < s->label_count);
          ls = &s->label_slots[label];
          if (code_match(&cc, ls->pos, OP_ret, -1)) {
            ls->ref_count--;
            break;
          }
        }
        goto no_change;
      case OP_drop:
        if (0) {
          /* remove drops before return_undef */
          /* do not perform this optimization in pass2 because
             it breaks patterns recognised in resolve_labels */
          int pos1 = pos_next;
          // <ByteDance begin>
          int64_t line1 = line_num;
          // <ByteDance end>
          while (code_match(&cc, pos1, OP_drop, -1)) {
            if (cc.line_num >= 0) line1 = cc.line_num;
            pos1 = cc.pos;
          }
          if (code_match(&cc, pos1, OP_return_undef, -1)) {
            pos_next = pos1;
            if (line1 != -1 && line1 != line_num) {
              line_num = line1;
              s->line_number_size++;
              dbuf_putc(&bc_out, OP_line_num);
              // <ByteDance begin>
              dbuf_put_u64(&bc_out, line_num);
              // <ByteDance end>
            }
            break;
          }
        }
        goto no_change;
      case OP_insert3:
        if (OPTIMIZE) {
          /* Transformation: insert3 put_array_el|put_ref_value drop ->
           * put_array_el|put_ref_value */
          if (code_match(&cc, pos_next, M2(OP_put_array_el, OP_put_ref_value),
                         OP_drop, -1)) {
            dbuf_putc(&bc_out, cc.op);
            pos_next = cc.pos;
            if (cc.line_num != -1 && cc.line_num != line_num) {
              line_num = cc.line_num;
              s->line_number_size++;
              dbuf_putc(&bc_out, OP_line_num);
              // <ByteDance begin>
              dbuf_put_u64(&bc_out, line_num);
              // <ByteDance end>
            }
            break;
          }
        }
        goto no_change;

      case OP_goto:
        s->jump_size++;
        /* fall thru */
      case OP_tail_call:
      case OP_tail_call_method:
      case OP_return:
      case OP_return_undef:
      case OP_throw:
      case OP_throw_var:
      case OP_ret:
        if (OPTIMIZE) {
          /* remove dead code */
          // <ByteDance begin>
          int64_t line = -1;
          // <ByteDance end>
          dbuf_put(&bc_out, bc_buf + pos, len);
          pos = skip_dead_code(s, bc_buf, bc_len, pos + len, &line);
          pos_next = pos;
          if (pos < bc_len && line >= 0 && line_num != line) {
            line_num = line;
            s->line_number_size++;
            dbuf_putc(&bc_out, OP_line_num);
            // <ByteDance begin>
            dbuf_put_u64(&bc_out, line_num);
            // <ByteDance end>
          }
          break;
        }
        goto no_change;

      case OP_label: {
        int label;
        LabelSlot *ls;

        label = get_u32(bc_buf + pos + 1);
        assert(label >= 0 && label < s->label_count);
        ls = &s->label_slots[label];
        ls->pos2 = bc_out.size + opcode_info[op].size;
      }
        goto no_change;

      case OP_enter_scope: {
        int scope_idx, scope = get_u16(bc_buf + pos + 1);

        if (scope == s->body_scope) {
          instantiate_hoisted_definitions(ctx, s, &bc_out);
        }

        for (scope_idx = s->scopes[scope].first; scope_idx >= 0;) {
          LEPUSVarDef *vd = &s->vars[scope_idx];
          if (vd->scope_level == scope) {
            if (scope_idx != s->arguments_arg_idx) {
              if (vd->var_kind == LEPUS_VAR_FUNCTION_DECL ||
                  vd->var_kind == LEPUS_VAR_NEW_FUNCTION_DECL) {
                /* Initialize lexical variable upon entering scope */
                dbuf_putc(&bc_out, OP_fclosure);
                dbuf_put_u32(&bc_out, vd->func_pool_idx);
                dbuf_putc(&bc_out, OP_put_loc);
                dbuf_put_u16(&bc_out, scope_idx);
              } else {
                /* XXX: should check if variable can be used
                  before initialization */
                dbuf_putc(&bc_out, OP_set_loc_uninitialized);
                dbuf_put_u16(&bc_out, scope_idx);
              }
            }
            scope_idx = vd->scope_next;
          } else {
            break;
          }
        }
      } break;

      case OP_leave_scope: {
        int scope_idx, scope = get_u16(bc_buf + pos + 1);

        for (scope_idx = s->scopes[scope].first; scope_idx >= 0;) {
          LEPUSVarDef *vd = &s->vars[scope_idx];
          if (vd->scope_level == scope) {
            if (vd->is_captured) {
              dbuf_putc(&bc_out, OP_close_loc);
              dbuf_put_u16(&bc_out, scope_idx);
            }
            scope_idx = vd->scope_next;
          } else {
            break;
          }
        }
      } break;

      case OP_set_name: {
        /* remove dummy set_name opcodes */
        LEPUSAtom name = get_u32(bc_buf + pos + 1);
        if (name == LEPUS_ATOM_NULL) break;
      }
        goto no_change;

      case OP_if_false:
      case OP_if_true:
      case OP_catch:
        s->jump_size++;
        goto no_change;

      case OP_dup:
        if (OPTIMIZE) {
          /* Transformation: dup if_false(l1) drop, l1: if_false(l2) ->
           * if_false(l2) */
          /* Transformation: dup if_true(l1) drop, l1: if_true(l2) ->
           * if_true(l2) */
          if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), OP_drop,
                         -1)) {
            int lab0, lab1, op1, pos1, line1, pos2;
            lab0 = lab1 = cc.label;
            assert(lab1 >= 0 && lab1 < s->label_count);
            op1 = cc.op;
            pos1 = cc.pos;
            line1 = cc.line_num;
            while (code_match(&cc, (pos2 = get_label_pos(s, lab1)), OP_dup, op1,
                              OP_drop, -1)) {
              lab1 = cc.label;
            }
            if (code_match(&cc, pos2, op1, -1)) {
              s->jump_size++;
              update_label(s, lab0, -1);
              update_label(s, cc.label, +1);
              dbuf_putc(&bc_out, op1);
              dbuf_put_u32(&bc_out, cc.label);
              pos_next = pos1;
              if (line1 != -1 && line1 != line_num) {
                line_num = line1;
                s->line_number_size++;
                dbuf_putc(&bc_out, OP_line_num);
                // <ByteDance begin>
                dbuf_put_u64(&bc_out, line_num);
                // <ByteDance end>
              }
              break;
            }
          }
        }
        goto no_change;

      case OP_nop:
        /* remove erased code */
        break;

      default:
      no_change:
        dbuf_put(&bc_out, bc_buf + pos, len);
        break;
    }
  }

  /* set the new byte code */
  dbuf_free(&s->byte_code);
  s->byte_code = bc_out;
  if (dbuf_error(&s->byte_code)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return -1;
  }
  return 0;
fail:
  /* continue the copy to keep the atom refcounts consistent */
  /* XXX: find a better solution ? */
  for (; pos < bc_len; pos = pos_next) {
    op = bc_buf[pos];
    len = opcode_info[op].size;
    pos_next = pos + len;
    dbuf_put(&bc_out, bc_buf + pos, len);
  }
  dbuf_free(&s->byte_code);
  s->byte_code = bc_out;
  return -1;
}

/* the pc2line table gives a line number for each PC value */
QJS_STATIC void add_pc2line_info(
    LEPUSFunctionDef *s, uint32_t pc,
    /* <ByteDance begin> */ int64_t line_num /* <ByteDance end>*/) {
  if (s->line_number_slots != NULL &&
      s->line_number_count < s->line_number_size &&
      pc >= s->line_number_last_pc && line_num != s->line_number_last) {
    s->line_number_slots[s->line_number_count].pc = pc;
    s->line_number_slots[s->line_number_count].line_num = line_num;
    s->line_number_count++;
    s->line_number_last_pc = pc;
    s->line_number_last = line_num;
  }
}

QJS_STATIC void compute_pc2line_info(LEPUSFunctionDef *s) {
  if (!(s->lepus_mode & LEPUS_MODE_STRIP) && s->line_number_slots) {
    // <ByteDance begin>
    int64_t last_line_num = s->line_num;
    // <ByteDance end>
    uint32_t last_pc = 0;
    int i;

    lepus_dbuf_init(s->ctx, &s->pc2line);
    for (i = 0; i < s->line_number_count; i++) {
      uint32_t pc = s->line_number_slots[i].pc;
      // <ByteDance begin>
      int64_t line_num = s->line_number_slots[i].line_num;
      int64_t diff_pc, diff_line;
      // <ByteDance end>

      if (line_num < 0) continue;

      diff_pc = pc - last_pc;
      diff_line = line_num - last_line_num;
      if (diff_line == 0 || diff_pc < 0) continue;

      if (diff_line >= PC2LINE_BASE &&
          diff_line < PC2LINE_BASE + PC2LINE_RANGE &&
          diff_pc <= PC2LINE_DIFF_PC_MAX) {
        dbuf_putc(&s->pc2line, (diff_line - PC2LINE_BASE) +
                                   diff_pc * PC2LINE_RANGE + PC2LINE_OP_FIRST);
      } else {
        /* longer encoding */
        dbuf_putc(&s->pc2line, 0);
        // <ByteDance begin>
        dbuf_put_leb128_u64(&s->pc2line, diff_pc);
        dbuf_put_sleb128_u64(&s->pc2line, diff_line);
        // <ByteDance end>
      }
      last_pc = pc;
      last_line_num = line_num;
    }
  }
}

QJS_STATIC RelocEntry *add_reloc(LEPUSContext *ctx, LabelSlot *ls,
                                 uint32_t addr, int size) {
  RelocEntry *re;
  re = static_cast<RelocEntry *>(lepus_malloc(ctx, sizeof(*re)));
  if (!re) return NULL;
  re->addr = addr;
  re->size = size;
  re->next = ls->first_reloc;
  ls->first_reloc = re;
  return re;
}

QJS_STATIC BOOL code_has_label(CodeContext *s, int pos, int label) {
  while (pos < s->bc_len) {
    int op = s->bc_buf[pos];
    if (op == OP_line_num) {
      // <ByteDance begin>
      pos += 9;
      // <ByteDance end>
      continue;
    }
    if (op == OP_label) {
      int lab = get_u32(s->bc_buf + pos + 1);
      if (lab == label) return TRUE;
      pos += 5;
      continue;
    }
    if (op == OP_goto) {
      int lab = get_u32(s->bc_buf + pos + 1);
      if (lab == label) return TRUE;
    }
    break;
  }
  return FALSE;
}

/* return the target label, following the OP_goto jumps
   the first opcode at destination is stored in *pop
 */
QJS_STATIC int find_jump_target(
    LEPUSFunctionDef *s, int label, int *pop,
    /* <ByteDance begin> */ int64_t *pline /* <ByteDance end>*/) {
  int i, pos, op;

  update_label(s, label, -1);
  for (i = 0; i < 10; i++) {
    assert(label >= 0 && label < s->label_count);
    pos = s->label_slots[label].pos2;
    for (;;) {
      switch (op = s->byte_code.buf[pos]) {
        case OP_line_num:
          // <ByteDance begin>
          if (pline) *pline = get_u64(s->byte_code.buf + pos + 1);
          // <ByteDance end>
          /* fall thru */
        case OP_label:
          pos += opcode_info[op].size;
          continue;
        case OP_goto:
          label = get_u32(s->byte_code.buf + pos + 1);
          break;
        case OP_drop:
          /* ignore drop opcodes if followed by OP_return_undef */
          while (s->byte_code.buf[++pos] == OP_drop) continue;
          if (s->byte_code.buf[pos] == OP_return_undef) op = OP_return_undef;
          /* fall thru */
        default:
          goto done;
      }
      break;
    }
  }
  /* cycle detected, could issue a warning */
done:
  *pop = op;
  update_label(s, label, +1);
  return label;
}

QJS_STATIC void push_short_int(DynBuf *bc_out, int val) {
#if SHORT_OPCODES
  if (val >= -1 && val <= 7) {
    dbuf_putc(bc_out, OP_push_0 + val);
    return;
  }
  if (val == (int8_t)val) {
    dbuf_putc(bc_out, OP_push_i8);
    dbuf_putc(bc_out, val);
    return;
  }
  if (val == (int16_t)val) {
    dbuf_putc(bc_out, OP_push_i16);
    dbuf_put_u16(bc_out, val);
    return;
  }
#endif
  dbuf_putc(bc_out, OP_push_i32);
  dbuf_put_u32(bc_out, val);
}

QJS_STATIC void put_short_code(DynBuf *bc_out, int op, int idx) {
#if SHORT_OPCODES
  if (idx < 4) {
    switch (op) {
      case OP_get_loc:
        dbuf_putc(bc_out, OP_get_loc0 + idx);
        return;
      case OP_put_loc:
        dbuf_putc(bc_out, OP_put_loc0 + idx);
        return;
      case OP_set_loc:
        dbuf_putc(bc_out, OP_set_loc0 + idx);
        return;
      case OP_get_arg:
        dbuf_putc(bc_out, OP_get_arg0 + idx);
        return;
      case OP_put_arg:
        dbuf_putc(bc_out, OP_put_arg0 + idx);
        return;
      case OP_set_arg:
        dbuf_putc(bc_out, OP_set_arg0 + idx);
        return;
      case OP_get_var_ref:
        dbuf_putc(bc_out, OP_get_var_ref0 + idx);
        return;
      case OP_put_var_ref:
        dbuf_putc(bc_out, OP_put_var_ref0 + idx);
        return;
      case OP_set_var_ref:
        dbuf_putc(bc_out, OP_set_var_ref0 + idx);
        return;
      case OP_call:
        dbuf_putc(bc_out, OP_call0 + idx);
        return;
    }
  }
  if (idx < 256) {
    switch (op) {
      case OP_get_loc:
        dbuf_putc(bc_out, OP_get_loc8);
        dbuf_putc(bc_out, idx);
        return;
      case OP_put_loc:
        dbuf_putc(bc_out, OP_put_loc8);
        dbuf_putc(bc_out, idx);
        return;
      case OP_set_loc:
        dbuf_putc(bc_out, OP_set_loc8);
        dbuf_putc(bc_out, idx);
        return;
    }
  }
#endif
  dbuf_putc(bc_out, op);
  dbuf_put_u16(bc_out, idx);
}

/* peephole optimizations and resolve goto/labels */
QJS_STATIC __exception int resolve_labels(LEPUSContext *ctx,
                                          LEPUSFunctionDef *s) {
  // <ByteDance begin>
  int pos, pos_next, bc_len, op, op1, len, i;
  int64_t line_num;
  // <ByteDance end>
  const uint8_t *bc_buf;
  DynBuf bc_out;
  LabelSlot *label_slots, *ls;
  RelocEntry *re, *re_next;
  CodeContext cc;
  int label;
#if SHORT_OPCODES
  JumpSlot *jp;
#endif

  label_slots = s->label_slots;

  line_num = s->line_num;
  // encode line_num to line_col_num
  line_num =
      (uint64_t)((uint64_t)line_num | ((uint64_t)1 << LINE_NUMBER_BITS_COUNT) |
                 (uint64_t)1 << LINE_COLUMN_TYPE_SHIFT);

  cc.bc_buf = bc_buf = s->byte_code.buf;
  cc.bc_len = bc_len = s->byte_code.size;
  lepus_dbuf_init(ctx, &bc_out);

#if SHORT_OPCODES
  if (s->jump_size) {
    s->jump_slots = static_cast<JumpSlot *>(
        lepus_mallocz(s->ctx, sizeof(*s->jump_slots) * s->jump_size));
    if (s->jump_slots == NULL) return -1;
  }
#endif
  /* XXX: Should skip this phase if not generating SHORT_OPCODES */
  if (s->line_number_size && !(s->lepus_mode & LEPUS_MODE_STRIP)) {
    s->line_number_slots = static_cast<LineNumberSlot *>(lepus_mallocz(
        s->ctx, sizeof(*s->line_number_slots) * s->line_number_size));
    if (s->line_number_slots == NULL) return -1;
    s->line_number_last = s->line_num;
    s->line_number_last_pc = 0;
  }

  /* initialize the 'home_object' variable if needed */
  if (s->home_object_var_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_HOME_OBJECT);
    put_short_code(&bc_out, OP_put_loc, s->home_object_var_idx);
  }
  /* initialize the 'this.active_func' variable if needed */
  if (s->this_active_func_var_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_THIS_FUNC);
    put_short_code(&bc_out, OP_put_loc, s->this_active_func_var_idx);
  }
  /* initialize the 'new.target' variable if needed */
  if (s->new_target_var_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_NEW_TARGET);
    put_short_code(&bc_out, OP_put_loc, s->new_target_var_idx);
  }
  /* initialize the 'this' variable if needed. In a derived class
     constructor, this is initially uninitialized. */
  if (s->this_var_idx >= 0) {
    if (s->is_derived_class_constructor) {
      dbuf_putc(&bc_out, OP_set_loc_uninitialized);
      dbuf_put_u16(&bc_out, s->this_var_idx);
    } else {
      dbuf_putc(&bc_out, OP_push_this);
      put_short_code(&bc_out, OP_put_loc, s->this_var_idx);
    }
  }
  /* initialize the 'arguments' variable if needed */
  if (s->arguments_var_idx >= 0) {
    if ((s->lepus_mode & LEPUS_MODE_STRICT) || !s->has_simple_parameter_list) {
      dbuf_putc(&bc_out, OP_special_object);
      dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_ARGUMENTS);
    } else {
      dbuf_putc(&bc_out, OP_special_object);
      dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_MAPPED_ARGUMENTS);
    }
    if (s->arguments_arg_idx >= 0)
      put_short_code(&bc_out, OP_set_loc, s->arguments_arg_idx);
    put_short_code(&bc_out, OP_put_loc, s->arguments_var_idx);
  }
  /* initialize a reference to the current function if needed */
  if (s->func_var_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_THIS_FUNC);
    put_short_code(&bc_out, OP_put_loc, s->func_var_idx);
  }
  /* initialize the variable environment object if needed */
  if (s->var_object_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
    put_short_code(&bc_out, OP_put_loc, s->var_object_idx);
  }

  if (s->arg_var_object_idx >= 0) {
    dbuf_putc(&bc_out, OP_special_object);
    dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
    put_short_code(&bc_out, OP_put_loc, s->arg_var_object_idx);
  }

  for (pos = 0; pos < bc_len; pos = pos_next) {
    int val;
    op = bc_buf[pos];
    len = opcode_info[op].size;
    pos_next = pos + len;
    switch (op) {
      case OP_close_var_object: {
        if (s->var_object_idx >= 0) {
          /* close the var object and create a new one */
          add_pc2line_info(s, bc_out.size, line_num);
          dbuf_putc(&bc_out, OP_close_loc);
          dbuf_put_u16(&bc_out, s->var_object_idx);
          dbuf_putc(&bc_out, OP_special_object);
          dbuf_putc(&bc_out, OP_SPECIAL_OBJECT_VAR_OBJECT);
          put_short_code(&bc_out, OP_put_loc, s->var_object_idx);
        }
      } break;

      case OP_line_num:
        /* line number info (for debug). We put it in a separate
           compressed table to reduce memory usage and get better
           performance */
        // <ByteDance begin>
        line_num = get_u64(bc_buf + pos + 1);
        // <ByteDance end>
        break;

      case OP_label: {
        label = get_u32(bc_buf + pos + 1);
        assert(label >= 0 && label < s->label_count);
        ls = &label_slots[label];
        assert(ls->addr == -1);
        ls->addr = bc_out.size;
        /* resolve the relocation entries */
        for (re = ls->first_reloc; re != NULL; re = re_next) {
          int diff = ls->addr - re->addr;
          re_next = re->next;
          switch (re->size) {
            case 4:
              put_u32(bc_out.buf + re->addr, diff);
              break;
            case 2:
              assert(diff == (int16_t)diff);
              put_u16(bc_out.buf + re->addr, diff);
              break;
            case 1:
              assert(diff == (int8_t)diff);
              put_u8(bc_out.buf + re->addr, diff);
              break;
          }
          lepus_free(ctx, re);
        }
        ls->first_reloc = NULL;
      } break;

      case OP_call:
      case OP_call_method: {
        /* detect and transform tail calls */
        int argc;
        argc = get_u16(bc_buf + pos + 1);
        if (code_match(&cc, pos_next, OP_return, -1)) {
          if (cc.line_num >= 0) line_num = cc.line_num;
          add_pc2line_info(s, bc_out.size, line_num);
          put_short_code(&bc_out, op + 1, argc);
          pos_next = skip_dead_code(s, bc_buf, bc_len, cc.pos, &line_num);
          break;
        }
        add_pc2line_info(s, bc_out.size, line_num);
        put_short_code(&bc_out, op, argc);
        break;
      }
        goto no_change;

      case OP_return:
      case OP_return_undef:
      case OP_return_async:
      case OP_throw:
      case OP_throw_var:
        pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
        goto no_change;

      case OP_goto:
        label = get_u32(bc_buf + pos + 1);
      has_goto:
        if (OPTIMIZE) {
          // <ByteDance begin>
          int64_t line1 = -1;
          // <ByteDance end>;
          /* Use custom matcher because multiple labels can follow */
          label = find_jump_target(s, label, &op1, &line1);
          if (code_has_label(&cc, pos_next, label)) {
            /* jump to next instruction: remove jump */
            update_label(s, label, -1);
            break;
          }
          if (op1 == OP_return || op1 == OP_return_undef || op1 == OP_throw) {
            /* jump to return/throw: remove jump, append return/throw */
            /* updating the line number obfuscates assembly listing */
            // if (line1 >= 0) line_num = line1;
            update_label(s, label, -1);
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, op1);
            pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
            break;
          }
          /* XXX: should duplicate single instructions followed by goto or
           * return */
          /* For example, can match one of these followed by return:
             push_i32 / push_const / push_atom_value / get_var /
             undefined / null / push_false / push_true / get_ref_value /
             get_loc / get_arg / get_var_ref
           */
        }
        goto has_label;

      case OP_gosub:
        label = get_u32(bc_buf + pos + 1);
        if (0 && OPTIMIZE) {
          label = find_jump_target(s, label, &op1, NULL);
          if (op1 == OP_ret) {
            update_label(s, label, -1);
            /* empty finally clause: remove gosub */
            break;
          }
        }
        goto has_label;

      case OP_catch:
        label = get_u32(bc_buf + pos + 1);
        goto has_label;

      case OP_if_true:
      case OP_if_false:
        label = get_u32(bc_buf + pos + 1);
        if (OPTIMIZE) {
          label = find_jump_target(s, label, &op1, NULL);
          /* transform if_false/if_true(l1) label(l1) -> drop label(l1) */
          if (code_has_label(&cc, pos_next, label)) {
            update_label(s, label, -1);
            dbuf_putc(&bc_out, OP_drop);
            break;
          }
          /* transform if_false(l1) goto(l2) label(l1) -> if_false(l2) label(l1)
           */
          if (code_match(&cc, pos_next, OP_goto, -1)) {
            int pos1 = cc.pos;
            // <ByteDance begin>
            int64_t line1 = cc.line_num;
            // <ByteDance end>;
            if (code_has_label(&cc, pos1, label)) {
              if (line1 >= 0) line_num = line1;
              pos_next = pos1;
              update_label(s, label, -1);
              label = cc.label;
              op ^= OP_if_true ^ OP_if_false;
            }
          }
        }
      has_label:
        add_pc2line_info(s, bc_out.size, line_num);
        if (op == OP_goto) {
          pos_next = skip_dead_code(s, bc_buf, bc_len, pos_next, &line_num);
        }
        assert(label >= 0 && label < s->label_count);
        ls = &label_slots[label];
#if SHORT_OPCODES
        jp = &s->jump_slots[s->jump_count++];
        jp->op = op;
        jp->size = 4;
        jp->pos = bc_out.size + 1;
        jp->label = label;

        if (ls->addr == -1) {
          int diff = ls->pos2 - pos - 1;
          if (diff < 128 &&
              (op == OP_if_false || op == OP_if_true || op == OP_goto)) {
            jp->size = 1;
            jp->op = OP_if_false8 + (op - OP_if_false);
            dbuf_putc(&bc_out, OP_if_false8 + (op - OP_if_false));
            dbuf_putc(&bc_out, 0);
            if (!add_reloc(ctx, ls, bc_out.size - 1, 1)) goto fail;
            break;
          }
          if (diff < 32768 && op == OP_goto) {
            jp->size = 2;
            jp->op = OP_goto16;
            dbuf_putc(&bc_out, OP_goto16);
            dbuf_put_u16(&bc_out, 0);
            if (!add_reloc(ctx, ls, bc_out.size - 2, 2)) goto fail;
            break;
          }
        } else {
          int diff = ls->addr - bc_out.size - 1;
          if (diff == (int8_t)diff &&
              (op == OP_if_false || op == OP_if_true || op == OP_goto)) {
            jp->size = 1;
            jp->op = OP_if_false8 + (op - OP_if_false);
            dbuf_putc(&bc_out, OP_if_false8 + (op - OP_if_false));
            dbuf_putc(&bc_out, diff);
            break;
          }
          if (diff == (int16_t)diff && op == OP_goto) {
            jp->size = 2;
            jp->op = OP_goto16;
            dbuf_putc(&bc_out, OP_goto16);
            dbuf_put_u16(&bc_out, diff);
            break;
          }
        }
#endif
        dbuf_putc(&bc_out, op);
        dbuf_put_u32(&bc_out, ls->addr - bc_out.size);
        if (ls->addr == -1) {
          /* unresolved yet: create a new relocation entry */
          if (!add_reloc(ctx, ls, bc_out.size - 4, 4)) goto fail;
        }
        break;
      case OP_with_get_var:
      case OP_with_put_var:
      case OP_with_delete_var:
      case OP_with_make_ref:
      case OP_with_get_ref:
      case OP_with_get_ref_undef: {
        LEPUSAtom atom;
        int is_with;

        atom = get_u32(bc_buf + pos + 1);
        label = get_u32(bc_buf + pos + 5);
        is_with = bc_buf[pos + 9];
        if (OPTIMIZE) {
          label = find_jump_target(s, label, &op1, NULL);
        }
        assert(label >= 0 && label < s->label_count);
        ls = &label_slots[label];
        add_pc2line_info(s, bc_out.size, line_num);
#if SHORT_OPCODES
        jp = &s->jump_slots[s->jump_count++];
        jp->op = op;
        jp->size = 4;
        jp->pos = bc_out.size + 5;
        jp->label = label;
#endif
        dbuf_putc(&bc_out, op);
        dbuf_put_u32(&bc_out, atom);
        dbuf_put_u32(&bc_out, ls->addr - bc_out.size);
        if (ls->addr == -1) {
          /* unresolved yet: create a new relocation entry */
          if (!add_reloc(ctx, ls, bc_out.size - 4, 4)) goto fail;
        }
        dbuf_putc(&bc_out, is_with);
      } break;

      case OP_drop:
        if (OPTIMIZE) {
          /* remove useless drops before return */
          if (code_match(&cc, pos_next, OP_return_undef, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            break;
          }
        }
        goto no_change;

      case OP_null:
#if SHORT_OPCODES
        if (OPTIMIZE) {
          /* transform null strict_eq into is_null */
          if (code_match(&cc, pos_next, OP_strict_eq, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_is_null);
            pos_next = cc.pos;
            break;
          }
          /* transform null strict_neq if_false/if_true -> is_null
           * if_true/if_false */
          if (code_match(&cc, pos_next, OP_strict_neq,
                         M2(OP_if_false, OP_if_true), -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_is_null);
            pos_next = cc.pos;
            label = cc.label;
            op = cc.op ^ OP_if_false ^ OP_if_true;
            goto has_label;
          }
        }
#endif
        /* fall thru */
      case OP_push_false:
      case OP_push_true:
        if (OPTIMIZE) {
          val = (op == OP_push_true);
          if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {
          has_constant_test:
            if (cc.line_num >= 0) line_num = cc.line_num;
            if (val == cc.op - OP_if_false) {
              /* transform null if_false(l1) -> goto l1 */
              /* transform false if_false(l1) -> goto l1 */
              /* transform true if_true(l1) -> goto l1 */
              pos_next = cc.pos;
              op = OP_goto;
              label = cc.label;
              goto has_goto;
            } else {
              /* transform null if_true(l1) -> nop */
              /* transform false if_true(l1) -> nop */
              /* transform true if_false(l1) -> nop */
              pos_next = cc.pos;
              update_label(s, cc.label, -1);
              break;
            }
          }
        }
        goto no_change;

      case OP_push_i32:
        if (OPTIMIZE) {
          /* transform i32(val) neg -> i32(-val) */
          val = get_i32(bc_buf + pos + 1);
          if ((val != INT32_MIN && val != 0) &&
              code_match(&cc, pos_next, OP_neg, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            if (code_match(&cc, cc.pos, OP_drop, -1)) {
              if (cc.line_num >= 0) line_num = cc.line_num;
            } else {
              add_pc2line_info(s, bc_out.size, line_num);
              push_short_int(&bc_out, -val);
            }
            pos_next = cc.pos;
            break;
          }
          /* remove push/drop pairs generated by the parser */
          if (code_match(&cc, pos_next, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            pos_next = cc.pos;
            break;
          }
          /* Optimize constant tests: `if (0)`, `if (1)`, `if (!0)`... */
          if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {
            val = (val != 0);
            goto has_constant_test;
          }
          add_pc2line_info(s, bc_out.size, line_num);
          push_short_int(&bc_out, val);
          break;
        }
        goto no_change;

#if SHORT_OPCODES
      case OP_push_const:
      case OP_fclosure:
        if (OPTIMIZE) {
          int idx = get_u32(bc_buf + pos + 1);
          if (idx < 256) {
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_push_const8 + op - OP_push_const);
            dbuf_putc(&bc_out, idx);
            break;
          }
        }
        goto no_change;

      case OP_get_field:
        if (OPTIMIZE) {
          LEPUSAtom atom = get_u32(bc_buf + pos + 1);
          if (atom == LEPUS_ATOM_length) {
            LEPUS_FreeAtom(ctx, atom);
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_get_length);
#ifdef ENABLE_PRIMJS_IC
            dbuf_put_u64(&bc_out, 0);
#endif
            break;
          }
        }
        goto no_change;
#endif
      case OP_push_atom_value:
        if (OPTIMIZE) {
          LEPUSAtom atom = get_u32(bc_buf + pos + 1);
          /* remove push/drop pairs generated by the parser */
          if (code_match(&cc, pos_next, OP_drop, -1)) {
            LEPUS_FreeAtom(ctx, atom);
            if (cc.line_num >= 0) line_num = cc.line_num;
            pos_next = cc.pos;
            break;
          }
#if SHORT_OPCODES
          if (atom == LEPUS_ATOM_empty_string) {
            LEPUS_FreeAtom(ctx, atom);
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_push_empty_string);
            break;
          }
#endif
        }
        goto no_change;

      case OP_to_propkey:
      case OP_to_propkey2:
        if (OPTIMIZE) {
          /* remove redundant to_propkey/to_propkey2 opcodes when storing simple
           * data */
          if (code_match(&cc, pos_next,
                         M3(OP_get_loc, OP_get_arg, OP_get_var_ref), -1,
                         OP_put_array_el, -1) ||
              code_match(&cc, pos_next,
                         M3(OP_push_i32, OP_push_const, OP_push_atom_value),
                         OP_put_array_el, -1) ||
              code_match(&cc, pos_next,
                         M4(OP_undefined, OP_null, OP_push_true, OP_push_false),
                         OP_put_array_el, -1)) {
            break;
          }
        }
        goto no_change;

      case OP_undefined:
        if (OPTIMIZE) {
          /* remove push/drop pairs generated by the parser */
          if (code_match(&cc, pos_next, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            pos_next = cc.pos;
            break;
          }
          /* transform undefined return -> return_undefined */
          if (code_match(&cc, pos_next, OP_return, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_return_undef);
            pos_next = cc.pos;
            break;
          }
          /* transform undefined if_true(l1)/if_false(l1) -> nop/goto(l1) */
          if (code_match(&cc, pos_next, M2(OP_if_false, OP_if_true), -1)) {
            val = 0;
            goto has_constant_test;
          }
#if SHORT_OPCODES
          /* transform undefined strict_eq -> is_undefined */
          if (code_match(&cc, pos_next, OP_strict_eq, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_is_undefined);
            pos_next = cc.pos;
            break;
          }
          /* transform undefined strict_neq if_false/if_true -> is_undefined
           * if_true/if_false */
          if (code_match(&cc, pos_next, OP_strict_neq,
                         M2(OP_if_false, OP_if_true), -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_is_undefined);
            pos_next = cc.pos;
            label = cc.label;
            op = cc.op ^ OP_if_false ^ OP_if_true;
            goto has_label;
          }
#endif
        }
        goto no_change;

      case OP_insert2:
        if (OPTIMIZE) {
          /* Transformation:
             insert2 put_field(a) drop -> put_field(a)
             insert2 put_var_strict(a) drop -> put_var_strict(a)
          */
          if (code_match(&cc, pos_next, M2(OP_put_field, OP_put_var_strict),
                         OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, cc.op);
            dbuf_put_u32(&bc_out, cc.atom);
#ifdef ENABLE_PRIMJS_IC
            if (cc.op == OP_put_field) {
              dbuf_put_u64(&bc_out, 0);
            }
#endif
            pos_next = cc.pos;
            break;
          }
        }
        goto no_change;

      case OP_dup:
        if (OPTIMIZE) {
          /* Transformation: dup put_x(n) drop -> put_x(n) */
          // <ByteDance begin>
          int op1 = -1;
          int64_t line2 = -1;
          // <ByteDance end>
          /* Transformation: dup put_x(n) -> set_x(n) */
          if (code_match(&cc, pos_next,
                         M3(OP_put_loc, OP_put_arg, OP_put_var_ref), -1, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            op1 = cc.op + 1; /* put_x -> set_x */
            pos_next = cc.pos;
            if (code_match(&cc, cc.pos, OP_drop, -1)) {
              if (cc.line_num >= 0) line_num = cc.line_num;
              op1 -= 1; /* set_x drop -> put_x */
              pos_next = cc.pos;
              if (code_match(&cc, cc.pos, op1 - 1, cc.idx, -1)) {
                line2 = cc.line_num; /* delay line number update */
                op1 += 1;            /* put_x(n) get_x(n) -> set_x(n) */
                pos_next = cc.pos;
              }
            }
            add_pc2line_info(s, bc_out.size, line_num);
            put_short_code(&bc_out, op1, cc.idx);
            if (line2 >= 0) line_num = line2;
            break;
          }
        }
        goto no_change;

      case OP_get_loc:
        if (OPTIMIZE) {
          /* transformation:
             get_loc(n) post_dec put_loc(n) drop -> dec_loc(n)
             get_loc(n) post_inc put_loc(n) drop -> inc_loc(n)
             get_loc(n) dec dup put_loc(n) drop -> dec_loc(n)
             get_loc(n) inc dup put_loc(n) drop -> inc_loc(n)
           */
          int idx;
          idx = get_u16(bc_buf + pos + 1);
          if (idx >= 256) goto no_change;
          if (code_match(&cc, pos_next, M2(OP_post_dec, OP_post_inc),
                         OP_put_loc, idx, OP_drop, -1) ||
              code_match(&cc, pos_next, M2(OP_dec, OP_inc), OP_dup, OP_put_loc,
                         idx, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, (cc.op == OP_inc || cc.op == OP_post_inc)
                                   ? OP_inc_loc
                                   : OP_dec_loc);
            dbuf_putc(&bc_out, idx);
            pos_next = cc.pos;
            break;
          }
          /* transformation:
             get_loc(n) push_atom_value(x) add dup put_loc(n) drop ->
             push_atom_value(x) add_loc(n)
           */
          if (code_match(&cc, pos_next, OP_push_atom_value, OP_add, OP_dup,
                         OP_put_loc, idx, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
#if SHORT_OPCODES
            if (cc.atom == LEPUS_ATOM_empty_string) {
              LEPUS_FreeAtom(ctx, cc.atom);
              dbuf_putc(&bc_out, OP_push_empty_string);
            } else
#endif
            {
              dbuf_putc(&bc_out, OP_push_atom_value);
              dbuf_put_u32(&bc_out, cc.atom);
            }
            dbuf_putc(&bc_out, OP_add_loc);
            dbuf_putc(&bc_out, idx);
            pos_next = cc.pos;
            break;
          }
          /* transformation:
             get_loc(n) push_i32(x) add dup put_loc(n) drop -> push_i32(x)
             add_loc(n)
           */
          if (code_match(&cc, pos_next, OP_push_i32, OP_add, OP_dup, OP_put_loc,
                         idx, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            push_short_int(&bc_out, cc.label);
            dbuf_putc(&bc_out, OP_add_loc);
            dbuf_putc(&bc_out, idx);
            pos_next = cc.pos;
            break;
          }
          /* transformation: XXX: also do these:
             get_loc(n) get_loc(x) add dup put_loc(n) drop -> get_loc(x)
             add_loc(n) get_loc(n) get_arg(x) add dup put_loc(n) drop ->
             get_arg(x) add_loc(n) get_loc(n) get_var_ref(x) add dup put_loc(n)
             drop -> get_var_ref(x) add_loc(n)
           */
          if (code_match(&cc, pos_next,
                         M3(OP_get_loc, OP_get_arg, OP_get_var_ref), -1, OP_add,
                         OP_dup, OP_put_loc, idx, OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            put_short_code(&bc_out, cc.op, cc.idx);
            dbuf_putc(&bc_out, OP_add_loc);
            dbuf_putc(&bc_out, idx);
            pos_next = cc.pos;
            break;
          }
          add_pc2line_info(s, bc_out.size, line_num);
          put_short_code(&bc_out, op, idx);
          break;
        }
        goto no_change;
#if SHORT_OPCODES
      case OP_get_arg:
      case OP_get_var_ref:
        if (OPTIMIZE) {
          int idx;
          idx = get_u16(bc_buf + pos + 1);
          add_pc2line_info(s, bc_out.size, line_num);
          put_short_code(&bc_out, op, idx);
          break;
        }
        goto no_change;
#endif
      case OP_put_loc:
      case OP_put_arg:
      case OP_put_var_ref:
        if (OPTIMIZE) {
          /* transformation: put_x(n) get_x(n) -> set_x(n) */
          int idx;
          idx = get_u16(bc_buf + pos + 1);
          if (code_match(&cc, pos_next, op - 1, idx, -1)) {
            add_pc2line_info(s, bc_out.size, line_num);
            if (cc.line_num >= 0) line_num = cc.line_num;
            put_short_code(&bc_out, op + 1, idx);
            pos_next = cc.pos;
            break;
          }
          add_pc2line_info(s, bc_out.size, line_num);
          put_short_code(&bc_out, op, idx);
          break;
        }
        goto no_change;

      case OP_post_inc:
      case OP_post_dec:
        if (OPTIMIZE) {
          /* transformation:
             post_inc put_x drop -> inc put_x
             post_inc perm3 put_field drop -> inc put_field
             post_inc perm3 put_var_strict drop -> inc put_var_strict
             post_inc perm4 put_array_el drop -> inc put_array_el
           */
          int op1, idx;
          if (code_match(&cc, pos_next,
                         M3(OP_put_loc, OP_put_arg, OP_put_var_ref), -1,
                         OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            op1 = cc.op;
            idx = cc.idx;
            pos_next = cc.pos;
            if (code_match(&cc, cc.pos, op1 - 1, idx, -1)) {
              op1 += 1; /* put_x(n) get_x(n) -> set_x(n) */
              pos_next = cc.pos;
              add_pc2line_info(s, bc_out.size, line_num);
              if (cc.line_num >= 0) line_num = cc.line_num;
            } else {
              add_pc2line_info(s, bc_out.size, line_num);
            }
            dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));
            put_short_code(&bc_out, op1, idx);
            break;
          }
          if (code_match(&cc, pos_next, OP_perm3,
                         M2(OP_put_field, OP_put_var_strict), OP_drop, -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));
            dbuf_putc(&bc_out, cc.op);
            dbuf_put_u32(&bc_out, cc.atom);
#ifdef ENABLE_PRIMJS_IC
            if (cc.op == OP_put_field) {
              dbuf_put_u64(&bc_out, 0);
            }
#endif
            pos_next = cc.pos;
            break;
          }
          if (code_match(&cc, pos_next, OP_perm4, OP_put_array_el, OP_drop,
                         -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            add_pc2line_info(s, bc_out.size, line_num);
            dbuf_putc(&bc_out, OP_dec + (op - OP_post_dec));
            dbuf_putc(&bc_out, OP_put_array_el);
            pos_next = cc.pos;
            break;
          }
        }
        goto no_change;

      case OP_typeof:
        if (OPTIMIZE) {
          /* simplify typeof tests */
          if (code_match(&cc, pos_next, OP_push_atom_value,
                         M4(OP_strict_eq, OP_strict_neq, OP_eq, OP_neq), -1)) {
            if (cc.line_num >= 0) line_num = cc.line_num;
            int op1 = (cc.op == OP_strict_eq || cc.op == OP_eq) ? OP_strict_eq
                                                                : OP_strict_neq;
#if SHORT_OPCODES
            int op2 = -1;
            switch (cc.atom) {
              case LEPUS_ATOM_undefined:
                op2 = OP_is_undefined;
                break;
              case LEPUS_ATOM_function:
                op2 = OP_is_function;
                break;
            }
            if (op2 >= 0) {
              /* transform typeof(s) == "<type>" into is_<type> */
              if (op1 == OP_strict_eq) {
                add_pc2line_info(s, bc_out.size, line_num);
                dbuf_putc(&bc_out, op2);
                LEPUS_FreeAtom(ctx, cc.atom);
                pos_next = cc.pos;
                break;
              }
              if (op1 == OP_strict_neq &&
                  code_match(&cc, cc.pos, OP_if_false, -1)) {
                /* transform typeof(s) != "<type>" if_false into is_<type>
                 * if_true */
                if (cc.line_num >= 0) line_num = cc.line_num;
                add_pc2line_info(s, bc_out.size, line_num);
                dbuf_putc(&bc_out, op2);
                LEPUS_FreeAtom(ctx, cc.atom);
                pos_next = cc.pos;
                label = cc.label;
                op = OP_if_true;
                goto has_label;
              }
            }
#endif
            if (cc.atom == LEPUS_ATOM_undefined) {
              /* transform typeof(s) == "undefined" into s === void 0 */
              add_pc2line_info(s, bc_out.size, line_num);
              dbuf_putc(&bc_out, OP_undefined);
              dbuf_putc(&bc_out, op1);
              LEPUS_FreeAtom(ctx, cc.atom);
              pos_next = cc.pos;
              break;
            }
          }
        }
        goto no_change;

      default:
      no_change:
        add_pc2line_info(s, bc_out.size, line_num);
        dbuf_put(&bc_out, bc_buf + pos, len);
        break;
    }
  }

  /* check that there were no missing labels */
  for (i = 0; i < s->label_count; i++) {
    assert(label_slots[i].first_reloc == NULL);
  }
#if SHORT_OPCODES
  if (OPTIMIZE) {
    /* more jump optimizations */
    int patch_offsets = 0;
    for (i = 0, jp = s->jump_slots; i < s->jump_count; i++, jp++) {
      LabelSlot *ls;
      JumpSlot *jp1;
      int j, pos, diff, delta;

      delta = 3;
      switch (op = jp->op) {
        case OP_goto16:
          delta = 1;
          /* fall thru */
        case OP_if_false:
        case OP_if_true:
        case OP_goto:
          pos = jp->pos;
          diff = s->label_slots[jp->label].addr - pos;
          if (diff >= -128 && diff <= 127 + delta) {
            jp->size = 1;
            if (op == OP_goto16) {
              bc_out.buf[pos - 1] = jp->op = OP_goto8;
            } else {
              bc_out.buf[pos - 1] = jp->op = OP_if_false8 + (op - OP_if_false);
            }
            goto shrink;
          } else if (diff == (int16_t)diff && op == OP_goto) {
            jp->size = 2;
            delta = 2;
            bc_out.buf[pos - 1] = jp->op = OP_goto16;
          shrink:
            /* XXX: should reduce complexity, using 2 finger copy scheme */
            memmove(bc_out.buf + pos + jp->size,
                    bc_out.buf + pos + jp->size + delta,
                    bc_out.size - pos - jp->size - delta);
            bc_out.size -= delta;
            patch_offsets++;
            for (j = 0, ls = s->label_slots; j < s->label_count; j++, ls++) {
              if (ls->addr > pos) ls->addr -= delta;
            }
            for (j = i + 1, jp1 = jp + 1; j < s->jump_count; j++, jp1++) {
              if (jp1->pos > pos) jp1->pos -= delta;
            }
            for (j = 0; j < s->line_number_count; j++) {
              if (s->line_number_slots[j].pc > pos)
                s->line_number_slots[j].pc -= delta;
            }
            continue;
          }
          break;
      }
    }
    if (patch_offsets) {
      JumpSlot *jp1;
      int j;
      for (j = 0, jp1 = s->jump_slots; j < s->jump_count; j++, jp1++) {
        int diff1 = s->label_slots[jp1->label].addr - jp1->pos;
        switch (jp1->size) {
          case 1:
            put_u8(bc_out.buf + jp1->pos, diff1);
            break;
          case 2:
            put_u16(bc_out.buf + jp1->pos, diff1);
            break;
          case 4:
            put_u32(bc_out.buf + jp1->pos, diff1);
            break;
        }
      }
    }
  }
  lepus_free(ctx, s->jump_slots);
  s->jump_slots = NULL;
#endif
  lepus_free(ctx, s->label_slots);
  s->label_slots = NULL;
  /* XXX: should delay until copying to runtime bytecode function */
  compute_pc2line_info(s);
  lepus_free(ctx, s->line_number_slots);
  s->line_number_slots = NULL;
  /* set the new byte code */
  dbuf_free(&s->byte_code);
  s->byte_code = bc_out;
  s->use_short_opcodes = TRUE;
  if (dbuf_error(&s->byte_code)) {
    LEPUS_ThrowOutOfMemory(ctx);
    return -1;
  }
  return 0;
fail:
  /* XXX: not safe */
  dbuf_free(&bc_out);
  return -1;
}

/* compute the maximum stack size needed by the function */

typedef struct StackSizeState {
  int stack_len_max;
  uint16_t *stack_level_tab;
} StackSizeState;

QJS_STATIC __exception int compute_stack_size_rec(LEPUSContext *ctx,
                                                  LEPUSFunctionDef *fd,
                                                  StackSizeState *s, int pos,
                                                  int op, int stack_len) {
  int bc_len, diff, n_pop, pos_next;
  const LEPUSOpCode *oi;
  const uint8_t *bc_buf;

  if (stack_len > s->stack_len_max) {
    s->stack_len_max = stack_len;
    if (s->stack_len_max > LEPUS_STACK_SIZE_MAX) goto stack_overflow;
  }
  bc_buf = fd->byte_code.buf;
  bc_len = fd->byte_code.size;
  for (;;) {
    if ((unsigned)pos >= bc_len) goto buf_overflow;
#if 0
        printf("%5d: %d\n", pos, stack_len);
#endif
    if (s->stack_level_tab[pos] != 0xffff) {
      /* already explored: check that the stack size is consistent */
      if (s->stack_level_tab[pos] != stack_len) {
        LEPUS_ThrowInternalError(ctx, "unconsistent stack size: %d %d (pc=%d)",
                                 s->stack_level_tab[pos], stack_len, pos);
        return -1;
      } else {
        return 0;
      }
    } else {
      s->stack_level_tab[pos] = stack_len;
    }

    op = bc_buf[pos];
    if (op == 0 || op >= OP_COUNT) {
      LEPUS_ThrowInternalError(ctx, "invalid opcode (op=%d, pc=%d)", op, pos);
      return -1;
    }
    oi = &short_opcode_info(op);
    pos_next = pos + oi->size;
    if (pos_next > bc_len) {
    buf_overflow:
      LEPUS_ThrowInternalError(ctx, "bytecode buffer overflow (op=%d, pc=%d)",
                               op, pos);
      return -1;
    }
    n_pop = oi->n_pop;
    /* call pops a variable number of arguments */
    if (oi->fmt == OP_FMT_npop) {
      n_pop += get_u16(bc_buf + pos + 1);
    } else {
#if SHORT_OPCODES
      if (oi->fmt == OP_FMT_npopx) {
        n_pop += op - OP_call0;
      }
#endif
    }

    if (stack_len < n_pop) {
      LEPUS_ThrowInternalError(ctx, "stack underflow (op=%d, pc=%d)", op, pos);
      return -1;
    }
    stack_len += oi->n_push - n_pop;
    if (stack_len > s->stack_len_max) {
      s->stack_len_max = stack_len;
      if (s->stack_len_max > LEPUS_STACK_SIZE_MAX) goto stack_overflow;
    }
    switch (op) {
      case OP_tail_call:
      case OP_tail_call_method:
      case OP_return:
      case OP_return_undef:
      case OP_return_async:
      case OP_throw:
      case OP_throw_var:
      case OP_ret:
        goto done;
      case OP_goto:
        diff = get_u32(bc_buf + pos + 1);
        pos_next = pos + 1 + diff;
        break;
#if SHORT_OPCODES
      case OP_goto16:
        diff = (int16_t)get_u16(bc_buf + pos + 1);
        pos_next = pos + 1 + diff;
        break;
      case OP_goto8:
        diff = (int8_t)bc_buf[pos + 1];
        pos_next = pos + 1 + diff;
        break;
      case OP_if_true8:
      case OP_if_false8:
        diff = (int8_t)bc_buf[pos + 1];
        if (compute_stack_size_rec(ctx, fd, s, pos + 1 + diff, op, stack_len))
          return -1;
        break;
#endif
      case OP_if_true:
      case OP_if_false:
      case OP_catch:
        diff = get_u32(bc_buf + pos + 1);
        if (compute_stack_size_rec(ctx, fd, s, pos + 1 + diff, op, stack_len))
          return -1;
        break;
      case OP_gosub:
        diff = get_u32(bc_buf + pos + 1);
        if (compute_stack_size_rec(ctx, fd, s, pos + 1 + diff, op,
                                   stack_len + 1))
          return -1;
        break;
      case OP_with_get_var:
      case OP_with_delete_var:
        diff = get_u32(bc_buf + pos + 5);
        if (compute_stack_size_rec(ctx, fd, s, pos + 5 + diff, op,
                                   stack_len + 1))
          return -1;
        break;
      case OP_with_make_ref:
      case OP_with_get_ref:
      case OP_with_get_ref_undef:
        diff = get_u32(bc_buf + pos + 5);
        if (compute_stack_size_rec(ctx, fd, s, pos + 5 + diff, op,
                                   stack_len + 2))
          return -1;
        break;
      case OP_with_put_var:
        diff = get_u32(bc_buf + pos + 5);
        if (compute_stack_size_rec(ctx, fd, s, pos + 5 + diff, op,
                                   stack_len - 1))
          return -1;
        break;

      default:
        break;
    }
    pos = pos_next;
  }
done:
  return 0;

stack_overflow:
  LEPUS_ThrowInternalError(ctx, "stack overflow (op=%d, pc=%d)", op, pos);
  return -1;
}

QJS_STATIC __exception int compute_stack_size(LEPUSContext *ctx,
                                              LEPUSFunctionDef *fd,
                                              int *pstack_size) {
  StackSizeState s_s, *s = &s_s;
  int bc_len, i, ret;

  bc_len = fd->byte_code.size;
  /* bc_len > 0 */
  s->stack_level_tab = static_cast<uint16_t *>(
      lepus_malloc(ctx, sizeof(s->stack_level_tab[0]) * bc_len));
  if (!s->stack_level_tab) return -1;
  for (i = 0; i < bc_len; i++) s->stack_level_tab[i] = 0xffff;
  s->stack_len_max = 0;
  ret = compute_stack_size_rec(ctx, fd, s, 0, OP_invalid, 0);
  lepus_free(ctx, s->stack_level_tab);
  *pstack_size = s->stack_len_max;
  return ret;
}

QJS_STATIC int add_module_variables(LEPUSContext *ctx, LEPUSFunctionDef *fd) {
  int i, idx;
  LEPUSModuleDef *m = fd->module;
  LEPUSExportEntry *me;
  LEPUSHoistedDef *hf;

  /* The imported global variables were added as closure variables
     in lepus_parse_import(). We add here the module global
     variables. */

  for (i = 0; i < fd->hoisted_def_count; i++) {
    hf = &fd->hoisted_def[i];
    if (add_closure_var(ctx, fd, TRUE, FALSE, i, hf->var_name, hf->is_const,
                        hf->is_lexical,
                        static_cast<LEPUSVarKindEnum>(FALSE)) < 0)
      return -1;
  }

  /* resolve the variable names of the local exports */
  for (i = 0; i < m->export_entries_count; i++) {
    me = &m->export_entries[i];
    if (me->export_type == LEPUS_EXPORT_TYPE_LOCAL) {
      idx = find_closure_var(ctx, fd, me->local_name);
      if (idx < 0) {
#ifdef LYNX_DEV
        LEPUS_ThrowSyntaxErrorAtom(ctx, "exported variable '%s' does not exist",
                                   me->local_name);
#endif
        return -1;
      }
      me->u.local.var_idx = idx;
    }
  }
  return 0;
}

// <primjs begin>
#ifdef ENABLE_PRIMJS_IC
static void resolve_ic(LEPUSContext *ctx, LEPUSFunctionBytecode *b) {
  uint8_t *byte_code_buf = b->byte_code_buf;

  uint32_t byte_code_len = b->byte_code_len;

  uint32_t get_feedback_vec_size = 0;
  uint32_t set_feedback_vec_size = 0;
  for (int pos = 0; pos < byte_code_len;) {
    uint8_t op = *(byte_code_buf + pos);
    LEPUSOpCode info = short_opcode_info(op);

    switch (op) {
      case OP_get_field: {
        put_u64(byte_code_buf + pos + 5,
                (uint64_t)(b->get_feedback_vec + get_feedback_vec_size++));
        break;
      }
      case OP_get_field2: {
        put_u64(byte_code_buf + pos + 5,
                (uint64_t)(b->get_feedback_vec + get_feedback_vec_size++));
        break;
      }
      case OP_put_field: {
        put_u64(byte_code_buf + pos + 5,
                (uint64_t)(b->set_feedback_vec + set_feedback_vec_size++));
        break;
      }
      case OP_get_length: {
        put_u64(byte_code_buf + pos + 1,
                (uint64_t)(b->get_feedback_vec + get_feedback_vec_size++));
        break;
      }
      case OP_get_var: {
        put_u64(byte_code_buf + pos + 5,
                (uint64_t)(b->get_feedback_vec + get_feedback_vec_size++));
        break;
      }
      case OP_get_var_undef: {
        put_u64(byte_code_buf + pos + 5,
                (uint64_t)(b->get_feedback_vec + get_feedback_vec_size++));
        break;
      }

      default: {
        break;
      }
    }
    pos += info.size;
  }
  assert(get_feedback_vec_size <= b->get_feedback_vec_size);
  assert(set_feedback_vec_size <= b->set_feedback_vec_size);
  b->get_feedback_vec_size = get_feedback_vec_size;
  b->set_feedback_vec_size = set_feedback_vec_size;
}
#endif

#ifdef TEST_BYTECODE_REWRITE
// Test only function.
static LEPUSValue force_read_from_snapshot(LEPUSContext *ctx,
                                           LEPUSFunctionBytecode *b) {
  LEPUSValue b_v = LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b);
  size_t out_buf_len;
  uint8_t *out_buf =
      LEPUS_WriteObject(ctx, &out_buf_len, b_v, LEPUS_WRITE_OBJ_BYTECODE);
  LEPUS_FreeValue(ctx, b_v);
  b_v = LEPUS_ReadObject(ctx, out_buf, out_buf_len, LEPUS_READ_OBJ_BYTECODE);
  lepus_free(ctx, out_buf);
  return b_v;
}
#endif

// <primjs end>

/* create a function object from a function definition. The function
   definition is freed. All the child functions are also created. It
   must be done this way to resolve all the variables. */
QJS_STATIC LEPUSValue lepus_create_function(LEPUSContext *ctx,
                                            LEPUSFunctionDef *fd) {
  LEPUSValue func_obj;
  LEPUSFunctionBytecode *b;
  struct list_head *el, *el1;
  int stack_size, scope, idx;
  int function_size, byte_code_offset, cpool_offset;
  int closure_var_offset, vardefs_offset;

  /* recompute scope linkage */
  for (scope = 0; scope < fd->scope_count; scope++) {
    fd->scopes[scope].first = -1;
  }
  if (fd->has_parameter_expressions) {
    /* special end of variable list marker for the argument scope */
    fd->scopes[ARG_SCOPE_INDEX].first = ARG_SCOPE_END;
  }
  for (idx = 0; idx < fd->var_count; idx++) {
    LEPUSVarDef *vd = &fd->vars[idx];
    vd->scope_next = fd->scopes[vd->scope_level].first;
    fd->scopes[vd->scope_level].first = idx;
  }
  for (scope = 2; scope < fd->scope_count; scope++) {
    LEPUSVarScope *sd = &fd->scopes[scope];
    if (sd->first < 0) sd->first = fd->scopes[sd->parent].first;
  }
  for (idx = 0; idx < fd->var_count; idx++) {
    LEPUSVarDef *vd = &fd->vars[idx];
    if (vd->scope_next < 0 && vd->scope_level > 1) {
      scope = fd->scopes[vd->scope_level].parent;
      vd->scope_next = fd->scopes[scope].first;
    }
  }

  /* if the function contains an eval call, the closure variables
     are used to compile the eval and they must be ordered by scope,
     so it is necessary to create the closure variables before any
     other variable lookup is done. */
  if (fd->has_eval_call) add_eval_variables(ctx, fd);

  /* add the module global variables in the closure */
  if (fd->module) {
    if (add_module_variables(ctx, fd)) goto fail;
  }

  /* first create all the child functions */
  list_for_each_safe(el, el1, &fd->child_list) {
    LEPUSFunctionDef *fd1;
    int cpool_idx;

    fd1 = list_entry(el, LEPUSFunctionDef, link);
    cpool_idx = fd1->parent_cpool_idx;
    func_obj = lepus_create_function(ctx, fd1);
    if (LEPUS_IsException(func_obj)) goto fail;
    /* save it in the constant pool */
    assert(cpool_idx >= 0);
    fd->cpool[cpool_idx] = func_obj;
  }

#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 4)
  if (!(fd->lepus_mode & LEPUS_MODE_STRIP)) {
    printf("pass 1\n");
    dump_byte_code(ctx, 1, fd->byte_code.buf, fd->byte_code.size, fd->args,
                   fd->arg_count, fd->vars, fd->var_count, fd->closure_var,
                   fd->closure_var_count, fd->cpool, fd->cpool_count,
                   fd->source, fd->line_num, fd->label_slots, NULL);
    printf("\n");
  }
#endif

  if (resolve_variables(ctx, fd)) goto fail;

#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 2)
  if (!(fd->lepus_mode & LEPUS_MODE_STRIP)) {
    printf("pass 2\n");
    dump_byte_code(ctx, 2, fd->byte_code.buf, fd->byte_code.size, fd->args,
                   fd->arg_count, fd->vars, fd->var_count, fd->closure_var,
                   fd->closure_var_count, fd->cpool, fd->cpool_count,
                   fd->source, fd->line_num, fd->label_slots, NULL);
    printf("\n");
  }
#endif

  if (resolve_labels(ctx, fd)) goto fail;

  if (compute_stack_size(ctx, fd, &stack_size) < 0) goto fail;

  if (fd->lepus_mode & LEPUS_MODE_STRIP) {
    function_size = offsetof(LEPUSFunctionBytecode, debug);
  } else {
    function_size = sizeof(*b);
  }
  cpool_offset = function_size;
  function_size += fd->cpool_count * sizeof(*fd->cpool);
  vardefs_offset = function_size;
  if (!(fd->lepus_mode & LEPUS_MODE_STRIP) || fd->has_eval_call) {
    function_size += (fd->arg_count + fd->var_count) * sizeof(*b->vardefs);
  }
  closure_var_offset = function_size;
  function_size += fd->closure_var_count * sizeof(*fd->closure_var);
  byte_code_offset = function_size;
  function_size += fd->byte_code.size;

  b = static_cast<LEPUSFunctionBytecode *>(lepus_mallocz(ctx, function_size));
  if (!b) goto fail;
#ifdef ENABLE_QUICKJS_DEBUGGER
  BOOL is_debug_mode;
  is_debug_mode = ctx->debugger_mode;
#endif
  if (ctx->debuginfo_outside == 1) {
    b->function_id = ctx->next_function_id++;
  }
  b->header.ref_count = 1;
  b->gc_header.mark = 0;

  b->byte_code_buf = (uint8_t *)b + byte_code_offset;
  b->byte_code_len = fd->byte_code.size;
  memcpy(b->byte_code_buf, fd->byte_code.buf, fd->byte_code.size);
  // <primjs begin>
#ifdef ENABLE_PRIMJS_BASELINEJIT
  b->execuate_count = 0;
#endif

#ifdef ENABLE_PRIMJS_IC
  if (fd->get_feedback_vec_size)
    b->get_feedback_vec = (TypeGetFeedBackVec *)lepus_mallocz(
        ctx, sizeof(TypeGetFeedBackVec) * fd->get_feedback_vec_size);
  if (fd->set_feedback_vec_size)
    b->set_feedback_vec = (TypeSetFeedBackVec *)lepus_mallocz(
        ctx, sizeof(TypeSetFeedBackVec) * fd->set_feedback_vec_size);
  b->get_feedback_vec_size = fd->get_feedback_vec_size;
  b->set_feedback_vec_size = fd->set_feedback_vec_size;
#endif
  // <primjs end>
  lepus_free(ctx, fd->byte_code.buf);
  fd->byte_code.buf = NULL;

  b->func_name = fd->func_name;
  if (fd->arg_count + fd->var_count > 0) {
    if ((fd->lepus_mode & LEPUS_MODE_STRIP) && !fd->has_eval_call) {
      /* Strip variable definitions not needed at runtime */
      int i;
      for (i = 0; i < fd->var_count; i++) {
        LEPUS_FreeAtom(ctx, fd->vars[i].var_name);
      }
      for (i = 0; i < fd->arg_count; i++) {
        LEPUS_FreeAtom(ctx, fd->args[i].var_name);
      }
      for (i = 0; i < fd->closure_var_count; i++) {
        LEPUS_FreeAtom(ctx, fd->closure_var[i].var_name);
        fd->closure_var[i].var_name = LEPUS_ATOM_NULL;
      }
    } else {
      b->vardefs = (LEPUSVarDef *)((uint8_t *)b + vardefs_offset);
      memcpy(b->vardefs, fd->args, fd->arg_count * sizeof(fd->args[0]));
      memcpy(b->vardefs + fd->arg_count, fd->vars,
             fd->var_count * sizeof(fd->vars[0]));
    }
    b->var_count = fd->var_count;
    b->arg_count = fd->arg_count;
    b->defined_arg_count = fd->defined_arg_count;
    lepus_free(ctx, fd->args);
    lepus_free(ctx, fd->vars);
  }
  b->cpool_count = fd->cpool_count;
  if (b->cpool_count) {
    b->cpool = (LEPUSValue *)((uint8_t *)b + cpool_offset);
    memcpy(b->cpool, fd->cpool, b->cpool_count * sizeof(*b->cpool));
  }
  lepus_free(ctx, fd->cpool);
  fd->cpool = NULL;

  b->stack_size = stack_size;

  if (fd->lepus_mode & LEPUS_MODE_STRIP) {
    LEPUS_FreeAtom(ctx, fd->filename);
    dbuf_free(&fd->pc2line);  // probably useless
  } else {
    /* XXX: source and pc2line info should be packed at the end of the
       LEPUSFunctionBytecode structure, avoiding allocation overhead
     */
    b->has_debug = 1;
    b->debug.filename = fd->filename;
    b->debug.line_num = fd->line_num;
#ifdef ENABLE_QUICKJS_DEBUGGER
    int64_t line_col = fd->column_num;
    int32_t line = -1;
    int64_t column = -1;
    ComputeLineCol(line_col, &line, &column);
    b->debug.column_num = column;
#endif

    b->debug.pc2line_buf = static_cast<uint8_t *>(
        lepus_realloc(ctx, fd->pc2line.buf, fd->pc2line.size));
    if (!b->debug.pc2line_buf) b->debug.pc2line_buf = fd->pc2line.buf;
    b->debug.pc2line_len = fd->pc2line.size;
    b->debug.source = fd->source;
    b->debug.source_len = fd->source_len;
  }
  if (fd->scopes != fd->def_scope_array) lepus_free(ctx, fd->scopes);

  b->closure_var_count = fd->closure_var_count;
  if (b->closure_var_count) {
    b->closure_var = (LEPUSClosureVar *)((uint8_t *)b + closure_var_offset);
    memcpy(b->closure_var, fd->closure_var,
           b->closure_var_count * sizeof(*b->closure_var));
  }
  lepus_free(ctx, fd->closure_var);
  fd->closure_var = NULL;

  b->has_prototype = fd->has_prototype;
  b->has_simple_parameter_list = fd->has_simple_parameter_list;
  b->lepus_mode = fd->lepus_mode;
  b->is_derived_class_constructor = fd->is_derived_class_constructor;
  b->func_kind = fd->func_kind;
  b->need_home_object = (fd->home_object_var_idx >= 0 || fd->need_home_object);
  b->new_target_allowed = fd->new_target_allowed;
  b->super_call_allowed = fd->super_call_allowed;
  b->super_allowed = fd->super_allowed;
  b->arguments_allowed = fd->arguments_allowed;

#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 1)
  if (!(fd->lepus_mode & LEPUS_MODE_STRIP)) {
    lepus_dump_function_bytecode(ctx, b);
  }
#endif

  if (fd->parent) {
    /* remove from parent list */
    list_del(&fd->link);
  }

#ifdef ENABLE_QUICKJS_DEBUGGER
  b->func_level_state = NO_DEBUGGER;
  if (GetDebuggerInfo(ctx) && (is_debug_mode || ctx->debugger_parse_script)) {
    DebuggerSetFunctionBytecodeScript(ctx, fd, b);
  }
#endif

#ifdef ENABLE_PRIMJS_IC
  resolve_ic(ctx, b);

#ifdef ENABLE_PRIMJS_BASELINEJIT
  // compile_function(ctx, b);
  b->jit_entry = prim_normal_entry;
#endif
#endif

  lepus_free(ctx, fd);
#ifdef TEST_BYTECODE_REWRITE
  return force_read_from_snapshot(ctx, b);
#else
  return LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b);
#endif
fail:
  lepus_free_function_def(ctx, fd);
  return LEPUS_EXCEPTION;
}
#endif

QJS_STATIC void free_function_bytecode(LEPUSRuntime *rt,
                                       LEPUSFunctionBytecode *b) {
  int i;

#if 0
    {
        char buf[ATOM_GET_STR_BUF_SIZE];
        printf("freeing %s\n",
               LEPUS_AtomGetStrRT(rt, buf, sizeof(buf), b->func_name));
    }
#endif
  free_bytecode_atoms(rt, b->byte_code_buf, b->byte_code_len, TRUE);

  if (b->vardefs) {
    for (i = 0; i < b->arg_count + b->var_count; i++) {
      LEPUS_FreeAtomRT(rt, b->vardefs[i].var_name);
    }
  }
  if (b->cpool) {
    for (i = 0; i < b->cpool_count; i++) LEPUS_FreeValueRT(rt, b->cpool[i]);
  }

  for (i = 0; i < b->closure_var_count; i++) {
    LEPUSClosureVar *cv = &b->closure_var[i];
    LEPUS_FreeAtomRT(rt, cv->var_name);
  }

  LEPUS_FreeAtomRT(rt, b->func_name);

#ifdef ENABLE_QUICKJS_DEBUGGER
  if (b->func_level_state != NO_DEBUGGER && b->link.next && b->link.prev) {
    list_del(&b->link);
  }
#endif

  if (b->has_debug) {
    LEPUS_FreeAtomRT(rt, b->debug.filename);
    lepus_free_rt(rt, b->debug.pc2line_buf);
#ifdef ENABLE_QUICKJS_DEBUGGER
    if (b->func_level_state != DEBUGGER_TOP_LEVEL_FUNCTION) {
      lepus_free_rt(rt, b->debug.source);
    }
#else
    lepus_free_rt(rt, b->debug.source);
#endif
  }
// <primjs begin>
#ifdef ENABLE_PRIMJS_IC
  for (i = 0; i < b->set_feedback_vec_size; i++) {
    TypeSetFeedBack *feedback_vec = (TypeSetFeedBack *)&b->set_feedback_vec[i];
    for (int j = 0; j < DEFAULT_FEEDBACK_SIZE; j++) {
      TypeSetFeedBack *feedback = (TypeSetFeedBack *)&feedback_vec[j];
      lepus_free_shape_null(rt, feedback->old_shape);
      lepus_free_shape_null(rt, feedback->new_shape);
    }
  }
  for (i = 0; i < b->get_feedback_vec_size; i++) {
    TypeGetFeedBack *feedback_vec = (TypeGetFeedBack *)&b->get_feedback_vec[i];
    for (int j = 0; j < DEFAULT_FEEDBACK_SIZE; j++) {
      TypeGetFeedBack *feedback = (TypeGetFeedBack *)&feedback_vec[j];
      lepus_free_shape_null(rt, feedback->shape);
      lepus_free_shape_null(rt, feedback->proto_shape);
    }
  }
  if (b->get_feedback_vec) lepus_free_rt(rt, b->get_feedback_vec);
  if (b->set_feedback_vec) lepus_free_rt(rt, b->set_feedback_vec);
#endif
  // <primjs end>
  lepus_free_rt(rt, b);
}

#ifndef NO_QUICKJS_COMPILER
QJS_STATIC __exception int lepus_parse_directives(LEPUSParseState *s) {
  char str[20];
  LEPUSParsePos pos;
  BOOL has_semi;

  if (s->token.val != TOK_STRING) return 0;

  lepus_parse_get_pos(s, &pos);

  while (s->token.val == TOK_STRING) {
    /* Copy actual source string representation */
    snprintf(str, sizeof str, "%.*s", (int)(s->buf_ptr - s->token.ptr - 2),
             s->token.ptr + 1);

    if (next_token(s)) return -1;

    has_semi = FALSE;
    switch (s->token.val) {
      case ';':
        if (next_token(s)) return -1;
        has_semi = TRUE;
        break;
      case '}':
      case TOK_EOF:
        has_semi = TRUE;
        break;
      case TOK_NUMBER:
      case TOK_STRING:
      case TOK_TEMPLATE:
      case TOK_IDENT:
      case TOK_REGEXP:
      case TOK_DEC:
      case TOK_INC:
      case TOK_NULL:
      case TOK_FALSE:
      case TOK_TRUE:
      case TOK_IF:
      case TOK_RETURN:
      case TOK_VAR:
      case TOK_THIS:
      case TOK_DELETE:
      case TOK_TYPEOF:
      case TOK_NEW:
      case TOK_DO:
      case TOK_WHILE:
      case TOK_FOR:
      case TOK_SWITCH:
      case TOK_THROW:
      case TOK_TRY:
      case TOK_FUNCTION:
      case TOK_DEBUGGER:
      case TOK_WITH:
      case TOK_CLASS:
      case TOK_CONST:
      case TOK_ENUM:
      case TOK_EXPORT:
      case TOK_IMPORT:
      case TOK_SUPER:
      case TOK_INTERFACE:
      case TOK_LET:
      case TOK_PACKAGE:
      case TOK_PRIVATE:
      case TOK_PROTECTED:
      case TOK_PUBLIC:
      case TOK_STATIC:
        /* automatic insertion of ';' */
        if (s->got_lf) has_semi = TRUE;
        break;
      default:
        break;
    }
    if (!has_semi) break;
    if (!strcmp(str, "use strict")) {
      s->cur_func->has_use_strict = TRUE;
      s->cur_func->lepus_mode |= LEPUS_MODE_STRICT;
    }
#if !defined(DUMP_BYTECODE) || !(DUMP_BYTECODE & 8)
    else if (!strcmp(str, "use strip")) {
      s->cur_func->lepus_mode |= LEPUS_MODE_STRIP;
    }
#endif
#ifdef CONFIG_BIGNUM
    else if (!strcmp(str, "use bigint")) {
      s->cur_func->lepus_mode |= LEPUS_MODE_BIGINT;
    } else if (!strcmp(str, "use math")) {
      s->cur_func->lepus_mode |= LEPUS_MODE_BIGINT | LEPUS_MODE_MATH;
    }
#endif
  }
  return lepus_parse_seek_token(s, &pos);
}

QJS_STATIC int lepus_parse_function_check_names(LEPUSParseState *s,
                                                LEPUSFunctionDef *fd,
                                                LEPUSAtom func_name) {
  LEPUSAtom name;
  int i, idx;

  if (fd->lepus_mode & LEPUS_MODE_STRICT) {
    if (!fd->has_simple_parameter_list && fd->has_use_strict) {
      return lepus_parse_error(s,
                               "\"use strict\" not allowed in function with "
                               "default or destructuring parameter");
    }
    if (func_name == LEPUS_ATOM_eval || func_name == LEPUS_ATOM_arguments) {
      return lepus_parse_error(s, "invalid function name in strict code");
    }
    for (idx = 0; idx < fd->arg_count; idx++) {
      name = fd->args[idx].var_name;

      if (name == LEPUS_ATOM_eval || name == LEPUS_ATOM_arguments) {
        return lepus_parse_error(s, "invalid argument name in strict code");
      }
    }
  }
  /* check async_generator case */
  if ((fd->lepus_mode & LEPUS_MODE_STRICT) || !fd->has_simple_parameter_list ||
      (fd->func_type == LEPUS_PARSE_FUNC_METHOD &&
       fd->func_kind == LEPUS_FUNC_ASYNC) ||
      fd->func_type == LEPUS_PARSE_FUNC_ARROW ||
      fd->func_type == LEPUS_PARSE_FUNC_METHOD) {
    for (idx = 0; idx < fd->arg_count; idx++) {
      name = fd->args[idx].var_name;
      if (name != LEPUS_ATOM_NULL) {
        for (i = 0; i < idx; i++) {
          if (fd->args[i].var_name == name) goto duplicate;
        }
        /* Check if argument name duplicates a destructuring parameter */
        /* XXX: should have a flag for such variables */
        for (i = 0; i < fd->var_count; i++) {
          if (fd->vars[i].var_name == name && fd->vars[i].scope_level == 0)
            goto duplicate;
        }
      }
    }
  }
  return 0;

duplicate:
  return lepus_parse_error(
      s, "duplicate argument names not allowed in this context");
}

/* create a function to initialize class fields */
QJS_STATIC LEPUSFunctionDef *lepus_parse_function_class_fields_init(
    LEPUSParseState *s) {
  LEPUSFunctionDef *fd;

  fd =
      lepus_new_function_def(s->ctx, s->cur_func, FALSE, FALSE, s->filename, 0);
  if (!fd) return NULL;
#ifdef ENABLE_QUICKJS_DEBUGGER
  fd->column_num = compute_column(s, 0);
#endif
  fd->func_name = LEPUS_ATOM_NULL;
  fd->has_prototype = FALSE;
  fd->has_home_object = TRUE;

  fd->has_arguments_binding = FALSE;
  fd->has_this_binding = TRUE;
  fd->is_derived_class_constructor = FALSE;
  fd->new_target_allowed = TRUE;
  fd->super_call_allowed = FALSE;
  fd->super_allowed = fd->has_home_object;
  fd->arguments_allowed = FALSE;

  fd->func_kind = LEPUS_FUNC_NORMAL;
  fd->func_type = LEPUS_PARSE_FUNC_METHOD;
  return fd;
}

/* func_name must be LEPUS_ATOM_NULL for LEPUS_PARSE_FUNC_STATEMENT and
   LEPUS_PARSE_FUNC_EXPR, LEPUS_PARSE_FUNC_ARROW and LEPUS_PARSE_FUNC_VAR */
QJS_STATIC __exception int lepus_parse_function_decl2(
    LEPUSParseState *s, LEPUSParseFunctionEnum func_type,
    LEPUSFunctionKindEnum func_kind, LEPUSAtom func_name, const uint8_t *ptr,
    int function_line_num, LEPUSParseExportEnum export_flag,
    LEPUSFunctionDef **pfd) {
  LEPUSContext *ctx = s->ctx;
  LEPUSFunctionDef *fd = s->cur_func;
  BOOL is_expr;
  int func_idx, lexical_func_idx = -1;
  BOOL has_opt_arg;
  BOOL create_func_var = FALSE;

  is_expr = (func_type != LEPUS_PARSE_FUNC_STATEMENT &&
             func_type != LEPUS_PARSE_FUNC_VAR);

  if (func_type == LEPUS_PARSE_FUNC_STATEMENT ||
      func_type == LEPUS_PARSE_FUNC_VAR || func_type == LEPUS_PARSE_FUNC_EXPR) {
    if (func_kind == LEPUS_FUNC_NORMAL &&
        token_is_pseudo_keyword(s, LEPUS_ATOM_async) &&
        peek_token(s, TRUE) != '\n') {
      if (next_token(s)) return -1;
      func_kind = LEPUS_FUNC_ASYNC;
    }
    if (next_token(s)) return -1;
    if (s->token.val == '*') {
      if (next_token(s)) return -1;
      func_kind =
          static_cast<LEPUSFunctionKindEnum>(func_kind | LEPUS_FUNC_GENERATOR);
    }

    if (s->token.val == TOK_IDENT) {
      if (s->token.u.ident.is_reserved ||
          (s->token.u.ident.atom == LEPUS_ATOM_yield &&
           func_type == LEPUS_PARSE_FUNC_EXPR &&
           (func_kind & LEPUS_FUNC_GENERATOR)) ||
          (s->token.u.ident.atom == LEPUS_ATOM_await &&
           func_type == LEPUS_PARSE_FUNC_EXPR &&
           (func_kind & LEPUS_FUNC_ASYNC))) {
        return lepus_parse_error_reserved_identifier(s);
      }
    }
    if (s->token.val == TOK_IDENT ||
        (((s->token.val == TOK_YIELD &&
           !(fd->lepus_mode & LEPUS_MODE_STRICT)) ||
          (s->token.val == TOK_AWAIT && !s->is_module)) &&
         func_type == LEPUS_PARSE_FUNC_EXPR)) {
      func_name = LEPUS_DupAtom(ctx, s->token.u.ident.atom);
      if (next_token(s)) {
        LEPUS_FreeAtom(ctx, func_name);
        return -1;
      }
    } else {
      if (func_type != LEPUS_PARSE_FUNC_EXPR &&
          export_flag != LEPUS_PARSE_EXPORT_DEFAULT) {
        return lepus_parse_error(s, "function name expected");
      }
    }
  } else if (func_type != LEPUS_PARSE_FUNC_ARROW) {
    func_name = LEPUS_DupAtom(ctx, func_name);
  }

  if (fd->is_eval && fd->eval_type == LEPUS_EVAL_TYPE_MODULE &&
      (func_type == LEPUS_PARSE_FUNC_STATEMENT ||
       func_type == LEPUS_PARSE_FUNC_VAR)) {
    LEPUSHoistedDef *hf;
    hf = find_hoisted_def(fd, func_name);
    /* XXX: should check scope chain */
    if (hf && hf->scope_level == fd->scope_level) {
      lepus_parse_error(
          s, "invalid redefinition of global identifier in module code");
      LEPUS_FreeAtom(ctx, func_name);
      return -1;
    }
  }

  if (func_type == LEPUS_PARSE_FUNC_VAR) {
    /* Create lexical name here so function closure contains it */
    if (!(fd->lepus_mode & LEPUS_MODE_STRICT) &&
        func_kind == LEPUS_FUNC_NORMAL &&
        find_lexical_decl(ctx, fd, func_name, fd->scope_first, FALSE) < 0 &&
        !((func_idx = find_var(ctx, fd, func_name)) >= 0 &&
          (func_idx & ARGUMENT_VAR_OFFSET)) &&
        !(func_name == LEPUS_ATOM_arguments && fd->has_arguments_binding)) {
      create_func_var = TRUE;
    }
    if (fd->is_eval &&
        (fd->eval_type == LEPUS_EVAL_TYPE_GLOBAL ||
         fd->eval_type == LEPUS_EVAL_TYPE_MODULE) &&
        fd->scope_level == fd->body_scope) {
      /* avoid creating a lexical variable in the global
         scope. XXX: check annex B */
      LEPUSHoistedDef *hf;
      hf = find_hoisted_def(fd, func_name);
      /* XXX: should check scope chain */
      if (hf && hf->scope_level == fd->scope_level) {
        lepus_parse_error(s, "invalid redefinition of global identifier");
        LEPUS_FreeAtom(ctx, func_name);
        return -1;
      }
    } else {
      /* Always create a lexical name, fail if at the same scope as
         existing name */
      /* Lexical variable will be initialized upon entering scope */
      lexical_func_idx = define_var(s, fd, func_name,
                                    func_kind != LEPUS_FUNC_NORMAL
                                        ? LEPUS_VAR_DEF_NEW_FUNCTION_DECL
                                        : LEPUS_VAR_DEF_FUNCTION_DECL);
      if (lexical_func_idx < 0) {
        LEPUS_FreeAtom(ctx, func_name);
        return -1;
      }
    }
  }

  fd = lepus_new_function_def(ctx, fd, FALSE, is_expr, s->filename,
                              function_line_num);
  if (!fd) {
    LEPUS_FreeAtom(ctx, func_name);
    return -1;
  }
#ifdef ENABLE_QUICKJS_DEBUGGER
  fd->column_num = compute_column(s, 0);
#endif
  if (pfd) *pfd = fd;
  s->cur_func = fd;
  fd->func_name = func_name;
  /* XXX: test !fd->is_generator is always false */
  fd->has_prototype = (func_type == LEPUS_PARSE_FUNC_STATEMENT ||
                       func_type == LEPUS_PARSE_FUNC_VAR ||
                       func_type == LEPUS_PARSE_FUNC_EXPR) &&
                      func_kind == LEPUS_FUNC_NORMAL;
  fd->has_home_object =
      (func_type == LEPUS_PARSE_FUNC_METHOD ||
       func_type == LEPUS_PARSE_FUNC_GETTER ||
       func_type == LEPUS_PARSE_FUNC_SETTER ||
       func_type == LEPUS_PARSE_FUNC_CLASS_CONSTRUCTOR ||
       func_type == LEPUS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);
  fd->has_arguments_binding = (func_type != LEPUS_PARSE_FUNC_ARROW);
  fd->has_this_binding = fd->has_arguments_binding;
  fd->is_derived_class_constructor =
      (func_type == LEPUS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);
  if (func_type == LEPUS_PARSE_FUNC_ARROW) {
    fd->new_target_allowed = fd->parent->new_target_allowed;
    fd->super_call_allowed = fd->parent->super_call_allowed;
    fd->super_allowed = fd->parent->super_allowed;
    fd->arguments_allowed = fd->parent->arguments_allowed;
  } else {
    fd->new_target_allowed = TRUE;
    fd->super_call_allowed = fd->is_derived_class_constructor;
    fd->super_allowed = fd->has_home_object;
    fd->arguments_allowed = TRUE;
  }

  /* fd->in_function_body == FALSE prevents yield/await during the parsing
     of the arguments in generator/async functions. They are parsed as
     regular identifiers for other function kinds. */
  fd->func_kind = func_kind;
  fd->func_type = func_type;

  if (func_type == LEPUS_PARSE_FUNC_CLASS_CONSTRUCTOR ||
      func_type == LEPUS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR) {
    /* error if not invoked as a constructor */
    emit_op(s, OP_check_ctor);
  }

  if (func_type == LEPUS_PARSE_FUNC_CLASS_CONSTRUCTOR) {
    emit_class_field_init(s);
  }

  /* parse arguments */
  fd->has_simple_parameter_list = TRUE;
  fd->has_parameter_expressions = FALSE;
  has_opt_arg = FALSE;
  if (func_type == LEPUS_PARSE_FUNC_ARROW && s->token.val == TOK_IDENT) {
    LEPUSAtom name;
    if (s->token.u.ident.is_reserved) {
      lepus_parse_error_reserved_identifier(s);
      goto fail;
    }
    name = s->token.u.ident.atom;
    if (add_arg(ctx, fd, name) < 0) goto fail;
    fd->defined_arg_count = 1;
  } else {
    if (s->token.val == '(') {
      int skip_bits;
      lepus_parse_skip_parens_token(s, &skip_bits, FALSE);
      if (skip_bits & SKIP_HAS_ASSIGNMENT) fd->has_parameter_expressions = TRUE;
      if (next_token(s)) goto fail;
    } else {
      if (lepus_parse_expect(s, '(')) goto fail;
    }

    if (fd->has_parameter_expressions) {
      fd->scope_level = -1; /* force no parent scope */
      if (push_scope(s) < 0) return -1;
    }

    while (s->token.val != ')') {
      LEPUSAtom name;
      BOOL rest = FALSE;
      int idx, has_initializer;

      if (s->token.val == TOK_ELLIPSIS) {
        fd->has_simple_parameter_list = FALSE;
        rest = TRUE;
        if (next_token(s)) goto fail;
      }
      if (s->token.val == '[' || s->token.val == '{') {
        fd->has_simple_parameter_list = FALSE;
        if (rest) {
          emit_op(s, OP_rest);
          emit_u16(s, fd->arg_count);
        } else {
          /* unnamed arg for destructuring */
          idx = add_arg(ctx, fd, LEPUS_ATOM_NULL);
          emit_op(s, OP_get_arg);
          emit_u16(s, idx);
        }
        has_initializer = lepus_parse_destructing_element(
            s, fd->has_parameter_expressions ? TOK_LET : TOK_VAR, 1, TRUE, -1,
            TRUE);
        if (has_initializer < 0) goto fail;
        if (has_initializer) has_opt_arg = TRUE;
        if (!has_opt_arg) fd->defined_arg_count++;
      } else if (s->token.val == TOK_IDENT) {
        if (s->token.u.ident.is_reserved) {
          lepus_parse_error_reserved_identifier(s);
          goto fail;
        }
        name = s->token.u.ident.atom;
        if (name == LEPUS_ATOM_yield && fd->func_kind == LEPUS_FUNC_GENERATOR) {
          lepus_parse_error_reserved_identifier(s);
          goto fail;
        }
        if (fd->has_parameter_expressions) {
          if (define_var(s, fd, name, LEPUS_VAR_DEF_LET) < 0) goto fail;
        }
        idx = add_arg(ctx, fd, name);
        if (idx < 0) goto fail;
        if (next_token(s)) goto fail;
        if (rest) {
          emit_op(s, OP_rest);
          emit_u16(s, idx);
          if (fd->has_parameter_expressions) {
            emit_op(s, OP_dup);
            emit_op(s, OP_scope_put_var_init);
            emit_atom(s, name);
            emit_u16(s, fd->scope_level);
          }
          emit_op(s, OP_put_arg);
          emit_u16(s, idx);
          fd->has_simple_parameter_list = FALSE;
          has_opt_arg = TRUE;
        } else if (s->token.val == '=') {
          fd->has_simple_parameter_list = FALSE;
          has_opt_arg = TRUE;

          if (next_token(s)) goto fail;

#if 0
                    /* XXX: not correct for eval code */
                    /* Check for a default value of `undefined`
                       to omit default argument processing */
                    if (s->token.val == TOK_IDENT &&
                        s->token.u.ident.atom == LEPUS_ATOM_undefined &&
                        fd->parent == NULL &&
                        ((tok = peek_token(s, FALSE)) == ',' || tok == ')')) {
                        if (next_token(s))  /* ignore undefined token */
                            goto fail;
                    } else
#endif

          int label = new_label(s);
          emit_op(s, OP_get_arg);
          emit_u16(s, idx);
          emit_op(s, OP_dup);
          emit_op(s, OP_undefined);
          emit_op(s, OP_strict_eq);
          emit_goto(s, OP_if_false, label);
          emit_op(s, OP_drop);
          if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) goto fail;
          set_object_name(s, name);
          emit_op(s, OP_dup);
          emit_op(s, OP_put_arg);
          emit_u16(s, idx);
          emit_label(s, label);
          emit_op(s, OP_scope_put_var_init);
          emit_atom(s, name);
          emit_u16(s, fd->scope_level);
        } else {
          if (!has_opt_arg) {
            fd->defined_arg_count++;
          }
          if (fd->has_parameter_expressions) {
            /* copy the argument to the argument scope */
            emit_op(s, OP_get_arg);
            emit_u16(s, idx);
            emit_op(s, OP_scope_put_var_init);
            emit_atom(s, name);
            emit_u16(s, fd->scope_level);
          }
        }
      } else {
        lepus_parse_error(s, "missing formal parameter");
        goto fail;
      }
      if (rest && s->token.val != ')') {
        lepus_parse_expect(s, ')');
        goto fail;
      }
      if (s->token.val == ')') break;
      if (lepus_parse_expect(s, ',')) goto fail;
    }
    if ((func_type == LEPUS_PARSE_FUNC_GETTER && fd->arg_count != 0) ||
        (func_type == LEPUS_PARSE_FUNC_SETTER && fd->arg_count != 1)) {
      lepus_parse_error(s, "invalid number of arguments for getter or setter");
      goto fail;
    }
  }

  if (fd->has_parameter_expressions) {
    int idx;

    /* Copy the variables in the argument scope to the variable
       scope (see FunctionDeclarationInstantiation() in spec). The
       normal arguments are already present, so no need to copy
       them. */
    idx = fd->scopes[fd->scope_level].first;
    while (idx >= 0) {
      LEPUSVarDef *vd = &fd->vars[idx];
      if (vd->scope_level != fd->scope_level) break;
      if (find_var(ctx, fd, vd->var_name) < 0) {
        if (add_var(ctx, fd, vd->var_name) < 0) goto fail;
        vd = &fd->vars[idx]; /* fd->vars may have been reallocated */
        emit_op(s, OP_scope_get_var);
        emit_atom(s, vd->var_name);
        emit_u16(s, fd->scope_level);
        emit_op(s, OP_scope_put_var);
        emit_atom(s, vd->var_name);
        emit_u16(s, 0);
      }
      idx = vd->scope_next;
    }

    /* the argument scope has no parent, hence we don't use pop_scope(s) */
    emit_op(s, OP_leave_scope);
    emit_u16(s, fd->scope_level);

    /* set the variable scope as the current scope */
    fd->scope_level = 0;
    fd->scope_first = fd->scopes[fd->scope_level].first;
  }

  if (next_token(s)) goto fail;

  /* generator function: yield after the parameters are evaluated */
  if (func_kind == LEPUS_FUNC_GENERATOR ||
      func_kind == LEPUS_FUNC_ASYNC_GENERATOR)
    emit_op(s, OP_initial_yield);

  /* in generators, yield expression is forbidden during the parsing
     of the arguments */
  fd->in_function_body = TRUE;
  push_scope(s); /* enter body scope: fd->scope_level = 1 */
  fd->body_scope = fd->scope_level;

  if (s->token.val == TOK_ARROW) {
    if (next_token(s)) goto fail;

    if (s->token.val != '{') {
      if (lepus_parse_function_check_names(s, fd, func_name)) goto fail;

      if (lepus_parse_assign_expr(s, PF_IN_ACCEPTED)) goto fail;

      if (func_kind != LEPUS_FUNC_NORMAL)
        emit_op(s, OP_return_async);
      else
        emit_op(s, OP_return);

      if (!(fd->lepus_mode & LEPUS_MODE_STRIP)) {
        /* save the function source code */
        /* the end of the function source code is after the last
           token of the function source stored into s->last_ptr */
        fd->source_len = s->last_ptr - ptr;
        fd->source = lepus_strndup(ctx, (const char *)ptr, fd->source_len);
        if (!fd->source) goto fail;
      }
      goto done;
    }
  }

  if (lepus_parse_expect(s, '{')) goto fail;

  if (lepus_parse_directives(s)) goto fail;

  /* in strict_mode, check function and argument names */
  if (lepus_parse_function_check_names(s, fd, func_name)) goto fail;

  while (s->token.val != '}') {
    if (lepus_parse_source_element(s)) goto fail;
  }
  if (!(fd->lepus_mode & LEPUS_MODE_STRIP)) {
    /* save the function source code */
    fd->source_len = s->buf_ptr - ptr;
    fd->source = lepus_strndup(ctx, (const char *)ptr, fd->source_len);
    if (!fd->source) goto fail;
  }

  if (next_token(s)) {
    /* consume the '}' */
    goto fail;
  }

  /* in case there is no return, add one */
  if (lepus_is_live_code(s)) {
    emit_return(s, FALSE);
  }
done:
  s->cur_func = fd->parent;

  /* create the function object */
  {
    int idx;
    LEPUSAtom func_name = fd->func_name;

    /* the real object will be set at the end of the compilation */
    idx = cpool_add(s, LEPUS_NULL);
    fd->parent_cpool_idx = idx;

    if (is_expr) {
      /* for constructors, no code needs to be generated here */
      if (func_type != LEPUS_PARSE_FUNC_CLASS_CONSTRUCTOR &&
          func_type != LEPUS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR) {
        /* OP_fclosure creates the function object from the bytecode
           and adds the scope information */
        emit_op(s, OP_fclosure);
        emit_u32(s, idx);
        if (func_name == LEPUS_ATOM_NULL) {
          emit_op(s, OP_set_name);
          emit_u32(s, LEPUS_ATOM_NULL);
        }
      }
    } else if (func_type == LEPUS_PARSE_FUNC_VAR) {
      emit_op(s, OP_fclosure);
      emit_u32(s, idx);
      if (create_func_var) {
        if (s->cur_func->is_global_var) {
          LEPUSHoistedDef *hf;
          /* the global variable must be defined at the start of the
             function */
          hf = add_hoisted_def(ctx, s->cur_func, -1, func_name, -1, FALSE);
          if (!hf) goto fail;
          hf->scope_level = 0;
          hf->force_init = ((s->cur_func->lepus_mode & LEPUS_MODE_STRICT) != 0);
          /* store directly into global var, bypass lexical scope */
          emit_op(s, OP_dup);
          emit_op(s, OP_scope_put_var);
          emit_atom(s, func_name);
          emit_u16(s, 0);
        } else {
          /* do not call define_var to bypass lexical scope check */
          func_idx = find_var(ctx, s->cur_func, func_name);
          if (func_idx < 0) {
            func_idx = add_var(ctx, s->cur_func, func_name);
            if (func_idx < 0) goto fail;
          }
          /* store directly into local var, bypass lexical catch scope */
          emit_op(s, OP_dup);
          emit_op(s, OP_scope_put_var);
          emit_atom(s, func_name);
          emit_u16(s, 0);
        }
      }
      if (lexical_func_idx >= 0) {
        /* lexical variable will be initialized upon entering scope */
        s->cur_func->vars[lexical_func_idx].func_pool_idx = idx;
        emit_op(s, OP_drop);
      } else {
        /* store function object into its lexical name */
        /* XXX: could use OP_put_loc directly */
        emit_op(s, OP_scope_put_var_init);
        emit_atom(s, func_name);
        emit_u16(s, s->cur_func->scope_level);
      }
    } else {
      if (!s->cur_func->is_global_var) {
        int var_idx = define_var(s, s->cur_func, func_name, LEPUS_VAR_DEF_VAR);

        if (var_idx < 0) goto fail;
        /* the variable will be assigned at the top of the function */
        if (var_idx & ARGUMENT_VAR_OFFSET) {
          s->cur_func->args[var_idx - ARGUMENT_VAR_OFFSET].func_pool_idx = idx;
        } else {
          s->cur_func->vars[var_idx].func_pool_idx = idx;
        }
      } else {
        LEPUSAtom func_var_name;
        LEPUSHoistedDef *hf;
        if (func_name == LEPUS_ATOM_NULL)
          func_var_name = LEPUS_ATOM__default_; /* export default */
        else
          func_var_name = func_name;
        /* the variable will be assigned at the top of the function */
        hf = add_hoisted_def(ctx, s->cur_func, idx, func_var_name, -1, FALSE);
        if (!hf) goto fail;
        hf->cpool_idx = idx;
        if (export_flag != LEPUS_PARSE_EXPORT_NONE) {
          if (!add_export_entry(s, s->cur_func->module, func_var_name,
                                export_flag == LEPUS_PARSE_EXPORT_NAMED
                                    ? func_var_name
                                    : LEPUS_ATOM_default,
                                LEPUS_EXPORT_TYPE_LOCAL))
            goto fail;
        }
      }
    }
  }
  return 0;
fail:
  s->cur_func = fd->parent;
  lepus_free_function_def(ctx, fd);
  if (pfd) *pfd = NULL;
  return -1;
}

QJS_STATIC __exception int lepus_parse_function_decl(
    LEPUSParseState *s, LEPUSParseFunctionEnum func_type,
    LEPUSFunctionKindEnum func_kind, LEPUSAtom func_name, const uint8_t *ptr,
    int function_line_num) {
  return lepus_parse_function_decl2(s, func_type, func_kind, func_name, ptr,
                                    function_line_num, LEPUS_PARSE_EXPORT_NONE,
                                    NULL);
}

QJS_STATIC __exception int lepus_parse_program(LEPUSParseState *s) {
  LEPUSFunctionDef *fd = s->cur_func;
  int idx;

  if (next_token(s)) return -1;

  if (lepus_parse_directives(s)) return -1;

  fd->is_global_var = (fd->eval_type == LEPUS_EVAL_TYPE_GLOBAL) ||
                      (fd->eval_type == LEPUS_EVAL_TYPE_MODULE) ||
                      !(fd->lepus_mode & LEPUS_MODE_STRICT);

  if (!s->is_module) {
    /* hidden variable for the return value */
    fd->eval_ret_idx = idx = add_var(s->ctx, fd, LEPUS_ATOM__ret_);
    if (idx < 0) return -1;
  }

  while (s->token.val != TOK_EOF) {
    if (lepus_parse_source_element(s)) return -1;
  }

  if (!s->is_module) {
    /* return the value of the hidden variable eval_ret_idx  */
    emit_op(s, OP_get_loc);
    emit_u16(s, fd->eval_ret_idx);

    emit_op(s, OP_return);
  } else {
    emit_op(s, OP_return_undef);
  }

  return 0;
}

QJS_STATIC void lepus_parse_init(LEPUSContext *ctx, LEPUSParseState *s,
                                 const char *input, size_t input_len,
                                 const char *filename) {
  memset(s, 0, sizeof(*s));
  s->ctx = ctx;
  s->filename = filename;
  s->line_num = 1;
  s->buf_ptr = (const uint8_t *)input;
  s->buf_end = s->buf_ptr + input_len;
  s->token.val = ' ';
  s->token.line_num = 1;

  // <ByteDance begin>
  s->last_line_begin_ptr = (const uint8_t *)input;
  s->line_begin_ptr = (const uint8_t *)input;
  s->cur_func = NULL;
  s->last_emit_ptr = (const uint8_t *)input;
  s->utf8_parse_front = (const uint8_t *)input;
  s->func_call_ptr = NULL;
  s->utf8_adapte_size = 0;
  s->func_call_adapte_size = -1;
  s->last_utf8_adapte_size = 0;
  // <ByteDance end>
}
#endif

QJS_STATIC LEPUSValue LEPUS_EvalFunctionInternal(LEPUSContext *ctx,
                                                 LEPUSValue fun_obj,
                                                 LEPUSValueConst this_obj,
                                                 LEPUSVarRef **var_refs,
                                                 LEPUSStackFrame *sf) {
  LEPUSValue ret_val;

  if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(fun_obj)) {
    fun_obj = lepus_closure(ctx, fun_obj, var_refs, sf);
    ret_val = LEPUS_CallFree(ctx, fun_obj, this_obj, 0, NULL);
  } else if (LEPUS_VALUE_IS_MODULE(fun_obj)) {
#ifndef NO_QUICKJS_COMPILER
    LEPUSModuleDef *m;
    m = static_cast<LEPUSModuleDef *>(LEPUS_VALUE_GET_PTR(fun_obj));
    /* the module refcount should be >= 2 */
    LEPUS_FreeValue(ctx, fun_obj);
    if (lepus_link_module(ctx, m) < 0) goto fail;
    ret_val = lepus_evaluate_module(ctx, m);
    if (LEPUS_IsException(ret_val)) {
    fail:
      lepus_free_modules(ctx, LEPUS_FREE_MODULE_NOT_EVALUATED);
      return LEPUS_EXCEPTION;
    }
#else
    return LEPUS_EXCEPTION;
#endif
  } else {
    LEPUS_FreeValue(ctx, fun_obj);
    ret_val = LEPUS_ThrowTypeError(ctx, "bytecode function expected");
  }
  return ret_val;
}

LEPUSValue LEPUS_EvalFunction(LEPUSContext *ctx, LEPUSValue fun_obj,
                              LEPUSValueConst this_obj) {
  return LEPUS_EvalFunctionInternal(ctx, fun_obj, this_obj, NULL, NULL);
}

#ifndef NO_QUICKJS_COMPILER
QJS_STATIC void skip_shebang(LEPUSParseState *s) {
  const uint8_t *p = s->buf_ptr;
  int c;

  if (p[0] == '#' && p[1] == '!') {
    p += 2;
    while (p < s->buf_end) {
      if (*p == '\n' || *p == '\r') {
        break;
      } else if (*p >= 0x80) {
        c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
        if (c == CP_LS || c == CP_PS) {
          break;
        } else if (c == -1) {
          p++;
        }
      } else {
        p++;
      }
    }
    s->buf_ptr = p;
  }
}

/* 'input' must be zero terminated i.e. input[input_len] = '\0'. */
QJS_STATIC LEPUSValue __JS_EvalInternal(LEPUSContext *ctx,
                                        LEPUSValueConst this_obj,
                                        const char *input, size_t input_len,
                                        const char *filename, int flags,
                                        int scope_idx, bool debugger_eval,
                                        LEPUSStackFrame *debugger_frame) {
  LEPUSParseState s1, *s = &s1;
  int err, lepus_mode, eval_type;
  LEPUSValue fun_obj, ret_val;
  LEPUSStackFrame *sf;
  LEPUSVarRef **var_refs;
  LEPUSFunctionBytecode *b;
  LEPUSFunctionDef *fd;
  LEPUSModuleDef *m;

  lepus_parse_init(ctx, s, input, input_len, filename);
  skip_shebang(s);

  eval_type =
      debugger_eval ? LEPUS_EVAL_TYPE_DIRECT : (flags & LEPUS_EVAL_TYPE_MASK);
  m = NULL;
  if (eval_type == LEPUS_EVAL_TYPE_DIRECT) {
    LEPUSObject *p;
    sf = debugger_eval ? debugger_frame : ctx->rt->current_stack_frame;
    assert(sf != NULL);
    assert(LEPUS_VALUE_IS_OBJECT(sf->cur_func));
    p = LEPUS_VALUE_GET_OBJ(sf->cur_func);
    assert(lepus_class_has_bytecode(p->class_id));
    b = p->u.func.function_bytecode;
    var_refs = p->u.func.var_refs;
    lepus_mode = b->lepus_mode;
  } else {
    sf = NULL;
    b = NULL;
    var_refs = NULL;
    lepus_mode = 0;
    if (flags & LEPUS_EVAL_FLAG_STRICT) lepus_mode |= LEPUS_MODE_STRICT;
    if (flags & LEPUS_EVAL_FLAG_STRIP) lepus_mode |= LEPUS_MODE_STRIP;
    if (eval_type == LEPUS_EVAL_TYPE_MODULE) {
      LEPUSAtom module_name = LEPUS_NewAtom(ctx, filename);
      if (module_name == LEPUS_ATOM_NULL) return LEPUS_EXCEPTION;
      m = lepus_new_module_def(ctx, module_name);
      if (!m) return LEPUS_EXCEPTION;
      lepus_mode |= LEPUS_MODE_STRICT;
    }
  }
  fd = lepus_new_function_def(ctx, NULL, TRUE, FALSE, filename, 1);

#ifdef ENABLE_QUICKJS_DEBUGGER
  fd->column_num = 0;
#endif

  if (!fd) goto fail1;
  s->cur_func = fd;
  fd->eval_type = eval_type;
  fd->has_this_binding = (eval_type != LEPUS_EVAL_TYPE_DIRECT);
  if (eval_type == LEPUS_EVAL_TYPE_DIRECT) {
    fd->new_target_allowed = b->new_target_allowed;
    fd->super_call_allowed = b->super_call_allowed;
    fd->super_allowed = b->super_allowed;
    fd->arguments_allowed = b->arguments_allowed;
  } else {
    fd->new_target_allowed = FALSE;
    fd->super_call_allowed = FALSE;
    fd->super_allowed = FALSE;
    fd->arguments_allowed = TRUE;
  }
  fd->lepus_mode = lepus_mode;
  fd->func_name = LEPUS_DupAtom(ctx, LEPUS_ATOM__eval_);
  if (b) {
    if (debugger_eval) {
      // use DEBUG_SCOPE_INDEX to add all lexical variables to debug eval
      // closure.
      int32_t idx = b->var_count ? DEBUG_SCOPE_INDEX : -1;
      if (add_closure_variables(ctx, fd, b, idx)) goto fail;
    } else {
      if (add_closure_variables(ctx, fd, b, scope_idx)) goto fail;
    }
  }
  fd->module = m;
  s->is_module = (m != NULL);
  s->allow_html_comments = !s->is_module;

  push_scope(s); /* body scope */
  fd->body_scope = fd->scope_level;

  err = lepus_parse_program(s);
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (!debugger_eval && (ctx->debugger_parse_script || ctx->debugger_mode) &&
      !(flags & LEPUS_DEBUGGER_NO_PERSIST_SCRIPT)) {
    DebuggerParseScript(ctx, input, input_len, fd, filename, s->line_num, err);
  }
#endif

  if (err) {
  fail:
    free_token(s, &s->token);
    lepus_free_function_def(ctx, fd);
    goto fail1;
  }

  /* create the function object and all the enclosed functions */
  fun_obj = lepus_create_function(ctx, fd);
  if (LEPUS_IsException(fun_obj)) goto fail1;
  /* Could add a flag to avoid resolution if necessary */
  if (m) {
    m->func_obj = fun_obj;
    if (lepus_resolve_module(ctx, m) < 0) goto fail1;
    fun_obj = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_MODULE, m));
  }
  if (flags & LEPUS_EVAL_FLAG_COMPILE_ONLY) {
    ret_val = fun_obj;
  } else {
    ret_val = LEPUS_EvalFunctionInternal(ctx, fun_obj, this_obj, var_refs, sf);
  }
  return ret_val;
fail1:
  /* XXX: should free all the unresolved dependencies */
  if (m) lepus_free_module_def(ctx, m);
  return LEPUS_EXCEPTION;
}

/* the indirection is needed to make 'eval' optional */
#ifdef ENABLE_QUICKJS_DEBUGGER
LEPUSValue LEPUS_EvalInternal(LEPUSContext *ctx,
#else
static LEPUSValue LEPUS_EvalInternal(
    LEPUSContext *ctx,
#endif
                              LEPUSValueConst this_obj, const char *input,
                              size_t input_len, const char *filename, int flags,
                              int scope_idx, bool debugger_eval,
                              LEPUSStackFrame *sf) {
  if (unlikely(!ctx->eval_internal)) {
    return LEPUS_ThrowTypeError(ctx, "eval is not supported");
  }
  return ctx->eval_internal(ctx, this_obj, input, input_len, filename, flags,
                            scope_idx, debugger_eval, sf);
}
#endif

LEPUSValue LEPUS_EvalObject(LEPUSContext *ctx, LEPUSValueConst this_obj,
                            LEPUSValueConst val, int flags, int scope_idx) {
#ifndef NO_QUICKJS_COMPILER
  LEPUSValue ret;
  const char *str;
  size_t len;

  if (!LEPUS_IsString(val)) return LEPUS_DupValue(ctx, val);
  str = LEPUS_ToCStringLen(ctx, &len, val);
  if (!str) return LEPUS_EXCEPTION;
  ret =
      LEPUS_EvalInternal(ctx, this_obj, str, len, "<input>", flags, scope_idx);
  LEPUS_FreeCString(ctx, str);
  return ret;
#else
  return LEPUS_UNDEFINED;
#endif
}

LEPUSValue LEPUS_Eval(LEPUSContext *ctx, const char *input, size_t input_len,
                      const char *filename, int eval_flags) {
#ifndef NO_QUICKJS_COMPILER
  int eval_type = eval_flags & LEPUS_EVAL_TYPE_MASK;
  LEPUSValue ret;

  assert(eval_type == LEPUS_EVAL_TYPE_GLOBAL ||
         eval_type == LEPUS_EVAL_TYPE_MODULE);
  ret = LEPUS_EvalInternal(ctx, ctx->global_obj, input, input_len, filename,
                           eval_flags, -1);
  return ret;
#else
  return LEPUS_UNDEFINED;
#endif
}

LEPUSValue LEPUS_EvalBinary(LEPUSContext *ctx, const uint8_t *buf,
                            size_t buf_len, int flags) {
  LEPUSValue obj;
  obj = LEPUS_ReadObject(ctx, buf, buf_len, LEPUS_READ_OBJ_BYTECODE);
  if (LEPUS_IsException(obj)) return obj;
  if (flags & LEPUS_EVAL_BINARY_LOAD_ONLY) {
    return obj;
  } else {
    /* if a module, we load the dependencies here */

#ifndef NO_QUICKJS_COMPILER
    if (LEPUS_VALUE_IS_MODULE(obj)) {
      LEPUSModuleDef *m =
          static_cast<LEPUSModuleDef *>(LEPUS_VALUE_GET_PTR(obj));
      if (lepus_resolve_module(ctx, m) < 0) {
        LEPUS_FreeValue(ctx, obj);
        lepus_free_modules(ctx, LEPUS_FREE_MODULE_NOT_RESOLVED);
        return LEPUS_EXCEPTION;
      }
    }
#endif

    return LEPUS_EvalFunction(ctx, obj, ctx->global_obj);
  }
}

/*******************************************************************/
/* binary object writer & reader */
typedef enum BCTagEnum {
  BC_TAG_NULL = 1,
  BC_TAG_UNDEFINED,
  BC_TAG_BOOL_FALSE,
  BC_TAG_BOOL_TRUE,
  BC_TAG_INT32,
  BC_TAG_FLOAT64,
  BC_TAG_STRING,
  BC_TAG_OBJECT,
  BC_TAG_ARRAY,
  BC_TAG_BIG_INT,
  BC_TAG_BIG_FLOAT,
  BC_TAG_TEMPLATE_OBJECT,
  BC_TAG_FUNCTION_BYTECODE,
  BC_TAG_MODULE,
#ifdef ENABLE_BUILTIN_SERIALIZE
  BC_TAG_TYPED_ARRAY,
  BC_TAG_ARRAY_BUFFER,
  BC_TAG_DATE,
  BC_TAG_OBJECT_VALUE,
  BC_TAG_DATAVIEW,
  BC_TAG_ERROR,
  BC_TAG_REGEXP,
  BC_TAG_MAP
#endif
} BCTagEnum;

#ifdef CONFIG_BIGNUM
#define BC_BASE_VERSION 2
#else
#define BC_BASE_VERSION 1
#endif
#define BC_BE_VERSION 0x40
#ifdef WORDS_BIGENDIAN
#define BC_VERSION (BC_BASE_VERSION | BC_BE_VERSION)
#else
#define BC_VERSION BC_BASE_VERSION
#endif

#ifndef NO_QUICKJS_COMPILER
#define MAGIC_SET (1 << 0)
#define MAGIC_WEAK (1 << 1)
typedef struct BCWriterState {
  LEPUSContext *ctx;
  DynBuf dbuf;
  BOOL byte_swap;
  BOOL allow_bytecode;
  uint32_t first_atom;
  uint32_t *atom_to_idx;
  int atom_to_idx_size;
  LEPUSAtom *idx_to_atom;
  int idx_to_atom_count;
  int idx_to_atom_size;
} BCWriterState;

#ifdef DUMP_READ_OBJECT
static const char *const bc_tag_str[] = {
    "invalid", "null",      "undefined", "false",    "true",
    "int32",   "float64",   "string",    "object",   "array",
    "big_int", "big_float", "template",  "function", "module",
};
#endif

QJS_STATIC void bc_put_u8(BCWriterState *s, uint8_t v) {
  dbuf_putc(&s->dbuf, v);
}

QJS_STATIC void bc_put_u16(BCWriterState *s, uint16_t v) {
  if (s->byte_swap) v = bswap16(v);
  dbuf_put_u16(&s->dbuf, v);
}

QJS_STATIC __attribute__((unused)) void bc_put_u32(BCWriterState *s,
                                                   uint32_t v) {
  if (s->byte_swap) v = bswap32(v);
  dbuf_put_u32(&s->dbuf, v);
}

QJS_STATIC void bc_put_u64(BCWriterState *s, uint64_t v) {
  if (s->byte_swap) v = bswap64(v);
  dbuf_put(&s->dbuf, (uint8_t *)&v, sizeof(v));
}

QJS_STATIC void bc_put_leb128(BCWriterState *s, uint32_t v) {
  dbuf_put_leb128(&s->dbuf, v);
}

QJS_STATIC void bc_put_sleb128(BCWriterState *s, int32_t v) {
  dbuf_put_sleb128(&s->dbuf, v);
}

QJS_STATIC void bc_set_flags(uint32_t *pflags, int *pidx, uint32_t val, int n) {
  *pflags = *pflags | (val << *pidx);
  *pidx += n;
}

QJS_STATIC int bc_atom_to_idx(BCWriterState *s, uint32_t *pres,
                              LEPUSAtom atom) {
  uint32_t v;

  if (atom < s->first_atom || __JS_AtomIsTaggedInt(atom)) {
    *pres = atom;
    return 0;
  }
  atom -= s->first_atom;
  if (atom < s->atom_to_idx_size && s->atom_to_idx[atom] != 0) {
    *pres = s->atom_to_idx[atom];
    return 0;
  }
  if (atom >= s->atom_to_idx_size) {
    size_t new_size, i, slack;
    uint32_t *new_tab;
    /* XXX: potential arithmetic overflow */
    new_size = s->atom_to_idx_size * 3 / 2;
    if ((atom + 1) > new_size) new_size = atom + 1;
    new_tab = static_cast<uint32_t *>(lepus_realloc2(
        s->ctx, s->atom_to_idx, new_size * sizeof(s->atom_to_idx[0]), &slack));
    if (!new_tab) goto fail;
    new_size += slack / sizeof(*new_tab);
    for (i = s->atom_to_idx_size; i < new_size; i++) new_tab[i] = 0;
    s->atom_to_idx = new_tab;
    s->atom_to_idx_size = new_size;
  }
  if ((s->idx_to_atom_count + 1) > s->idx_to_atom_size) {
    size_t new_size, slack;
    LEPUSAtom *new_tab;
    new_size = s->idx_to_atom_size * 3 / 2;
    if ((s->idx_to_atom_count + 1) > new_size)
      new_size = s->idx_to_atom_count + 1;
    new_tab = static_cast<LEPUSAtom *>(lepus_realloc2(
        s->ctx, s->idx_to_atom, new_size * sizeof(s->idx_to_atom[0]), &slack));
    if (!new_tab) goto fail;
    new_size += slack / sizeof(*new_tab);
    s->idx_to_atom = new_tab;
    s->idx_to_atom_size = new_size;
  }

  v = s->idx_to_atom_count++;
  s->idx_to_atom[v] = atom + s->first_atom;
  v += s->first_atom;
  s->atom_to_idx[atom] = v;
  *pres = v;
  return 0;
fail:
  *pres = 0;
  return -1;
}

QJS_STATIC int bc_put_atom(BCWriterState *s, LEPUSAtom atom) {
  uint32_t v;

  if (__JS_AtomIsTaggedInt(atom)) {
    v = (__JS_AtomToUInt32(atom) << 1) | 1;
  } else {
    if (bc_atom_to_idx(s, &v, atom)) return -1;
    v <<= 1;
  }
  bc_put_leb128(s, v);
  return 0;
}

QJS_STATIC void bc_byte_swap(uint8_t *bc_buf, int bc_len) {
  int pos, len, op, fmt;

  pos = 0;
  while (pos < bc_len) {
    op = bc_buf[pos];
    len = short_opcode_info(op).size;
    fmt = short_opcode_info(op).fmt;
    switch (fmt) {
      case OP_FMT_u16:
      case OP_FMT_i16:
      case OP_FMT_label16:
      case OP_FMT_npop:
      case OP_FMT_loc:
      case OP_FMT_arg:
      case OP_FMT_var_ref:
        put_u16(bc_buf + pos + 1, bswap16(get_u16(bc_buf + pos + 1)));
        break;
      case OP_FMT_i32:
      case OP_FMT_u32:
      case OP_FMT_const:
      case OP_FMT_label:
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
        put_u32(bc_buf + pos + 1, bswap32(get_u32(bc_buf + pos + 1)));
        break;
      // <ByteDance begin>
      case OP_FMT_u64:
        put_u64(bc_buf + pos + 1, bswap64(get_u64(bc_buf) + pos + 1));
        break;
      // <ByteDance end>
      case OP_FMT_atom_u16:
      case OP_FMT_label_u16:
        put_u32(bc_buf + pos + 1, bswap32(get_u32(bc_buf + pos + 1)));
        put_u16(bc_buf + pos + 1 + 4, bswap16(get_u16(bc_buf + pos + 1 + 4)));
        break;
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        put_u32(bc_buf + pos + 1, bswap32(get_u32(bc_buf + pos + 1)));
        put_u32(bc_buf + pos + 1 + 4, bswap32(get_u32(bc_buf + pos + 1 + 4)));
        if (fmt == OP_FMT_atom_label_u16) {
          put_u16(bc_buf + pos + 1 + 4 + 4,
                  bswap16(get_u16(bc_buf + pos + 1 + 4 + 4)));
        }
        break;
      default:
        break;
    }
    pos += len;
  }
}
#ifdef ENABLE_PRIMJS_IC
QJS_STATIC int LEPUS_WriteFunctionBytecode(BCWriterState *s,
                                           LEPUSFunctionBytecode *b,
                                           const uint8_t *bc_buf1, int bc_len) {
  int pos, pos_raw, len, op;
  LEPUSAtom atom;
  uint8_t *bc_buf;
  uint8_t *tag_buf;
  uint32_t val;
  int rewrite_count = 0;
  int offset, offset_new;
  int pos_begin, pos_end;
  int bc_len_raw =
      bc_len - 8 * (b->get_feedback_vec_size + b->set_feedback_vec_size);

  bc_buf = static_cast<uint8_t *>(lepus_malloc(s->ctx, bc_len_raw));
  tag_buf = static_cast<uint8_t *>(lepus_mallocz(s->ctx, bc_len));

  if (!bc_buf) return -1;

  int len_raw = 0;

  pos_raw = pos = 0;
  while (pos < bc_len) {
    op = bc_buf1[pos];
    len = short_opcode_info(op).size;
    switch (op) {
      case OP_put_field:
      case OP_get_field:
      case OP_get_field2:
      case OP_get_var:
      case OP_get_var_undef:
      case OP_get_length: {
        tag_buf[pos] = 8;
        len_raw = len - 8;
        memcpy(bc_buf + pos_raw, bc_buf1 + pos, len_raw);
        pos_raw += len_raw;
        break;
      }
      default: {
        len_raw = len;
        memcpy(bc_buf + pos_raw, bc_buf1 + pos, len_raw);
        pos_raw += len_raw;
        break;
      }
    }

    switch (short_opcode_info(op).fmt) {
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
      case OP_FMT_atom_u16:
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        atom = get_u32(bc_buf1 + pos + 1);
        if (bc_atom_to_idx(s, &val, atom)) goto fail;
        put_u32(bc_buf + pos_raw - len_raw + 1, val);
        break;
      default:
        break;
    }
    pos += len;
  }

  // reloction
  pos_raw = pos = 0;
  while (pos < bc_len) {
    op = bc_buf1[pos];
    len = short_opcode_info(op).size;

    switch (short_opcode_info(op).fmt) {
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        pos++;
        pos += 4;
        offset = get_u32(bc_buf1 + pos);
        rewrite_count = 0;
        pos_begin = offset > 0 ? pos : pos + offset;
        pos_end = offset > 0 ? pos + offset : pos;
        for (int k = pos_begin; k < pos_end; k++) rewrite_count += tag_buf[k];
        offset_new =
            offset > 0 ? (offset - rewrite_count) : (offset + rewrite_count);
        assert(offset_new == (int32_t)offset_new);
        put_u32(bc_buf + pos_raw + 5, offset_new);
        pos += (len - 5);
        break;
#if SHORT_OPCODES
      case OP_FMT_label8:
        pos++;
        offset = (int8_t)bc_buf1[pos];
        rewrite_count = 0;
        pos_begin = offset > 0 ? pos : pos + offset;
        pos_end = offset > 0 ? pos + offset : pos;
        for (int k = pos_begin; k < pos_end; k++) rewrite_count += tag_buf[k];
        offset_new =
            offset > 0 ? (offset - rewrite_count) : (offset + rewrite_count);
        assert(offset_new == (int8_t)offset_new);
        put_u8(bc_buf + pos_raw + 1, offset_new);
        pos += (len - 1);
        break;
      case OP_FMT_label16:
        pos++;
        offset = (int16_t)get_u16(bc_buf1 + pos);
        rewrite_count = 0;
        pos_begin = offset > 0 ? pos : pos + offset;
        pos_end = offset > 0 ? pos + offset : pos;
        for (int k = pos_begin; k < pos_end; k++) rewrite_count += tag_buf[k];
        offset_new =
            offset > 0 ? (offset - rewrite_count) : (offset + rewrite_count);
        assert(offset_new == (int16_t)offset_new);
        put_u16(bc_buf + pos_raw + 1, offset_new);
        pos += (len - 1);
        break;
#endif
      case OP_FMT_label:
      case OP_FMT_label_u16:
        pos++;
        offset = get_u32(bc_buf1 + pos);
        rewrite_count = 0;
        pos_begin = offset > 0 ? pos : pos + offset;
        pos_end = offset > 0 ? pos + offset : pos;
        for (int k = pos_begin; k < pos_end; k++) rewrite_count += tag_buf[k];
        offset_new =
            offset > 0 ? (offset - rewrite_count) : (offset + rewrite_count);
        assert(offset_new == (int32_t)offset_new);
        put_u32(bc_buf + pos_raw + 1, offset_new);
        pos += (len - 1);
        break;
      default:
        pos += len;
        break;
    }
    switch (op) {
      case OP_put_field:
      case OP_get_field:
      case OP_get_field2:
      case OP_get_var:
      case OP_get_var_undef:
      case OP_get_length: {
        pos_raw += (len - 8);
        break;
      }
      default: {
        pos_raw += len;
        break;
      }
    }
  }

  if (s->byte_swap) bc_byte_swap(bc_buf, bc_len_raw);

  dbuf_put(&s->dbuf, bc_buf, bc_len_raw);

  lepus_free(s->ctx, bc_buf);
  lepus_free(s->ctx, tag_buf);
  return 0;
fail:
  lepus_free(s->ctx, bc_buf);
  return -1;
}
#else
QJS_STATIC int LEPUS_WriteFunctionBytecode(BCWriterState *s,
                                           LEPUSFunctionBytecode *b,
                                           const uint8_t *bc_buf1, int bc_len) {
  int pos, len, op;
  LEPUSAtom atom;
  uint8_t *bc_buf;
  uint32_t val;

  bc_buf = static_cast<uint8_t *>(lepus_malloc(s->ctx, bc_len));
  if (!bc_buf) return -1;
  memcpy(bc_buf, bc_buf1, bc_len);

  pos = 0;
  while (pos < bc_len) {
    op = bc_buf[pos];
#ifdef ENABLE_QUICKJS_SECURITY_MODE
    LEPUSContext *ctx = s->ctx;
    if (ctx->op_transform_callback.encode_opcode) {
      uint8_t encode_op =
          (uint8_t)ctx->op_transform_callback.encode_opcode(ctx, op);
      bc_buf[pos] = encode_op;
    }
#endif
    len = short_opcode_info(op).size;
    switch (short_opcode_info(op).fmt) {
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
      case OP_FMT_atom_u16:
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        atom = get_u32(bc_buf + pos + 1);
        if (bc_atom_to_idx(s, &val, atom)) goto fail;
        put_u32(bc_buf + pos + 1, val);
        break;
      default:
        break;
    }
    pos += len;
  }

  if (s->byte_swap) bc_byte_swap(bc_buf, bc_len);

  dbuf_put(&s->dbuf, bc_buf, bc_len);

  lepus_free(s->ctx, bc_buf);
  return 0;
fail:
  lepus_free(s->ctx, bc_buf);
  return -1;
}
#endif

QJS_STATIC void LEPUS_WriteString(BCWriterState *s, LEPUSString *p) {
  int i;
  bc_put_leb128(s, ((uint32_t)p->len << 1) | p->is_wide_char);
  if (p->is_wide_char) {
    for (i = 0; i < p->len; i++) bc_put_u16(s, p->u.str16[i]);
  } else {
    dbuf_put(&s->dbuf, p->u.str8, p->len);
  }
}

QJS_STATIC int LEPUS_WriteObjectRec(BCWriterState *s, LEPUSValueConst obj);
static int LEPUS_WriteArray(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  uint32_t i, len;
  LEPUSValue val;
  int ret;
  BOOL is_template;

  if (s->allow_bytecode && !p->extensible) {
    /* not extensible array: we consider it is a
       template when we are saving bytecode */
    bc_put_u8(s, BC_TAG_TEMPLATE_OBJECT);
    is_template = TRUE;
  } else {
    bc_put_u8(s, BC_TAG_ARRAY);
    is_template = FALSE;
  }
  if (lepus_get_length32(s->ctx, &len, obj)) goto fail1;
  bc_put_leb128(s, len);
  for (i = 0; i < len; i++) {
    val = LEPUS_GetPropertyUint32(s->ctx, obj, i);
    if (LEPUS_IsException(val)) goto fail1;
    ret = LEPUS_WriteObjectRec(s, val);
    LEPUS_FreeValue(s->ctx, val);
    if (ret) goto fail1;
  }
  if (is_template) {
    val = LEPUS_GetProperty(s->ctx, obj, LEPUS_ATOM_raw);
    if (LEPUS_IsException(val)) goto fail1;
    ret = LEPUS_WriteObjectRec(s, val);
    LEPUS_FreeValue(s->ctx, val);
    if (ret) goto fail1;
  }
  return 0;
fail1:
  return -1;
}

#ifdef ENABLE_BUILTIN_SERIALIZE
static int LEPUS_WriteTypedArray(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  LEPUSTypedArray *ta = p->u.typed_array;

  bc_put_u8(s, BC_TAG_TYPED_ARRAY);
  bc_put_u8(s, p->class_id - LEPUS_CLASS_UINT8C_ARRAY);
  bc_put_leb128(s, p->u.array.count);
  bc_put_leb128(s, ta->offset);
  if (LEPUS_WriteObjectRec(s, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer)))
    return -1;
  return 0;
}

static int LEPUS_WriteDataView(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  LEPUSTypedArray *ta = p->u.typed_array;

  bc_put_u8(s, BC_TAG_DATAVIEW);
  bc_put_leb128(s, ta->length);
  bc_put_leb128(s, ta->offset);
  if (LEPUS_WriteObjectRec(s, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer)))
    return -1;
  return 0;
}

static int LEPUS_WriteError(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSContext *ctx = s->ctx;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  bc_put_u8(s, BC_TAG_ERROR);
  LEPUSObject *proto = p->shape->proto;
  LEPUSValue name = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_name);
  const char *str = LEPUS_ToCString(ctx, name);
  LEPUS_FreeValue(ctx, name);
  int8_t magic = -1;
  for (int i = 0; i < LEPUS_NATIVE_ERROR_COUNT; ++i) {
    if (strcmp(str, native_error_name[i]) == 0) {
      magic = i;
      break;
    }
  }
  LEPUS_FreeCString(ctx, str);
  bc_put_u8(s, magic);

  LEPUSValue message = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_message);
  if (unlikely(LEPUS_WriteObjectRec(s, message))) return -1;
  LEPUS_FreeValue(ctx, message);

  LEPUSValue stack = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_stack);
  if (unlikely(LEPUS_WriteObjectRec(s, stack))) return -1;
  LEPUS_FreeValue(ctx, stack);

  if (magic == LEPUS_AGGREGATE_ERROR) {
    LEPUSValue error_list = LEPUS_GetPropertyStr(ctx, obj, "errors");
    if (unlikely(LEPUS_WriteObjectRec(s, error_list))) {
      LEPUS_FreeValue(ctx, error_list);
      return -1;
    }
    LEPUS_FreeValue(ctx, error_list);
  }
  return 0;
}

static int LEPUS_WriteRegExp(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSContext *ctx = s->ctx;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  bc_put_u8(s, BC_TAG_REGEXP);
  LEPUSValue pat, bc;
  pat = LEPUS_MKPTR(LEPUS_TAG_STRING, p->u.regexp.pattern);
  bc = LEPUS_MKPTR(LEPUS_TAG_STRING, p->u.regexp.bytecode);
  if (unlikely(LEPUS_WriteObjectRec(s, pat))) return -1;
  if (unlikely(LEPUS_WriteObjectRec(s, bc))) return -1;
  return 0;
}

static int LEPUS_WriteMap(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSContext *ctx = s->ctx;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  bc_put_u8(s, BC_TAG_MAP);
  uint8_t magic = p->class_id - LEPUS_CLASS_MAP;
  bc_put_u8(s, magic);
  bool is_set = magic & MAGIC_SET;
  LEPUSMapState *ms = static_cast<LEPUSMapState *>(p->u.opaque);
  bc_put_u32(s, ms->record_count);
  list_head *el;
  LEPUSMapRecord *rec;
  list_for_each(el, &ms->records) {
    rec = list_entry(el, LEPUSMapRecord, link);
    if (rec->empty) continue;
    if (unlikely(LEPUS_WriteObjectRec(s, rec->key))) return -1;
    if (!is_set)
      if (unlikely(LEPUS_WriteObjectRec(s, rec->value))) goto fail;
  }
  return 0;
fail:
  return -1;
}

static int LEPUS_WriteArrayBuffer(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  LEPUSArrayBuffer *abuf = p->u.array_buffer;
  if (abuf->detached) {
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(s->ctx);
    return -1;
  }
  bc_put_u8(s, BC_TAG_ARRAY_BUFFER);
  bc_put_leb128(s, abuf->byte_length);
  dbuf_put(&s->dbuf, abuf->data, abuf->byte_length);
  return 0;
}
#endif

static int LEPUS_WriteObjectTag(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  uint32_t i, prop_count;
  LEPUSShape *sh;
  LEPUSShapeProperty *pr;
  int pass;
  LEPUSAtom atom;

  bc_put_u8(s, BC_TAG_OBJECT);
  prop_count = 0;
  sh = p->shape;
  for (pass = 0; pass < 2; pass++) {
    if (pass == 1) bc_put_leb128(s, prop_count);
    for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
      atom = pr->atom;
      if (atom != LEPUS_ATOM_NULL && LEPUS_AtomIsString(s->ctx, atom) &&
          (pr->flags & LEPUS_PROP_ENUMERABLE)) {
        if (pr->flags & LEPUS_PROP_TMASK) {
          LEPUS_ThrowTypeError(s->ctx, "only value properties are supported");
          goto fail;
        }
        if (pass == 0) {
          prop_count++;
        } else {
          bc_put_atom(s, atom);
          if (LEPUS_WriteObjectRec(s, p->prop[i].u.value)) goto fail;
        }
      }
    }
  }
  return 0;
fail:
  return -1;
}

static int LEPUS_WriteFunction(BCWriterState *s, LEPUSValueConst obj) {
  uint8_t debuginfo_outside = s->ctx->debuginfo_outside;
  LEPUSFunctionBytecode *b =
      static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(obj));
  uint32_t flags;
  int idx, i;

  if (!s->allow_bytecode) goto fail;
  bc_put_u8(s, BC_TAG_FUNCTION_BYTECODE);
  flags = idx = 0;
  bc_set_flags(&flags, &idx, b->has_prototype, 1);
  bc_set_flags(&flags, &idx, b->has_simple_parameter_list, 1);
  bc_set_flags(&flags, &idx, b->is_derived_class_constructor, 1);
  bc_set_flags(&flags, &idx, b->need_home_object, 1);
  bc_set_flags(&flags, &idx, b->func_kind, 2);
  bc_set_flags(&flags, &idx, b->new_target_allowed, 1);
  bc_set_flags(&flags, &idx, b->super_call_allowed, 1);
  bc_set_flags(&flags, &idx, b->super_allowed, 1);
  bc_set_flags(&flags, &idx, b->arguments_allowed, 1);
  bc_set_flags(&flags, &idx, b->has_debug, 1);
  assert(idx <= 16);
  bc_put_u16(s, flags);
  bc_put_u8(s, b->lepus_mode);
  bc_put_atom(s, b->func_name);

  bc_put_leb128(s, b->arg_count);
  bc_put_leb128(s, b->var_count);
  bc_put_leb128(s, b->defined_arg_count);
  bc_put_leb128(s, b->stack_size);
  bc_put_leb128(s, b->closure_var_count);
  bc_put_leb128(s, b->cpool_count);
#ifdef ENABLE_PRIMJS_IC
  int raw_bytecode_len;
  raw_bytecode_len = b->byte_code_len -
                     8 * (b->get_feedback_vec_size + b->set_feedback_vec_size);
  bc_put_leb128(s, raw_bytecode_len);
#else
  bc_put_leb128(s, b->byte_code_len);
#endif
  if (b->vardefs) {
    bc_put_leb128(s, b->arg_count + b->var_count);
    for (i = 0; i < b->arg_count + b->var_count; i++) {
      LEPUSVarDef *vd = &b->vardefs[i];
      bc_put_atom(s, vd->var_name);
      bc_put_leb128(s, vd->scope_level);
      bc_put_leb128(s, vd->scope_next + 1);
      flags = idx = 0;
      bc_set_flags(&flags, &idx, vd->var_kind, 4);
      bc_set_flags(&flags, &idx, vd->is_const, 1);
      bc_set_flags(&flags, &idx, vd->is_lexical, 1);
      bc_set_flags(&flags, &idx, vd->is_captured, 1);
      assert(idx <= 8);
      bc_put_u8(s, flags);
    }
  } else {
    bc_put_leb128(s, 0);
  }

  for (i = 0; i < b->closure_var_count; i++) {
    LEPUSClosureVar *cv = &b->closure_var[i];
    bc_put_atom(s, cv->var_name);
    bc_put_leb128(s, cv->var_idx);
    flags = idx = 0;
    bc_set_flags(&flags, &idx, cv->is_local, 1);
    bc_set_flags(&flags, &idx, cv->is_arg, 1);
    bc_set_flags(&flags, &idx, cv->is_const, 1);
    bc_set_flags(&flags, &idx, cv->is_lexical, 1);
    bc_set_flags(&flags, &idx, cv->var_kind, 4);
    assert(idx <= 8);
    bc_put_u8(s, flags);
  }

  if (LEPUS_WriteFunctionBytecode(s, b, b->byte_code_buf, b->byte_code_len))
    goto fail;

  // in lepusng debug mode, info related b->debug is saved in
  // debug-info.json. do not need to save in template.js
  if (b->has_debug) {
    if (debuginfo_outside == 1) {
      // b->debug.filename: magic string
      // b->debug.line_num: b->function_id. for debug
      // b->debug.pc2line_len: 0
      LEPUSAtom magic_atom = LEPUS_NewAtom(s->ctx, "__lepusNG_function_id__");
      bc_put_atom(s, magic_atom);
      bc_put_leb128(s, b->function_id);
      bc_put_leb128(s, 0);
    } else {
      bc_put_atom(s, b->debug.filename);
      bc_put_leb128(s, b->debug.line_num);
      bc_put_leb128(s, b->debug.pc2line_len);
      dbuf_put(&s->dbuf, b->debug.pc2line_buf, b->debug.pc2line_len);
    }
  }

  for (i = 0; i < b->cpool_count; i++) {
    if (LEPUS_WriteObjectRec(s, b->cpool[i])) goto fail;
  }
  return 0;
fail:
  return -1;
}

static int LEPUS_WriteModule(BCWriterState *s, LEPUSValueConst obj) {
  LEPUSModuleDef *m = static_cast<LEPUSModuleDef *>(LEPUS_VALUE_GET_PTR(obj));
  int i;

  if (!s->allow_bytecode) goto fail;
  bc_put_u8(s, BC_TAG_MODULE);
  bc_put_atom(s, m->module_name);

  bc_put_leb128(s, m->req_module_entries_count);
  for (i = 0; i < m->req_module_entries_count; i++) {
    LEPUSReqModuleEntry *rme = &m->req_module_entries[i];
    bc_put_atom(s, rme->module_name);
  }

  bc_put_leb128(s, m->export_entries_count);
  for (i = 0; i < m->export_entries_count; i++) {
    LEPUSExportEntry *me = &m->export_entries[i];
    bc_put_u8(s, me->export_type);
    if (me->export_type == LEPUS_EXPORT_TYPE_LOCAL) {
      bc_put_leb128(s, me->u.local.var_idx);
    } else {
      bc_put_leb128(s, me->u.req_module_idx);
      bc_put_atom(s, me->local_name);
    }
    bc_put_atom(s, me->export_name);
  }

  bc_put_leb128(s, m->star_export_entries_count);
  for (i = 0; i < m->star_export_entries_count; i++) {
    LEPUSStarExportEntry *se = &m->star_export_entries[i];
    bc_put_leb128(s, se->req_module_idx);
  }

  bc_put_leb128(s, m->import_entries_count);
  for (i = 0; i < m->import_entries_count; i++) {
    LEPUSImportEntry *mi = &m->import_entries[i];
    bc_put_leb128(s, mi->var_idx);
    bc_put_atom(s, mi->import_name);
    bc_put_leb128(s, mi->req_module_idx);
  }

  if (LEPUS_WriteObjectRec(s, m->func_obj)) goto fail;
  return 0;
fail:
  return -1;
}
__exception QJS_STATIC int LEPUS_WriteObjectRec(BCWriterState *s,
                                                LEPUSValueConst obj) {
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(obj);
  uint8_t debuginfo_outside = s->ctx->debuginfo_outside;

  switch (tag) {
    case LEPUS_TAG_NULL:
      bc_put_u8(s, BC_TAG_NULL);
      break;
    case LEPUS_TAG_UNDEFINED:
      bc_put_u8(s, BC_TAG_UNDEFINED);
      break;
    case LEPUS_TAG_BOOL:
      bc_put_u8(s, BC_TAG_BOOL_FALSE + LEPUS_VALUE_GET_BOOL(obj));
      break;
    case LEPUS_TAG_INT:
      bc_put_u8(s, BC_TAG_INT32);
      bc_put_sleb128(s, LEPUS_VALUE_GET_INT(obj));
      break;
    case LEPUS_TAG_FLOAT64: {
      LEPUSFloat64Union u;
      bc_put_u8(s, BC_TAG_FLOAT64);
      u.d = LEPUS_VALUE_GET_FLOAT64(obj);
      bc_put_u64(s, u.u64);
    } break;
    case LEPUS_TAG_STRING: {
      LEPUSString *p = LEPUS_VALUE_GET_STRING(obj);
      bc_put_u8(s, BC_TAG_STRING);
      LEPUS_WriteString(s, p);
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE: {
      if (LEPUS_WriteFunction(s, obj)) goto fail;
    } break;
    case LEPUS_TAG_MODULE: {
      if (LEPUS_WriteModule(s, obj)) goto fail;
    } break;
    case LEPUS_TAG_OBJECT: {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
      uint32_t i, prop_count, len;
      LEPUSShape *sh;
      LEPUSShapeProperty *pr;
      LEPUSValue val;
      int ret, pass;
      BOOL is_template;
      LEPUSAtom atom;

      if (p->tmp_mark) {
        LEPUS_ThrowTypeError(s->ctx, "circular reference");
        goto fail;
      }
      p->tmp_mark = 1;
      switch (p->class_id) {
        case LEPUS_CLASS_ARRAY:
          ret = LEPUS_WriteArray(s, obj);
          break;
        case LEPUS_CLASS_OBJECT:
          ret = LEPUS_WriteObjectTag(s, obj);
          break;
#ifdef ENABLE_BUILTIN_SERIALIZE
        case LEPUS_CLASS_ARRAY_BUFFER:
          ret = LEPUS_WriteArrayBuffer(s, obj);
          break;
        case LEPUS_CLASS_DATE:
          bc_put_u8(s, BC_TAG_DATE);
          ret = LEPUS_WriteObjectRec(s, p->u.object_data);
          break;
        case LEPUS_CLASS_UINT8C_ARRAY ... LEPUS_CLASS_FLOAT64_ARRAY:
          ret = LEPUS_WriteTypedArray(s, obj);
          break;
        case LEPUS_CLASS_DATAVIEW:
          ret = LEPUS_WriteDataView(s, obj);
          break;
        case LEPUS_CLASS_ERROR:
          ret = LEPUS_WriteError(s, obj);
          break;
        case LEPUS_CLASS_REGEXP:
          ret = LEPUS_WriteRegExp(s, obj);
          break;
        case LEPUS_CLASS_MAP ... LEPUS_CLASS_SET:
          ret = LEPUS_WriteMap(s, obj);
          break;
        case LEPUS_CLASS_NUMBER:
        case LEPUS_CLASS_STRING:
        case LEPUS_CLASS_BOOLEAN:
#ifdef CONFIG_BIGNUM
        case LEPUS_CLASS_BIG_INT:
        case LEPUS_CLASS_BIG_FLOAT:
#endif
          bc_put_u8(s, BC_TAG_OBJECT_VALUE);
          ret = LEPUS_WriteObjectRec(s, p->u.object_data);
          break;
#endif  // ENABLE_BUILTIN_SERIALIZE
        default:
          LEPUS_ThrowTypeError(s->ctx, "unsupported object class");
          p->tmp_mark = 0;
          goto fail;
      }
      p->tmp_mark = 0;
      if (ret) goto fail;
    } break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      int32_t e;
      LEPUSBigFloat *bf =
          static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(obj));
      bf_t *a = &bf->num;
      size_t len, i, n1, j;
      limb_t v;

      bc_put_u8(s,
                tag == LEPUS_TAG_BIG_INT ? BC_TAG_BIG_INT : BC_TAG_BIG_FLOAT);
      if (a->len != 0) {
        i = 0;
        while (i < a->len && a->tab[i] == 0) i++;
        assert(i < a->len);
        v = a->tab[i];
        n1 = sizeof(limb_t);
        while ((v & 0xff) == 0) {
          n1--;
          v >>= 8;
        }
        i++;
        len = (a->len - i) * sizeof(limb_t) + n1;
        if (len > INT32_MAX) {
          LEPUS_ThrowInternalError(s->ctx, "bignum is too large");
          goto fail;
        }
        /* XXX: it would be slightly more efficient to put the
           sign in the MSB of the mantissa */
        bc_put_leb128(s, len * 2 + a->sign);
        /* always saved in byte based little endian representation */
        for (j = 0; j < n1; j++) {
          dbuf_putc(&s->dbuf, v >> (j * 8));
        }
        for (; i < a->len; i++) {
          limb_t v = a->tab[i];
#if LIMB_BITS == 32
#ifdef WORDS_BIGENDIAN
          v = bswap32(v);
#endif
          dbuf_put_u32(&s->dbuf, v);
#else
#ifdef WORDS_BIGENDIAN
          v = bswap64(v);
#endif
          dbuf_put_u64(&s->dbuf, v);
#endif
        }
#if LIMB_BITS != 32
        if (a->expn <= INT32_MIN || a->expn >= (INT32_MAX - 1)) {
          LEPUS_ThrowInternalError(s->ctx, "bignum exponent is too large");
          goto fail;
        }
#endif
        bc_put_sleb128(s, a->expn);
      } else {
        bc_put_leb128(s, a->sign); /* length + sign */
        if (tag == LEPUS_TAG_BIG_FLOAT) {
          /* special numbers */
          if (a->expn == BF_EXP_ZERO) {
            e = 0;
          } else if (a->expn == BF_EXP_INF) {
            e = 1;
          } else {
            e = 2;
          }
          bc_put_u8(s, e);
        }
      }
    } break;
#endif
    default:
#ifdef config_BIGNUM
    invalid_tag:
#endif
#if defined(__aarch64__) && !defined(OS_WIN)
      LEPUS_ThrowInternalError(s->ctx, "unsupported tag (%p)", (void *)tag);
#else
      LEPUS_ThrowInternalError(s->ctx, "unsupported tag (%" PRId64 ")", tag);
#endif
      goto fail;
  }
  return 0;

fail:
  return -1;
}

/* create the atom table */
QJS_STATIC int LEPUS_WriteObjectAtoms(BCWriterState *s) {
  LEPUSRuntime *rt = s->ctx->rt;
  DynBuf dbuf1;
  int i, atoms_size;
  uint8_t version;

  dbuf1 = s->dbuf;
  lepus_dbuf_init(s->ctx, &s->dbuf);

  version = BC_VERSION;
  if (s->byte_swap) version ^= BC_BE_VERSION;
  bc_put_u8(s, version);

  bc_put_leb128(s, s->idx_to_atom_count);
  for (i = 0; i < s->idx_to_atom_count; i++) {
    LEPUSAtomStruct *p = rt->atom_array[s->idx_to_atom[i]];
    LEPUS_WriteString(s, p);
  }
  /* XXX: should check for OOM in above phase */

  /* move the atoms at the start */
  /* XXX: could just append dbuf1 data, but it uses more memory if
     dbuf1 is larger than dbuf */
  atoms_size = s->dbuf.size;
  if (dbuf_realloc(&dbuf1, dbuf1.size + atoms_size)) goto fail;
  memmove(dbuf1.buf + atoms_size, dbuf1.buf, dbuf1.size);
  memcpy(dbuf1.buf, s->dbuf.buf, atoms_size);
  dbuf1.size += atoms_size;
  dbuf_free(&s->dbuf);
  s->dbuf = dbuf1;
  return 0;
fail:
  dbuf_free(&dbuf1);
  return -1;
}

uint8_t *LEPUS_WriteObject(LEPUSContext *ctx, size_t *psize,
                           LEPUSValueConst obj, int flags) {
  BCWriterState ss, *s = &ss;

  memset(s, 0, sizeof(*s));
  s->ctx = ctx;
  /* XXX: byte swapped output is untested */
  s->byte_swap = ((flags & LEPUS_WRITE_OBJ_BSWAP) != 0);
  s->allow_bytecode = ((flags & LEPUS_WRITE_OBJ_BYTECODE) != 0);
  /* XXX: could use a different version when bytecode is included */
  if (s->allow_bytecode)
    s->first_atom = LEPUS_ATOM_END;
  else
    s->first_atom = 1;
  lepus_dbuf_init(ctx, &s->dbuf);

  if (LEPUS_WriteObjectRec(s, obj)) goto fail;
  if (LEPUS_WriteObjectAtoms(s)) goto fail;
  lepus_free(ctx, s->atom_to_idx);
  lepus_free(ctx, s->idx_to_atom);
  *psize = s->dbuf.size;
  return s->dbuf.buf;
fail:
  lepus_free(ctx, s->atom_to_idx);
  lepus_free(ctx, s->idx_to_atom);
  dbuf_free(&s->dbuf);
  *psize = 0;
  return NULL;
}
#endif

typedef struct BCReaderState {
  LEPUSContext *ctx;
  const uint8_t *buf_start, *ptr, *buf_end;
  uint32_t first_atom;
  uint32_t idx_to_atom_count;
  LEPUSAtom *idx_to_atom;
  int error_state;
  BOOL allow_bytecode;
  BOOL is_rom_data;
#ifdef DUMP_READ_OBJECT
  const uint8_t *ptr_last;
  int level;
#endif
} BCReaderState;

#ifdef DUMP_READ_OBJECT
static void __attribute__((format(printf, 2, 3)))
bc_read_trace(BCReaderState *s, const char *fmt, ...) {
  va_list ap;
  int i, n, n0;

  if (!s->ptr_last) s->ptr_last = s->buf_start;

  n = n0 = 0;
  if (s->ptr > s->ptr_last || s->ptr == s->buf_start) {
    n0 = printf("%04x: ", (int)(s->ptr_last - s->buf_start));
    n += n0;
  }
  for (i = 0; s->ptr_last < s->ptr; i++) {
    if ((i & 7) == 0 && i > 0) {
      printf("\n%*s", n0, "");
      n = n0;
    }
    n += printf(" %02x", *s->ptr_last++);
  }
  if (*fmt == '}') s->level--;
  if (n < 32 + s->level * 2) {
    printf("%*s", 32 + s->level * 2 - n, "");
  }
  va_start(ap, fmt);
  vfprintf(stdout, fmt, ap);
  va_end(ap);
  if (strchr(fmt, '{')) s->level++;
}
#else
#define bc_read_trace(...)
#endif

QJS_STATIC int bc_read_error_end(BCReaderState *s) {
  if (!s->error_state) {
    LEPUS_ThrowSyntaxError(s->ctx, "read after the end of the buffer");
  }
  return s->error_state = -1;
}

QJS_STATIC int bc_get_u8(BCReaderState *s, uint8_t *pval) {
  if (unlikely(s->buf_end - s->ptr < 1)) {
    *pval = 0; /* avoid warning */
    return bc_read_error_end(s);
  }
  *pval = *s->ptr++;
  return 0;
}

QJS_STATIC int bc_get_u16(BCReaderState *s, uint16_t *pval) {
  if (unlikely(s->buf_end - s->ptr < 2)) {
    *pval = 0; /* avoid warning */
    return bc_read_error_end(s);
  }
  *pval = get_u16(s->ptr);
  s->ptr += 2;
  return 0;
}

QJS_STATIC __attribute__((unused)) int bc_get_u32(BCReaderState *s,
                                                  uint32_t *pval) {
  if (unlikely(s->buf_end - s->ptr < 4)) {
    *pval = 0; /* avoid warning */
    return bc_read_error_end(s);
  }
  *pval = get_u32(s->ptr);
  s->ptr += 4;
  return 0;
}

QJS_STATIC int bc_get_u64(BCReaderState *s, uint64_t *pval) {
  if (unlikely(s->buf_end - s->ptr < 8)) {
    *pval = 0; /* avoid warning */
    return bc_read_error_end(s);
  }
  *pval = get_u64(s->ptr);
  s->ptr += 8;
  return 0;
}

QJS_STATIC int bc_get_leb128(BCReaderState *s, uint32_t *pval) {
  int ret;
  ret = get_leb128(pval, s->ptr, s->buf_end);
  if (unlikely(ret < 0)) return bc_read_error_end(s);
  s->ptr += ret;
  return 0;
}

QJS_STATIC int bc_get_sleb128(BCReaderState *s, int32_t *pval) {
  int ret;
  ret = get_sleb128(pval, s->ptr, s->buf_end);
  if (unlikely(ret < 0)) return bc_read_error_end(s);
  s->ptr += ret;
  return 0;
}

/* XXX: used to read an `int` with a positive value */
QJS_STATIC int bc_get_leb128_int(BCReaderState *s, int *pval) {
  return bc_get_leb128(s, (uint32_t *)pval);
}

QJS_STATIC int bc_get_leb128_u16(BCReaderState *s, uint16_t *pval) {
  uint32_t val;
  if (bc_get_leb128(s, &val)) {
    *pval = 0;
    return -1;
  }
  *pval = val;
  return 0;
}

QJS_STATIC int bc_get_buf(BCReaderState *s, uint8_t *buf, uint32_t buf_len) {
  if (buf_len != 0) {
    if (unlikely(!buf || s->buf_end - s->ptr < buf_len))
      return bc_read_error_end(s);
    memcpy(buf, s->ptr, buf_len);
    s->ptr += buf_len;
  }
  return 0;
}

QJS_STATIC int bc_idx_to_atom(BCReaderState *s, LEPUSAtom *patom,
                              uint32_t idx) {
  LEPUSAtom atom;

  if (__JS_AtomIsTaggedInt(idx)) {
    atom = idx;
  } else if (idx < s->first_atom) {
    atom = LEPUS_DupAtom(s->ctx, idx);
  } else {
    idx -= s->first_atom;
    if (idx >= s->idx_to_atom_count) {
      LEPUS_ThrowSyntaxError(s->ctx, "invalid atom index (pos=%u)",
                             (unsigned int)(s->ptr - s->buf_start));
      *patom = LEPUS_ATOM_NULL;
      return s->error_state = -1;
    }
    atom = LEPUS_DupAtom(s->ctx, s->idx_to_atom[idx]);
  }
  *patom = atom;
  return 0;
}

QJS_STATIC int bc_get_atom(BCReaderState *s, LEPUSAtom *patom) {
  uint32_t v;
  if (bc_get_leb128(s, &v)) return -1;
  if (v & 1) {
    *patom = __JS_AtomFromUInt32(v >> 1);
    return 0;
  } else {
    return bc_idx_to_atom(s, patom, v >> 1);
  }
}

QJS_STATIC LEPUSString *LEPUS_ReadString(BCReaderState *s) {
  uint32_t len;
  size_t size;
  BOOL is_wide_char;
  LEPUSString *p;

  if (bc_get_leb128(s, &len)) return NULL;
  is_wide_char = len & 1;
  len >>= 1;
  p = lepus_alloc_string(s->ctx, len, is_wide_char);
  if (!p) {
    s->error_state = -1;
    return NULL;
  }
  size = (size_t)len << is_wide_char;
  if ((s->buf_end - s->ptr) < size) {
    bc_read_error_end(s);
    lepus_free_string(s->ctx->rt, p);
    return NULL;
  }
  memcpy(p->u.str8, s->ptr, size);
  s->ptr += size;
  if (!is_wide_char) {
    p->u.str8[size] = '\0'; /* add the trailing zero for 8 bit strings */
  }
#ifdef DUMP_READ_OBJECT
  bc_read_trace(s, "string: ");
  LEPUS_DumpString(s->ctx->rt, p);
  printf("\n");
#endif
  return p;
}

QJS_STATIC uint32_t bc_get_flags(uint32_t flags, int *pidx, int n) {
  uint32_t val;
  /* XXX: this does not work for n == 32 */
  val = (flags >> *pidx) & ((1U << n) - 1);
  *pidx += n;
  return val;
}

#ifdef ENABLE_PRIMJS_IC
QJS_STATIC int LEPUS_ReadFunctionBytecode(LEPUSContext *ctx, BCReaderState *s,
                                          LEPUSFunctionBytecode *&b,
                                          int byte_code_offset,
                                          uint32_t bc_len) {
  uint8_t *bc_buf, *bc_buf_new, *bc_buf_raw;
  LEPUSFunctionBytecode *b_new;
  int pos, pos_new, len, op, bc_len_new, new_function_size;
  LEPUSAtom atom;
  uint32_t idx;
  uint8_t *tag_buf;

  tag_buf = static_cast<uint8_t *>(lepus_mallocz(ctx, bc_len));

  if (s->is_rom_data) {
    /* directly use the input buffer */
    if (unlikely(s->buf_end - s->ptr < bc_len)) return bc_read_error_end(s);
    bc_buf = (uint8_t *)s->ptr;
    s->ptr += bc_len;
  } else {
    bc_buf = (uint8_t *)b + byte_code_offset;
    if (bc_get_buf(s, bc_buf, bc_len)) return -1;
  }
  b->byte_code_buf = bc_buf;
  bc_buf_raw = static_cast<uint8_t *>(lepus_mallocz(ctx, bc_len));
  memcpy(bc_buf_raw, bc_buf, bc_len);
  // <primjs begin>
  uint32_t get_feedback_vec_size = 0;
  uint32_t set_feedback_vec_size = 0;
  // <primjs end>
  pos = 0;
  bc_len_new = bc_len;
  while (pos < bc_len) {
    op = bc_buf[pos];
    len = short_opcode_info(op).size;
    switch (op) {
      case OP_get_field:
      case OP_get_field2:
      case OP_put_field:
      case OP_get_var:
      case OP_get_var_undef:
      case OP_get_length: {
        tag_buf[pos] = 8;
        len -= 8;
        bc_len_new += 8;
        break;
      }
      case OP_if_false8:
      case OP_if_true8:
      case OP_goto8:
        tag_buf[pos] = 3;
        bc_len_new += 3;
        break;
      case OP_goto16:
        tag_buf[pos] = 2;
        bc_len_new += 2;
        break;
      default: {
        break;
      }
    }
    pos += len;
  }
  new_function_size = byte_code_offset + bc_len_new;
  b_new = static_cast<LEPUSFunctionBytecode *>(
      lepus_mallocz(ctx, new_function_size));
  memcpy(b_new, b, byte_code_offset);
  if (b->vardefs) {
    b_new->vardefs =
        (LEPUSVarDef *)((uint8_t *)b_new +
                        (int)((uint8_t *)b->vardefs - (uint8_t *)b));
  }
  if (b->closure_var) {
    b_new->closure_var =
        (LEPUSClosureVar *)((uint8_t *)b_new +
                            (int)((uint8_t *)b->closure_var - (uint8_t *)b));
  }
  // rewite new bytecodebuf
  b_new->byte_code_len = bc_len_new;
  bc_buf_new = (uint8_t *)b_new + byte_code_offset;
  b_new->byte_code_buf = bc_buf_new;

  int rewrite_count = 0;
  int offset, offset_new;
  int pos_1, pos_begin, pos_end;
  int op_new;

  pos_new = pos = 0;
  while (pos < bc_len) {
    op = bc_buf_raw[pos];
    len = short_opcode_info(op).size;

    // <primjs begin>
    switch (op) {
      case OP_put_field: {
        set_feedback_vec_size++;
        goto process_feedback;
      }
      case OP_get_var:
      case OP_get_var_undef:
      case OP_get_field:
      case OP_get_field2:
      case OP_get_length: {
        get_feedback_vec_size++;
      process_feedback:
        memcpy(bc_buf_new + pos_new, bc_buf_raw + pos, len - 8);
        put_u64(bc_buf_new + pos_new + (len - 8), 0);
        pos += (len - 8);
        break;
      }
      default: {
        memcpy(bc_buf_new + pos_new, bc_buf_raw + pos, len);
        pos += len;
        break;
      }
    }
    // <primjs end>

    switch (short_opcode_info(op).fmt) {
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
      case OP_FMT_atom_u16:
        idx = get_u32(bc_buf_new + pos_new + 1);
        if (s->is_rom_data) {
          /* just increment the reference count of the atom */
          LEPUS_DupAtom(s->ctx, (LEPUSAtom)idx);
        } else {
          if (bc_idx_to_atom(s, &atom, idx)) {
            /* Note: the atoms will be freed up to this position */
            b_new->byte_code_len = pos_new;
            return -1;
          }
          put_u32(bc_buf_new + pos_new + 1, atom);
#ifdef DUMP_READ_OBJECT
          bc_read_trace(s, "at %d, fixup atom: ", pos_new + 1);
          print_atom(s->ctx, atom);
          printf("\n");
#endif
        }
        break;
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        pos -= len;
        pos++;
        pos += 4;
        offset = get_u32(bc_buf_raw + pos);
        rewrite_count = 0;
        pos_begin = offset > 0 ? pos : pos + offset;
        pos_end = offset > 0 ? pos + offset : pos;
        for (int k = pos_begin; k < pos_end; k++) rewrite_count += tag_buf[k];
        offset_new =
            offset > 0 ? (offset + rewrite_count) : (offset - rewrite_count);
        assert(offset_new == (int32_t)offset_new);
        put_u32(bc_buf_new + pos_new + 5, offset_new);
        pos += (len - 5);
        idx = get_u32(bc_buf_new + pos_new + 1);
        if (s->is_rom_data) {
          /* just increment the reference count of the atom */
          LEPUS_DupAtom(s->ctx, (LEPUSAtom)idx);
        } else {
          if (bc_idx_to_atom(s, &atom, idx)) {
            /* Note: the atoms will be freed up to this position */
            b_new->byte_code_len = pos_new;
            return -1;
          }
          put_u32(bc_buf_new + pos_new + 1, atom);
#ifdef DUMP_READ_OBJECT
          bc_read_trace(s, "at %d, fixup atom: ", pos_new + 1);
          print_atom(s->ctx, atom);
          printf("\n");
#endif
        }
        break;
#if SHORT_OPCODES
      case OP_FMT_label8:
        pos -= len;
        pos++;
        offset = (int8_t)bc_buf_raw[pos];
        rewrite_count = 0;
        pos_begin = offset > 0 ? pos : pos + offset;
        pos_end = offset > 0 ? pos + offset : pos;
        for (int k = pos_begin; k < pos_end; k++) rewrite_count += tag_buf[k];
        offset_new = offset > 0 ? (offset + rewrite_count + 3)
                                : (offset - rewrite_count + 3);
        // assert(offset_new == (int8_t)offset_new);
        op_new = (op - OP_if_false8) + OP_if_false;
        put_u8(bc_buf_new + pos_new, (uint8_t)op_new);
        put_u32(bc_buf_new + pos_new + 1, offset_new);
        pos += (len - 1);
        pos_new += 3;
        break;
      case OP_FMT_label16:
        pos -= len;
        pos++;
        offset = (int16_t)get_u16(bc_buf_raw + pos);
        rewrite_count = 0;
        pos_begin = offset > 0 ? pos : pos + offset;
        pos_end = offset > 0 ? pos + offset : pos;
        for (int k = pos_begin; k < pos_end; k++) rewrite_count += tag_buf[k];
        offset_new = offset > 0 ? (offset + rewrite_count + 2)
                                : (offset - rewrite_count + 2);
        // assert(offset_new == (int16_t)offset_new);
        put_u8(bc_buf_new + pos_new, OP_goto);
        put_u32(bc_buf_new + pos_new + 1, offset_new);
        pos += (len - 1);
        pos_new += 2;
        break;
#endif
      case OP_FMT_label:
      case OP_FMT_label_u16:
        pos -= len;
        pos++;
        offset = get_u32(bc_buf_raw + pos);
        rewrite_count = 0;
        pos_begin = offset > 0 ? pos : pos + offset;
        pos_end = offset > 0 ? pos + offset : pos;
        for (int k = pos_begin; k < pos_end; k++) rewrite_count += tag_buf[k];
        offset_new =
            offset > 0 ? (offset + rewrite_count) : (offset - rewrite_count);
        assert(offset_new == (int32_t)offset_new);
        put_u32(bc_buf_new + pos_new + 1, offset_new);
        pos += (len - 1);
        break;
      default:
        break;
    }

    pos_new += len;
  }
  b_new->get_feedback_vec_size = get_feedback_vec_size;
  b_new->set_feedback_vec_size = set_feedback_vec_size;

  lepus_free(ctx, b);

  b = b_new;

  lepus_free(ctx, bc_buf_raw);
  lepus_free(ctx, tag_buf);

  if (b->get_feedback_vec_size)
    b->get_feedback_vec = (TypeGetFeedBackVec *)lepus_mallocz(
        ctx, sizeof(TypeGetFeedBackVec) * b->get_feedback_vec_size);
  if (b->set_feedback_vec_size)
    b->set_feedback_vec = (TypeSetFeedBackVec *)lepus_mallocz(
        ctx, sizeof(TypeSetFeedBackVec) * b->set_feedback_vec_size);

  resolve_ic(ctx, b);

  return 0;
}
#else
QJS_STATIC int LEPUS_ReadFunctionBytecode(LEPUSContext *ctx, BCReaderState *s,
                                          LEPUSFunctionBytecode *&b,
                                          int byte_code_offset,
                                          uint32_t bc_len) {
  uint8_t *bc_buf;
  int pos, len, op;
  LEPUSAtom atom;
  uint32_t idx;

  if (s->is_rom_data) {
    /* directly use the input buffer */
    if (unlikely(s->buf_end - s->ptr < bc_len)) return bc_read_error_end(s);
    bc_buf = (uint8_t *)s->ptr;
    s->ptr += bc_len;
  } else {
    bc_buf = (uint8_t *)b + byte_code_offset;
    if (bc_get_buf(s, bc_buf, bc_len)) return -1;
  }
  b->byte_code_buf = bc_buf;

  pos = 0;
  while (pos < bc_len) {
    op = bc_buf[pos];
#ifdef ENABLE_QUICKJS_SECURITY_MODE
    LEPUSContext *ctx = s->ctx;
    if (ctx->op_transform_callback.decode_opcode)
      op = ctx->op_transform_callback.decode_opcode(ctx, op);
    bc_buf[pos] = (uint8_t)op;
#endif
    len = short_opcode_info(op).size;
    switch (short_opcode_info(op).fmt) {
      case OP_FMT_atom:
      case OP_FMT_atom_u8:
      case OP_FMT_atom_u16:
      case OP_FMT_atom_label_u8:
      case OP_FMT_atom_label_u16:
        idx = get_u32(bc_buf + pos + 1);
        if (s->is_rom_data) {
          /* just increment the reference count of the atom */
          LEPUS_DupAtom(s->ctx, (LEPUSAtom)idx);
        } else {
          if (bc_idx_to_atom(s, &atom, idx)) {
            /* Note: the atoms will be freed up to this position */
            b->byte_code_len = pos;
            return -1;
          }
          put_u32(bc_buf + pos + 1, atom);
#ifdef DUMP_READ_OBJECT
          bc_read_trace(s, "at %d, fixup atom: ", pos + 1);
          print_atom(s->ctx, atom);
          printf("\n");
#endif
        }
        break;
      default:
        break;
    }
    pos += len;
  }
  return 0;
}
#endif

QJS_STATIC LEPUSValue LEPUS_ReadObjectRec(BCReaderState *s);

QJS_STATIC LEPUSValue LEPUS_ReadFunction(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj = LEPUS_UNDEFINED;
  LEPUSFunctionBytecode bc, *b;
  uint16_t v16;
  uint8_t v8;
  int idx, i, local_count;
  int function_size, cpool_offset, byte_code_offset;
  int closure_var_offset, vardefs_offset;

  if (!s->allow_bytecode) goto fail;
  bc_read_trace(s, "%s {\n", bc_tag_str[tag]);

  memset(&bc, 0, sizeof(bc));
  bc.header.ref_count = 1;

  if (bc_get_u16(s, &v16)) goto fail;
  idx = 0;
  bc.has_prototype = bc_get_flags(v16, &idx, 1);
  bc.has_simple_parameter_list = bc_get_flags(v16, &idx, 1);
  bc.is_derived_class_constructor = bc_get_flags(v16, &idx, 1);
  bc.need_home_object = bc_get_flags(v16, &idx, 1);
  bc.func_kind = bc_get_flags(v16, &idx, 2);
  bc.new_target_allowed = bc_get_flags(v16, &idx, 1);
  bc.super_call_allowed = bc_get_flags(v16, &idx, 1);
  bc.super_allowed = bc_get_flags(v16, &idx, 1);
  bc.arguments_allowed = bc_get_flags(v16, &idx, 1);
  bc.has_debug = bc_get_flags(v16, &idx, 1);
  bc.read_only_bytecode = s->is_rom_data;
  if (bc_get_u8(s, &v8)) goto fail;
  bc.lepus_mode = v8;
  if (bc_get_atom(s, &bc.func_name))  //@ atom leak if failure
    goto fail;
  if (bc_get_leb128_u16(s, &bc.arg_count)) goto fail;
  if (bc_get_leb128_u16(s, &bc.var_count)) goto fail;
  if (bc_get_leb128_u16(s, &bc.defined_arg_count)) goto fail;
  if (bc_get_leb128_u16(s, &bc.stack_size)) goto fail;
  if (bc_get_leb128_int(s, &bc.closure_var_count)) goto fail;
  if (bc_get_leb128_int(s, &bc.cpool_count)) goto fail;
  if (bc_get_leb128_int(s, &bc.byte_code_len)) goto fail;
  if (bc_get_leb128_int(s, &local_count)) goto fail;

  if (bc.has_debug) {
    function_size = sizeof(*b);
  } else {
    function_size = offsetof(LEPUSFunctionBytecode, debug);
  }
  cpool_offset = function_size;
  function_size += bc.cpool_count * sizeof(*bc.cpool);
  vardefs_offset = function_size;
  function_size += local_count * sizeof(*bc.vardefs);
  closure_var_offset = function_size;
  function_size += bc.closure_var_count * sizeof(*bc.closure_var);
  byte_code_offset = function_size;
  if (!bc.read_only_bytecode) {
    function_size += bc.byte_code_len;
  }

  b = static_cast<LEPUSFunctionBytecode *>(lepus_mallocz(ctx, function_size));
  if (!b) return LEPUS_EXCEPTION;

  memcpy(b, &bc, offsetof(LEPUSFunctionBytecode, debug));
  // obj = LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b);

#ifdef DUMP_READ_OBJECT
  bc_read_trace(s, "name: ");
  print_atom(s->ctx, b->func_name);
  printf("\n");
#endif
  bc_read_trace(s, "args=%d vars=%d defargs=%d closures=%d cpool=%d\n",
                b->arg_count, b->var_count, b->defined_arg_count,
                b->closure_var_count, b->cpool_count);
  bc_read_trace(s, "stack=%d bclen=%d locals=%d\n", b->stack_size,
                b->byte_code_len, local_count);

  if (local_count != 0) {
    bc_read_trace(s, "vars {\n");
    b->vardefs = (LEPUSVarDef *)((uint8_t *)b + vardefs_offset);
    for (i = 0; i < local_count; i++) {
      LEPUSVarDef *vd = &b->vardefs[i];
      if (bc_get_atom(s, &vd->var_name)) goto fail;
      if (bc_get_leb128_int(s, &vd->scope_level)) goto fail;
      if (bc_get_leb128_int(s, &vd->scope_next)) goto fail;
      vd->scope_next--;
      if (bc_get_u8(s, &v8)) goto fail;
      idx = 0;
      vd->var_kind = bc_get_flags(v8, &idx, 4);
      vd->is_const = bc_get_flags(v8, &idx, 1);
      vd->is_lexical = bc_get_flags(v8, &idx, 1);
      vd->is_captured = bc_get_flags(v8, &idx, 1);
#ifdef DUMP_READ_OBJECT
      bc_read_trace(s, "name: ");
      print_atom(s->ctx, vd->var_name);
      printf("\n");
#endif
    }
    bc_read_trace(s, "}\n");
  }
  if (b->closure_var_count != 0) {
    bc_read_trace(s, "closure vars {\n");
    b->closure_var = (LEPUSClosureVar *)((uint8_t *)b + closure_var_offset);
    for (i = 0; i < b->closure_var_count; i++) {
      LEPUSClosureVar *cv = &b->closure_var[i];
      int var_idx;
      if (bc_get_atom(s, &cv->var_name)) goto fail;
      if (bc_get_leb128_int(s, &var_idx)) goto fail;
      cv->var_idx = var_idx;
      if (bc_get_u8(s, &v8)) goto fail;
      idx = 0;
      cv->is_local = bc_get_flags(v8, &idx, 1);
      cv->is_arg = bc_get_flags(v8, &idx, 1);
      cv->is_const = bc_get_flags(v8, &idx, 1);
      cv->is_lexical = bc_get_flags(v8, &idx, 1);
      cv->var_kind = bc_get_flags(v8, &idx, 4);
#ifdef DUMP_READ_OBJECT
      bc_read_trace(s, "name: ");
      print_atom(s->ctx, cv->var_name);
      printf("\n");
#endif
    }
    bc_read_trace(s, "}\n");
  }
  {
    bc_read_trace(s, "bytecode {\n");
    if (LEPUS_ReadFunctionBytecode(ctx, s, b, byte_code_offset,
                                   b->byte_code_len))
      goto fail;
    obj = LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b);
    // < primjs end>
    bc_read_trace(s, "}\n");
  }
  if (b->has_debug) {
    /* read optional debug information */
    bc_read_trace(s, "debug {\n");
    if (bc_get_atom(s, &b->debug.filename)) goto fail;
    if (ctx->debuginfo_outside == 2) {
      // use debug.filename to initialize debuginfo_outside
      const char *magic_num = LEPUS_AtomToCString(ctx, b->debug.filename);
      if (magic_num && strcmp(magic_num, "__lepusNG_function_id__") == 0) {
        ctx->debuginfo_outside = 1;
      } else {
        ctx->debuginfo_outside = 0;
      }
      LEPUS_FreeCString(ctx, magic_num);
    }

    if (bc_get_leb128_int(s, &b->debug.line_num)) goto fail;
    if (ctx->debuginfo_outside == 1) {
      LEPUS_FreeAtom(ctx, b->debug.filename);
      b->debug.filename = LEPUS_NewAtom(ctx, "file://lepus.js");
      b->function_id = b->debug.line_num;
    }

    if (bc_get_leb128_int(s, &b->debug.pc2line_len)) goto fail;
    if (b->debug.pc2line_len) {
      b->debug.pc2line_buf =
          static_cast<uint8_t *>(lepus_mallocz(ctx, b->debug.pc2line_len));
      if (!b->debug.pc2line_buf) goto fail;
      if (bc_get_buf(s, b->debug.pc2line_buf, b->debug.pc2line_len)) goto fail;
    }
#ifdef DUMP_READ_OBJECT
    bc_read_trace(s, "filename: ");
    print_atom(s->ctx, b->debug.filename);
    printf("\n");
#endif
    bc_read_trace(s, "}\n");
  }
  if (b->cpool_count != 0) {
    bc_read_trace(s, "cpool {\n");
    b->cpool = (LEPUSValue *)((uint8_t *)b + cpool_offset);
    for (i = 0; i < b->cpool_count; i++) {
      LEPUSValue val;
      val = LEPUS_ReadObjectRec(s);
      if (LEPUS_IsException(val)) goto fail;
      b->cpool[i] = val;
    }
    bc_read_trace(s, "}\n");
  }
  // <bytedance begin>
#ifdef ENABLE_QUICKJS_DEBUGGER
  b->func_level_state = NO_DEBUGGER;
  if (ctx->debugger_mode) {
    b->func_level_state = DEBUGGER_LOW_LEVEL_FUNCTION;
    list_add_tail(&b->link, &ctx->bytecode_list);
  }
#endif
  // <bytedance end>
  bc_read_trace(s, "}\n");

#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 1)
  if (!(b->lepus_mode & LEPUS_MODE_STRIP)) {
    lepus_dump_function_bytecode(ctx, b);
  }
#endif
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}
QJS_STATIC LEPUSValue LEPUS_ReadModule(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSModuleDef *m = NULL;
  LEPUSValue obj = LEPUS_UNDEFINED;
  LEPUSAtom module_name;
  int i;
  uint8_t v8;

  if (!s->allow_bytecode) goto fail;
  bc_read_trace(s, "%s {\n", bc_tag_str[tag]);
  if (bc_get_atom(s, &module_name)) goto fail;
#ifdef DUMP_READ_OBJECT
  bc_read_trace(s, "name: ");
  print_atom(s->ctx, module_name);
  printf("\n");
#endif
  m = lepus_new_module_def(ctx, module_name);
  if (!m) goto fail;
  obj = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_MODULE, m));
  if (bc_get_leb128_int(s, &m->req_module_entries_count)) goto fail;
  if (m->req_module_entries_count != 0) {
    m->req_module_entries_size = m->req_module_entries_count;
    m->req_module_entries = static_cast<LEPUSReqModuleEntry *>(lepus_mallocz(
        ctx, sizeof(m->req_module_entries[0]) * m->req_module_entries_size));
    if (!m->req_module_entries) goto fail;
    for (i = 0; i < m->req_module_entries_count; i++) {
      LEPUSReqModuleEntry *rme = &m->req_module_entries[i];
      if (bc_get_atom(s, &rme->module_name)) goto fail;
    }
  }

  if (bc_get_leb128_int(s, &m->export_entries_count)) goto fail;
  if (m->export_entries_count != 0) {
    m->export_entries_size = m->export_entries_count;
    m->export_entries = static_cast<LEPUSExportEntry *>(lepus_mallocz(
        ctx, sizeof(m->export_entries[0]) * m->export_entries_size));
    if (!m->export_entries) goto fail;
    for (i = 0; i < m->export_entries_count; i++) {
      LEPUSExportEntry *me = &m->export_entries[i];
      if (bc_get_u8(s, &v8)) goto fail;
      me->export_type = static_cast<LEPUSExportTypeEnum>(v8);
      if (me->export_type == LEPUS_EXPORT_TYPE_LOCAL) {
        if (bc_get_leb128_int(s, &me->u.local.var_idx)) goto fail;
      } else {
        if (bc_get_leb128_int(s, &me->u.req_module_idx)) goto fail;
        if (bc_get_atom(s, &me->local_name)) goto fail;
      }
      if (bc_get_atom(s, &me->export_name)) goto fail;
    }
  }

  if (bc_get_leb128_int(s, &m->star_export_entries_count)) goto fail;
  if (m->star_export_entries_count != 0) {
    m->star_export_entries_size = m->star_export_entries_count;
    m->star_export_entries = static_cast<LEPUSStarExportEntry *>(lepus_mallocz(
        ctx, sizeof(m->star_export_entries[0]) * m->star_export_entries_size));
    if (!m->star_export_entries) goto fail;
    for (i = 0; i < m->star_export_entries_count; i++) {
      LEPUSStarExportEntry *se = &m->star_export_entries[i];
      if (bc_get_leb128_int(s, &se->req_module_idx)) goto fail;
    }
  }

  if (bc_get_leb128_int(s, &m->import_entries_count)) goto fail;
  if (m->import_entries_count != 0) {
    m->import_entries_size = m->import_entries_count;
    m->import_entries = static_cast<LEPUSImportEntry *>(lepus_mallocz(
        ctx, sizeof(m->import_entries[0]) * m->import_entries_size));
    if (!m->import_entries) goto fail;
    for (i = 0; i < m->import_entries_count; i++) {
      LEPUSImportEntry *mi = &m->import_entries[i];
      if (bc_get_leb128_int(s, &mi->var_idx)) goto fail;
      if (bc_get_atom(s, &mi->import_name)) goto fail;
      if (bc_get_leb128_int(s, &mi->req_module_idx)) goto fail;
    }
  }

  m->func_obj = LEPUS_ReadObjectRec(s);
  if (LEPUS_IsException(m->func_obj)) goto fail;
  bc_read_trace(s, "}\n");
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  if (m) {
    lepus_free_module_def(ctx, m);
  }
  return LEPUS_EXCEPTION;
}
QJS_STATIC LEPUSValue LEPUS_ReadObjectTag(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj;
  uint32_t prop_count, i;
  LEPUSAtom atom;
  LEPUSValue val;
  int ret;

  bc_read_trace(s, "%s {\n", bc_tag_str[tag]);

  obj = LEPUS_NewObject(ctx);
  if (bc_get_leb128(s, &prop_count)) goto fail;
  for (i = 0; i < prop_count; i++) {
    if (bc_get_atom(s, &atom)) goto fail;
#ifdef DUMP_READ_OBJECT
    bc_read_trace(s, "propname: ");
    print_atom(s->ctx, atom);
    printf("\n");
#endif
    val = LEPUS_ReadObjectRec(s);
    if (LEPUS_IsException(val)) {
      LEPUS_FreeAtom(ctx, atom);
      goto fail;
    }
    ret = LEPUS_DefinePropertyValue(ctx, obj, atom, val, LEPUS_PROP_C_W_E);
    LEPUS_FreeAtom(ctx, atom);
    if (ret < 0) goto fail;
  }
  bc_read_trace(s, "}\n");
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue LEPUS_ReadArray(BCReaderState *s, int tag) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj;
  uint32_t len, i;
  LEPUSValue val;
  int ret, prop_flags;
  BOOL is_template;

  bc_read_trace(s, "%s {\n", bc_tag_str[tag]);

  obj = LEPUS_NewArray(ctx);
  is_template = (tag == BC_TAG_TEMPLATE_OBJECT);
  if (bc_get_leb128(s, &len)) goto fail;
  for (i = 0; i < len; i++) {
    val = LEPUS_ReadObjectRec(s);
    if (LEPUS_IsException(val)) goto fail;
    if (is_template)
      prop_flags = LEPUS_PROP_ENUMERABLE;
    else
      prop_flags = LEPUS_PROP_C_W_E;
    ret = LEPUS_DefinePropertyValueUint32(ctx, obj, i, val, prop_flags);
    if (ret < 0) goto fail;
  }
  if (is_template) {
    val = LEPUS_ReadObjectRec(s);
    if (LEPUS_IsException(val)) goto fail;
    if (!LEPUS_IsUndefined(val)) {
      ret = LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_raw, val, 0);
      if (ret < 0) goto fail;
    }
    seal_template_obj(ctx, obj);
    LEPUS_PreventExtensions(ctx, obj);
  }
  bc_read_trace(s, "}\n");
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}
#ifdef ENABLE_BUILTIN_SERIALIZE
QJS_STATIC LEPUSArrayBuffer *lepus_get_array_buffer(LEPUSContext *ctx,
                                                    LEPUSValueConst obj);
QJS_STATIC LEPUSValue lepus_typed_array_constructor(LEPUSContext *ctx,
                                                    LEPUSValueConst this_val,
                                                    int argc,
                                                    LEPUSValueConst *argv,
                                                    int classid);
QJS_STATIC LEPUSValue LEPUS_ReadTypedArray(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj = LEPUS_UNDEFINED, array_buffer = LEPUS_UNDEFINED;
  uint8_t array_tag;
  LEPUSValueConst args[3];
  uint32_t offset, len, idx;

  if (bc_get_u8(s, &array_tag)) return LEPUS_EXCEPTION;
  if (array_tag >= LEPUS_TYPED_ARRAY_COUNT)
    return LEPUS_ThrowTypeError(ctx, "invalid typed array");
  if (bc_get_leb128(s, &len)) return LEPUS_EXCEPTION;
  if (bc_get_leb128(s, &offset)) return LEPUS_EXCEPTION;
  array_buffer = LEPUS_ReadObjectRec(s);
  if (LEPUS_IsException(array_buffer)) return LEPUS_EXCEPTION;
  if (!lepus_get_array_buffer(ctx, array_buffer)) {
    LEPUS_FreeValue(ctx, array_buffer);
    return LEPUS_EXCEPTION;
  }
  args[0] = array_buffer;
  args[1] = LEPUS_NewInt64(ctx, offset);
  args[2] = LEPUS_NewInt64(ctx, len);
  obj = lepus_typed_array_constructor(ctx, LEPUS_UNDEFINED, 3, args,
                                      LEPUS_CLASS_UINT8C_ARRAY + array_tag);
  if (LEPUS_IsException(obj)) goto fail;
  LEPUS_FreeValue(ctx, array_buffer);
  return obj;
fail:
  LEPUS_FreeValue(ctx, array_buffer);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}
QJS_STATIC LEPUSValue lepus_map_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst new_target,
                                            int argc, LEPUSValueConst *argv,
                                            int magic);
QJS_STATIC LEPUSValue lepus_dataview_constructor(LEPUSContext *ctx,
                                                 LEPUSValueConst new_target,
                                                 int argc,
                                                 LEPUSValueConst *argv);
QJS_STATIC LEPUSValue LEPUS_ReadDataView(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj = LEPUS_UNDEFINED, array_buffer = LEPUS_UNDEFINED;
  LEPUSValueConst args[3];
  uint32_t offset, len, idx;

  if (bc_get_leb128(s, &len)) return LEPUS_EXCEPTION;
  if (bc_get_leb128(s, &offset)) return LEPUS_EXCEPTION;
  array_buffer = LEPUS_ReadObjectRec(s);
  if (LEPUS_IsException(array_buffer)) return LEPUS_EXCEPTION;
  if (!lepus_get_array_buffer(ctx, array_buffer)) {
    LEPUS_FreeValue(ctx, array_buffer);
    return LEPUS_EXCEPTION;
  }
  args[0] = array_buffer;
  args[1] = LEPUS_NewInt64(ctx, offset);
  args[2] = LEPUS_NewInt64(ctx, len);
  obj = lepus_dataview_constructor(ctx, LEPUS_UNDEFINED, 3, args);
  if (LEPUS_IsException(obj)) goto fail;
  LEPUS_FreeValue(ctx, array_buffer);
  return obj;
fail:
  LEPUS_FreeValue(ctx, array_buffer);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue LEPUS_ReadError(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj = LEPUS_UNDEFINED, msg = LEPUS_UNDEFINED,
             proto = LEPUS_UNDEFINED, stack = LEPUS_UNDEFINED;
  int8_t magic;
  if (bc_get_u8(s, (uint8_t *)&magic)) goto fail;
  msg = LEPUS_ToStringFree(ctx, LEPUS_ReadObjectRec(s));
  if (LEPUS_IsException(msg)) goto fail;
  stack = LEPUS_ToStringFree(ctx, LEPUS_ReadObjectRec(s));
  if (LEPUS_IsException(stack)) goto fail;
  if (magic < 0) {
    proto = ctx->class_proto[LEPUS_CLASS_ERROR];
  } else {
    proto = ctx->native_error_proto[magic];
  }
  obj = LEPUS_NewObjectProtoClass(ctx, proto, LEPUS_CLASS_ERROR);
  if (LEPUS_IsException(obj)) goto fail;
  LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_message, msg,
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_stack, stack,
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  if (magic == LEPUS_AGGREGATE_ERROR) {
    LEPUSValue error_list = LEPUS_ReadObjectRec(s);
    if (LEPUS_IsException(error_list)) {
      LEPUS_FreeValue(ctx, error_list);
      goto fail;
    }
    LEPUSAtom atom_errors = LEPUS_NewAtom(ctx, "errors");
    LEPUS_DefinePropertyValue(ctx, obj, atom_errors, error_list,
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  }
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, msg);
  LEPUS_FreeValue(ctx, stack);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue LEPUS_ReadRegExp(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue obj, pattern, bc;
  pattern = LEPUS_ReadObjectRec(s);
  bc = LEPUS_ReadObjectRec(s);
  obj = lepus_regexp_constructor_internal(ctx, LEPUS_UNDEFINED, pattern, bc);
  return obj;
}

static LEPUSValue LEPUS_ReadMap(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  uint8_t magic;
  bc_get_u8(s, &magic);
  const bool is_set = magic & MAGIC_SET;
  LEPUSValue obj = lepus_map_constructor(ctx, LEPUS_UNDEFINED, 0, NULL, magic);
  uint32_t count;
  bc_get_u32(s, &count);
  LEPUSValue adder =
      LEPUS_GetProperty(ctx, obj, is_set ? LEPUS_ATOM_add : LEPUS_ATOM_set);
  if (unlikely(LEPUS_IsException(adder))) goto fail;
  if (unlikely(!LEPUS_IsFunction(ctx, adder))) {
    LEPUS_ThrowTypeError(ctx, "set/add is not a function");
    goto fail;
  }
  for (uint32_t cnt = 0; cnt < count; ++cnt) {
    LEPUSValue key = LEPUS_ReadObjectRec(s);
    LEPUSValue value = LEPUS_UNDEFINED;
    LEPUSValue ret;
    if (!is_set) {
      LEPUSValue args[2];
      args[0] = key;
      value = LEPUS_ReadObjectRec(s);
      args[1] = value;

      ret = LEPUS_Call(ctx, adder, obj, 2, args);
      LEPUS_FreeValue(ctx, value);
    } else {
      ret = LEPUS_Call(ctx, adder, obj, 1, &key);
    }
    LEPUS_FreeValue(ctx, key);
    if (unlikely(LEPUS_IsException(ret))) goto fail;
    LEPUS_FreeValue(ctx, ret);
  }
  LEPUS_FreeValue(ctx, adder);
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, adder);
  return LEPUS_EXCEPTION;
}
QJS_STATIC LEPUSValue LEPUS_ReadArrayBuffer(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  uint32_t byte_length;
  LEPUSValue obj;

  if (bc_get_leb128(s, &byte_length)) return LEPUS_EXCEPTION;
  if (unlikely(s->buf_end - s->ptr < byte_length)) {
    bc_read_error_end(s);
    return LEPUS_EXCEPTION;
  }
  obj = LEPUS_NewArrayBufferCopy(ctx, s->ptr, byte_length);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  s->ptr += byte_length;
  return obj;
}

QJS_STATIC LEPUSValue LEPUS_ReadDate(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue val, obj = LEPUS_UNDEFINED;
  val = LEPUS_ReadObjectRec(s);
  if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
  if (!LEPUS_IsNumber(val)) {
    LEPUS_ThrowTypeError(ctx, "Number tag expected for date");
    goto fail;
  }
  obj = LEPUS_NewObjectProtoClass(ctx, ctx->class_proto[LEPUS_CLASS_DATE],
                                  LEPUS_CLASS_DATE);
  if (LEPUS_IsException(obj)) goto fail;
  LEPUS_SetObjectData(ctx, obj, val);
  return obj;
fail:
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue LEPUS_ReadObjectValue(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue val, obj = LEPUS_UNDEFINED;

  val = LEPUS_ReadObjectRec(s);
  if (LEPUS_IsException(val)) goto fail;
  obj = LEPUS_ToObject(ctx, val);
  if (LEPUS_IsException(obj)) goto fail;
  LEPUS_FreeValue(ctx, val);
  return obj;
fail:
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}
#endif  // ENABLE_BUILTIN_SERIALIZE

QJS_STATIC LEPUSValue LEPUS_ReadObjectRec(BCReaderState *s) {
  LEPUSContext *ctx = s->ctx;
  uint8_t tag;
  LEPUSValue obj = LEPUS_UNDEFINED;

  if (bc_get_u8(s, &tag)) return LEPUS_EXCEPTION;

  switch (tag) {
    case BC_TAG_NULL:
      bc_read_trace(s, "null\n");
      obj = LEPUS_NULL;
      break;
    case BC_TAG_UNDEFINED:
      bc_read_trace(s, "undefined\n");
      obj = LEPUS_UNDEFINED;
      break;
    case BC_TAG_BOOL_FALSE:
    case BC_TAG_BOOL_TRUE:
      bc_read_trace(s, "%s\n", bc_tag_str[tag]);
      obj = LEPUS_NewBool(ctx, tag - BC_TAG_BOOL_FALSE);
      break;
    case BC_TAG_INT32: {
      int32_t val;
      if (bc_get_sleb128(s, &val)) return LEPUS_EXCEPTION;
      bc_read_trace(s, "int32 %d\n", val);
      obj = LEPUS_NewInt32(ctx, val);
    } break;
    case BC_TAG_FLOAT64: {
      LEPUSFloat64Union u;
      if (bc_get_u64(s, &u.u64)) return LEPUS_EXCEPTION;
      bc_read_trace(s, "float64 %g\n", u.d);
      obj = __JS_NewFloat64(ctx, u.d);
    } break;
    case BC_TAG_STRING: {
      LEPUSString *p;
      p = LEPUS_ReadString(s);
      if (!p) return LEPUS_EXCEPTION;
      obj = LEPUS_MKPTR(LEPUS_TAG_STRING, p);
    } break;
    case BC_TAG_FUNCTION_BYTECODE: {
      obj = LEPUS_ReadFunction(s);
    } break;
    case BC_TAG_MODULE: {
      obj = LEPUS_ReadModule(s);
    } break;
    case BC_TAG_OBJECT: {
      obj = LEPUS_ReadObjectTag(s);
    } break;
    case BC_TAG_ARRAY:
    case BC_TAG_TEMPLATE_OBJECT: {
      obj = LEPUS_ReadArray(s, tag);
    } break;
#ifdef ENABLE_BUILTIN_SERIALIZE
    case BC_TAG_TYPED_ARRAY:
      obj = LEPUS_ReadTypedArray(s);
      break;
    case BC_TAG_ARRAY_BUFFER:
      obj = LEPUS_ReadArrayBuffer(s);
      break;
    case BC_TAG_DATE:
      obj = LEPUS_ReadDate(s);
      break;
    case BC_TAG_OBJECT_VALUE:
      obj = LEPUS_ReadObjectValue(s);
      break;
    case BC_TAG_DATAVIEW:
      obj = LEPUS_ReadDataView(s);
      break;
    case BC_TAG_ERROR:
      obj = LEPUS_ReadError(s);
      break;
    case BC_TAG_REGEXP:
      obj = LEPUS_ReadRegExp(s);
      break;
    case BC_TAG_MAP:
      obj = LEPUS_ReadMap(s);
      break;
#endif
#ifdef CONFIG_BIGNUM
    case BC_TAG_BIG_INT:
    case BC_TAG_BIG_FLOAT: {
      uint8_t sign, v8;
      int32_t e;
      uint32_t len;
      limb_t l, i, n;
      LEPUSBigFloat *p;
      bf_t *a;

      bc_read_trace(s, "%s {\n", bc_tag_str[tag]);

      if (bc_get_leb128(s, &len)) goto fail;
      sign = len & 1;
      len >>= 1;
      p = lepus_new_bf(s->ctx);
      if (!p) goto fail;
      if (tag == BC_TAG_BIG_INT)
        obj = LEPUS_MKPTR(LEPUS_TAG_BIG_INT, p);
      else
        obj = LEPUS_MKPTR(LEPUS_TAG_BIG_FLOAT, p);
      l = (len + sizeof(limb_t) - 1) / sizeof(limb_t);
      a = &p->num;
      bf_resize(a, l);
      a->sign = sign;
      if (len == 0) {
        if (tag == BC_TAG_BIG_INT) {
          a->expn = BF_EXP_ZERO;
        } else {
          if (bc_get_u8(s, &v8)) goto fail;
          switch (v8) {
            case 0:
              a->expn = BF_EXP_ZERO;
              break;
            case 1:
              a->expn = BF_EXP_INF;
              break;
            default:
            case 2:
              a->expn = BF_EXP_NAN;
              break;
          }
        }
      } else {
        n = len & (sizeof(limb_t) - 1);
        if (n != 0) {
          limb_t v;
          v = 0;
          for (i = 0; i < n; i++) {
            if (bc_get_u8(s, &v8)) goto fail;
            v |= (limb_t)v8 << ((sizeof(limb_t) - n + i) * 8);
          }
          a->tab[0] = v;
          i = 1;
        } else {
          i = 0;
        }
        for (; i < l; i++) {
          limb_t v;
#if LIMB_BITS == 32
          if (bc_get_u32(s, &v)) goto fail;
#ifdef WORDS_BIGENDIAN
          v = bswap32(v);
#endif
#else
          if (bc_get_u64(s, &v)) goto fail;
#ifdef WORDS_BIGENDIAN
          v = bswap64(v);
#endif
#endif
          a->tab[i] = v;
        }
        if (bc_get_sleb128(s, &e)) goto fail;
        a->expn = e;
      }
      bc_read_trace(s, "}\n");
    } break;
#endif
    default:
#ifdef CONFIG_BIGNUM
    invalid_tag:
#endif
      return LEPUS_ThrowSyntaxError(ctx, "invalid tag (tag=%d pos=%u)", tag,
                                    (unsigned int)(s->ptr - s->buf_start));
  }
  return obj;
#ifdef CONFIG_BIGNUM
fail:
#endif
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC int LEPUS_ReadObjectAtoms(BCReaderState *s) {
  uint8_t v8;
  LEPUSString *p;
  int i;
  LEPUSAtom atom;

  if (bc_get_u8(s, &v8)) return -1;
  /* XXX: could support byte swapped input */
  if (v8 != BC_VERSION) {
    LEPUS_ThrowSyntaxError(s->ctx, "invalid version (%d expected=%d)", v8,
                           BC_VERSION);
    return -1;
  }
  if (bc_get_leb128(s, &s->idx_to_atom_count)) return -1;

  bc_read_trace(s, "%d atom indexes {\n", s->idx_to_atom_count);

  if (s->idx_to_atom_count != 0) {
    s->idx_to_atom = static_cast<LEPUSAtom *>(lepus_mallocz(
        s->ctx, s->idx_to_atom_count * sizeof(s->idx_to_atom[0])));
    if (!s->idx_to_atom) return s->error_state = -1;
  }
  for (i = 0; i < s->idx_to_atom_count; i++) {
    p = LEPUS_ReadString(s);
    if (!p) return -1;
    atom = LEPUS_NewAtomStr(s->ctx, p);
    if (atom == LEPUS_ATOM_NULL) return s->error_state = -1;
    s->idx_to_atom[i] = atom;
    if (s->is_rom_data && (atom != (i + s->first_atom)))
      s->is_rom_data = FALSE; /* atoms must be relocated */
  }
  bc_read_trace(s, "}\n");
  return 0;
}

QJS_STATIC void bc_reader_free(BCReaderState *s) {
  int i;
  if (s->idx_to_atom) {
    for (i = 0; i < s->idx_to_atom_count; i++) {
      LEPUS_FreeAtom(s->ctx, s->idx_to_atom[i]);
    }
    lepus_free(s->ctx, s->idx_to_atom);
  }
}

LEPUSValue LEPUS_ReadObject(LEPUSContext *ctx, const uint8_t *buf,
                            size_t buf_len, int flags) {
  BCReaderState ss, *s = &ss;
  LEPUSValue obj;

  ctx->binary_object_count += 1;
  ctx->binary_object_size += buf_len;

  memset(s, 0, sizeof(*s));
  s->ctx = ctx;
  s->buf_start = buf;
  s->buf_end = buf + buf_len;
  s->ptr = buf;
  s->allow_bytecode = ((flags & LEPUS_READ_OBJ_BYTECODE) != 0);
  s->is_rom_data = ((flags & LEPUS_READ_OBJ_ROM_DATA) != 0);
  if (s->allow_bytecode)
    s->first_atom = LEPUS_ATOM_END;
  else
    s->first_atom = 1;
  if (LEPUS_ReadObjectAtoms(s)) {
    obj = LEPUS_EXCEPTION;
  } else {
    obj = LEPUS_ReadObjectRec(s);
  }
  bc_reader_free(s);
  return obj;
}

/*******************************************************************/
/* runtime functions & objects */

QJS_STATIC LEPUSValue lepus_string_constructor(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv);
QJS_STATIC LEPUSValue lepus_boolean_constructor(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc,
                                                LEPUSValueConst *argv);
QJS_STATIC LEPUSValue lepus_number_constructor(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv);

QJS_STATIC int check_function(LEPUSContext *ctx, LEPUSValueConst obj) {
  if (likely(LEPUS_IsFunction(ctx, obj))) return 0;
  LEPUS_ThrowTypeError(ctx, "not a function");
  return -1;
}

QJS_STATIC int check_exception_free(LEPUSContext *ctx, LEPUSValue obj) {
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_IsException(obj);
}

QJS_STATIC LEPUSAtom find_atom(LEPUSContext *ctx, const char *name) {
  LEPUSAtom atom;
  int len;

  if (*name == '[') {
    name++;
    len = strlen(name) - 1;
    /* We assume 8 bit non null strings, which is the case for these
       symbols */
    for (atom = LEPUS_ATOM_Symbol_toPrimitive; atom < LEPUS_ATOM_END; atom++) {
      LEPUSAtomStruct *p = ctx->rt->atom_array[atom];
      LEPUSString *str = p;
      if (str->len == len && !memcmp(str->u.str8, name, len))
        return LEPUS_DupAtom(ctx, atom);
    }
    abort();
  } else {
    atom = LEPUS_NewAtom(ctx, name);
  }
  return atom;
}

QJS_STATIC LEPUSValue LEPUS_InstantiateFunctionListItem2(LEPUSContext *ctx,
                                                         LEPUSObject *p,
                                                         LEPUSAtom atom,
                                                         void *opaque) {
  const LEPUSCFunctionListEntry *e =
      static_cast<LEPUSCFunctionListEntry *>(opaque);
  LEPUSValue val;

  switch (e->def_type) {
    case LEPUS_DEF_CFUNC:
      val = LEPUS_NewCFunction2(
          ctx, e->u.func.cfunc.generic, e->name, e->u.func.length,
          static_cast<LEPUSCFunctionEnum>(e->u.func.cproto), e->magic);
      break;
    case LEPUS_DEF_PROP_STRING:
      val = LEPUS_NewAtomString(ctx, e->u.str);
      break;
    case LEPUS_DEF_OBJECT:
      val = LEPUS_NewObject(ctx);
      LEPUS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab,
                                    e->u.prop_list.len);
      break;
    default:
      abort();
  }
  return val;
}

QJS_STATIC int LEPUS_InstantiateFunctionListItem(
    LEPUSContext *ctx, LEPUSValueConst obj, LEPUSAtom atom,
    const LEPUSCFunctionListEntry *e) {
  LEPUSValue val;
  int prop_flags = e->prop_flags;

  switch (e->def_type) {
    case LEPUS_DEF_ALIAS: {
      LEPUSAtom atom1 = find_atom(ctx, e->u.alias.name);
      switch (e->u.alias.base) {
        case -1:
          val = LEPUS_GetProperty(ctx, obj, atom1);
          break;
        case 0:
          val = LEPUS_GetProperty(ctx, ctx->global_obj, atom1);
          break;
        case 1:
          val = LEPUS_GetProperty(ctx, ctx->class_proto[LEPUS_CLASS_ARRAY],
                                  atom1);
          break;
        default:
          abort();
      }
      LEPUS_FreeAtom(ctx, atom1);
      if (atom == LEPUS_ATOM_Symbol_toPrimitive) {
        /* Symbol.toPrimitive functions are not writable */
        prop_flags = LEPUS_PROP_CONFIGURABLE;
      } else if (atom == LEPUS_ATOM_Symbol_hasInstance) {
        /* Function.prototype[Symbol.hasInstance] is not writable nor
         * configurable */
        prop_flags = 0;
      }
    } break;
    case LEPUS_DEF_CFUNC:
      if (atom == LEPUS_ATOM_Symbol_toPrimitive) {
        /* Symbol.toPrimitive functions are not writable */
        prop_flags = LEPUS_PROP_CONFIGURABLE;
      } else if (atom == LEPUS_ATOM_Symbol_hasInstance) {
        /* Function.prototype[Symbol.hasInstance] is not writable nor
         * configurable */
        prop_flags = 0;
      }
#ifdef ENABLE_PRIMJS_IC
      val = LEPUS_NewCFunction2(
          ctx, e->u.func.cfunc.generic, e->name, e->u.func.length,
          static_cast<LEPUSCFunctionEnum>(e->u.func.cproto), e->magic);
      break;
#else
      LEPUS_DefineAutoInitProperty(ctx, obj, atom,
                                   LEPUS_InstantiateFunctionListItem2,
                                   (void *)e, prop_flags);
      return 0;
#endif
    case LEPUS_DEF_CGETSET:
    case LEPUS_DEF_CGETSET_MAGIC: {
      LEPUSValue getter, setter;
      char buf[64];

      getter = LEPUS_UNDEFINED;
      if (e->u.getset.get.generic) {
        snprintf(buf, sizeof(buf), "get %s", e->name);
        getter = LEPUS_NewCFunction2(ctx, e->u.getset.get.generic, buf, 0,
                                     e->def_type == LEPUS_DEF_CGETSET_MAGIC
                                         ? LEPUS_CFUNC_getter_magic
                                         : LEPUS_CFUNC_getter,
                                     e->magic);
      }
      setter = LEPUS_UNDEFINED;
      if (e->u.getset.set.generic) {
        snprintf(buf, sizeof(buf), "set %s", e->name);
        setter = LEPUS_NewCFunction2(ctx, e->u.getset.set.generic, buf, 1,
                                     e->def_type == LEPUS_DEF_CGETSET_MAGIC
                                         ? LEPUS_CFUNC_setter_magic
                                         : LEPUS_CFUNC_setter,
                                     e->magic);
      }
      LEPUS_DefinePropertyGetSet(ctx, obj, atom, getter, setter, prop_flags);
      return 0;
    } break;
    case LEPUS_DEF_PROP_INT32:
      val = LEPUS_NewInt32(ctx, e->u.i32);
      break;
    case LEPUS_DEF_PROP_INT64:
      val = LEPUS_NewInt64(ctx, e->u.i64);
      break;
    case LEPUS_DEF_PROP_DOUBLE:
      val = __JS_NewFloat64(ctx, e->u.f64);
      break;
    case LEPUS_DEF_PROP_UNDEFINED:
      val = LEPUS_UNDEFINED;
      break;
    case LEPUS_DEF_PROP_STRING:
#ifdef ENABLE_PRIMJS_IC
      val = LEPUS_NewAtomString(ctx, e->u.str);
      break;
#else
      LEPUS_DefineAutoInitProperty(ctx, obj, atom,
                                   LEPUS_InstantiateFunctionListItem2,
                                   (void *)e, prop_flags);
      return 0;
#endif
    case LEPUS_DEF_OBJECT:
#ifdef ENABLE_PRIMJS_IC
      val = LEPUS_NewObject(ctx);
      LEPUS_SetPropertyFunctionList(ctx, val, e->u.prop_list.tab,
                                    e->u.prop_list.len);
      break;
#else
      LEPUS_DefineAutoInitProperty(ctx, obj, atom,
                                   LEPUS_InstantiateFunctionListItem2,
                                   (void *)e, prop_flags);
      return 0;
#endif
    default:
      abort();
  }
  LEPUS_DefinePropertyValue(ctx, obj, atom, val, prop_flags);
  return 0;
}

void LEPUS_SetPropertyFunctionList(LEPUSContext *ctx, LEPUSValueConst obj,
                                   const LEPUSCFunctionListEntry *tab,
                                   int len) {
  int i, prop_flags;

  for (i = 0; i < len; i++) {
    const LEPUSCFunctionListEntry *e = &tab[i];
    LEPUSAtom atom = find_atom(ctx, e->name);
    LEPUS_InstantiateFunctionListItem(ctx, obj, atom, e);
    LEPUS_FreeAtom(ctx, atom);
  }
}

int LEPUS_AddModuleExportList(LEPUSContext *ctx, LEPUSModuleDef *m,
                              const LEPUSCFunctionListEntry *tab, int len) {
#ifndef NO_QUICKJS_COMPILER
  int i;
  for (i = 0; i < len; i++) {
    if (LEPUS_AddModuleExport(ctx, m, tab[i].name)) return -1;
  }
#endif
  return 0;
}

int LEPUS_SetModuleExportList(LEPUSContext *ctx, LEPUSModuleDef *m,
                              const LEPUSCFunctionListEntry *tab, int len) {
#ifndef NO_QUICKJS_COMPILER
  int i;
  LEPUSValue val;

  for (i = 0; i < len; i++) {
    const LEPUSCFunctionListEntry *e = &tab[i];
    switch (e->def_type) {
      case LEPUS_DEF_CFUNC:
        val = LEPUS_NewCFunction2(
            ctx, e->u.func.cfunc.generic, e->name, e->u.func.length,
            static_cast<LEPUSCFunctionEnum>(e->u.func.cproto), e->magic);
        break;
      case LEPUS_DEF_PROP_STRING:
        val = LEPUS_NewString(ctx, e->u.str);
        break;
      case LEPUS_DEF_PROP_INT32:
        val = LEPUS_NewInt32(ctx, e->u.i32);
        break;
      case LEPUS_DEF_PROP_INT64:
        val = LEPUS_NewInt64(ctx, e->u.i64);
        break;
      case LEPUS_DEF_PROP_DOUBLE:
        val = __JS_NewFloat64(ctx, e->u.f64);
        break;
      default:
        abort();
    }
    if (LEPUS_SetModuleExport(ctx, m, e->name, val)) return -1;
  }
  return 0;
#else
  return 0;
#endif
}

/* Note: 'func_obj' is not necessarily a constructor */
QJS_STATIC void LEPUS_SetConstructor2(LEPUSContext *ctx,
                                      LEPUSValueConst func_obj,
                                      LEPUSValueConst proto, int proto_flags,
                                      int ctor_flags) {
  LEPUS_DefinePropertyValue(ctx, func_obj, LEPUS_ATOM_prototype,
                            LEPUS_DupValue(ctx, proto), proto_flags);
  LEPUS_DefinePropertyValue(ctx, proto, LEPUS_ATOM_constructor,
                            LEPUS_DupValue(ctx, func_obj), ctor_flags);
  set_cycle_flag(ctx, func_obj);
  set_cycle_flag(ctx, proto);
}

QJS_STATIC void LEPUS_SetConstructor(LEPUSContext *ctx,
                                     LEPUSValueConst func_obj,
                                     LEPUSValueConst proto) {
  LEPUS_SetConstructor2(ctx, func_obj, proto, 0,
                        LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
}

QJS_STATIC void LEPUS_NewGlobalCConstructor2(LEPUSContext *ctx,
                                             LEPUSValue func_obj,
                                             const char *name,
                                             LEPUSValueConst proto) {
  LEPUS_DefinePropertyValueStr(ctx, ctx->global_obj, name,
                               LEPUS_DupValue(ctx, func_obj),
                               LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  LEPUS_SetConstructor(ctx, func_obj, proto);
  LEPUS_FreeValue(ctx, func_obj);
}

QJS_STATIC LEPUSValueConst LEPUS_NewGlobalCConstructor(LEPUSContext *ctx,
                                                       const char *name,
                                                       LEPUSCFunction *func,
                                                       int length,
                                                       LEPUSValueConst proto) {
  LEPUSValue func_obj;
  func_obj = LEPUS_NewCFunction2(ctx, func, name, length,
                                 LEPUS_CFUNC_constructor_or_func, 0);
  LEPUS_NewGlobalCConstructor2(ctx, func_obj, name, proto);
  return func_obj;
}

QJS_STATIC LEPUSValueConst LEPUS_NewGlobalCConstructorOnly(
    LEPUSContext *ctx, const char *name, LEPUSCFunction *func, int length,
    LEPUSValueConst proto) {
  LEPUSValue func_obj;
  func_obj =
      LEPUS_NewCFunction2(ctx, func, name, length, LEPUS_CFUNC_constructor, 0);
  LEPUS_NewGlobalCConstructor2(ctx, func_obj, name, proto);
  return func_obj;
}

QJS_STATIC LEPUSValue lepus_global_eval(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  return LEPUS_EvalObject(ctx, ctx->global_obj, argv[0],
                          LEPUS_EVAL_TYPE_INDIRECT, -1);
}

QJS_STATIC LEPUSValue lepus_global_isNaN(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  double d;

  /* XXX: does this work for bigfloat? */
  if (unlikely(LEPUS_ToFloat64(ctx, &d, argv[0]))) return LEPUS_EXCEPTION;
  return LEPUS_NewBool(ctx, isnan(d));
}

#ifdef CONFIG_BIGNUM
static BOOL lepus_number_is_finite(LEPUSContext *ctx, LEPUSValueConst val) {
  BOOL res;
  int32_t tag;

  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_FLOAT64:
      res = isfinite(LEPUS_VALUE_GET_FLOAT64(val));
      break;
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      res = bf_is_finite(&p->num);
    } break;
    default:
      res = TRUE;
      break;
  }
  return res;
}
#endif

QJS_STATIC LEPUSValue lepus_global_isFinite(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  BOOL res;
#ifdef CONFIG_BIGNUM
  LEPUSValue val;

  val = LEPUS_ToNumber(ctx, argv[0]);
  if (LEPUS_IsException(val)) return val;
  res = lepus_number_is_finite(ctx, val);
  LEPUS_FreeValue(ctx, val);
#else
  double d;
  if (unlikely(LEPUS_ToFloat64(ctx, &d, argv[0]))) return LEPUS_EXCEPTION;
  res = isfinite(d);
#endif
  return LEPUS_NewBool(ctx, res);
}

/* Object class */

LEPUSValue LEPUS_ToObject(LEPUSContext *ctx, LEPUSValueConst val) {
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(val);
  LEPUSValue obj;

  switch (tag) {
    default:
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
      return LEPUS_ThrowTypeError(ctx, "cannot convert to object");
    case LEPUS_TAG_OBJECT:
    case LEPUS_TAG_EXCEPTION:
      return LEPUS_DupValue(ctx, val);
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_INT:
      if (is_bignum_mode(ctx))
        obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_BIG_INT);
      else
        obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_NUMBER);
      goto set_value;
    case LEPUS_TAG_BIG_INT:
      obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_BIG_INT);
      goto set_value;
    case LEPUS_TAG_FLOAT64:
      obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_NUMBER);
      goto set_value;
    case LEPUS_TAG_BIG_FLOAT:
      obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_BIG_FLOAT);
      goto set_value;
#else
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64:
      obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_NUMBER);
      goto set_value;
#endif
    case LEPUS_TAG_STRING:
      /* XXX: should call the string constructor */
      {
        LEPUSString *p1 = LEPUS_VALUE_GET_STRING(val);
        obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_STRING);
        LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_length,
                                  LEPUS_NewInt32(ctx, p1->len), 0);
      }
      goto set_value;
    case LEPUS_TAG_BOOL:
      obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_BOOLEAN);
      goto set_value;
    case LEPUS_TAG_SYMBOL:
      obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_SYMBOL);
    set_value:
      if (!LEPUS_IsException(obj))
        LEPUS_SetObjectData(ctx, obj, LEPUS_DupValue(ctx, val));
      return obj;

// ByteDance begin
#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF:
      obj = ctx->rt->lepus_callbacks_.convert_to_object(ctx, val);
      return LEPUS_DupValue(ctx, obj);
#endif
      // ByteDance end
  }
}

QJS_STATIC LEPUSValue LEPUS_ToObjectFree(LEPUSContext *ctx, LEPUSValue val) {
  LEPUSValue obj = LEPUS_ToObject(ctx, val);
  LEPUS_FreeValue(ctx, val);
  return obj;
}

QJS_STATIC int lepus_obj_to_desc(LEPUSContext *ctx, LEPUSPropertyDescriptor *d,
                                 LEPUSValueConst desc) {
  LEPUSValue val, getter, setter;
  int flags;

  if (!LEPUS_IsObject(desc)) {
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  flags = 0;
  val = LEPUS_UNDEFINED;
  getter = LEPUS_UNDEFINED;
  setter = LEPUS_UNDEFINED;
  if (LEPUS_HasProperty(ctx, desc, LEPUS_ATOM_configurable)) {
    LEPUSValue prop = LEPUS_GetProperty(ctx, desc, LEPUS_ATOM_configurable);
    if (LEPUS_IsException(prop)) goto fail;
    flags |= LEPUS_PROP_HAS_CONFIGURABLE;
    if (LEPUS_ToBoolFree(ctx, prop)) flags |= LEPUS_PROP_CONFIGURABLE;
  }
  if (LEPUS_HasProperty(ctx, desc, LEPUS_ATOM_writable)) {
    LEPUSValue prop = LEPUS_GetProperty(ctx, desc, LEPUS_ATOM_writable);
    if (LEPUS_IsException(prop)) goto fail;
    flags |= LEPUS_PROP_HAS_WRITABLE;
    if (LEPUS_ToBoolFree(ctx, prop)) flags |= LEPUS_PROP_WRITABLE;
  }
  if (LEPUS_HasProperty(ctx, desc, LEPUS_ATOM_enumerable)) {
    LEPUSValue prop = LEPUS_GetProperty(ctx, desc, LEPUS_ATOM_enumerable);
    if (LEPUS_IsException(prop)) goto fail;
    flags |= LEPUS_PROP_HAS_ENUMERABLE;
    if (LEPUS_ToBoolFree(ctx, prop)) flags |= LEPUS_PROP_ENUMERABLE;
  }
  if (LEPUS_HasProperty(ctx, desc, LEPUS_ATOM_value)) {
    flags |= LEPUS_PROP_HAS_VALUE;
    val = LEPUS_GetProperty(ctx, desc, LEPUS_ATOM_value);
    if (LEPUS_IsException(val)) goto fail;
  }
  if (LEPUS_HasProperty(ctx, desc, LEPUS_ATOM_get)) {
    flags |= LEPUS_PROP_HAS_GET;
    getter = LEPUS_GetProperty(ctx, desc, LEPUS_ATOM_get);
    if (LEPUS_IsException(getter) ||
        !(LEPUS_IsUndefined(getter) || LEPUS_IsFunction(ctx, getter))) {
      LEPUS_ThrowTypeError(ctx, "invalid getter");
      goto fail;
    }
  }
  if (LEPUS_HasProperty(ctx, desc, LEPUS_ATOM_set)) {
    flags |= LEPUS_PROP_HAS_SET;
    setter = LEPUS_GetProperty(ctx, desc, LEPUS_ATOM_set);
    if (LEPUS_IsException(setter) ||
        !(LEPUS_IsUndefined(setter) || LEPUS_IsFunction(ctx, setter))) {
      LEPUS_ThrowTypeError(ctx, "invalid setter");
      goto fail;
    }
  }
  if ((flags & (LEPUS_PROP_HAS_SET | LEPUS_PROP_HAS_GET)) &&
      (flags & (LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE))) {
    LEPUS_ThrowTypeError(ctx,
                         "cannot have setter/getter and value or writable");
    goto fail;
  }
  d->flags = flags;
  d->value = val;
  d->getter = getter;
  d->setter = setter;
  return 0;
fail:
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, getter);
  LEPUS_FreeValue(ctx, setter);
  return -1;
}

QJS_STATIC __exception int LEPUS_DefinePropertyDesc(LEPUSContext *ctx,
                                                    LEPUSValueConst obj,
                                                    LEPUSAtom prop,
                                                    LEPUSValueConst desc,
                                                    int flags) {
  LEPUSPropertyDescriptor d;
  int ret;

  if (lepus_obj_to_desc(ctx, &d, desc) < 0) return -1;

  ret = LEPUS_DefineProperty(ctx, obj, prop, d.value, d.getter, d.setter,
                             d.flags | flags);
  lepus_free_desc(ctx, &d);
  return ret;
}

QJS_STATIC __exception int LEPUS_ObjectDefineProperties(
    LEPUSContext *ctx, LEPUSValueConst obj, LEPUSValueConst properties) {
  LEPUSValue props, desc;
  LEPUSObject *p;
  LEPUSPropertyEnum *atoms;
  uint32_t len, i;
  int ret = -1;

  if (!LEPUS_IsObject(obj)) {
    LEPUS_ThrowTypeErrorNotAnObject(ctx);
    return -1;
  }
  desc = LEPUS_UNDEFINED;
  props = LEPUS_ToObject(ctx, properties);
  if (LEPUS_IsException(props)) return -1;
  p = LEPUS_VALUE_GET_OBJ(props);
  if (LEPUS_GetOwnPropertyNamesInternal(
          ctx, &atoms, &len, p,
          LEPUS_GPN_ENUM_ONLY | LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK) <
      0)
    goto exception;
  for (i = 0; i < len; i++) {
    LEPUS_FreeValue(ctx, desc);
    desc = LEPUS_GetProperty(ctx, props, atoms[i].atom);
    if (LEPUS_IsException(desc)) goto exception;
    if (LEPUS_DefinePropertyDesc(ctx, obj, atoms[i].atom, desc,
                                 LEPUS_PROP_THROW) < 0)
      goto exception;
  }
  ret = 0;

exception:
  lepus_free_prop_enum(ctx, atoms, len);
  LEPUS_FreeValue(ctx, props);
  LEPUS_FreeValue(ctx, desc);
  return ret;
}

QJS_STATIC LEPUSValue lepus_object_constructor(LEPUSContext *ctx,
                                               LEPUSValueConst new_target,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue ret;
  if (!LEPUS_IsUndefined(new_target) &&
      LEPUS_VALUE_GET_OBJ(new_target) !=
          LEPUS_VALUE_GET_OBJ(LEPUS_GetActiveFunction(ctx))) {
    ret = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_OBJECT);
  } else {
    int64_t tag = LEPUS_VALUE_GET_NORM_TAG(argv[0]);
    switch (tag) {
      case LEPUS_TAG_NULL:
      case LEPUS_TAG_UNDEFINED:
        ret = LEPUS_NewObject(ctx);
        break;
      default:
        ret = LEPUS_ToObject(ctx, argv[0]);
        break;
    }
  }
  return ret;
}

QJS_STATIC LEPUSValue lepus_object_create(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValueConst proto, props;
  LEPUSValue obj;

  proto = argv[0];
  if (!LEPUS_IsObject(proto) && !LEPUS_IsNull(proto))
    return LEPUS_ThrowTypeError(ctx, "not a prototype");
  obj = LEPUS_NewObjectProto(ctx, proto);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  props = argv[1];
  if (!LEPUS_IsUndefined(props)) {
    if (LEPUS_ObjectDefineProperties(ctx, obj, props)) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
  }
  return obj;
}

QJS_STATIC LEPUSValue lepus_object_getPrototypeOf(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv,
                                                  int magic) {
  LEPUSValueConst val;

  val = argv[0];
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) {
    /* ES6 feature non compatible with ES5.1: primitive types are
       accepted */
    if (magic || LEPUS_VALUE_IS_NULL(val) || LEPUS_VALUE_IS_UNDEFINED(val))
      return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  }
  return LEPUS_DupValue(ctx, LEPUS_GetPrototype(ctx, val));
}

QJS_STATIC LEPUSValue lepus_object_setPrototypeOf(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv) {
  LEPUSValueConst obj;
  obj = argv[0];
  if (LEPUS_SetPrototypeInternal(ctx, obj, argv[1], TRUE) < 0)
    return LEPUS_EXCEPTION;
  return LEPUS_DupValue(ctx, obj);
}

/* magic = 1 if called as Reflect.defineProperty */
QJS_STATIC LEPUSValue lepus_object_defineProperty(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv,
                                                  int magic) {
  LEPUSValueConst obj, prop, desc;
  int ret, flags;
  LEPUSAtom atom;

  obj = LEPUSRef2Value(ctx, argv[0]);
  prop = argv[1];
  desc = argv[2];

  if (LEPUS_VALUE_IS_NOT_OBJECT(obj))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  atom = lepus_value_to_atom(ctx, prop);
  if (unlikely(atom == LEPUS_ATOM_NULL)) return LEPUS_EXCEPTION;
  flags = 0;
  if (!magic) flags |= LEPUS_PROP_THROW;
  ret = LEPUS_DefinePropertyDesc(ctx, obj, atom, desc, flags);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0) {
    return LEPUS_EXCEPTION;
  } else if (magic) {
    return LEPUS_NewBool(ctx, ret);
  } else {
    return LEPUS_DupValue(ctx, obj);
  }
}

QJS_STATIC LEPUSValue lepus_object_defineProperties(LEPUSContext *ctx,
                                                    LEPUSValueConst this_val,
                                                    int argc,
                                                    LEPUSValueConst *argv) {
  // defineProperties(obj, properties)
  LEPUSValueConst obj = LEPUSRef2Value(ctx, argv[0]);

  if (LEPUS_ObjectDefineProperties(ctx, obj, argv[1]))
    return LEPUS_EXCEPTION;
  else
    return LEPUS_DupValue(ctx, obj);
}

/* magic = 1 if called as __defineSetter__ */
QJS_STATIC LEPUSValue lepus_object___defineGetter__(LEPUSContext *ctx,
                                                    LEPUSValueConst this_val,
                                                    int argc,
                                                    LEPUSValueConst *argv,
                                                    int magic) {
  LEPUSValue obj;
  LEPUSValueConst prop, value, get, set;
  int ret, flags;
  LEPUSAtom atom;

  prop = argv[0];
  value = argv[1];

  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;

  if (check_function(ctx, value)) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  atom = lepus_value_to_atom(ctx, prop);
  if (unlikely(atom == LEPUS_ATOM_NULL)) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  flags = LEPUS_PROP_THROW | LEPUS_PROP_HAS_ENUMERABLE | LEPUS_PROP_ENUMERABLE |
          LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE;
  if (magic) {
    get = LEPUS_UNDEFINED;
    set = value;
    flags |= LEPUS_PROP_HAS_SET;
  } else {
    get = value;
    set = LEPUS_UNDEFINED;
    flags |= LEPUS_PROP_HAS_GET;
  }
  ret = LEPUS_DefineProperty(ctx, obj, atom, LEPUS_UNDEFINED, get, set, flags);
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0) {
    return LEPUS_EXCEPTION;
  } else {
    return LEPUS_UNDEFINED;
  }
}

LEPUSValue lepus_object_getOwnPropertyDescriptor(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 int magic) {
  LEPUSValueConst obj, prop;
  LEPUSAtom atom;
  LEPUSValue ret;
  LEPUSPropertyDescriptor desc;
  int res, flags;
  // <bytedance begin>
  obj = LEPUSRef2Value(ctx, argv[0]);
  // <bytedance end>
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    /* ES6 feature non compatible with ES5.1: obj can be a primitive type */
    if (magic || LEPUS_VALUE_IS_NULL(obj) || LEPUS_VALUE_IS_UNDEFINED(obj))
      return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  }
  prop = argv[1];
  atom = lepus_value_to_atom(ctx, prop);
  if (unlikely(atom == LEPUS_ATOM_NULL)) return LEPUS_EXCEPTION;
  ret = LEPUS_UNDEFINED;
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    res = LEPUS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(obj),
                                       atom);
    if (res < 0) goto exception;
    if (res) {
      ret = LEPUS_NewObject(ctx);
      if (LEPUS_IsException(ret)) goto exception1;
      flags = LEPUS_PROP_C_W_E | LEPUS_PROP_THROW;
      if (desc.flags & LEPUS_PROP_GETSET) {
        if (LEPUS_DefinePropertyValue(ctx, ret, LEPUS_ATOM_get,
                                      LEPUS_DupValue(ctx, desc.getter),
                                      flags) < 0 ||
            LEPUS_DefinePropertyValue(ctx, ret, LEPUS_ATOM_set,
                                      LEPUS_DupValue(ctx, desc.setter),
                                      flags) < 0)
          goto exception1;
      } else {
        if (LEPUS_DefinePropertyValue(ctx, ret, LEPUS_ATOM_value,
                                      LEPUS_DupValue(ctx, desc.value),
                                      flags) < 0 ||
            LEPUS_DefinePropertyValue(
                ctx, ret, LEPUS_ATOM_writable,
                LEPUS_NewBool(ctx, (desc.flags & LEPUS_PROP_WRITABLE) != 0),
                flags) < 0)
          goto exception1;
      }
      if (LEPUS_DefinePropertyValue(
              ctx, ret, LEPUS_ATOM_enumerable,
              LEPUS_NewBool(ctx, (desc.flags & LEPUS_PROP_ENUMERABLE) != 0),
              flags) < 0 ||
          LEPUS_DefinePropertyValue(
              ctx, ret, LEPUS_ATOM_configurable,
              LEPUS_NewBool(ctx, (desc.flags & LEPUS_PROP_CONFIGURABLE) != 0),
              flags) < 0)
        goto exception1;
      lepus_free_desc(ctx, &desc);
    }
  }
  LEPUS_FreeAtom(ctx, atom);
  return ret;

exception1:
  lepus_free_desc(ctx, &desc);
  LEPUS_FreeValue(ctx, ret);
exception:
  LEPUS_FreeAtom(ctx, atom);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_object_getOwnPropertyDescriptors(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv) {
  // getOwnPropertyDescriptors(obj)
  LEPUSValue obj, r;
  LEPUSObject *p;
  LEPUSPropertyEnum *props;
  uint32_t len, i;

  r = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, argv[0]);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;

  p = LEPUS_VALUE_GET_OBJ(obj);
  if (LEPUS_GetOwnPropertyNamesInternal(
          ctx, &props, &len, p, LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK))
    goto exception;
  r = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(r)) goto exception;
  for (i = 0; i < len; i++) {
    LEPUSValue atomValue, desc;
    LEPUSValueConst args[2];

    atomValue = LEPUS_AtomToValue(ctx, props[i].atom);
    if (LEPUS_IsException(atomValue)) goto exception;
    args[0] = obj;
    args[1] = atomValue;
    desc =
        lepus_object_getOwnPropertyDescriptor(ctx, LEPUS_UNDEFINED, 2, args, 0);
    LEPUS_FreeValue(ctx, atomValue);
    if (LEPUS_IsException(desc)) goto exception;
    if (!LEPUS_IsUndefined(desc)) {
      if (LEPUS_DefinePropertyValue(ctx, r, props[i].atom, desc,
                                    LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  lepus_free_prop_enum(ctx, props, len);
  LEPUS_FreeValue(ctx, obj);
  return r;

exception:
  lepus_free_prop_enum(ctx, props, len);
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, r);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue LEPUS_GetOwnPropertyNames2(LEPUSContext *ctx,
                                                 LEPUSValueConst obj1,
                                                 int flags, int kind) {
  LEPUSValue obj, r, val, key, value;
  LEPUSObject *p;
  LEPUSPropertyEnum *atoms;
  uint32_t len, i, j;

  r = LEPUS_UNDEFINED;
  val = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, obj1);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (LEPUS_GetOwnPropertyNamesInternal(ctx, &atoms, &len, p,
                                        flags & ~LEPUS_GPN_ENUM_ONLY))
    goto exception;
  r = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(r)) goto exception;
  for (j = i = 0; i < len; i++) {
    LEPUSAtom atom = atoms[i].atom;
    if (flags & LEPUS_GPN_ENUM_ONLY) {
      LEPUSPropertyDescriptor desc;
      int res;

      /* Check if property is still enumerable */
      res = LEPUS_GetOwnPropertyInternal(ctx, &desc, p, atom);
      if (res < 0) goto exception;
      if (!res) continue;
      lepus_free_desc(ctx, &desc);
      if (!(desc.flags & LEPUS_PROP_ENUMERABLE)) continue;
    }
    switch (kind) {
      default:
      case LEPUS_ITERATOR_KIND_KEY:
        val = LEPUS_AtomToValue(ctx, atom);
        if (LEPUS_IsException(val)) goto exception;
        break;
      case LEPUS_ITERATOR_KIND_VALUE:
        val = LEPUS_GetProperty(ctx, obj, atom);
        if (LEPUS_IsException(val)) goto exception;
        break;
      case LEPUS_ITERATOR_KIND_KEY_AND_VALUE:
        val = LEPUS_NewArray(ctx);
        if (LEPUS_IsException(val)) goto exception;
        key = LEPUS_AtomToValue(ctx, atom);
        if (LEPUS_IsException(key)) goto exception1;
        if (LEPUS_CreateDataPropertyUint32(ctx, val, 0, key, LEPUS_PROP_THROW) <
            0)
          goto exception1;
        value = LEPUS_GetProperty(ctx, obj, atom);
        if (LEPUS_IsException(value)) goto exception1;
        if (LEPUS_CreateDataPropertyUint32(ctx, val, 1, value,
                                           LEPUS_PROP_THROW) < 0)
          goto exception1;
        break;
    }
    if (LEPUS_CreateDataPropertyUint32(ctx, r, j++, val, 0) < 0) goto exception;
  }
  goto done;

exception1:
  LEPUS_FreeValue(ctx, val);
exception:
  LEPUS_FreeValue(ctx, r);
  r = LEPUS_EXCEPTION;
done:
  lepus_free_prop_enum(ctx, atoms, len);
  LEPUS_FreeValue(ctx, obj);
  return r;
}

QJS_STATIC LEPUSValue lepus_object_getOwnPropertyNames(LEPUSContext *ctx,
                                                       LEPUSValueConst this_val,
                                                       int argc,
                                                       LEPUSValueConst *argv) {
  return LEPUS_GetOwnPropertyNames2(ctx, argv[0], LEPUS_GPN_STRING_MASK,
                                    LEPUS_ITERATOR_KIND_KEY);
}

QJS_STATIC LEPUSValue
lepus_object_getOwnPropertySymbols(LEPUSContext *ctx, LEPUSValueConst this_val,
                                   int argc, LEPUSValueConst *argv) {
  return LEPUS_GetOwnPropertyNames2(ctx, argv[0], LEPUS_GPN_SYMBOL_MASK,
                                    LEPUS_ITERATOR_KIND_KEY);
}

QJS_STATIC LEPUSValue lepus_object_keys(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv, int kind) {
  return LEPUS_GetOwnPropertyNames2(
      ctx, argv[0], LEPUS_GPN_ENUM_ONLY | LEPUS_GPN_STRING_MASK, kind);
}

QJS_STATIC LEPUSValue lepus_object_isExtensible(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc, LEPUSValueConst *argv,
                                                int reflect) {
  LEPUSValueConst obj;
  int ret;
  // <bytedance begin>
  obj = LEPUSRef2Value(ctx, argv[0]);
  // <bytedance end>
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    if (reflect)
      return LEPUS_ThrowTypeErrorNotAnObject(ctx);
    else
      return LEPUS_FALSE;
  }
  ret = LEPUS_IsExtensible(ctx, obj);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue lepus_object_preventExtensions(LEPUSContext *ctx,
                                                     LEPUSValueConst this_val,
                                                     int argc,
                                                     LEPUSValueConst *argv,
                                                     int reflect) {
  LEPUSValueConst obj;
  int ret;
  // <bytedance begin>
  obj = LEPUSRef2Value(ctx, argv[0]);
  // <bytedance end>
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) {
    if (reflect)
      return LEPUS_ThrowTypeErrorNotAnObject(ctx);
    else
      return LEPUS_DupValue(ctx, obj);
  }
  ret = LEPUS_PreventExtensions(ctx, obj);
  if (ret < 0) return LEPUS_EXCEPTION;
  if (reflect)
    return LEPUS_NewBool(ctx, ret);
  else {
    if (!ret)
      return LEPUS_ThrowTypeError(
          ctx, "proxy preventExtensions handler returned false");
    return LEPUS_DupValue(ctx, obj);
  }
}

QJS_STATIC LEPUSValue lepus_object_hasOwnProperty(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv) {
  LEPUSValue obj;
  LEPUSAtom atom;
  LEPUSObject *p;
  BOOL ret;

  atom = lepus_value_to_atom(ctx, argv[0]); /* must be done first */
  if (unlikely(atom == LEPUS_ATOM_NULL)) return LEPUS_EXCEPTION;
  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) {
    LEPUS_FreeAtom(ctx, atom);
    return obj;
  }
  p = LEPUS_VALUE_GET_OBJ(obj);
  ret = LEPUS_GetOwnPropertyInternal(ctx, NULL, p, atom);
  LEPUS_FreeAtom(ctx, atom);
  LEPUS_FreeValue(ctx, obj);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue lepus_object_valueOf(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  return LEPUS_ToObject(ctx, this_val);
}

QJS_STATIC LEPUSValue lepus_object_toString(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue obj, tag;
  int is_array;
  LEPUSAtom atom;
  LEPUSObject *p;

  if (LEPUS_IsNull(this_val)) {
    tag = LEPUS_NewString(ctx, "Null");
  } else if (LEPUS_IsUndefined(this_val)) {
    tag = LEPUS_NewString(ctx, "Undefined");
  } else {
    obj = LEPUS_ToObject(ctx, this_val);
    if (LEPUS_IsException(obj)) return obj;
    is_array = LEPUS_IsArray(ctx, obj);
    if (is_array < 0) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
    if (is_array) {
      atom = LEPUS_ATOM_Array;
    } else if (LEPUS_IsFunction(ctx, obj)) {
      atom = LEPUS_ATOM_Function;
    } else {
      p = LEPUS_VALUE_GET_OBJ(obj);
      switch (p->class_id) {
        case LEPUS_CLASS_STRING:
        case LEPUS_CLASS_ARGUMENTS:
        case LEPUS_CLASS_MAPPED_ARGUMENTS:
        case LEPUS_CLASS_ERROR:
        case LEPUS_CLASS_BOOLEAN:
        case LEPUS_CLASS_NUMBER:
        case LEPUS_CLASS_DATE:
        case LEPUS_CLASS_REGEXP:
          atom = ctx->rt->class_array[p->class_id].class_name;
          break;
        default:
          atom = LEPUS_ATOM_Object;
          break;
      }
    }
    tag = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_Symbol_toStringTag);
    LEPUS_FreeValue(ctx, obj);
    if (LEPUS_IsException(tag)) return LEPUS_EXCEPTION;
    if (!LEPUS_IsString(tag)) {
      LEPUS_FreeValue(ctx, tag);
      tag = LEPUS_AtomToString(ctx, atom);
    }
  }
  return LEPUS_ConcatString3(ctx, "[object ", tag, "]");
}

QJS_STATIC LEPUSValue lepus_object_toLocaleString(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv) {
  return LEPUS_Invoke(ctx, this_val, LEPUS_ATOM_toString, 0, NULL);
}

QJS_STATIC LEPUSValue lepus_object_assign(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  // Object.assign(obj, source1)
  LEPUSValue obj, s;
  int i;

  s = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, argv[0]);
  if (LEPUS_IsException(obj)) goto exception;
  for (i = 1; i < argc; i++) {
    if (!LEPUS_IsNull(argv[i]) && !LEPUS_IsUndefined(argv[i])) {
      s = LEPUS_ToObject(ctx, argv[i]);
      if (LEPUS_IsException(s)) goto exception;
      if (LEPUS_CopyDataProperties(ctx, obj, s, LEPUS_UNDEFINED, TRUE))
        goto exception;
      LEPUS_FreeValue(ctx, s);
    }
  }
  return obj;
exception:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, s);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_object_seal(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv,
                                        int freeze_flag) {
  LEPUSValueConst obj = argv[0];
  LEPUSObject *p;
  LEPUSPropertyEnum *props;
  uint32_t len, i;
  int flags, desc_flags, res;
  // <bytedance begin>
  obj = LEPUSRef2Value(ctx, obj);
  // <bytedance end>

  if (!LEPUS_IsObject(obj)) return LEPUS_DupValue(ctx, obj);

  res = LEPUS_PreventExtensions(ctx, obj);
  if (res < 0) return LEPUS_EXCEPTION;
  if (!res) {
    return LEPUS_ThrowTypeError(
        ctx, "proxy preventExtensions handler returned false");
  }

  p = LEPUS_VALUE_GET_OBJ(obj);
  flags = LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK;
  if (LEPUS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))
    return LEPUS_EXCEPTION;

  for (i = 0; i < len; i++) {
    LEPUSPropertyDescriptor desc;
    LEPUSAtom prop = props[i].atom;

    desc_flags = LEPUS_PROP_THROW | LEPUS_PROP_HAS_CONFIGURABLE;
    if (freeze_flag) {
      res = LEPUS_GetOwnPropertyInternal(ctx, &desc, p, prop);
      if (res < 0) goto exception;
      if (res) {
        if (desc.flags & LEPUS_PROP_WRITABLE)
          desc_flags |= LEPUS_PROP_HAS_WRITABLE;
        lepus_free_desc(ctx, &desc);
      }
    }
    if (LEPUS_DefineProperty(ctx, obj, prop, LEPUS_UNDEFINED, LEPUS_UNDEFINED,
                             LEPUS_UNDEFINED, desc_flags) < 0)
      goto exception;
  }
  lepus_free_prop_enum(ctx, props, len);
  return lepus_object_preventExtensions(ctx, LEPUS_UNDEFINED, 1, argv, 0);

exception:
  lepus_free_prop_enum(ctx, props, len);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_object_isSealed(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv,
                                            int is_frozen) {
  LEPUSValueConst obj = argv[0];
  LEPUSObject *p;
  LEPUSPropertyEnum *props;
  uint32_t len, i;
  int flags, res;
  // <bytedance begin>
  obj = LEPUSRef2Value(ctx, obj);
  // <bytedance end>

  if (!LEPUS_IsObject(obj)) return LEPUS_TRUE;

  p = LEPUS_VALUE_GET_OBJ(obj);
  flags = LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK;
  if (LEPUS_GetOwnPropertyNamesInternal(ctx, &props, &len, p, flags))
    return LEPUS_EXCEPTION;

  for (i = 0; i < len; i++) {
    LEPUSPropertyDescriptor desc;
    LEPUSAtom prop = props[i].atom;

    res = LEPUS_GetOwnPropertyInternal(ctx, &desc, p, prop);
    if (res < 0) goto exception;
    if (res) {
      lepus_free_desc(ctx, &desc);
      if ((desc.flags & LEPUS_PROP_CONFIGURABLE) ||
          (is_frozen && (desc.flags & LEPUS_PROP_WRITABLE))) {
        res = FALSE;
        goto done;
      }
    }
  }
  res = LEPUS_IsExtensible(ctx, obj);
  if (res < 0) return LEPUS_EXCEPTION;
  res ^= 1;
done:
  lepus_free_prop_enum(ctx, props, len);
  return LEPUS_NewBool(ctx, res);

exception:
  lepus_free_prop_enum(ctx, props, len);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_object_fromEntries(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue obj, iter, next_method = LEPUS_UNDEFINED;
  LEPUSValueConst iterable;
  BOOL done;

  /*  RequireObjectCoercible() not necessary because it is tested in
      LEPUS_GetIterator() by LEPUS_GetProperty() */
  // <bytedance begin>
  iterable = LEPUSRef2Value(ctx, argv[0]);
  // <bytedance end>

  obj = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(obj)) return obj;

  iter = LEPUS_GetIterator(ctx, iterable, FALSE);
  if (LEPUS_IsException(iter)) goto fail;
  next_method = LEPUS_GetProperty(ctx, iter, LEPUS_ATOM_next);
  if (LEPUS_IsException(next_method)) goto fail;

  for (;;) {
    LEPUSValue key, value, item;
    item = LEPUS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
    if (LEPUS_IsException(item)) goto fail;
    if (done) {
      LEPUS_FreeValue(ctx, item);
      break;
    }

    key = LEPUS_UNDEFINED;
    value = LEPUS_UNDEFINED;
    if (!LEPUS_IsObject(item)) {
      LEPUS_ThrowTypeErrorNotAnObject(ctx);
      goto fail1;
    }
    key = LEPUS_GetPropertyUint32(ctx, item, 0);
    if (LEPUS_IsException(key)) goto fail1;
    value = LEPUS_GetPropertyUint32(ctx, item, 1);
    if (LEPUS_IsException(value)) {
      LEPUS_FreeValue(ctx, key);
      goto fail1;
    }
    if (LEPUS_DefinePropertyValueValue(
            ctx, obj, key, value, LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0) {
    fail1:
      LEPUS_FreeValue(ctx, item);
      goto fail;
    }
    LEPUS_FreeValue(ctx, item);
  }
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  return obj;
fail:
  if (LEPUS_IsObject(iter)) {
    /* close the iterator object, preserving pending exception */
    LEPUS_IteratorClose(ctx, iter, TRUE);
  }
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

#if 0
/* Note: corresponds to ECMA spec: CreateDataPropertyOrThrow() */
static LEPUSValue lepus_object___setOwnProperty(LEPUSContext *ctx, LEPUSValueConst this_val,
                                          int argc, LEPUSValueConst *argv)
{
    int ret;
    ret = LEPUS_DefinePropertyValueValue(ctx, argv[0], LEPUS_DupValue(ctx, argv[1]),
                                      LEPUS_DupValue(ctx, argv[2]),
                                      LEPUS_PROP_C_W_E | LEPUS_PROP_THROW);
    if (ret < 0)
        return LEPUS_EXCEPTION;
    else
        return LEPUS_NewBool(ctx, ret);
}

static LEPUSValue lepus_object___toObject(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv)
{
    return LEPUS_ToObject(ctx, argv[0]);
}

static LEPUSValue lepus_object___toPrimitive(LEPUSContext *ctx, LEPUSValueConst this_val,
                                       int argc, LEPUSValueConst *argv)
{
    int hint = HINT_NONE;

    if (LEPUS_VALUE_IS_INT(argv[1]))
        hint = LEPUS_VALUE_GET_INT(argv[1]);

    return LEPUS_ToPrimitive(ctx, argv[0], hint);
}
#endif

/* return an empty string if not an object */
QJS_STATIC LEPUSValue lepus_object___getClass(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSAtom atom;
  LEPUSObject *p;
  int64_t tag;
  int class_id;
  // <bytedance begin>
#ifdef ENABLE_LEPUSNG
  LEPUSValue obj = argv[0];
  if (LEPUS_IsLepusRef(obj)) {
    if (LEPUS_LepusRefIsArray(ctx->rt, obj)) {
      atom = ctx->rt->class_array[LEPUS_CLASS_ARRAY].class_name;
    } else if (LEPUS_LepusRefIsTable(ctx->rt, obj)) {
      atom = ctx->rt->class_array[LEPUS_CLASS_OBJECT].class_name;
    } else {
      atom = LEPUS_ATOM_empty_string;
    }
    return LEPUS_AtomToString(ctx, atom);
  }
#endif
  // <bytedance end>

  tag = LEPUS_VALUE_GET_NORM_TAG(argv[0]);
  if (tag == LEPUS_TAG_OBJECT) {
    p = LEPUS_VALUE_GET_OBJ(argv[0]);
    class_id = p->class_id;
    if (class_id == LEPUS_CLASS_PROXY && LEPUS_IsFunction(ctx, argv[0]))
      class_id = LEPUS_CLASS_BYTECODE_FUNCTION;
    atom = ctx->rt->class_array[class_id].class_name;
  } else {
    atom = LEPUS_ATOM_empty_string;
  }
  return LEPUS_AtomToString(ctx, atom);
}

QJS_STATIC LEPUSValue lepus_object_is(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  return LEPUS_NewBool(ctx, lepus_same_value(ctx, argv[0], argv[1]));
}

// <ByteDance begin>
LEPUSValue LEPUS_DeepEqual(LEPUSContext *ctx, LEPUSValueConst obj1,
                           LEPUSValueConst obj2) {
#ifdef ENABLE_LEPUSNG
  if (LEPUS_IsLepusRef(obj1) && LEPUS_IsLepusRef(obj2)) {
    BOOL ret = ctx->rt->lepus_callbacks_.lepus_ref_equal(obj1, obj2);
    return LEPUS_NewBool(ctx, ret);
  }
#endif

  BOOL ret = lepus_same_value(ctx, obj1, obj2);
  if (ret || (!LEPUS_IsObject(obj1) && !LEPUS_IsLepusRef(obj1)) ||
      (!LEPUS_IsObject(obj2) && !LEPUS_IsLepusRef(obj2))) {
    return LEPUS_NewBool(ctx, ret);
  }
  obj1 = LEPUSRef2Value(ctx, obj1);
  obj2 = LEPUSRef2Value(ctx, obj2);
  // if both obj1 and obj2 are not object, return FALSE
  if (!LEPUS_IsObject(obj1) || !LEPUS_IsObject(obj2)) {
    return LEPUS_NewBool(ctx, FALSE);
  }
  // for object compare
  LEPUSObject *p1 = LEPUS_VALUE_GET_OBJ(obj1);
  LEPUSObject *p2 = LEPUS_VALUE_GET_OBJ(obj2);
  uint32_t i;
  LEPUSShape *sh1, *sh2;
  LEPUSShapeProperty *pr1, *pr2;
  LEPUSValue val1, val2, result;
  LEPUSAtom atom;
  if (p1->class_id != p2->class_id) {
    goto fail;
  }

  if (p1->class_id != LEPUS_CLASS_ARRAY && p1->class_id != LEPUS_CLASS_OBJECT) {
    goto fail;
  }

  if (p1->class_id == LEPUS_CLASS_ARRAY) {
    uint32_t len1, len2;
    if (lepus_get_length32(ctx, &len1, obj1) ||
        lepus_get_length32(ctx, &len2, obj2)) {
      goto fail;
    }
    if (len1 != len2) goto fail;

    for (i = 0; i < len1; i++) {
      val1 = LEPUS_GetPropertyUint32(ctx, obj1, i);
      val2 = LEPUS_GetPropertyUint32(ctx, obj2, i);
      if (LEPUS_IsException(val1) || LEPUS_IsException(val2)) goto fail;
      result = LEPUS_DeepEqual(ctx, val1, val2);
      LEPUS_FreeValue(ctx, val1);
      LEPUS_FreeValue(ctx, val2);
      if (!LEPUS_VALUE_GET_BOOL(result)) goto fail;
    }

    goto ok;

  } else {
    sh1 = p1->shape;
    sh2 = p2->shape;
    if (sh1->prop_count != sh2->prop_count) goto fail;
    for (i = 0, pr1 = get_shape_prop(sh1); i < sh1->prop_count; i++, pr1++) {
      atom = pr1->atom;
      if (atom != LEPUS_ATOM_NULL && LEPUS_AtomIsString(ctx, atom) &&
          (pr1->flags & LEPUS_PROP_ENUMERABLE)) {
        val2 = LEPUS_GetProperty(ctx, obj2, atom);
        if (LEPUS_IsException(val2)) goto fail;
        val1 = p1->prop[i].u.value;
        result = LEPUS_DeepEqual(ctx, val1, val2);
        LEPUS_FreeValue(ctx, val2);
        if (!LEPUS_VALUE_GET_BOOL(result)) goto fail;
      }
    }
    goto ok;
  }

fail:
  return LEPUS_NewBool(ctx, 0);

ok:
  return LEPUS_NewBool(ctx, 1);
}

void LEPUS_IterateObject(LEPUSContext *ctx, LEPUSValue obj,
                         IterateObject callback, void *pfunc, void *raw_data) {
  if (!LEPUS_IsObject(obj)) return;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  uint32_t i, len;
  LEPUSValue val = LEPUS_UNDEFINED;
  LEPUSShape *sh;
  LEPUSShapeProperty *pr;
  LEPUSAtom atom;
  LEPUSValue atomValue;
  if (p->class_id == LEPUS_CLASS_ARRAY) {
    if (lepus_get_length32(ctx, &len, obj)) goto fail;
    for (i = 0; i < len; i++) {
      val = LEPUS_GetPropertyUint32(ctx, obj, i);
      if (LEPUS_IsException(val)) goto fail;
      callback(ctx, LEPUS_NewInt32(ctx, i), val, pfunc, raw_data);
      LEPUS_FreeValue(ctx, val);
    }
  } else {
    sh = p->shape;
    for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
      atom = pr->atom;
      if (atom != LEPUS_ATOM_NULL && LEPUS_AtomIsString(ctx, atom) &&
          (pr->flags & LEPUS_PROP_ENUMERABLE)) {
        if (pr->flags & LEPUS_PROP_TMASK) {
          LEPUS_ThrowTypeError(ctx, "only value properties are supported");
          goto fail;
        }
        atomValue = LEPUS_AtomToValue(ctx, atom);
        callback(ctx, atomValue, p->prop[i].u.value, pfunc, raw_data);
        LEPUS_FreeValue(ctx, atomValue);
      }
    }
  }
  return;

fail:
  LEPUS_FreeValue(ctx, val);
}
int LEPUS_GetLength(LEPUSContext *ctx, LEPUSValue val) {
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(val);
  if (tag == LEPUS_TAG_STRING) {
    LEPUSString *p = LEPUS_VALUE_GET_STRING(val);
    return p->len;
  } else if (tag == LEPUS_TAG_OBJECT) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
    uint32_t len;
    if (p->class_id == LEPUS_CLASS_ARRAY) {
      if (lepus_get_length32(ctx, &len, val)) return -1;
      return len;
    } else {
      return p->shape->prop_count;
    }
  }
#ifdef ENABLE_LEPUSNG
  // <ByteDance begin>
  else if (tag == LEPUS_TAG_LEPUS_REF) {
    if (ctx->rt->lepus_callbacks_.get_length) {
      return ctx->rt->lepus_callbacks_.get_length(ctx, val);
    }
  }
#endif
  // <ByteDance end>
  return 0;
}

#if 0
static LEPUSValue lepus_object___getObjectData(LEPUSContext *ctx, LEPUSValueConst this_val,
                                         int argc, LEPUSValueConst *argv)
{
    return LEPUS_GetObjectData(ctx, argv[0]);
}

static LEPUSValue lepus_object___setObjectData(LEPUSContext *ctx, LEPUSValueConst this_val,
                                         int argc, LEPUSValueConst *argv)
{
    if (LEPUS_SetObjectData(ctx, argv[0], LEPUS_DupValue(ctx, argv[1])))
        return LEPUS_EXCEPTION;
    return LEPUS_DupValue(ctx, argv[1]);
}

static LEPUSValue lepus_object___toPropertyKey(LEPUSContext *ctx, LEPUSValueConst this_val,
                                         int argc, LEPUSValueConst *argv)
{
    return LEPUS_ToPropertyKey(ctx, argv[0]);
}

static LEPUSValue lepus_object___isObject(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv)
{
    return LEPUS_NewBool(ctx, LEPUS_IsObject(argv[0]));
}

static LEPUSValue lepus_object___isSameValueZero(LEPUSContext *ctx, LEPUSValueConst this_val,
                                           int argc, LEPUSValueConst *argv)
{
    return LEPUS_NewBool(ctx, lepus_same_value_zero(ctx, argv[0], argv[1]));
}

static LEPUSValue lepus_object___isConstructor(LEPUSContext *ctx, LEPUSValueConst this_val,
                                         int argc, LEPUSValueConst *argv)
{
    return LEPUS_NewBool(ctx, LEPUS_IsConstructor(ctx, argv[0]));
}
#endif

QJS_STATIC LEPUSValue
LEPUS_SpeciesConstructor(LEPUSContext *ctx, LEPUSValueConst obj,
                         LEPUSValueConst defaultConstructor) {
  LEPUSValue ctor, species;

  if (!LEPUS_IsObject(obj)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  ctor = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_constructor);
  if (LEPUS_IsException(ctor)) return ctor;
  if (LEPUS_IsUndefined(ctor)) return LEPUS_DupValue(ctx, defaultConstructor);
  if (!LEPUS_IsObject(ctor)) {
    LEPUS_FreeValue(ctx, ctor);
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  }
  species = LEPUS_GetProperty(ctx, ctor, LEPUS_ATOM_Symbol_species);
  LEPUS_FreeValue(ctx, ctor);
  if (LEPUS_IsException(species)) return species;
  if (LEPUS_IsUndefined(species) || LEPUS_IsNull(species))
    return LEPUS_DupValue(ctx, defaultConstructor);
  if (!LEPUS_IsConstructor(ctx, species)) {
    LEPUS_FreeValue(ctx, species);
    return LEPUS_ThrowTypeError(ctx, "not a constructor");
  }
  return species;
}

#if 0
static LEPUSValue lepus_object___speciesConstructor(LEPUSContext *ctx, LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv)
{
    return LEPUS_SpeciesConstructor(ctx, argv[0], argv[1]);
}
#endif

QJS_STATIC LEPUSValue lepus_object_get___proto__(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val) {
  LEPUSValue val, ret;

  val = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  ret = LEPUS_DupValue(ctx, LEPUS_GetPrototype(ctx, val));
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue lepus_object_set___proto__(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 LEPUSValueConst proto) {
  if (LEPUS_IsUndefined(this_val) || LEPUS_IsNull(this_val))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  if (!LEPUS_IsObject(proto) && !LEPUS_IsNull(proto)) return LEPUS_UNDEFINED;
  if (LEPUS_SetPrototypeInternal(ctx, this_val, proto, TRUE) < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue lepus_object_isPrototypeOf(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  LEPUSValue obj;
  LEPUSValueConst v;
  int max_depth = 1000, res = -1;

  v = argv[0];
  if (!LEPUS_IsObject(v)) return LEPUS_FALSE;
  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  while (--max_depth > 0) {
    v = LEPUS_GetPrototype(ctx, v);
    if (LEPUS_IsException(v)) goto exception;
    if (LEPUS_IsNull(v)) {
      res = FALSE;
      break;
    }
    if (lepus_strict_eq2(ctx, LEPUS_DupValue(ctx, obj), LEPUS_DupValue(ctx, v),
                         LEPUS_EQ_STRICT)) {
      res = TRUE;
      break;
    }
  }
  LEPUS_FreeValue(ctx, obj);
  if (res < 0)
    return LEPUS_ThrowInternalError(ctx, "prototype chain cycle");
  else
    return LEPUS_NewBool(ctx, res);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue
lepus_object_propertyIsEnumerable(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv) {
  LEPUSValue obj, res = LEPUS_EXCEPTION;
  LEPUSAtom prop = LEPUS_ATOM_NULL;
  LEPUSPropertyDescriptor desc;
  int has_prop;

  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) goto exception;
  prop = lepus_value_to_atom(ctx, argv[0]);
  if (unlikely(prop == LEPUS_ATOM_NULL)) goto exception;

  has_prop =
      LEPUS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(obj), prop);
  if (has_prop < 0) goto exception;
  if (has_prop) {
    res = LEPUS_NewBool(ctx, (desc.flags & LEPUS_PROP_ENUMERABLE) != 0);
    lepus_free_desc(ctx, &desc);
  } else {
    res = LEPUS_FALSE;
  }

exception:
  LEPUS_FreeAtom(ctx, prop);
  LEPUS_FreeValue(ctx, obj);
  return res;
}

QJS_STATIC LEPUSValue lepus_object___lookupGetter__(LEPUSContext *ctx,
                                                    LEPUSValueConst this_val,
                                                    int argc,
                                                    LEPUSValueConst *argv,
                                                    int setter) {
  LEPUSValue obj, res = LEPUS_EXCEPTION;
  LEPUSValueConst v;
  LEPUSAtom prop = LEPUS_ATOM_NULL;
  LEPUSPropertyDescriptor desc;
  int has_prop;

  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) goto exception;
  prop = lepus_value_to_atom(ctx, argv[0]);
  if (unlikely(prop == LEPUS_ATOM_NULL)) goto exception;

  for (v = obj;;) {
    has_prop =
        LEPUS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(v), prop);
    if (has_prop < 0) goto exception;
    if (has_prop) {
      if (desc.flags & LEPUS_PROP_GETSET)
        res = LEPUS_DupValue(ctx, setter ? desc.setter : desc.getter);
      else
        res = LEPUS_UNDEFINED;
      lepus_free_desc(ctx, &desc);
      break;
    }
    v = LEPUS_GetPrototype(ctx, v);
    if (LEPUS_IsException(v)) goto exception;
    if (LEPUS_IsNull(v)) {
      res = LEPUS_UNDEFINED;
      break;
    }
  }

exception:
  LEPUS_FreeAtom(ctx, prop);
  LEPUS_FreeValue(ctx, obj);
  return res;
}

static const LEPUSCFunctionListEntry lepus_object_funcs[] = {
    LEPUS_CFUNC_DEF("create", 2, lepus_object_create),
    LEPUS_CFUNC_MAGIC_DEF("getPrototypeOf", 1, lepus_object_getPrototypeOf, 0),
    LEPUS_CFUNC_DEF("setPrototypeOf", 2, lepus_object_setPrototypeOf),
    LEPUS_CFUNC_MAGIC_DEF("defineProperty", 3, lepus_object_defineProperty, 0),
    LEPUS_CFUNC_DEF("defineProperties", 2, lepus_object_defineProperties),
    LEPUS_CFUNC_DEF("getOwnPropertyNames", 1, lepus_object_getOwnPropertyNames),
    LEPUS_CFUNC_DEF("getOwnPropertySymbols", 1,
                    lepus_object_getOwnPropertySymbols),
    LEPUS_CFUNC_MAGIC_DEF("keys", 1, lepus_object_keys,
                          LEPUS_ITERATOR_KIND_KEY),
    LEPUS_CFUNC_MAGIC_DEF("values", 1, lepus_object_keys,
                          LEPUS_ITERATOR_KIND_VALUE),
    LEPUS_CFUNC_MAGIC_DEF("entries", 1, lepus_object_keys,
                          LEPUS_ITERATOR_KIND_KEY_AND_VALUE),
    LEPUS_CFUNC_MAGIC_DEF("isExtensible", 1, lepus_object_isExtensible, 0),
    LEPUS_CFUNC_MAGIC_DEF("preventExtensions", 1,
                          lepus_object_preventExtensions, 0),
    LEPUS_CFUNC_MAGIC_DEF("getOwnPropertyDescriptor", 2,
                          lepus_object_getOwnPropertyDescriptor, 0),
    LEPUS_CFUNC_DEF("getOwnPropertyDescriptors", 1,
                    lepus_object_getOwnPropertyDescriptors),
    LEPUS_CFUNC_DEF("is", 2, lepus_object_is),
    LEPUS_CFUNC_DEF("assign", 2, lepus_object_assign),
    LEPUS_CFUNC_MAGIC_DEF("seal", 1, lepus_object_seal, 0),
    LEPUS_CFUNC_MAGIC_DEF("freeze", 1, lepus_object_seal, 1),
    LEPUS_CFUNC_MAGIC_DEF("isSealed", 1, lepus_object_isSealed, 0),
    LEPUS_CFUNC_MAGIC_DEF("isFrozen", 1, lepus_object_isSealed, 1),
    LEPUS_CFUNC_DEF("__getClass", 1, lepus_object___getClass),
    // LEPUS_CFUNC_DEF("__isObject", 1, lepus_object___isObject ),
    // LEPUS_CFUNC_DEF("__isConstructor", 1, lepus_object___isConstructor ),
    // LEPUS_CFUNC_DEF("__toObject", 1, lepus_object___toObject ),
    // LEPUS_CFUNC_DEF("__setOwnProperty", 3, lepus_object___setOwnProperty ),
    // LEPUS_CFUNC_DEF("__toPrimitive", 2, lepus_object___toPrimitive ),
    // LEPUS_CFUNC_DEF("__toPropertyKey", 1, lepus_object___toPropertyKey ),
    // LEPUS_CFUNC_DEF("__speciesConstructor", 2,
    // lepus_object___speciesConstructor ), LEPUS_CFUNC_DEF("__isSameValueZero",
    // 2, lepus_object___isSameValueZero ), LEPUS_CFUNC_DEF("__getObjectData",
    // 1, lepus_object___getObjectData ), LEPUS_CFUNC_DEF("__setObjectData", 2,
    // lepus_object___setObjectData ),
    LEPUS_CFUNC_DEF("fromEntries", 1, lepus_object_fromEntries),
};

static const LEPUSCFunctionListEntry lepus_object_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, lepus_object_toString),
    LEPUS_CFUNC_DEF("toLocaleString", 0, lepus_object_toLocaleString),
    LEPUS_CFUNC_DEF("valueOf", 0, lepus_object_valueOf),
    LEPUS_CFUNC_DEF("hasOwnProperty", 1, lepus_object_hasOwnProperty),
    LEPUS_CFUNC_DEF("isPrototypeOf", 1, lepus_object_isPrototypeOf),
    LEPUS_CFUNC_DEF("propertyIsEnumerable", 1,
                    lepus_object_propertyIsEnumerable),
    LEPUS_CGETSET_DEF("__proto__", lepus_object_get___proto__,
                      lepus_object_set___proto__),
    LEPUS_CFUNC_MAGIC_DEF("__defineGetter__", 2, lepus_object___defineGetter__,
                          0),
    LEPUS_CFUNC_MAGIC_DEF("__defineSetter__", 2, lepus_object___defineGetter__,
                          1),
    LEPUS_CFUNC_MAGIC_DEF("__lookupGetter__", 1, lepus_object___lookupGetter__,
                          0),
    LEPUS_CFUNC_MAGIC_DEF("__lookupSetter__", 1, lepus_object___lookupGetter__,
                          1),
};

/* Function class */

QJS_STATIC LEPUSValue lepus_function_proto(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue lepus_function_constructor(LEPUSContext *ctx,
                                                 LEPUSValueConst new_target,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 int magic) {
  LEPUSFunctionKindEnum func_kind = static_cast<LEPUSFunctionKindEnum>(magic);
  int i, n, ret;
  LEPUSValue s, proto, obj = LEPUS_UNDEFINED;
  StringBuffer b_s, *b = &b_s;

  string_buffer_init(ctx, b, 0);
  string_buffer_putc8(b, '(');

  if (func_kind == LEPUS_FUNC_ASYNC ||
      func_kind == LEPUS_FUNC_ASYNC_GENERATOR) {
    string_buffer_puts8(b, "async ");
  }
  string_buffer_puts8(b, "function");

  if (func_kind == LEPUS_FUNC_GENERATOR ||
      func_kind == LEPUS_FUNC_ASYNC_GENERATOR) {
    string_buffer_putc8(b, '*');
  }
  string_buffer_puts8(b, " anonymous(");

  n = argc - 1;
  for (i = 0; i < n; i++) {
    if (i != 0) {
      string_buffer_putc8(b, ',');
    }
    if (string_buffer_concat_value(b, argv[i])) goto fail;
  }
  string_buffer_puts8(b, "\n) {\n");
  if (n >= 0) {
    if (string_buffer_concat_value(b, argv[n])) goto fail;
  }
  string_buffer_puts8(b, "\n})");
  s = string_buffer_end(b);
  if (LEPUS_IsException(s)) goto fail1;

  obj = LEPUS_EvalObject(ctx, ctx->global_obj, s, LEPUS_EVAL_TYPE_INDIRECT, -1);
  LEPUS_FreeValue(ctx, s);
  if (LEPUS_IsException(obj)) goto fail1;
  if (!LEPUS_IsUndefined(new_target)) {
    /* set the prototype */
    proto = lepus_get_prototype_from_ctor(ctx, new_target, LEPUS_UNDEFINED);
    if (LEPUS_IsException(proto)) goto fail1;
    if (!LEPUS_IsUndefined(proto)) {
      ret = LEPUS_SetPrototypeInternal(ctx, obj, proto, TRUE);
      LEPUS_FreeValue(ctx, proto);
      if (ret < 0) goto fail1;
    }
  }
  return obj;

fail:
  string_buffer_free(b);
fail1:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

__exception int lepus_get_length32(LEPUSContext *ctx, uint32_t *pres,
                                   LEPUSValueConst obj) {
  LEPUSValue len_val;
  len_val = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_length);
  if (LEPUS_IsException(len_val)) {
    *pres = 0;
    return -1;
  }
  return LEPUS_ToUint32Free(ctx, pres, len_val);
}

QJS_STATIC __exception int lepus_get_length64(LEPUSContext *ctx, int64_t *pres,
                                              LEPUSValueConst obj) {
  LEPUSValue len_val;
  len_val = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_length);
  if (LEPUS_IsException(len_val)) {
    *pres = 0;
    return -1;
  }
  return LEPUS_ToLengthFree(ctx, pres, len_val);
}

QJS_STATIC void free_arg_list(LEPUSContext *ctx, LEPUSValue *tab,
                              uint32_t len) {
  uint32_t i;
  for (i = 0; i < len; i++) {
    LEPUS_FreeValue(ctx, tab[i]);
  }
  lepus_free(ctx, tab);
}

/* XXX: should use ValueArray */
QJS_STATIC LEPUSValue *build_arg_list(LEPUSContext *ctx, uint32_t *plen,
                                      LEPUSValueConst array_arg) {
  uint32_t len, i;
  LEPUSValue *tab, ret;
  LEPUSObject *p;

  if (LEPUS_VALUE_IS_NOT_OBJECT(array_arg)) {
    LEPUS_ThrowTypeError(ctx, "not a object");
    return NULL;
  }
  if (lepus_get_length32(ctx, &len, array_arg)) return NULL;
  /* avoid allocating 0 bytes */
  tab = static_cast<LEPUSValue *>(
      lepus_mallocz(ctx, sizeof(tab[0]) * max_uint32(1, len)));
  if (!tab) return NULL;
  p = LEPUS_VALUE_GET_OBJ(array_arg);

  if ((p->class_id == LEPUS_CLASS_ARRAY ||
       p->class_id == LEPUS_CLASS_ARGUMENTS) &&
      p->fast_array && len == p->u.array.count) {
    for (i = 0; i < len; i++) {
      tab[i] = LEPUS_DupValue(ctx, p->u.array.u.values[i]);
    }
  } else {
    for (i = 0; i < len; i++) {
      ret = LEPUS_GetPropertyUint32(ctx, array_arg, i);
      if (LEPUS_IsException(ret)) {
        free_arg_list(ctx, tab, i);
        return NULL;
      }
      tab[i] = ret;
    }
  }
  *plen = len;
  return tab;
}

LEPUSValue lepus_function_apply(LEPUSContext *ctx, LEPUSValueConst this_val,
                                int argc, LEPUSValueConst *argv, int magic) {
  LEPUSValueConst this_arg, array_arg;
  uint32_t len;
  LEPUSValue *tab, ret;

  if (check_function(ctx, this_val)) return LEPUS_EXCEPTION;
  this_arg = argv[0];
  array_arg = argv[1];
  if (LEPUS_VALUE_IS_UNDEFINED(array_arg) || LEPUS_VALUE_IS_NULL(array_arg)) {
    return LEPUS_Call(ctx, this_val, this_arg, 0, NULL);
  }
  tab = build_arg_list(ctx, &len, array_arg);
  if (!tab) return LEPUS_EXCEPTION;
  if (magic) {
    ret = LEPUS_CallConstructor2(ctx, this_val, this_arg, len,
                                 (LEPUSValueConst *)tab);
  } else {
    ret = LEPUS_Call(ctx, this_val, this_arg, len, (LEPUSValueConst *)tab);
  }
  free_arg_list(ctx, tab, len);
  return ret;
}

QJS_STATIC LEPUSValue lepus_function_call(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  if (argc <= 0) {
    return LEPUS_Call(ctx, this_val, LEPUS_UNDEFINED, 0, NULL);
  } else {
    return LEPUS_Call(ctx, this_val, argv[0], argc - 1, argv + 1);
  }
}

QJS_STATIC LEPUSValue lepus_function_bind(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSBoundFunction *bf;
  LEPUSValue func_obj, name1, len_val;
  LEPUSObject *p;
  int arg_count, i, ret;

  if (check_function(ctx, this_val)) return LEPUS_EXCEPTION;

  func_obj = LEPUS_NewObjectProtoClass(ctx, ctx->function_proto,
                                       LEPUS_CLASS_BOUND_FUNCTION);
  if (LEPUS_IsException(func_obj)) return LEPUS_EXCEPTION;
  p = LEPUS_VALUE_GET_OBJ(func_obj);
  p->is_constructor = LEPUS_IsConstructor(ctx, this_val);
  arg_count = max_int(0, argc - 1);
  bf = static_cast<LEPUSBoundFunction *>(
      lepus_malloc(ctx, sizeof(*bf) + arg_count * sizeof(LEPUSValue)));
  if (!bf) goto exception;
  bf->func_obj = LEPUS_DupValue(ctx, this_val);
  bf->this_val = LEPUS_DupValue(ctx, argv[0]);
  bf->argc = arg_count;
  for (i = 0; i < arg_count; i++) {
    bf->argv[i] = LEPUS_DupValue(ctx, argv[i + 1]);
  }
  p->u.bound_function = bf;

  ret = LEPUS_GetOwnProperty(ctx, NULL, this_val, LEPUS_ATOM_length);
  if (ret < 0) goto exception;
  if (!ret) {
    len_val = LEPUS_NewInt32(ctx, 0);
  } else {
    len_val = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_length);
    if (LEPUS_IsException(len_val)) goto exception;
    if (LEPUS_VALUE_IS_INT(len_val)) {
      int len1 = LEPUS_VALUE_GET_INT(len_val);
      if (len1 <= arg_count)
        len1 = 0;
      else
        len1 -= arg_count;
      len_val = LEPUS_NewInt32(ctx, len1);
    } else if (LEPUS_VALUE_IS_FLOAT64(len_val)) {
      double d = LEPUS_VALUE_GET_FLOAT64(len_val);
      if (isnan(d)) {
        d = 0.0;
      } else {
        d = trunc(d);
        if (d <= (double)arg_count)
          d = 0.0;
        else
          d -= (double)arg_count; /* also converts -0 to +0 */
      }
      len_val = LEPUS_NewFloat64(ctx, d);
    } else {
      LEPUS_FreeValue(ctx, len_val);
      len_val = LEPUS_NewInt32(ctx, 0);
    }
  }

  LEPUS_DefinePropertyValue(ctx, func_obj, LEPUS_ATOM_length, len_val,
                            LEPUS_PROP_CONFIGURABLE);

  name1 = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_name);
  if (LEPUS_IsException(name1)) goto exception;
  if (!LEPUS_IsString(name1)) {
    LEPUS_FreeValue(ctx, name1);
    name1 = LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string);
  }
  name1 = LEPUS_ConcatString3(ctx, "bound ", name1, "");
  if (LEPUS_IsException(name1)) goto exception;
  LEPUS_DefinePropertyValue(ctx, func_obj, LEPUS_ATOM_name, name1,
                            LEPUS_PROP_CONFIGURABLE);
  return func_obj;
exception:
  LEPUS_FreeValue(ctx, func_obj);
  return LEPUS_EXCEPTION;
}

QJS_HIDE LEPUSValue lepus_function_toString(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSObject *p;
  LEPUSFunctionKindEnum func_kind = LEPUS_FUNC_NORMAL;

  if (check_function(ctx, this_val)) return LEPUS_EXCEPTION;

  p = LEPUS_VALUE_GET_OBJ(this_val);
  if (lepus_class_has_bytecode(p->class_id)) {
    LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
    if (b->has_debug && b->debug.source) {
      return LEPUS_NewStringLen(ctx, b->debug.source, b->debug.source_len);
    }
    func_kind = static_cast<LEPUSFunctionKindEnum>(b->func_kind);
  }
  {
    LEPUSValue name;
    const char *pref, *suff;

    if (p->is_class) {
      pref = "class ";
      suff = " {\n    [native code]\n}";
    } else {
      switch (func_kind) {
        default:
        case LEPUS_FUNC_NORMAL:
          pref = "function ";
          break;
        case LEPUS_FUNC_GENERATOR:
          pref = "function *";
          break;
        case LEPUS_FUNC_ASYNC:
          pref = "async function ";
          break;
        case LEPUS_FUNC_ASYNC_GENERATOR:
          pref = "async function *";
          break;
      }
      suff = "() {\n    [native code]\n}";
    }
    name = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_name);
    if (LEPUS_IsUndefined(name))
      name = LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string);
    return LEPUS_ConcatString3(ctx, pref, name, suff);
  }
}

QJS_STATIC LEPUSValue lepus_function_hasInstance(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  int ret;
  ret = LEPUS_OrdinaryIsInstanceOf(ctx, argv[0], this_val);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

static const LEPUSCFunctionListEntry lepus_function_proto_funcs[] = {
    LEPUS_CFUNC_DEF("call", 1, lepus_function_call),
    LEPUS_CFUNC_MAGIC_DEF("apply", 2, lepus_function_apply, 0),
    LEPUS_CFUNC_DEF("bind", 1, lepus_function_bind),
    LEPUS_CFUNC_DEF("toString", 0, lepus_function_toString),
    LEPUS_CFUNC_DEF("[Symbol.hasInstance]", 1, lepus_function_hasInstance),
    LEPUS_CGETSET_DEF("fileName", lepus_function_proto_fileName, NULL),
    LEPUS_CGETSET_DEF("lineNumber", lepus_function_proto_lineNumber, NULL),
};

/* Error class */
QJS_STATIC LEPUSValue iterator_to_array(LEPUSContext *ctx,
                                        LEPUSValueConst items) {
  LEPUSValue iter, next_method = LEPUS_UNDEFINED;
  LEPUSValue v, r = LEPUS_UNDEFINED;
  int64_t k;
  BOOL done;

  iter = LEPUS_GetIterator(ctx, items, FALSE);
  if (LEPUS_IsException(iter)) goto exception;
  next_method = LEPUS_GetProperty(ctx, iter, LEPUS_ATOM_next);
  if (LEPUS_IsException(next_method)) goto exception;
  r = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(r)) goto exception;
  for (k = 0;; k++) {
    v = LEPUS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
    if (LEPUS_IsException(v)) goto exception_close;
    if (done) break;
    if (LEPUS_DefinePropertyValueInt64(ctx, r, k, v,
                                       LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
      goto exception_close;
  }
done:
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  return r;
exception_close:
  LEPUS_IteratorClose(ctx, iter, TRUE);
exception:
  LEPUS_FreeValue(ctx, r);
  r = LEPUS_EXCEPTION;
  goto done;
}

QJS_STATIC LEPUSValue lepus_error_constructor(LEPUSContext *ctx,
                                              LEPUSValueConst new_target,
                                              int argc, LEPUSValueConst *argv,
                                              int magic) {
  LEPUSValue obj, msg, proto;
  LEPUSValueConst message;

  if (LEPUS_IsUndefined(new_target)) new_target = LEPUS_GetActiveFunction(ctx);
  proto = LEPUS_GetProperty(ctx, new_target, LEPUS_ATOM_prototype);
  if (LEPUS_IsException(proto)) return proto;
  if (!LEPUS_IsObject(proto)) {
    LEPUSValueConst proto1;
    LEPUS_FreeValue(ctx, proto);
    if (magic < 0) {
      proto1 = ctx->class_proto[LEPUS_CLASS_ERROR];
    } else {
      proto1 = ctx->native_error_proto[magic];
    }
    proto = LEPUS_DupValue(ctx, proto1);
  }
  obj = LEPUS_NewObjectProtoClass(ctx, proto, LEPUS_CLASS_ERROR);
  LEPUS_FreeValue(ctx, proto);
  if (LEPUS_IsException(obj)) return obj;
  if (magic == LEPUS_AGGREGATE_ERROR) {
    message = argv[1];
  } else {
    message = argv[0];
  }
  if (!LEPUS_IsUndefined(message)) {
    msg = LEPUS_ToString(ctx, message);
    if (unlikely(LEPUS_IsException(msg))) goto exception;
    LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_message, msg,
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  }

  if (magic == LEPUS_AGGREGATE_ERROR) {
    LEPUSValue error_list = iterator_to_array(ctx, argv[0]);
    if (LEPUS_IsException(error_list)) goto exception;
    // TODO
    LEPUSAtom atom_errors = LEPUS_NewAtom(ctx, "errors");
    LEPUS_DefinePropertyValue(ctx, obj, atom_errors, error_list,
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    LEPUS_FreeAtom(ctx, atom_errors);
  }
  /* skip the Error() function in the backtrace */
  build_backtrace(ctx, obj, NULL, 0, NULL,
                  LEPUS_BACKTRACE_FLAG_SKIP_FIRST_LEVEL);
  return obj;
exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_error_toString(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValue name, msg;

  if (!LEPUS_IsObject(this_val)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  name = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_name);
  if (LEPUS_IsUndefined(name))
    name = LEPUS_AtomToString(ctx, LEPUS_ATOM_Error);
  else
    name = LEPUS_ToStringFree(ctx, name);
  if (LEPUS_IsException(name)) return LEPUS_EXCEPTION;

  msg = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_message);
  if (LEPUS_IsUndefined(msg))
    msg = LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string);
  else
    msg = LEPUS_ToStringFree(ctx, msg);
  if (LEPUS_IsException(msg)) {
    LEPUS_FreeValue(ctx, name);
    return LEPUS_EXCEPTION;
  }
  if (!LEPUS_IsEmptyString(name) && !LEPUS_IsEmptyString(msg))
    name = LEPUS_ConcatString3(ctx, "", name, ": ");
  return LEPUS_ConcatString(ctx, name, msg);
}

static const LEPUSCFunctionListEntry lepus_error_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, lepus_error_toString),
    LEPUS_PROP_STRING_DEF("name", "Error",
                          LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
    LEPUS_PROP_STRING_DEF("message", "",
                          LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

/* Array */

QJS_STATIC int LEPUS_CopySubArray(LEPUSContext *ctx, LEPUSValueConst obj,
                                  int64_t to_pos, int64_t from_pos,
                                  int64_t count, int dir) {
  int64_t i, from, to;
  LEPUSValue val;
  int fromPresent;

  /* XXX: should special case fast arrays */
  for (i = 0; i < count; i++) {
    if (dir < 0) {
      from = from_pos + count - i - 1;
      to = to_pos + count - i - 1;
    } else {
      from = from_pos + i;
      to = to_pos + i;
    }
    fromPresent = LEPUS_TryGetPropertyInt64(ctx, obj, from, &val);
    if (fromPresent < 0) goto exception;

    if (fromPresent) {
      if (LEPUS_SetPropertyInt64(ctx, obj, to, val) < 0) goto exception;
    } else {
      if (LEPUS_DeletePropertyInt64(ctx, obj, to, LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  return 0;

exception:
  return -1;
}

QJS_STATIC LEPUSValue lepus_array_constructor(LEPUSContext *ctx,
                                              LEPUSValueConst new_target,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValue obj;
  int i;

  obj = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_ARRAY);
  if (LEPUS_IsException(obj)) return obj;
  if (argc == 1 && LEPUS_IsNumber(argv[0])) {
    uint32_t len;
    if (LEPUS_ToArrayLengthFree(ctx, &len, LEPUS_DupValue(ctx, argv[0]), TRUE))
      goto fail;
    if (LEPUS_SetProperty(ctx, obj, LEPUS_ATOM_length,
                          LEPUS_NewUint32(ctx, len)) < 0)
      goto fail;
  } else {
    for (i = 0; i < argc; i++) {
      if (LEPUS_SetPropertyUint32(ctx, obj, i, LEPUS_DupValue(ctx, argv[i])) <
          0)
        goto fail;
    }
  }
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_from(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  // from(items, mapfn = void 0, this_arg = void 0)
  LEPUSValueConst items = argv[0], mapfn, this_arg;
  LEPUSValueConst args[2];
  LEPUSValue stack[2];
  LEPUSValue iter, r, v, v2, arrayLike;
  int64_t k, len;
  int done, mapping;

  mapping = FALSE;
  mapfn = LEPUS_UNDEFINED;
  this_arg = LEPUS_UNDEFINED;
  r = LEPUS_UNDEFINED;
  arrayLike = LEPUS_UNDEFINED;
  stack[0] = LEPUS_UNDEFINED;
  stack[1] = LEPUS_UNDEFINED;

  if (argc > 1) {
    mapfn = argv[1];
    if (!LEPUS_IsUndefined(mapfn)) {
      if (check_function(ctx, mapfn)) goto exception;
      mapping = 1;
      if (argc > 2) this_arg = argv[2];
    }
  }
  // <bytedance begin>
  items = LEPUSRef2Value(ctx, items);
  // <bytedance end>
  iter = LEPUS_GetProperty(ctx, items, LEPUS_ATOM_Symbol_iterator);
  if (LEPUS_IsException(iter)) goto exception;
  if (!LEPUS_IsUndefined(iter)) {
    LEPUS_FreeValue(ctx, iter);
    if (LEPUS_IsConstructor(ctx, this_val))
      r = LEPUS_CallConstructor(ctx, this_val, 0, NULL);
    else
      r = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(r)) goto exception;
    stack[0] = LEPUS_DupValue(ctx, items);
    if (lepus_for_of_start(ctx, &stack[1], FALSE)) goto exception;
    for (k = 0;; k++) {
      v = LEPUS_IteratorNext(ctx, stack[0], stack[1], 0, NULL, &done);
      if (LEPUS_IsException(v)) goto exception_close;
      if (done) break;
      if (mapping) {
        args[0] = v;
        args[1] = LEPUS_NewInt32(ctx, k);
        v2 = LEPUS_Call(ctx, mapfn, this_arg, 2, args);
        LEPUS_FreeValue(ctx, v);
        v = v2;
        if (LEPUS_IsException(v)) goto exception_close;
      }
      if (LEPUS_DefinePropertyValueInt64(
              ctx, r, k, v, LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
        goto exception_close;
    }
  } else {
    arrayLike = LEPUS_ToObject(ctx, items);
    if (LEPUS_IsException(arrayLike)) goto exception;
    if (lepus_get_length64(ctx, &len, arrayLike) < 0) goto exception;
    v = LEPUS_NewInt64(ctx, len);
    args[0] = v;
    if (LEPUS_IsConstructor(ctx, this_val)) {
      r = LEPUS_CallConstructor(ctx, this_val, 1, args);
    } else {
      r = lepus_array_constructor(ctx, LEPUS_UNDEFINED, 1, args);
    }
    LEPUS_FreeValue(ctx, v);
    if (LEPUS_IsException(r)) goto exception;
    for (k = 0; k < len; k++) {
      v = LEPUS_GetPropertyInt64(ctx, arrayLike, k);
      if (LEPUS_IsException(v)) goto exception;
      if (mapping) {
        args[0] = v;
        args[1] = LEPUS_NewInt32(ctx, k);
        v2 = LEPUS_Call(ctx, mapfn, this_arg, 2, args);
        LEPUS_FreeValue(ctx, v);
        v = v2;
        if (LEPUS_IsException(v)) goto exception;
      }
      if (LEPUS_DefinePropertyValueInt64(
              ctx, r, k, v, LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  if (LEPUS_SetProperty(ctx, r, LEPUS_ATOM_length, LEPUS_NewUint32(ctx, k)) < 0)
    goto exception;
  goto done;

exception_close:
  if (!LEPUS_IsUndefined(stack[0])) LEPUS_IteratorClose(ctx, stack[0], TRUE);
exception:
  LEPUS_FreeValue(ctx, r);
  r = LEPUS_EXCEPTION;
done:
  LEPUS_FreeValue(ctx, arrayLike);
  LEPUS_FreeValue(ctx, stack[0]);
  LEPUS_FreeValue(ctx, stack[1]);
  return r;
}

QJS_STATIC LEPUSValue lepus_array_of(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  LEPUSValue obj, args[1];
  int i;

  if (LEPUS_IsConstructor(ctx, this_val)) {
    args[0] = LEPUS_NewInt32(ctx, argc);
    obj = LEPUS_CallConstructor(ctx, this_val, 1, (LEPUSValueConst *)args);
  } else {
    obj = LEPUS_NewArray(ctx);
  }
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  for (i = 0; i < argc; i++) {
    if (LEPUS_CreateDataPropertyUint32(
            ctx, obj, i, LEPUS_DupValue(ctx, argv[i]), LEPUS_PROP_THROW) < 0) {
      goto fail;
    }
  }
  if (LEPUS_SetProperty(ctx, obj, LEPUS_ATOM_length,
                        LEPUS_NewUint32(ctx, argc)) < 0) {
  fail:
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  return obj;
}

QJS_STATIC LEPUSValue lepus_array_isArray(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  int ret;
  ret = LEPUS_IsArray(ctx, argv[0]);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else {
    if (ret == 0 && ctx && LEPUS_IsLepusRef(argv[0])) {
      ret = LEPUS_LepusRefIsArray(ctx->rt, argv[0]);
    }
    return LEPUS_NewBool(ctx, ret);
  }
}

QJS_STATIC LEPUSValue lepus_get_this(LEPUSContext *ctx,
                                     LEPUSValueConst this_val) {
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue LEPUS_ArraySpeciesCreate(LEPUSContext *ctx,
                                               LEPUSValueConst obj,
                                               LEPUSValueConst len_val) {
  LEPUSValue ctor, ret;
  int res;

  res = LEPUS_IsArray(ctx, obj);
  if (res < 0) return LEPUS_EXCEPTION;
  if (!res) return lepus_array_constructor(ctx, LEPUS_UNDEFINED, 1, &len_val);
  ctor = LEPUS_SpeciesConstructor(ctx, obj, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return LEPUS_EXCEPTION;
  if (LEPUS_IsUndefined(ctor))
    return lepus_array_constructor(ctx, LEPUS_UNDEFINED, 1, &len_val);
  ret = LEPUS_CallConstructor(ctx, ctor, 1, &len_val);
  LEPUS_FreeValue(ctx, ctor);
  return ret;
}

static const LEPUSCFunctionListEntry lepus_array_funcs[] = {
    LEPUS_CFUNC_DEF("isArray", 1, lepus_array_isArray),
    LEPUS_CFUNC_DEF("from", 1, lepus_array_from),
    LEPUS_CFUNC_DEF("of", 0, lepus_array_of),
    LEPUS_CGETSET_DEF("[Symbol.species]", lepus_get_this, NULL),
};

QJS_STATIC int LEPUS_isConcatSpreadable(LEPUSContext *ctx,
                                        LEPUSValueConst obj) {
  LEPUSValue val;

  if (!LEPUS_IsObject(obj)) return FALSE;
  val = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_Symbol_isConcatSpreadable);
  if (LEPUS_IsException(val)) return -1;
  if (!LEPUS_IsUndefined(val)) return LEPUS_ToBoolFree(ctx, val);
  return LEPUS_IsArray(ctx, obj);
}

QJS_STATIC LEPUSValue lepus_array_concat(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValue obj, arr, val;
  LEPUSValueConst e;
  int64_t len, k, n;
  int i, res;

  arr = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) goto exception;

  arr = LEPUS_ArraySpeciesCreate(ctx, obj, LEPUS_NewInt32(ctx, 0));
  if (LEPUS_IsException(arr)) goto exception;
  n = 0;
  for (i = -1; i < argc; i++) {
    if (i < 0) {
      e = obj;
    } else {
      // <bytedance begin>
      e = LEPUSRef2Value(ctx, argv[i]);
      // <bytedance end>
    }

    res = LEPUS_isConcatSpreadable(ctx, e);
    if (res < 0) goto exception;
    if (res) {
      if (lepus_get_length64(ctx, &len, e)) goto exception;
      if (n + len > MAX_SAFE_INTEGER) {
        LEPUS_ThrowTypeError(ctx, "Array loo long");
        goto exception;
      }
      for (k = 0; k < len; k++, n++) {
        res = LEPUS_TryGetPropertyInt64(ctx, e, k, &val);
        if (res < 0) goto exception;
        if (res) {
          if (LEPUS_DefinePropertyValueInt64(
                  ctx, arr, n, val, LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
            goto exception;
        }
      }
    } else {
      if (n >= MAX_SAFE_INTEGER) {
        LEPUS_ThrowTypeError(ctx, "Array loo long");
        goto exception;
      }
      if (LEPUS_DefinePropertyValueInt64(ctx, arr, n, LEPUS_DupValue(ctx, e),
                                         LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) <
          0)
        goto exception;
      n++;
    }
  }
  if (LEPUS_SetProperty(ctx, arr, LEPUS_ATOM_length, LEPUS_NewInt64(ctx, n)) <
      0)
    goto exception;

  LEPUS_FreeValue(ctx, obj);
  return arr;

exception:
  LEPUS_FreeValue(ctx, arr);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

#define special_every 0
#define special_some 1
#define special_forEach 2
#define special_map 3
#define special_filter 4
#define special_TA 8

QJS_STATIC int lepus_typed_array_get_length_internal(LEPUSContext *ctx,
                                                     LEPUSValueConst obj);

QJS_STATIC LEPUSValue
lepus_typed_array___speciesCreate(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv);

QJS_STATIC LEPUSValue lepus_array_every(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv, int special) {
  LEPUSValue obj, val, index_val, res, ret;
  LEPUSValueConst args[3];
  LEPUSValueConst func, this_arg;
  int64_t len, k, n;
  int present;

  ret = LEPUS_UNDEFINED;
  val = LEPUS_UNDEFINED;
  if (special & special_TA) {
    obj = LEPUS_DupValue(ctx, this_val);
    len = lepus_typed_array_get_length_internal(ctx, obj);
    if (len < 0) goto exception;
  } else {
    obj = LEPUS_ToObject(ctx, this_val);
    if (lepus_get_length64(ctx, &len, obj)) goto exception;
  }
  func = argv[0];
  this_arg = LEPUS_UNDEFINED;
  if (argc > 1) this_arg = argv[1];

  if (check_function(ctx, func)) goto exception;

  switch (special) {
    case special_every:
    case special_every | special_TA:
      ret = LEPUS_TRUE;
      break;
    case special_some:
    case special_some | special_TA:
      ret = LEPUS_FALSE;
      break;
    case special_map:
      /* XXX: LEPUS_ArraySpeciesCreate should take int64_t */
      ret = LEPUS_ArraySpeciesCreate(ctx, obj, LEPUS_NewInt64(ctx, len));
      if (LEPUS_IsException(ret)) goto exception;
      break;
    case special_filter:
      ret = LEPUS_ArraySpeciesCreate(ctx, obj, LEPUS_NewInt32(ctx, 0));
      if (LEPUS_IsException(ret)) goto exception;
      break;
    case special_map | special_TA:
      args[0] = obj;
      args[1] = LEPUS_NewInt32(ctx, len);
      ret = lepus_typed_array___speciesCreate(ctx, LEPUS_UNDEFINED, 2, args);
      if (LEPUS_IsException(ret)) goto exception;
      break;
    case special_filter | special_TA:
      ret = LEPUS_NewArray(ctx);
      if (LEPUS_IsException(ret)) goto exception;
      break;
  }
  n = 0;

  for (k = 0; k < len; k++) {
    present = LEPUS_TryGetPropertyInt64(ctx, obj, k, &val);
    if (present < 0) goto exception;
    if (present) {
      index_val = LEPUS_NewInt64(ctx, k);
      if (LEPUS_IsException(index_val)) goto exception;
      // <bytedance begin>
      args[0] = LEPUSRef2Value(ctx, val);
      // <bytedance end>
      args[1] = index_val;
      args[2] = obj;
      res = LEPUS_Call(ctx, func, this_arg, 3, args);
      LEPUS_FreeValue(ctx, index_val);
      if (LEPUS_IsException(res)) goto exception;
      switch (special) {
        case special_every:
        case special_every | special_TA:
          if (!LEPUS_ToBoolFree(ctx, res)) {
            ret = LEPUS_FALSE;
            goto done;
          }
          break;
        case special_some:
        case special_some | special_TA:
          if (LEPUS_ToBoolFree(ctx, res)) {
            ret = LEPUS_TRUE;
            goto done;
          }
          break;
        case special_map:
          if (LEPUS_DefinePropertyValueInt64(
                  ctx, ret, k, res, LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
            goto exception;
          break;
        case special_map | special_TA:
          if (LEPUS_SetPropertyValue(ctx, ret, LEPUS_NewInt32(ctx, k), res,
                                     LEPUS_PROP_THROW) < 0)
            goto exception;
          break;
        case special_filter:
        case special_filter | special_TA:
          if (LEPUS_ToBoolFree(ctx, res)) {
            if (LEPUS_DefinePropertyValueInt64(
                    ctx, ret, n++, LEPUS_DupValue(ctx, val),
                    LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
              goto exception;
          }
          break;
        default:
          LEPUS_FreeValue(ctx, res);
          break;
      }
      LEPUS_FreeValue(ctx, val);
      val = LEPUS_UNDEFINED;
    }
  }
done:
  if (special == (special_filter | special_TA)) {
    LEPUSValue arr;
    args[0] = obj;
    args[1] = LEPUS_NewInt32(ctx, n);
    arr = lepus_typed_array___speciesCreate(ctx, LEPUS_UNDEFINED, 2, args);
    if (LEPUS_IsException(arr)) goto exception;
    args[0] = ret;
    res = LEPUS_Invoke(ctx, arr, LEPUS_ATOM_set, 1, args);
    if (check_exception_free(ctx, res)) goto exception;
    LEPUS_FreeValue(ctx, ret);
    ret = arr;
  }
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return ret;

exception:
  LEPUS_FreeValue(ctx, ret);
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

#define special_reduce 0
#define special_reduceRight 1

QJS_STATIC LEPUSValue lepus_array_reduce(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv, int special) {
  LEPUSValue obj, val, index_val, acc, acc1;
  LEPUSValueConst args[4];
  LEPUSValueConst func;
  int64_t len, k, k1;
  int present;

  acc = LEPUS_UNDEFINED;
  val = LEPUS_UNDEFINED;
  if (special & special_TA) {
    obj = LEPUS_DupValue(ctx, this_val);
    len = lepus_typed_array_get_length_internal(ctx, obj);
    if (len < 0) goto exception;
  } else {
    obj = LEPUS_ToObject(ctx, this_val);
    if (lepus_get_length64(ctx, &len, obj)) goto exception;
  }
  func = argv[0];

  if (check_function(ctx, func)) goto exception;

  k = 0;
  if (argc > 1) {
    acc = LEPUS_DupValue(ctx, argv[1]);
  } else {
    for (;;) {
      if (k >= len) {
        LEPUS_ThrowTypeError(ctx, "empty array");
        goto exception;
      }
      k1 = (special & special_reduceRight) ? len - k - 1 : k;
      k++;
      present = LEPUS_TryGetPropertyInt64(ctx, obj, k1, &acc);
      if (present < 0) goto exception;
      if (present) break;
    }
  }
  for (; k < len; k++) {
    k1 = (special & special_reduceRight) ? len - k - 1 : k;
    present = LEPUS_TryGetPropertyInt64(ctx, obj, k1, &val);
    if (present < 0) goto exception;
    if (present) {
      index_val = LEPUS_NewInt64(ctx, k1);
      if (LEPUS_IsException(index_val)) goto exception;
      args[0] = acc;
      // <bytedance begin>
      args[1] = LEPUSRef2Value(ctx, val);
      // <bytedance end>
      args[2] = index_val;
      args[3] = obj;
      acc1 = LEPUS_Call(ctx, func, LEPUS_UNDEFINED, 4, args);
      LEPUS_FreeValue(ctx, index_val);
      LEPUS_FreeValue(ctx, val);
      val = LEPUS_UNDEFINED;
      if (LEPUS_IsException(acc1)) goto exception;
      LEPUS_FreeValue(ctx, acc);
      acc = acc1;
    }
  }
  LEPUS_FreeValue(ctx, obj);
  return acc;

exception:
  LEPUS_FreeValue(ctx, acc);
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_fill(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue obj;
  int64_t len, start, end;

  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;

  start = 0;
  if (argc > 1 && !LEPUS_IsUndefined(argv[1])) {
    if (LEPUS_ToInt64Clamp(ctx, &start, argv[1], 0, len, len)) goto exception;
  }

  end = len;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (LEPUS_ToInt64Clamp(ctx, &end, argv[2], 0, len, len)) goto exception;
  }

  /* XXX: should special case fast arrays */
  while (start < end) {
    if (LEPUS_SetPropertyInt64(ctx, obj, start, LEPUS_DupValue(ctx, argv[0])) <
        0)
      goto exception;
    start++;
  }
  return obj;

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_includes(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValue obj, val;
  int64_t len, n, res;
  LEPUSValue *arrp;
  uint32_t count;

  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;

  res = FALSE;
  if (len > 0) {
    n = 0;
    if (argc > 1) {
      if (LEPUS_ToInt64Clamp(ctx, &n, argv[1], 0, len, len)) goto exception;
    }
    if (lepus_get_fast_array(ctx, obj, &arrp, &count)) {
      for (; n < count; n++) {
        if (lepus_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]),
                             LEPUS_DupValue(ctx, arrp[n]),
                             LEPUS_EQ_SAME_VALUE_ZERO)) {
          res = TRUE;
          goto done;
        }
      }
    }
    for (; n < len; n++) {
      val = LEPUS_GetPropertyInt64(ctx, obj, n);
      if (LEPUS_IsException(val)) goto exception;
      if (lepus_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]), val,
                           LEPUS_EQ_SAME_VALUE_ZERO)) {
        res = TRUE;
        break;
      }
    }
  }
done:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_NewBool(ctx, res);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_indexOf(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue obj, val;
  int64_t len, n, res;
  LEPUSValue *arrp;
  uint32_t count;

  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;

  res = -1;
  if (len > 0) {
    n = 0;
    if (argc > 1) {
      if (LEPUS_ToInt64Clamp(ctx, &n, argv[1], 0, len, len)) goto exception;
    }
    if (lepus_get_fast_array(ctx, obj, &arrp, &count)) {
      for (; n < count; n++) {
        if (lepus_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]),
                             LEPUS_DupValue(ctx, arrp[n]), LEPUS_EQ_STRICT)) {
          res = n;
          goto done;
        }
      }
    }
    for (; n < len; n++) {
      int present = LEPUS_TryGetPropertyInt64(ctx, obj, n, &val);
      if (present < 0) goto exception;
      if (present) {
        if (lepus_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]), val,
                             LEPUS_EQ_STRICT)) {
          res = n;
          break;
        }
      }
    }
  }
done:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_NewInt64(ctx, res);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_lastIndexOf(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValue obj, val;
  int64_t len, n, res;
  int present;

  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;

  res = -1;
  if (len > 0) {
    n = len - 1;
    if (argc > 1) {
      if (LEPUS_ToInt64Clamp(ctx, &n, argv[1], -1, len - 1, len))
        goto exception;
    }
    /* XXX: should special case fast arrays */
    for (; n >= 0; n--) {
      present = LEPUS_TryGetPropertyInt64(ctx, obj, n, &val);
      if (present < 0) goto exception;
      if (present) {
        if (lepus_strict_eq2(ctx, LEPUS_DupValue(ctx, argv[0]), val,
                             LEPUS_EQ_STRICT)) {
          res = n;
          break;
        }
      }
    }
  }
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_NewInt64(ctx, res);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_find(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv, int findIndex) {
  LEPUSValueConst func, this_arg;
  LEPUSValueConst args[3];
  LEPUSValue obj, val, index_val, res;
  int64_t len, k;

  index_val = LEPUS_UNDEFINED;
  val = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;

  func = argv[0];
  if (check_function(ctx, func)) goto exception;

  this_arg = LEPUS_UNDEFINED;
  if (argc > 1) this_arg = argv[1];

  for (k = 0; k < len; k++) {
    index_val = LEPUS_NewInt64(ctx, k);
    if (LEPUS_IsException(index_val)) goto exception;
    val = LEPUS_GetPropertyValue(ctx, obj, index_val);
    if (LEPUS_IsException(val)) goto exception;
    args[0] = val;
    args[1] = index_val;
    args[2] = this_val;
    res = LEPUS_Call(ctx, func, this_arg, 3, args);
    if (LEPUS_IsException(res)) goto exception;
    if (LEPUS_ToBoolFree(ctx, res)) {
      if (findIndex) {
        LEPUS_FreeValue(ctx, val);
        LEPUS_FreeValue(ctx, obj);
        return index_val;
      } else {
        LEPUS_FreeValue(ctx, index_val);
        LEPUS_FreeValue(ctx, obj);
        return val;
      }
    }
    LEPUS_FreeValue(ctx, val);
    LEPUS_FreeValue(ctx, index_val);
  }
  LEPUS_FreeValue(ctx, obj);
  if (findIndex)
    return LEPUS_NewInt32(ctx, -1);
  else
    return LEPUS_UNDEFINED;

exception:
  LEPUS_FreeValue(ctx, index_val);
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_toString(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValue obj, method, ret;

  obj = LEPUS_ToObject(ctx, this_val);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  method = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_join);
  if (LEPUS_IsException(method)) {
    ret = LEPUS_EXCEPTION;
  } else if (!LEPUS_IsFunction(ctx, method)) {
    /* Use intrinsic Object.prototype.toString */
    LEPUS_FreeValue(ctx, method);
    ret = lepus_object_toString(ctx, obj, 0, NULL);
  } else {
    ret = LEPUS_CallFree(ctx, method, obj, 0, NULL);
  }
  LEPUS_FreeValue(ctx, obj);
  return ret;
}

QJS_STATIC LEPUSValue lepus_array_join(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv,
                                       int toLocaleString) {
  LEPUSValue obj, sep = LEPUS_UNDEFINED, el;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *p = NULL;
  int64_t i, n;
  int c;

  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &n, obj)) goto exception;

  c = ','; /* default separator */
  if (!toLocaleString && argc > 0 && !LEPUS_IsUndefined(argv[0])) {
    sep = LEPUS_ToString(ctx, argv[0]);
    if (LEPUS_IsException(sep)) goto exception;
    p = LEPUS_VALUE_GET_STRING(sep);
    if (p->len == 1 && !p->is_wide_char)
      c = p->u.str8[0];
    else
      c = -1;
  }
  string_buffer_init(ctx, b, 0);

  for (i = 0; i < n; i++) {
    if (i > 0) {
      if (c >= 0) {
        string_buffer_putc8(b, c);
      } else {
        string_buffer_concat(b, p, 0, p->len);
      }
    }
    el = LEPUS_GetPropertyUint32(ctx, obj, i);
    if (LEPUS_IsException(el)) goto fail;
    if (!LEPUS_IsNull(el) && !LEPUS_IsUndefined(el)) {
      if (toLocaleString) {
        el = LEPUS_ToLocaleStringFree(ctx, el);
      }
      if (string_buffer_concat_value_free(b, el)) goto fail;
    }
  }
  LEPUS_FreeValue(ctx, sep);
  LEPUS_FreeValue(ctx, obj);
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
  LEPUS_FreeValue(ctx, sep);
exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_pop(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv, int shift) {
  LEPUSValue obj, res = LEPUS_UNDEFINED;
  int64_t len, newLen;
  LEPUSValue *arrp;
  uint32_t count32;

  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;
  newLen = 0;
  if (len > 0) {
    newLen = len - 1;
    /* Special case fast arrays */
    if (lepus_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
      if (shift) {
        res = arrp[0];
        memmove(arrp, arrp + 1, (count32 - 1) * sizeof(*arrp));
        p->u.array.count--;
      } else {
        res = arrp[count32 - 1];
        p->u.array.count--;
      }
    } else {
      if (shift) {
        res = LEPUS_GetPropertyInt64(ctx, obj, 0);
        if (LEPUS_IsException(res)) goto exception;
        if (LEPUS_CopySubArray(ctx, obj, 0, 1, len - 1, +1)) goto exception;
      } else {
        res = LEPUS_GetPropertyInt64(ctx, obj, newLen);
        if (LEPUS_IsException(res)) goto exception;
      }
      if (LEPUS_DeletePropertyInt64(ctx, obj, newLen, LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  if (LEPUS_SetProperty(ctx, obj, LEPUS_ATOM_length,
                        LEPUS_NewInt64(ctx, newLen)) < 0)
    goto exception;

  LEPUS_FreeValue(ctx, obj);
  return res;

exception:
  LEPUS_FreeValue(ctx, res);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_push(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv, int unshift) {
  LEPUSValue obj;
  int i;
  int64_t len, from, newLen;

  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;
  newLen = len + argc;
  if (newLen > MAX_SAFE_INTEGER) {
    LEPUS_ThrowTypeError(ctx, "Array loo long");
    goto exception;
  }
  from = len;
  if (unshift && argc > 0) {
    if (LEPUS_CopySubArray(ctx, obj, argc, 0, len, -1)) goto exception;
    from = 0;
  }
  for (i = 0; i < argc; i++) {
    if (LEPUS_SetPropertyInt64(ctx, obj, from + i,
                               LEPUS_DupValue(ctx, argv[i])) < 0)
      goto exception;
  }
  if (LEPUS_SetProperty(ctx, obj, LEPUS_ATOM_length,
                        LEPUS_NewInt64(ctx, newLen)) < 0)
    goto exception;

  LEPUS_FreeValue(ctx, obj);
  return LEPUS_NewInt64(ctx, newLen);

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_reverse(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue obj, lval, hval;
  LEPUSValue *arrp;
  int64_t len, l, h;
  int l_present, h_present;
  uint32_t count32;

  lval = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;

  /* Special case fast arrays */
  if (lepus_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
    uint32_t ll, hh;

    if (count32 > 1) {
      for (ll = 0, hh = count32 - 1; ll < hh; ll++, hh--) {
        lval = arrp[ll];
        arrp[ll] = arrp[hh];
        arrp[hh] = lval;
      }
    }
    return obj;
  }

  for (l = 0, h = len - 1; l < h; l++, h--) {
    l_present = LEPUS_TryGetPropertyInt64(ctx, obj, l, &lval);
    if (l_present < 0) goto exception;
    h_present = LEPUS_TryGetPropertyInt64(ctx, obj, h, &hval);
    if (h_present < 0) goto exception;
    if (h_present) {
      if (LEPUS_SetPropertyInt64(ctx, obj, l, hval) < 0) goto exception;

      if (l_present) {
        if (LEPUS_SetPropertyInt64(ctx, obj, h, lval) < 0) {
          lval = LEPUS_UNDEFINED;
          goto exception;
        }
        lval = LEPUS_UNDEFINED;
      } else {
        if (LEPUS_DeletePropertyInt64(ctx, obj, h, LEPUS_PROP_THROW) < 0)
          goto exception;
      }
    } else {
      if (l_present) {
        if (LEPUS_DeletePropertyInt64(ctx, obj, l, LEPUS_PROP_THROW) < 0)
          goto exception;
        if (LEPUS_SetPropertyInt64(ctx, obj, h, lval) < 0) {
          lval = LEPUS_UNDEFINED;
          goto exception;
        }
        lval = LEPUS_UNDEFINED;
      }
    }
  }
  return obj;

exception:
  LEPUS_FreeValue(ctx, lval);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_slice(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv, int splice) {
  LEPUSValue obj, arr, val, len_val;
  int64_t len, start, k, final, n, count, del_count, new_len;
  int kPresent;
  LEPUSValue *arrp;
  uint32_t count32, i, item_count;

  arr = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;

  if (LEPUS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len)) goto exception;

  if (splice) {
    if (argc == 0) {
      item_count = 0;
      del_count = 0;
    } else if (argc == 1) {
      item_count = 0;
      del_count = len - start;
    } else {
      item_count = argc - 2;
      if (LEPUS_ToInt64Clamp(ctx, &del_count, argv[1], 0, len - start, 0))
        goto exception;
    }
    if (len + item_count - del_count > MAX_SAFE_INTEGER) {
      LEPUS_ThrowTypeError(ctx, "Array loo long");
      goto exception;
    }
    count = del_count;
  } else {
    item_count = 0; /* avoid warning */
    final = len;
    if (!LEPUS_IsUndefined(argv[1])) {
      if (LEPUS_ToInt64Clamp(ctx, &final, argv[1], 0, len, len)) goto exception;
    }
    count = max_int64(final - start, 0);
  }
  len_val = LEPUS_NewInt64(ctx, count);
  arr = LEPUS_ArraySpeciesCreate(ctx, obj, len_val);
  LEPUS_FreeValue(ctx, len_val);
  if (LEPUS_IsException(arr)) goto exception;

  k = start;
  final = start + count;
  n = 0;
  /* The fast array test on arr ensures that
     LEPUS_CreateDataPropertyUint32() won't modify obj in case arr is
     an exotic object */
  /* Special case fast arrays */
  if (lepus_get_fast_array(ctx, obj, &arrp, &count32) &&
      lepus_is_fast_array(ctx, arr)) {
    /* XXX: should share code with fast array constructor */
    for (; k < final && k < count32; k++, n++) {
      if (LEPUS_CreateDataPropertyUint32(
              ctx, arr, n, LEPUS_DupValue(ctx, arrp[k]), LEPUS_PROP_THROW) < 0)
        goto exception;
    }
  }
  /* Copy the remaining elements if any (handle case of inherited properties) */
  for (; k < final; k++, n++) {
    kPresent = LEPUS_TryGetPropertyInt64(ctx, obj, k, &val);
    if (kPresent < 0) goto exception;
    if (kPresent) {
      if (LEPUS_CreateDataPropertyUint32(ctx, arr, n, val, LEPUS_PROP_THROW) <
          0)
        goto exception;
    }
  }
  if (LEPUS_SetProperty(ctx, arr, LEPUS_ATOM_length, LEPUS_NewInt64(ctx, n)) <
      0)
    goto exception;

  if (splice) {
    new_len = len + item_count - del_count;
    if (item_count != del_count) {
      if (LEPUS_CopySubArray(ctx, obj, start + item_count, start + del_count,
                             len - (start + del_count),
                             item_count <= del_count ? +1 : -1) < 0)
        goto exception;

      for (k = len; k-- > new_len;) {
        if (LEPUS_DeletePropertyInt64(ctx, obj, k, LEPUS_PROP_THROW) < 0)
          goto exception;
      }
    }
    for (i = 0; i < item_count; i++) {
      int j = i;
      if (LEPUS_SetPropertyInt64(ctx, obj, start + i,
                                 LEPUS_DupValue(ctx, argv[j + 2])) < 0)
        goto exception;
    }
    if (LEPUS_SetProperty(ctx, obj, LEPUS_ATOM_length,
                          LEPUS_NewInt64(ctx, new_len)) < 0)
      goto exception;
  }
  LEPUS_FreeValue(ctx, obj);
  return arr;

exception:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_copyWithin(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  LEPUSValue obj;
  int64_t len, from, to, final, count;

  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;

  if (LEPUS_ToInt64Clamp(ctx, &to, argv[0], 0, len, len)) goto exception;

  if (LEPUS_ToInt64Clamp(ctx, &from, argv[1], 0, len, len)) goto exception;

  final = len;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (LEPUS_ToInt64Clamp(ctx, &final, argv[2], 0, len, len)) goto exception;
  }

  count = min_int64(final - from, len - to);

  if (LEPUS_CopySubArray(ctx, obj, to, from, count,
                         (from < to && to < from + count) ? -1 : +1))
    goto exception;

  return obj;

exception:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC int64_t LEPUS_FlattenIntoArray(
    LEPUSContext *ctx, LEPUSValueConst target, LEPUSValueConst source,
    int64_t sourceLen, int64_t targetIndex, int depth,
    LEPUSValueConst mapperFunction, LEPUSValueConst thisArg) {
  LEPUSValue element;
  int64_t sourceIndex, elementLen;
  int present, is_array;

  for (sourceIndex = 0; sourceIndex < sourceLen; sourceIndex++) {
    present = LEPUS_TryGetPropertyInt64(ctx, source, sourceIndex, &element);
    if (present < 0) return -1;
    if (!present) continue;
    if (!LEPUS_IsUndefined(mapperFunction)) {
      LEPUSValueConst args[3] = {element, LEPUS_NewInt64(ctx, sourceIndex),
                                 source};
      element = LEPUS_Call(ctx, mapperFunction, thisArg, 3, args);
      LEPUS_FreeValue(ctx, (LEPUSValue)args[0]);
      LEPUS_FreeValue(ctx, (LEPUSValue)args[1]);
      if (LEPUS_IsException(element)) return -1;
    }
    if (depth > 0) {
      is_array = LEPUS_IsArray(ctx, element);
      if (is_array < 0) goto fail;
      if (is_array) {
        if (lepus_get_length64(ctx, &elementLen, element) < 0) goto fail;
        targetIndex = LEPUS_FlattenIntoArray(ctx, target, element, elementLen,
                                             targetIndex, depth - 1,
                                             LEPUS_UNDEFINED, LEPUS_UNDEFINED);
        if (targetIndex < 0) goto fail;
        LEPUS_FreeValue(ctx, element);
        continue;
      }
    }
    if (targetIndex >= MAX_SAFE_INTEGER) {
      LEPUS_ThrowTypeError(ctx, "Array too long");
      goto fail;
    }
    if (LEPUS_DefinePropertyValueInt64(ctx, target, targetIndex, element,
                                       LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
      return -1;
    targetIndex++;
  }
  return targetIndex;

fail:
  LEPUS_FreeValue(ctx, element);
  return -1;
}

QJS_STATIC LEPUSValue lepus_array_flatten(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv, int map) {
  LEPUSValue obj, arr;
  LEPUSValueConst mapperFunction, thisArg;
  int64_t sourceLen;
  int depthNum;

  arr = LEPUS_UNDEFINED;
  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &sourceLen, obj)) goto exception;

  depthNum = 1;
  mapperFunction = LEPUS_UNDEFINED;
  thisArg = LEPUS_UNDEFINED;
  if (map) {
    mapperFunction = argv[0];
    if (argc > 1) {
      thisArg = argv[1];
    }
    if (check_function(ctx, mapperFunction)) goto exception;
  } else {
    if (argc > 0 && !LEPUS_IsUndefined(argv[0])) {
      if (LEPUS_ToInt32Sat(ctx, &depthNum, argv[0]) < 0) goto exception;
    }
  }
  arr = LEPUS_ArraySpeciesCreate(ctx, obj, LEPUS_NewInt32(ctx, 0));
  if (LEPUS_IsException(arr)) goto exception;
  if (LEPUS_FlattenIntoArray(ctx, arr, obj, sourceLen, 0, depthNum,
                             mapperFunction, thisArg) < 0)
    goto exception;
  LEPUS_FreeValue(ctx, obj);
  return arr;

exception:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

/* Array sort */

typedef struct ValueSlot {
  LEPUSValue val;
  LEPUSString *str;
  int64_t pos;
} ValueSlot;

struct array_sort_context {
  LEPUSContext *ctx;
  int exception;
  int has_method;
  LEPUSValueConst method;
};

QJS_STATIC int lepus_array_cmp_generic(const void *a, const void *b,
                                       void *opaque) {
  struct array_sort_context *psc =
      static_cast<struct array_sort_context *>(opaque);
  LEPUSContext *ctx = psc->ctx;
  LEPUSValueConst argv[2];
  LEPUSValue res;
  ValueSlot *ap = (ValueSlot *)(void *)a;
  ValueSlot *bp = (ValueSlot *)(void *)b;
  int cmp;

  if (psc->exception) return 0;

  if (psc->has_method) {
    /* custom sort function is specified as returning 0 for identical
     * objects: avoid method call overhead.
     */
    if (!memcmp(&ap->val, &bp->val, sizeof(ap->val))) goto cmp_same;
    argv[0] = ap->val;
    argv[1] = bp->val;
    res = LEPUS_Call(ctx, psc->method, LEPUS_UNDEFINED, 2, argv);
    if (LEPUS_IsException(res)) goto exception;
    if (LEPUS_VALUE_IS_INT(res)) {
      int val = LEPUS_VALUE_GET_INT(res);
      cmp = (val > 0) - (val < 0);
    } else {
      double val;
      if (LEPUS_ToFloat64Free(ctx, &val, res) < 0) goto exception;
      cmp = (val > 0) - (val < 0);
    }
  } else {
    /* Not supposed to bypass ToString even for identical objects as
     * tested in test262/test/built-ins/Array/prototype/sort/bug_596_1.lepus
     */
    if (!ap->str) {
      LEPUSValue str = LEPUS_ToString(ctx, ap->val);
      if (LEPUS_IsException(str)) goto exception;
      ap->str = LEPUS_VALUE_GET_STRING(str);
    }
    if (!bp->str) {
      LEPUSValue str = LEPUS_ToString(ctx, bp->val);
      if (LEPUS_IsException(str)) goto exception;
      bp->str = LEPUS_VALUE_GET_STRING(str);
    }
    cmp = lepus_string_compare(ctx, ap->str, bp->str);
  }
  if (cmp != 0) return cmp;
cmp_same:
  /* make sort stable: compare array offsets */
  return (ap->pos > bp->pos) - (ap->pos < bp->pos);

exception:
  psc->exception = 1;
  return 0;
}

QJS_STATIC LEPUSValue lepus_array_sort(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  struct array_sort_context asc = {ctx, 0, 0, argv[0]};
  LEPUSValue obj = LEPUS_UNDEFINED;
  ValueSlot *array = NULL;
  size_t array_size = 0, pos = 0, n = 0;
  int64_t i, len, undefined_count = 0;
  int present;

  if (!LEPUS_IsUndefined(asc.method)) {
    if (check_function(ctx, asc.method)) goto exception;
    asc.has_method = 1;
  }
  obj = LEPUS_ToObject(ctx, this_val);
  if (lepus_get_length64(ctx, &len, obj)) goto exception;

  /* XXX: should special case fast arrays */
  for (i = 0; i < len; i++) {
    if (pos >= array_size) {
      size_t new_size, slack;
      ValueSlot *new_array;
      new_size = (array_size + (array_size >> 1) + 31) & ~15;
      new_array = static_cast<ValueSlot *>(
          lepus_realloc2(ctx, array, new_size * sizeof(*array), &slack));
      if (new_array == NULL) goto exception;
      new_size += slack / sizeof(*new_array);
      array = new_array;
      array_size = new_size;
    }
    present = LEPUS_TryGetPropertyInt64(ctx, obj, i, &array[pos].val);
    if (present < 0) goto exception;
    if (present == 0) continue;
    if (LEPUS_IsUndefined(array[pos].val)) {
      undefined_count++;
      continue;
    }
    array[pos].str = NULL;
    array[pos].pos = i;
    pos++;
  }
  rqsort(array, pos, sizeof(*array), lepus_array_cmp_generic, &asc);
  if (asc.exception) goto exception;

  /* XXX: should special case fast arrays */
  while (n < pos) {
    if (array[n].str)
      LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, array[n].str));
    if (array[n].pos == n) {
      LEPUS_FreeValue(ctx, array[n].val);
    } else {
      if (LEPUS_SetPropertyInt64(ctx, obj, n, array[n].val) < 0) {
        n++;
        goto exception;
      }
    }
    n++;
  }
  lepus_free(ctx, array);
  for (i = n; undefined_count-- > 0; i++) {
    if (LEPUS_SetPropertyInt64(ctx, obj, i, LEPUS_UNDEFINED) < 0) goto fail;
  }
  for (; i < len; i++) {
    if (LEPUS_DeletePropertyInt64(ctx, obj, i, LEPUS_PROP_THROW) < 0) goto fail;
  }
  return obj;

exception:
  for (; n < pos; n++) {
    LEPUS_FreeValue(ctx, array[n].val);
    if (array[n].str)
      LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, array[n].str));
  }
  lepus_free(ctx, array);
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

typedef struct LEPUSArrayIteratorData {
  LEPUSValue obj;
  LEPUSIteratorKindEnum kind;
  uint32_t idx;
} LEPUSArrayIteratorData;

QJS_STATIC void lepus_array_iterator_finalizer(LEPUSRuntime *rt,
                                               LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSArrayIteratorData *it = p->u.array_iterator_data;
  if (it) {
    LEPUS_FreeValueRT(rt, it->obj);
    lepus_free_rt(rt, it);
  }
}

QJS_STATIC void lepus_array_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                          LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSArrayIteratorData *it = p->u.array_iterator_data;
  if (it) {
    LEPUS_MarkValue(rt, it->obj, mark_func);
  }
}

QJS_STATIC LEPUSValue lepus_create_array(LEPUSContext *ctx, int len,
                                         LEPUSValueConst *tab) {
  LEPUSValue obj;
  int i;

  obj = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  for (i = 0; i < len; i++) {
    if (LEPUS_CreateDataPropertyUint32(ctx, obj, i, LEPUS_DupValue(ctx, tab[i]),
                                       0) < 0) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
  }
  return obj;
}

QJS_STATIC LEPUSValue lepus_create_array_iterator(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv,
                                                  int magic) {
  LEPUSValue enum_obj, arr;
  LEPUSArrayIteratorData *it;
  LEPUSIteratorKindEnum kind;
  int class_id;

  kind = static_cast<LEPUSIteratorKindEnum>(magic & 3);
  if (magic & 4) {
    /* string iterator case */
    arr = LEPUS_ToStringCheckObject(ctx, this_val);
    class_id = LEPUS_CLASS_STRING_ITERATOR;
  } else {
    arr = LEPUS_ToObject(ctx, this_val);
    class_id = LEPUS_CLASS_ARRAY_ITERATOR;
  }
  if (LEPUS_IsException(arr)) goto fail;
  enum_obj = LEPUS_NewObjectClass(ctx, class_id);
  if (LEPUS_IsException(enum_obj)) goto fail;
  it = static_cast<LEPUSArrayIteratorData *>(lepus_malloc(ctx, sizeof(*it)));
  if (!it) goto fail1;
  it->obj = arr;
  it->kind = kind;
  it->idx = 0;
  LEPUS_SetOpaque(enum_obj, it);
  return enum_obj;
fail1:
  LEPUS_FreeValue(ctx, enum_obj);
fail:
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_array_iterator_next(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc, LEPUSValueConst *argv,
                                                BOOL *pdone, int magic) {
  LEPUSArrayIteratorData *it;
  uint32_t len, idx;
  LEPUSValue val, obj;
  LEPUSObject *p;

  it = static_cast<LEPUSArrayIteratorData *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_ARRAY_ITERATOR));
  if (!it) goto fail1;
  if (LEPUS_IsUndefined(it->obj)) goto done;
  p = LEPUS_VALUE_GET_OBJ(it->obj);
  if (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
      p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
    if (typed_array_is_detached(ctx, p)) {
      LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
      goto fail1;
    }
    len = p->u.array.count;
  } else {
    if (lepus_get_length32(ctx, &len, it->obj)) {
    fail1:
      *pdone = FALSE;
      return LEPUS_EXCEPTION;
    }
  }
  idx = it->idx;
  if (idx >= len) {
    LEPUS_FreeValue(ctx, it->obj);
    it->obj = LEPUS_UNDEFINED;
  done:
    *pdone = TRUE;
    return LEPUS_UNDEFINED;
  }
  it->idx = idx + 1;
  *pdone = FALSE;
  if (it->kind == LEPUS_ITERATOR_KIND_KEY) {
    return LEPUS_NewUint32(ctx, idx);
  } else {
    val = LEPUS_GetPropertyUint32(ctx, it->obj, idx);
    if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
    if (it->kind == LEPUS_ITERATOR_KIND_VALUE) {
      return val;
    } else {
      LEPUSValueConst args[2];
      LEPUSValue num;
      num = LEPUS_NewUint32(ctx, idx);
      args[0] = num;
      args[1] = val;
      obj = lepus_create_array(ctx, 2, args);
      LEPUS_FreeValue(ctx, val);
      LEPUS_FreeValue(ctx, num);
      return obj;
    }
  }
}

QJS_STATIC LEPUSValue lepus_iterator_proto_iterator(LEPUSContext *ctx,
                                                    LEPUSValueConst this_val,
                                                    int argc,
                                                    LEPUSValueConst *argv) {
  return LEPUS_DupValue(ctx, this_val);
}

static const LEPUSCFunctionListEntry lepus_iterator_proto_funcs[] = {
    LEPUS_CFUNC_DEF("[Symbol.iterator]", 0, lepus_iterator_proto_iterator),
};

static const LEPUSCFunctionListEntry lepus_array_proto_funcs[] = {
    LEPUS_CFUNC_DEF("concat", 1, lepus_array_concat),
    LEPUS_CFUNC_MAGIC_DEF("every", 1, lepus_array_every, special_every),
    LEPUS_CFUNC_MAGIC_DEF("some", 1, lepus_array_every, special_some),
    LEPUS_CFUNC_MAGIC_DEF("forEach", 1, lepus_array_every, special_forEach),
    LEPUS_CFUNC_MAGIC_DEF("map", 1, lepus_array_every, special_map),
    LEPUS_CFUNC_MAGIC_DEF("filter", 1, lepus_array_every, special_filter),
    LEPUS_CFUNC_MAGIC_DEF("reduce", 1, lepus_array_reduce, special_reduce),
    LEPUS_CFUNC_MAGIC_DEF("reduceRight", 1, lepus_array_reduce,
                          special_reduceRight),
    LEPUS_CFUNC_DEF("fill", 1, lepus_array_fill),
    LEPUS_CFUNC_MAGIC_DEF("find", 1, lepus_array_find, 0),
    LEPUS_CFUNC_MAGIC_DEF("findIndex", 1, lepus_array_find, 1),
    LEPUS_CFUNC_DEF("indexOf", 1, lepus_array_indexOf),
    LEPUS_CFUNC_DEF("lastIndexOf", 1, lepus_array_lastIndexOf),
    LEPUS_CFUNC_DEF("includes", 1, lepus_array_includes),
    LEPUS_CFUNC_MAGIC_DEF("join", 1, lepus_array_join, 0),
    LEPUS_CFUNC_DEF("toString", 0, lepus_array_toString),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, lepus_array_join, 1),
    LEPUS_CFUNC_MAGIC_DEF("pop", 0, lepus_array_pop, 0),
    LEPUS_CFUNC_MAGIC_DEF("push", 1, lepus_array_push, 0),
    LEPUS_CFUNC_MAGIC_DEF("shift", 0, lepus_array_pop, 1),
    LEPUS_CFUNC_MAGIC_DEF("unshift", 1, lepus_array_push, 1),
    LEPUS_CFUNC_DEF("reverse", 0, lepus_array_reverse),
    LEPUS_CFUNC_DEF("sort", 1, lepus_array_sort),
    LEPUS_CFUNC_MAGIC_DEF("slice", 2, lepus_array_slice, 0),
    LEPUS_CFUNC_MAGIC_DEF("splice", 2, lepus_array_slice, 1),
    LEPUS_CFUNC_DEF("copyWithin", 2, lepus_array_copyWithin),
    LEPUS_CFUNC_MAGIC_DEF("flatMap", 1, lepus_array_flatten, 1),
    LEPUS_CFUNC_MAGIC_DEF("flat", 0, lepus_array_flatten, 0),
    LEPUS_CFUNC_MAGIC_DEF("flatten", 0, lepus_array_flatten, 0),
    LEPUS_CFUNC_MAGIC_DEF("values", 0, lepus_create_array_iterator,
                          LEPUS_ITERATOR_KIND_VALUE),
    LEPUS_ALIAS_DEF("[Symbol.iterator]", "values"),
    LEPUS_CFUNC_MAGIC_DEF("keys", 0, lepus_create_array_iterator,
                          LEPUS_ITERATOR_KIND_KEY),
    LEPUS_CFUNC_MAGIC_DEF("entries", 0, lepus_create_array_iterator,
                          LEPUS_ITERATOR_KIND_KEY_AND_VALUE),
};

static const LEPUSCFunctionListEntry lepus_array_iterator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 0, lepus_array_iterator_next, 0),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Array Iterator",
                          LEPUS_PROP_CONFIGURABLE),
};

/* Number */

QJS_STATIC LEPUSValue lepus_number_constructor(LEPUSContext *ctx,
                                               LEPUSValueConst new_target,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue val, obj;
#ifdef CONFIG_BIGNUM
  if (argc == 0) {
    if (is_bignum_mode(ctx))
      val = __JS_NewFloat64(ctx, 0);
    else
      val = LEPUS_NewInt32(ctx, 0);
  } else {
    val = LEPUS_ToNumeric(ctx, argv[0]);
    if (LEPUS_IsException(val)) return val;
    switch (LEPUS_VALUE_GET_TAG(val)) {
      case LEPUS_TAG_BIG_INT:
      case LEPUS_TAG_BIG_FLOAT: {
        LEPUSBigFloat *p =
            static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
        double d;
        bf_get_float64(&p->num, &d, BF_RNDN);
        LEPUS_FreeValue(ctx, val);
        val = __JS_NewFloat64(ctx, d);
      } break;
      case LEPUS_TAG_INT:
        if (is_bignum_mode(ctx)) {
          /* always return a number in bignum mode */
          val = __JS_NewFloat64(ctx, LEPUS_VALUE_GET_INT(val));
        }
        break;
      default:
        break;
    }
  }
#else
  if (argc == 0) {
    val = LEPUS_NewInt32(ctx, 0);
  } else {
    val = LEPUS_ToNumber(ctx, argv[0]);
    if (LEPUS_IsException(val)) return val;
  }
#endif
  if (!LEPUS_IsUndefined(new_target)) {
    obj = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_NUMBER);
    if (!LEPUS_IsException(obj)) LEPUS_SetObjectData(ctx, obj, val);
    return obj;
  } else {
    return val;
  }
}

#if 0
static LEPUSValue lepus_number___toInteger(LEPUSContext *ctx, LEPUSValueConst this_val,
                                     int argc, LEPUSValueConst *argv)
{
    return LEPUS_ToIntegerFree(ctx, LEPUS_DupValue(ctx, argv[0]));
}

static LEPUSValue lepus_number___toLength(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv)
{
    int64_t v;
    if (LEPUS_ToLengthFree(ctx, &v, LEPUS_DupValue(ctx, argv[0])))
        return LEPUS_EXCEPTION;
    return LEPUS_NewInt64(ctx, v);
}
#endif

QJS_STATIC LEPUSValue lepus_number_isNaN(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  /* XXX: should just check for float and big_float */
  if (!LEPUS_IsNumber(argv[0])) return LEPUS_FALSE;
  return lepus_global_isNaN(ctx, this_val, argc, argv);
}

QJS_STATIC LEPUSValue lepus_number_isFinite(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  if (!LEPUS_IsNumber(argv[0])) return LEPUS_FALSE;
  return lepus_global_isFinite(ctx, this_val, argc, argv);
}

QJS_STATIC LEPUSValue lepus_number_isInteger(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  int ret;
  ret = LEPUS_NumberIsInteger(ctx, argv[0]);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue lepus_number_isSafeInteger(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  double d;
  if (!LEPUS_IsNumber(argv[0])) return LEPUS_FALSE;
  if (unlikely(LEPUS_ToFloat64(ctx, &d, argv[0]))) return LEPUS_EXCEPTION;
  return LEPUS_NewBool(
      ctx, isfinite(d) && floor(d) == d && fabs(d) <= (double)MAX_SAFE_INTEGER);
}

static LEPUSCFunctionListEntry lepus_number_funcs[] = {
    /* global ParseInt and parseFloat should be defined already or delayed */
    LEPUS_ALIAS_BASE_DEF("parseInt", "parseInt", 0),
    LEPUS_ALIAS_BASE_DEF("parseFloat", "parseFloat", 0),
    LEPUS_CFUNC_DEF("isNaN", 1, lepus_number_isNaN),
    LEPUS_CFUNC_DEF("isFinite", 1, lepus_number_isFinite),
    LEPUS_CFUNC_DEF("isInteger", 1, lepus_number_isInteger),
    LEPUS_CFUNC_DEF("isSafeInteger", 1, lepus_number_isSafeInteger),
    LEPUS_PROP_DOUBLE_DEF("MAX_VALUE", 1.7976931348623157e+308, 0),
    LEPUS_PROP_DOUBLE_DEF("MIN_VALUE", 5e-324, 0),
    LEPUS_PROP_DOUBLE_DEF("NaN", LEPUS_FLOAT64_NAN, 0),
    LEPUS_PROP_DOUBLE_DEF("NEGATIVE_INFINITY", -INFINITY, 0),
    LEPUS_PROP_DOUBLE_DEF("POSITIVE_INFINITY", INFINITY, 0),
    LEPUS_PROP_DOUBLE_DEF("EPSILON", 2.220446049250313e-16, 0),        /* ES6 */
    LEPUS_PROP_DOUBLE_DEF("MAX_SAFE_INTEGER", 9007199254740991.0, 0),  /* ES6 */
    LEPUS_PROP_DOUBLE_DEF("MIN_SAFE_INTEGER", -9007199254740991.0, 0), /* ES6 */
    // LEPUS_CFUNC_DEF("__toInteger", 1, lepus_number___toInteger ),
    // LEPUS_CFUNC_DEF("__toLength", 1, lepus_number___toLength ),
};

QJS_STATIC LEPUSValue lepus_thisNumberValue(LEPUSContext *ctx,
                                            LEPUSValueConst this_val) {
  if (LEPUS_IsNumber(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == LEPUS_CLASS_NUMBER) {
      if (LEPUS_IsNumber(p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a number");
}

QJS_STATIC LEPUSValue lepus_number_valueOf(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  return lepus_thisNumberValue(ctx, this_val);
}

QJS_STATIC LEPUSValue lepus_number_toString(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv, int magic) {
  LEPUSValue val;
  int base;

  val = lepus_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (magic || LEPUS_IsUndefined(argv[0])) {
    base = 10;
  } else {
    if (LEPUS_ToInt32Sat(ctx, &base, argv[0])) goto fail;
    if (base < 2 || base > 36) {
      LEPUS_ThrowRangeError(ctx, "radix must be between 2 and 36");
      goto fail;
    }
  }
#ifdef CONFIG_BIGNUM
  {
    LEPUSValue ret =
        lepus_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
    LEPUS_FreeValue(ctx, val);
    return ret;
  }
#else
  {
    double d;
    if (LEPUS_ToFloat64Free(ctx, &d, val)) return LEPUS_EXCEPTION;
    return lepus_dtoa(ctx, d, base, 0, LEPUS_DTOA_VAR_FORMAT);
  }
#endif
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

#ifdef CONFIG_BIGNUM

static LEPUSValue lepus_thisBigFloatValue(LEPUSContext *ctx,
                                          LEPUSValueConst this_val);

static int64_t lepus_number_get_prec_max(LEPUSContext *ctx, int magic) {
  if (magic)
    return BF_PREC_MAX;
  else
    return 100;
}

static int get_rnd_mode(LEPUSContext *ctx, LEPUSValueConst val) {
  int rnd_mode;
  if (LEPUS_ToInt32Sat(ctx, &rnd_mode, val)) return -1;
  if (rnd_mode < BF_RNDN || rnd_mode > BF_RNDF) {
    LEPUS_ThrowRangeError(ctx, "invalid rounding mode");
    return -1;
  }
  return rnd_mode;
}

static LEPUSValue lepus_number_toFixed(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv, int magic) {
  LEPUSValue val, ret;
  int64_t f;
  int res, rnd_mode;
  bf_t a_s, *a, b;
  BOOL is_float;

  if (magic)
    val = lepus_thisBigFloatValue(ctx, this_val);
  else
    val = lepus_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (LEPUS_ToInt64Sat(ctx, &f, argv[0])) goto fail;
  if (f < 0 || f > lepus_number_get_prec_max(ctx, magic)) {
    LEPUS_ThrowRangeError(ctx, "invalid number of digits");
    goto fail;
  }
  rnd_mode = BF_RNDNA;
  if (magic && argc > 1) {
    rnd_mode = get_rnd_mode(ctx, argv[1]);
    if (rnd_mode < 0) goto fail;
  }

  a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, val);
  if (!a) goto fail;
  bf_init(ctx->bf_ctx, &b);
  bf_set_float64(&b, 1e21);
  res = bf_cmpu(a, &b);
  bf_delete(&b);
  if (a == &a_s) bf_delete(a);
  if (res >= 0) {
    ret = LEPUS_ToString(ctx, val);
  } else {
    ret = lepus_ftoa(ctx, val, 10, f, rnd_mode | BF_FTOA_FORMAT_FRAC);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static LEPUSValue lepus_number_toExponential(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv, int magic) {
  LEPUSValue val, ret;
  int64_t f;
  int rnd_mode;

  if (magic)
    val = lepus_thisBigFloatValue(ctx, this_val);
  else
    val = lepus_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (LEPUS_ToInt64Sat(ctx, &f, argv[0])) goto fail;
  if (!lepus_number_is_finite(ctx, val)) {
    ret = LEPUS_ToString(ctx, val);
  } else if (LEPUS_IsUndefined(argv[0])) {
    ret = lepus_ftoa(ctx, val, 10, 0,
                     BF_RNDN | BF_FTOA_FORMAT_FREE_MIN | BF_FTOA_FORCE_EXP);
  } else {
    if (f < 0 || f > lepus_number_get_prec_max(ctx, magic)) {
      LEPUS_ThrowRangeError(ctx, "invalid number of digits");
      goto fail;
    }
    rnd_mode = BF_RNDNA;
    if (magic && argc > 1) {
      rnd_mode = get_rnd_mode(ctx, argv[1]);
      if (rnd_mode < 0) goto fail;
    }
    ret = lepus_ftoa(ctx, val, 10, f + 1,
                     rnd_mode | BF_FTOA_FORMAT_FIXED | BF_FTOA_FORCE_EXP);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static LEPUSValue lepus_number_toPrecision(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv, int magic) {
  LEPUSValue val, ret;
  int64_t p;
  int rnd_mode;

  if (magic)
    val = lepus_thisBigFloatValue(ctx, this_val);
  else
    val = lepus_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (LEPUS_IsUndefined(argv[0])) goto to_string;
  if (LEPUS_ToInt64Sat(ctx, &p, argv[0])) goto fail;
  if (!lepus_number_is_finite(ctx, val)) {
  to_string:
    ret = LEPUS_ToString(ctx, this_val);
  } else {
    if (p < 1 || p > lepus_number_get_prec_max(ctx, magic)) {
      LEPUS_ThrowRangeError(ctx, "invalid number of digits");
      goto fail;
    }
    rnd_mode = BF_RNDNA;
    if (magic && argc > 1) {
      rnd_mode = get_rnd_mode(ctx, argv[1]);
      if (rnd_mode < 0) goto fail;
    }
    ret = lepus_ftoa(ctx, val, 10, p, rnd_mode | BF_FTOA_FORMAT_FIXED);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static const LEPUSCFunctionListEntry lepus_number_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("toExponential", 1, lepus_number_toExponential, 0),
    LEPUS_CFUNC_MAGIC_DEF("toFixed", 1, lepus_number_toFixed, 0),
    LEPUS_CFUNC_MAGIC_DEF("toPrecision", 1, lepus_number_toPrecision, 0),
    LEPUS_CFUNC_MAGIC_DEF("toString", 1, lepus_number_toString, 0),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, lepus_number_toString, 1),
    LEPUS_CFUNC_DEF("valueOf", 0, lepus_number_valueOf),
};

#else /* !CONFIG_BIGNUM */

QJS_STATIC LEPUSValue lepus_number_toFixed(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValue val;
  int f;
  double d;

  val = lepus_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (LEPUS_ToFloat64Free(ctx, &d, val)) return LEPUS_EXCEPTION;
  if (LEPUS_ToInt32Sat(ctx, &f, argv[0])) return LEPUS_EXCEPTION;
  if (f < 0 || f > 100)
    return LEPUS_ThrowRangeError(ctx, "invalid number of digits");
  if (fabs(d) >= 1e21) {
    return LEPUS_ToStringFree(ctx, __JS_NewFloat64(ctx, d));
  } else {
    return lepus_dtoa(ctx, d, 10, f, LEPUS_DTOA_FRAC_FORMAT);
  }
}

QJS_STATIC LEPUSValue lepus_number_toExponential(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  LEPUSValue val;
  int f, flags;
  double d;

  val = lepus_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (LEPUS_ToFloat64Free(ctx, &d, val)) return LEPUS_EXCEPTION;
  if (LEPUS_ToInt32Sat(ctx, &f, argv[0])) return LEPUS_EXCEPTION;
  if (!isfinite(d)) {
    return LEPUS_ToStringFree(ctx, __JS_NewFloat64(ctx, d));
  }
  if (LEPUS_IsUndefined(argv[0])) {
    flags = 0;
    f = 0;
  } else {
    if (f < 0 || f > 100)
      return LEPUS_ThrowRangeError(ctx, "invalid number of digits");
    f++;
    flags = LEPUS_DTOA_FIXED_FORMAT;
  }
  return lepus_dtoa(ctx, d, 10, f, flags | LEPUS_DTOA_FORCE_EXP);
}

QJS_STATIC LEPUSValue lepus_number_toPrecision(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue val;
  int p;
  double d;

  val = lepus_thisNumberValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (LEPUS_ToFloat64Free(ctx, &d, val)) return LEPUS_EXCEPTION;
  if (LEPUS_IsUndefined(argv[0])) goto to_string;
  if (LEPUS_ToInt32Sat(ctx, &p, argv[0])) return LEPUS_EXCEPTION;
  if (!isfinite(d)) {
  to_string:
    return LEPUS_ToStringFree(ctx, __JS_NewFloat64(ctx, d));
  }
  if (p < 1 || p > 100)
    return LEPUS_ThrowRangeError(ctx, "invalid number of digits");
  return lepus_dtoa(ctx, d, 10, p, LEPUS_DTOA_FIXED_FORMAT);
}

static const LEPUSCFunctionListEntry lepus_number_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toExponential", 1, lepus_number_toExponential),
    LEPUS_CFUNC_DEF("toFixed", 1, lepus_number_toFixed),
    LEPUS_CFUNC_DEF("toPrecision", 1, lepus_number_toPrecision),
    LEPUS_CFUNC_MAGIC_DEF("toString", 1, lepus_number_toString, 0),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, lepus_number_toString, 1),
    LEPUS_CFUNC_DEF("valueOf", 0, lepus_number_valueOf),
};

#endif /* !CONFIG_BIGNUM */

QJS_STATIC LEPUSValue lepus_parseInt(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  const char *str;
  int radix;
  LEPUSValue ret;

  str = LEPUS_ToCString(ctx, argv[0]);
  if (!str) return LEPUS_EXCEPTION;
  if (LEPUS_ToInt32(ctx, &radix, argv[1])) {
    LEPUS_FreeCString(ctx, str);
    return LEPUS_EXCEPTION;
  }
  if (radix != 0 && (radix < 2 || radix > 36)) {
    ret = LEPUS_NAN;
  } else {
#ifdef CONFIG_BIGNUM
    int flags;
    flags = BF_ATOF_INT_ONLY | BF_ATOF_NAN_IF_EMPTY | BF_ATOF_FLOAT64;
    if (is_bignum_mode(ctx)) flags |= BF_ATOF_INT_PREC_INF;
    ret = lepus_atof(ctx, str, NULL, radix, flags);
#else
    ret = lepus_atod(ctx, str, NULL, radix, ATOD_INT_ONLY | ATOD_NAN_IF_EMPTY);
#endif
  }
  LEPUS_FreeCString(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue lepus_parseFloat(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  const char *str;
  LEPUSValue ret;

  str = LEPUS_ToCString(ctx, argv[0]);
  if (!str) return LEPUS_EXCEPTION;
#ifdef CONFIG_BIGNUM
  ret = lepus_atof(ctx, str, NULL, 10,
                   BF_ATOF_JS_QUIRKS | BF_ATOF_NAN_IF_EMPTY | BF_ATOF_FLOAT64);
#else
  ret = lepus_atod(ctx, str, NULL, 10, ATOD_NAN_IF_EMPTY);
#endif
  LEPUS_FreeCString(ctx, str);
  return ret;
}

/* Boolean */
QJS_STATIC LEPUSValue lepus_boolean_constructor(LEPUSContext *ctx,
                                                LEPUSValueConst new_target,
                                                int argc,
                                                LEPUSValueConst *argv) {
  LEPUSValue val, obj;
  val = LEPUS_NewBool(ctx, LEPUS_ToBool(ctx, argv[0]));
  if (!LEPUS_IsUndefined(new_target)) {
    obj = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_BOOLEAN);
    if (!LEPUS_IsException(obj)) LEPUS_SetObjectData(ctx, obj, val);
    return obj;
  } else {
    return val;
  }
}

QJS_STATIC LEPUSValue lepus_thisBooleanValue(LEPUSContext *ctx,
                                             LEPUSValueConst this_val) {
  if (LEPUS_VALUE_IS_BOOL(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == LEPUS_CLASS_BOOLEAN) {
      if (LEPUS_VALUE_IS_BOOL(p->u.object_data)) return p->u.object_data;
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a boolean");
}

QJS_STATIC LEPUSValue lepus_boolean_toString(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  LEPUSValue val = lepus_thisBooleanValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  return LEPUS_AtomToString(
      ctx, LEPUS_VALUE_GET_BOOL(val) ? LEPUS_ATOM_true : LEPUS_ATOM_false);
}

QJS_STATIC LEPUSValue lepus_boolean_valueOf(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  return lepus_thisBooleanValue(ctx, this_val);
}

static const LEPUSCFunctionListEntry lepus_boolean_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, lepus_boolean_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, lepus_boolean_valueOf),
};

/* String */

QJS_STATIC int lepus_string_get_own_property(LEPUSContext *ctx,
                                             LEPUSPropertyDescriptor *desc,
                                             LEPUSValueConst obj,
                                             LEPUSAtom prop) {
  LEPUSObject *p;
  LEPUSString *p1;
  uint32_t idx, ch;

  /* This is a class exotic method: obj class_id is LEPUS_CLASS_STRING */
  if (__JS_AtomIsTaggedInt(prop)) {
    p = LEPUS_VALUE_GET_OBJ(obj);
    if (LEPUS_VALUE_IS_STRING(p->u.object_data)) {
      p1 = LEPUS_VALUE_GET_STRING(p->u.object_data);
      idx = __JS_AtomToUInt32(prop);
      if (idx < p1->len) {
        if (desc) {
          if (p1->is_wide_char)
            ch = p1->u.str16[idx];
          else
            ch = p1->u.str8[idx];
          desc->flags = LEPUS_PROP_ENUMERABLE;
          desc->value = lepus_new_string_char(ctx, ch);
          desc->getter = LEPUS_UNDEFINED;
          desc->setter = LEPUS_UNDEFINED;
        }
        return TRUE;
      }
    }
  }
  return FALSE;
}

QJS_STATIC uint32_t lepus_string_obj_get_length(LEPUSContext *ctx,
                                                LEPUSValueConst obj) {
  LEPUSObject *p;
  LEPUSString *p1;
  uint32_t len = 0;

  /* This is a class exotic method: obj class_id is LEPUS_CLASS_STRING */
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (LEPUS_VALUE_IS_STRING(p->u.object_data)) {
    p1 = LEPUS_VALUE_GET_STRING(p->u.object_data);
    len = p1->len;
  }
  return len;
}

QJS_STATIC int lepus_string_get_own_property_names(LEPUSContext *ctx,
                                                   LEPUSPropertyEnum **ptab,
                                                   uint32_t *plen,
                                                   LEPUSValueConst obj) {
  LEPUSPropertyEnum *tab;
  uint32_t len, i;

  len = lepus_string_obj_get_length(ctx, obj);
  tab = NULL;
  if (len > 0) {
    /* do not allocate 0 bytes */
    tab = static_cast<LEPUSPropertyEnum *>(
        lepus_malloc(ctx, sizeof(LEPUSPropertyEnum) * len));
    if (!tab) return -1;
    for (i = 0; i < len; i++) {
      tab[i].atom = __JS_AtomFromUInt32(i);
    }
  }
  *ptab = tab;
  *plen = len;
  return 0;
}

QJS_STATIC int lepus_string_define_own_property(
    LEPUSContext *ctx, LEPUSValueConst this_obj, LEPUSAtom prop,
    LEPUSValueConst val, LEPUSValueConst getter, LEPUSValueConst setter,
    int flags) {
  uint32_t idx;
  LEPUSObject *p;
  LEPUSString *p1, *p2;

  if (__JS_AtomIsTaggedInt(prop)) {
    idx = __JS_AtomToUInt32(prop);
    p = LEPUS_VALUE_GET_OBJ(this_obj);
    if (!LEPUS_VALUE_IS_STRING(p->u.object_data)) goto def;
    p1 = LEPUS_VALUE_GET_STRING(p->u.object_data);
    if (idx >= p1->len) goto def;
    if (!check_define_prop_flags(LEPUS_PROP_ENUMERABLE, flags)) goto fail;
    /* check that the same value is configured */
    if (flags & LEPUS_PROP_HAS_VALUE) {
      if (!LEPUS_VALUE_IS_STRING(val)) goto fail;
      p2 = LEPUS_VALUE_GET_STRING(val);
      if (p2->len != 1) goto fail;
      if (string_get(p1, idx) != string_get(p2, 0)) {
      fail:
        return LEPUS_ThrowTypeErrorOrFalse(ctx, flags,
                                           "property is not configurable");
      }
    }
    return TRUE;
  } else {
  def:
    return LEPUS_DefineProperty(ctx, this_obj, prop, val, getter, setter,
                                flags | LEPUS_PROP_NO_EXOTIC);
  }
}

QJS_STATIC int lepus_string_delete_property(LEPUSContext *ctx,
                                            LEPUSValueConst obj,
                                            LEPUSAtom prop) {
  uint32_t idx;

  if (__JS_AtomIsTaggedInt(prop)) {
    idx = __JS_AtomToUInt32(prop);
    if (idx < lepus_string_obj_get_length(ctx, obj)) {
      return FALSE;
    }
  }
  return TRUE;
}

QJS_STATIC LEPUSValue lepus_string_constructor(LEPUSContext *ctx,
                                               LEPUSValueConst new_target,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue val, obj;
  if (argc == 0) {
    val = LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string);
  } else {
    if (LEPUS_IsUndefined(new_target) && LEPUS_IsSymbol(argv[0])) {
      LEPUSAtomStruct *p =
          static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(argv[0]));
      val = LEPUS_ConcatString3(
          ctx, "Symbol(",
          LEPUS_AtomToString(ctx, lepus_get_atom_index(ctx->rt, p)), ")");
    } else {
      val = LEPUS_ToString(ctx, argv[0]);
    }
    if (LEPUS_IsException(val)) return val;
  }
  if (!LEPUS_IsUndefined(new_target)) {
    LEPUSString *p1 = LEPUS_VALUE_GET_STRING(val);

    obj = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_STRING);
    if (!LEPUS_IsException(obj)) {
      LEPUS_SetObjectData(ctx, obj, val);
      LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_length,
                                LEPUS_NewInt32(ctx, p1->len), 0);
    }
    return obj;
  } else {
    return val;
  }
}

QJS_STATIC LEPUSValue lepus_thisStringValue(LEPUSContext *ctx,
                                            LEPUSValueConst this_val) {
  if (LEPUS_VALUE_IS_STRING(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == LEPUS_CLASS_STRING) {
      if (LEPUS_VALUE_IS_STRING(p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a string");
}

QJS_STATIC LEPUSValue lepus_string_fromCharCode(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc,
                                                LEPUSValueConst *argv) {
  int i;
  StringBuffer b_s, *b = &b_s;

  string_buffer_init(ctx, b, argc);

  for (i = 0; i < argc; i++) {
    int32_t c;
    if (LEPUS_ToInt32(ctx, &c, argv[i]) ||
        string_buffer_putc16(b, c & 0xffff)) {
      string_buffer_free(b);
      return LEPUS_EXCEPTION;
    }
  }
  return string_buffer_end(b);
}

QJS_STATIC LEPUSValue lepus_string_fromCodePoint(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  double d;
  int i, c;
  StringBuffer b_s, *b = &b_s;

  /* XXX: could pre-compute string length if all arguments are LEPUS_TAG_INT */

  if (string_buffer_init(ctx, b, argc)) goto fail;
  for (i = 0; i < argc; i++) {
    if (LEPUS_VALUE_IS_INT(argv[i])) {
      c = LEPUS_VALUE_GET_INT(argv[i]);
      if (c < 0 || c > 0x10ffff) goto range_error;
    } else {
      if (LEPUS_ToFloat64(ctx, &d, argv[i])) goto fail;
      if (d < 0 || d > 0x10ffff || (c = (int)d) != d) goto range_error;
    }
    if (string_buffer_putc(b, c)) goto fail;
  }
  return string_buffer_end(b);

range_error:
  LEPUS_ThrowRangeError(ctx, "invalid code point");
fail:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_string_raw(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  // raw(temp,...a)
  LEPUSValue cooked, val, raw;
  StringBuffer b_s, *b = &b_s;
  int64_t i, n;

  string_buffer_init(ctx, b, 0);
  raw = LEPUS_UNDEFINED;
  cooked = LEPUS_ToObject(ctx, argv[0]);
  if (LEPUS_IsException(cooked)) goto exception;
  raw = LEPUS_ToObjectFree(ctx, LEPUS_GetProperty(ctx, cooked, LEPUS_ATOM_raw));
  if (LEPUS_IsException(raw)) goto exception;
  if (lepus_get_length64(ctx, &n, raw) < 0) goto exception;

  for (i = 0; i < n; i++) {
    val = LEPUS_ToStringFree(ctx, LEPUS_GetPropertyInt64(ctx, raw, i));
    if (LEPUS_IsException(val)) goto exception;
    string_buffer_concat_value_free(b, val);
    if (i < n - 1 && i + 1 < argc) {
      if (string_buffer_concat_value(b, argv[i + 1])) goto exception;
    }
  }
  LEPUS_FreeValue(ctx, cooked);
  LEPUS_FreeValue(ctx, raw);
  return string_buffer_end(b);

exception:
  LEPUS_FreeValue(ctx, cooked);
  LEPUS_FreeValue(ctx, raw);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

#ifdef QJS_UNITTEST
/* only used in test262 */
LEPUSValue lepus_string_codePointRange(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  uint32_t start, end, i, n;
  StringBuffer b_s, *b = &b_s;

  if (LEPUS_ToUint32(ctx, &start, argv[0]) ||
      LEPUS_ToUint32(ctx, &end, argv[1]))
    return LEPUS_EXCEPTION;
  end = min_uint32(end, 0x10ffff + 1);

  if (start > end) {
    start = end;
  }
  n = end - start;
  if (end > 0x10000) {
    n += end - max_uint32(start, 0x10000);
  }
  if (string_buffer_init2(ctx, b, n, end >= 0x100)) return LEPUS_EXCEPTION;
  for (i = start; i < end; i++) {
    string_buffer_putc(b, i);
  }
  return string_buffer_end(b);
}

/* only used in test262 */
LEPUSValue lepus_gc(LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
                    LEPUSValueConst *argv) {
  LEPUS_RunGC(ctx->rt);
  return LEPUS_UNDEFINED;
}
#endif
#if 0
static LEPUSValue lepus_string___isSpace(LEPUSContext *ctx, LEPUSValueConst this_val,
                                   int argc, LEPUSValueConst *argv)
{
    int c;
    if (LEPUS_ToInt32(ctx, &c, argv[0]))
        return LEPUS_EXCEPTION;
    return LEPUS_NewBool(ctx, lre_is_space(c));
}
#endif

QJS_STATIC LEPUSValue lepus_string_charCodeAt(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValue val, ret;
  LEPUSString *p;
  int idx, c;

  val = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);
  if (LEPUS_ToInt32Sat(ctx, &idx, argv[0])) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_EXCEPTION;
  }
  if (idx < 0 || idx >= p->len) {
    ret = LEPUS_NAN;
  } else {
    if (p->is_wide_char)
      c = p->u.str16[idx];
    else
      c = p->u.str8[idx];
    ret = LEPUS_NewInt32(ctx, c);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue lepus_string_charAt(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue val, ret;
  LEPUSString *p;
  int idx, c;

  val = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);
  if (LEPUS_ToInt32Sat(ctx, &idx, argv[0])) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_EXCEPTION;
  }
  if (idx < 0 || idx >= p->len) {
    ret = lepus_new_string8(ctx, NULL, 0);
  } else {
    if (p->is_wide_char)
      c = p->u.str16[idx];
    else
      c = p->u.str8[idx];
    ret = lepus_new_string_char(ctx, c);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue lepus_string_codePointAt(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue val, ret;
  LEPUSString *p;
  int idx, c;

  val = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);
  if (LEPUS_ToInt32Sat(ctx, &idx, argv[0])) {
    LEPUS_FreeValue(ctx, val);
    return LEPUS_EXCEPTION;
  }
  if (idx < 0 || idx >= p->len) {
    ret = LEPUS_UNDEFINED;
  } else {
    c = string_getc(p, &idx);
    ret = LEPUS_NewInt32(ctx, c);
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue lepus_string_concat(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue r;
  int i;

  /* XXX: Use more efficient method */
  /* XXX: This method is OK if r has a single refcount */
  /* XXX: should use string_buffer? */
  r = LEPUS_ToStringCheckObject(ctx, this_val);
  for (i = 0; i < argc; i++) {
    if (LEPUS_IsException(r)) break;
    r = LEPUS_ConcatString(ctx, r, LEPUS_DupValue(ctx, argv[i]));
  }
  return r;
}

QJS_STATIC int string_cmp(LEPUSString *p1, LEPUSString *p2, int x1, int x2,
                          int len) {
  int i, c1, c2;
  for (i = 0; i < len; i++) {
    if ((c1 = string_get(p1, x1 + i)) != (c2 = string_get(p2, x2 + i)))
      return c1 - c2;
  }
  return 0;
}

QJS_STATIC int string_indexof_char(LEPUSString *p, int c, int from) {
  /* assuming 0 <= from <= p->len */
  int i, len = p->len;
  if (p->is_wide_char) {
    for (i = from; i < len; i++) {
      if (p->u.str16[i] == c) return i;
    }
  } else {
    if ((c & ~0xff) == 0) {
      for (i = from; i < len; i++) {
        if (p->u.str8[i] == (uint8_t)c) return i;
      }
    }
  }
  return -1;
}

QJS_STATIC int string_indexof(LEPUSString *p1, LEPUSString *p2, int from) {
  /* assuming 0 <= from <= p1->len */
  int c, i, j, len1 = p1->len, len2 = p2->len;
  if (len2 == 0) return from;
  for (i = from, c = string_get(p2, 0); i + len2 <= len1; i = j + 1) {
    j = string_indexof_char(p1, c, i);
    if (j < 0 || j + len2 > len1) break;
    if (!string_cmp(p1, p2, j + 1, 1, len2 - 1)) return j;
  }
  return -1;
}

QJS_STATIC int string_advance_index(LEPUSString *p, int index, BOOL unicode) {
  if (!unicode || (unsigned)index >= p->len || !p->is_wide_char) {
    index++;
  } else {
    string_getc(p, &index);
  }
  return index;
}

QJS_STATIC LEPUSValue lepus_string_indexOf(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv,
                                           int lastIndexOf) {
  LEPUSValue str, v;
  int i, len, v_len, pos, start, stop, ret, inc;
  LEPUSString *p;
  LEPUSString *p1;

  str = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  v = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(v)) goto fail;
  p = LEPUS_VALUE_GET_STRING(str);
  p1 = LEPUS_VALUE_GET_STRING(v);
  len = p->len;
  v_len = p1->len;
  if (lastIndexOf) {
    pos = len - v_len;
    if (argc > 1) {
      double d;
      if (LEPUS_ToFloat64(ctx, &d, argv[1])) goto fail;
      if (!isnan(d)) {
        if (d <= 0)
          pos = 0;
        else if (d < pos)
          pos = d;
      }
    }
    start = pos;
    stop = 0;
    inc = -1;
  } else {
    pos = 0;
    if (argc > 1) {
      if (LEPUS_ToInt32Clamp(ctx, &pos, argv[1], 0, len, 0)) goto fail;
    }
    start = pos;
    stop = len - v_len;
    inc = 1;
  }
  ret = -1;
  if (len >= v_len && inc * (stop - start) >= 0) {
    for (i = start;; i += inc) {
      if (!string_cmp(p, p1, i, 0, v_len)) {
        ret = i;
        break;
      }
      if (i == stop) break;
    }
  }
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, v);
  return LEPUS_NewInt32(ctx, ret);

fail:
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, v);
  return LEPUS_EXCEPTION;
}

/* return < 0 if exception or TRUE/FALSE */
QJS_HIDE int lepus_is_regexp(LEPUSContext *ctx, LEPUSValueConst obj);

QJS_STATIC LEPUSValue lepus_string_includes(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv, int magic) {
  LEPUSValue str, v = LEPUS_UNDEFINED;
  int i, len, v_len, pos, start, stop, ret;
  LEPUSString *p;
  LEPUSString *p1;

  str = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  ret = lepus_is_regexp(ctx, argv[0]);
  if (ret) {
    if (ret > 0) LEPUS_ThrowTypeError(ctx, "regex not supported");
    goto fail;
  }
  v = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(v)) goto fail;
  p = LEPUS_VALUE_GET_STRING(str);
  p1 = LEPUS_VALUE_GET_STRING(v);
  len = p->len;
  v_len = p1->len;
  pos = (magic & 2) ? len : 0;
  if (argc > 1 && !LEPUS_IsUndefined(argv[1])) {
    if (LEPUS_ToInt32Clamp(ctx, &pos, argv[1], 0, len, 0)) goto fail;
  }
  len -= v_len;
  start = pos;
  stop = len;
  if (magic & 1) {
    stop = pos;
  }
  if (magic & 2) {
    pos -= v_len;
    start = stop = pos;
  }
  ret = 0;
  if (start >= 0 && start <= stop) {
    for (i = start;; i++) {
      if (!string_cmp(p, p1, i, 0, v_len)) {
        ret = 1;
        break;
      }
      if (i == stop) break;
    }
  }
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, v);
  return LEPUS_NewBool(ctx, ret);

fail:
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, v);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_string_match(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv, int atom) {
  // match(rx), search(rx), matchAll(rx)
  // atom is LEPUS_ATOM_Symbol_match, LEPUS_ATOM_Symbol_search, or
  // LEPUS_ATOM_Symbol_matchAll
  LEPUSValueConst O = this_val, regexp = argv[0], args[2];
  LEPUSValue matcher, S, rx, result, str;
  int args_len;

  if (LEPUS_IsUndefined(O) || LEPUS_IsNull(O))
    return LEPUS_ThrowTypeError(ctx, "cannot convert to object");

  if (!LEPUS_IsUndefined(regexp) && !LEPUS_IsNull(regexp)) {
    matcher = LEPUS_GetProperty(ctx, regexp, atom);
    if (LEPUS_IsException(matcher)) return LEPUS_EXCEPTION;
    if (!LEPUS_IsUndefined(matcher) && !LEPUS_IsNull(matcher)) {
      return LEPUS_CallFree(ctx, matcher, regexp, 1, &O);
    }
  }
  S = LEPUS_ToString(ctx, O);
  if (LEPUS_IsException(S)) return LEPUS_EXCEPTION;
  args_len = 1;
  args[0] = regexp;
  str = LEPUS_UNDEFINED;
  if (atom == LEPUS_ATOM_Symbol_matchAll) {
    str = LEPUS_NewString(ctx, "g");
    if (LEPUS_IsException(str)) goto fail;
    args[args_len++] = (LEPUSValueConst)str;
  }
  rx = LEPUS_CallConstructor(ctx, ctx->regexp_ctor, args_len, args);
  LEPUS_FreeValue(ctx, str);
  if (LEPUS_IsException(rx)) {
  fail:
    LEPUS_FreeValue(ctx, S);
    return LEPUS_EXCEPTION;
  }
  result = LEPUS_InvokeFree(ctx, rx, atom, 1, (LEPUSValueConst *)&S);
  LEPUS_FreeValue(ctx, S);
  return result;
}

QJS_STATIC LEPUSValue lepus_string___GetSubstitution(LEPUSContext *ctx,
                                                     LEPUSValueConst this_val,
                                                     int argc,
                                                     LEPUSValueConst *argv) {
  // GetSubstitution(matched, str, position, captures, namedCaptures, rep)
  LEPUSValueConst matched, str, captures, namedCaptures, rep;
  LEPUSValue capture, name, s;
  uint32_t position, len, matched_len, captures_len;
  int i, j, j0, k, k1;
  int c, c1;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *sp, *rp;

  matched = argv[0];
  str = argv[1];
  captures = argv[3];
  namedCaptures = argv[4];
  rep = argv[5];

  if (!LEPUS_IsString(rep) || !LEPUS_IsString(str))
    return LEPUS_ThrowTypeError(ctx, "not a string");

  sp = LEPUS_VALUE_GET_STRING(str);
  rp = LEPUS_VALUE_GET_STRING(rep);

  string_buffer_init(ctx, b, 0);

  captures_len = 0;
  if (!LEPUS_IsUndefined(captures)) {
    if (lepus_get_length32(ctx, &captures_len, captures)) goto exception;
  }
  if (lepus_get_length32(ctx, &matched_len, matched)) goto exception;
  if (LEPUS_ToUint32(ctx, &position, argv[2]) < 0) goto exception;

  len = rp->len;
  i = 0;
  for (;;) {
    j = string_indexof_char(rp, '$', i);
    if (j < 0 || j + 1 >= len) break;
    string_buffer_concat(b, rp, i, j);
    j0 = j++;
    c = string_get(rp, j++);
    if (c == '$') {
      string_buffer_putc8(b, '$');
    } else if (c == '&') {
      if (string_buffer_concat_value(b, matched)) goto exception;
    } else if (c == '`') {
      string_buffer_concat(b, sp, 0, position);
    } else if (c == '\'') {
      string_buffer_concat(b, sp, position + matched_len, sp->len);
    } else if (c >= '0' && c <= '9') {
      k = c - '0';
      c1 = string_get(rp, j);
      if (c1 >= '0' && c1 <= '9') {
        /* This behavior is specified in ES6 and refined in ECMA 2019 */
        /* ECMA 2019 does not have the extra test, but
           Test262 S15.5.4.11_A3_T1..3 require this behavior */
        k1 = k * 10 + c1 - '0';
        if (k1 >= 1 && k1 < captures_len) {
          k = k1;
          j++;
        }
      }
      if (k >= 1 && k < captures_len) {
        s = LEPUS_GetPropertyInt64(ctx, captures, k);
        if (LEPUS_IsException(s)) goto exception;
        if (!LEPUS_IsUndefined(s)) {
          if (string_buffer_concat_value_free(b, s)) goto exception;
        }
      } else {
        goto norep;
      }
    } else if (c == '<' && !LEPUS_IsUndefined(namedCaptures)) {
      k = string_indexof_char(rp, '>', j);
      if (k < 0) goto norep;
      name = lepus_sub_string(ctx, rp, j, k);
      if (LEPUS_IsException(name)) goto exception;
      capture = LEPUS_GetPropertyValue(ctx, namedCaptures, name);
      if (LEPUS_IsException(capture)) goto exception;
      if (!LEPUS_IsUndefined(capture)) {
        if (string_buffer_concat_value_free(b, capture)) goto exception;
      }
      j = k + 1;
    } else {
    norep:
      string_buffer_concat(b, rp, j0, j);
    }
    i = j;
  }
  string_buffer_concat(b, rp, i, rp->len);
  return string_buffer_end(b);
exception:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_string_replace(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  // replace(rx, rep)
  LEPUSValueConst O = this_val, searchValue = argv[0], replaceValue = argv[1];
  LEPUSValueConst args[6];
  LEPUSValue str, search_str, replaceValue_str, repl_str;
  LEPUSString *sp, *searchp;
  StringBuffer b_s, *b = &b_s;
  int pos, functionalReplace;

  if (LEPUS_IsUndefined(O) || LEPUS_IsNull(O))
    return LEPUS_ThrowTypeError(ctx, "cannot convert to object");

  search_str = LEPUS_UNDEFINED;
  replaceValue_str = LEPUS_UNDEFINED;
  repl_str = LEPUS_UNDEFINED;

  if (!LEPUS_IsUndefined(searchValue) && !LEPUS_IsNull(searchValue)) {
    LEPUSValue replacer;
    replacer = LEPUS_GetProperty(ctx, searchValue, LEPUS_ATOM_Symbol_replace);
    if (LEPUS_IsException(replacer)) return LEPUS_EXCEPTION;
    if (!LEPUS_IsUndefined(replacer) && !LEPUS_IsNull(replacer)) {
      args[0] = O;
      args[1] = replaceValue;
      return LEPUS_CallFree(ctx, replacer, searchValue, 2, args);
    }
  }
  string_buffer_init(ctx, b, 0);

  str = LEPUS_ToString(ctx, O);
  if (LEPUS_IsException(str)) goto exception;
  search_str = LEPUS_ToString(ctx, searchValue);
  if (LEPUS_IsException(search_str)) goto exception;
  functionalReplace = LEPUS_IsFunction(ctx, replaceValue);
  if (!functionalReplace) {
    replaceValue_str = LEPUS_ToString(ctx, replaceValue);
    if (LEPUS_IsException(replaceValue_str)) goto exception;
  }

  sp = LEPUS_VALUE_GET_STRING(str);
  searchp = LEPUS_VALUE_GET_STRING(search_str);

  pos = string_indexof(sp, searchp, 0);
  if (pos < 0) {
    string_buffer_free(b);
    LEPUS_FreeValue(ctx, search_str);
    LEPUS_FreeValue(ctx, replaceValue_str);
    return str;
  }
  if (functionalReplace) {
    args[0] = search_str;
    args[1] = LEPUS_NewInt32(ctx, pos);
    args[2] = str;
    repl_str = LEPUS_ToStringFree(
        ctx, LEPUS_Call(ctx, replaceValue, LEPUS_UNDEFINED, 3, args));
  } else {
    args[0] = search_str;
    args[1] = str;
    args[2] = LEPUS_NewInt32(ctx, pos);
    args[3] = LEPUS_UNDEFINED;
    args[4] = LEPUS_UNDEFINED;
    args[5] = replaceValue_str;
    repl_str = lepus_string___GetSubstitution(ctx, LEPUS_UNDEFINED, 6, args);
  }
  if (LEPUS_IsException(repl_str)) goto exception;

  string_buffer_concat(b, sp, 0, pos);
  string_buffer_concat_value_free(b, repl_str);
  string_buffer_concat(b, sp, pos + searchp->len, sp->len);
  LEPUS_FreeValue(ctx, search_str);
  LEPUS_FreeValue(ctx, replaceValue_str);
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

exception:
  string_buffer_free(b);
  LEPUS_FreeValue(ctx, search_str);
  LEPUS_FreeValue(ctx, replaceValue_str);
  LEPUS_FreeValue(ctx, str);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_string_split(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  // split(sep, limit)
  LEPUSValueConst O = this_val, separator = argv[0], limit = argv[1];
  LEPUSValueConst args[2];
  LEPUSValue S, A, R, T;
  uint32_t lim, lengthA;
  int64_t p, q, s, r, e;
  LEPUSString *sp, *rp;

  if (LEPUS_IsUndefined(O) || LEPUS_IsNull(O))
    return LEPUS_ThrowTypeError(ctx, "cannot convert to object");

  S = LEPUS_UNDEFINED;
  A = LEPUS_UNDEFINED;
  R = LEPUS_UNDEFINED;

  if (!LEPUS_IsUndefined(separator) && !LEPUS_IsNull(separator)) {
    LEPUSValue splitter;
    splitter = LEPUS_GetProperty(ctx, separator, LEPUS_ATOM_Symbol_split);
    if (LEPUS_IsException(splitter)) return LEPUS_EXCEPTION;
    if (!LEPUS_IsUndefined(splitter) && !LEPUS_IsNull(splitter)) {
      args[0] = O;
      args[1] = limit;
      return LEPUS_CallFree(ctx, splitter, separator, 2, args);
    }
  }
  S = LEPUS_ToString(ctx, O);
  if (LEPUS_IsException(S)) goto exception;
  A = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(A)) goto exception;
  lengthA = 0;
  if (LEPUS_IsUndefined(limit)) {
    lim = 0xffffffff;
  } else {
    if (LEPUS_ToUint32(ctx, &lim, limit) < 0) goto exception;
  }
  sp = LEPUS_VALUE_GET_STRING(S);
  s = sp->len;
  R = LEPUS_ToString(ctx, separator);
  if (LEPUS_IsException(R)) goto exception;
  rp = LEPUS_VALUE_GET_STRING(R);
  r = rp->len;
  p = 0;
  if (lim == 0) goto done;
  if (LEPUS_IsUndefined(separator)) goto add_tail;
  if (s == 0) {
    if (r != 0) goto add_tail;
    goto done;
  }
  q = p;
  for (q = p; (q += !r) <= s - r - !r; q = p = e + r) {
    e = string_indexof(sp, rp, q);
    if (e < 0) break;
    T = lepus_sub_string(ctx, sp, p, e);
    if (LEPUS_IsException(T)) goto exception;
    if (LEPUS_CreateDataPropertyUint32(ctx, A, lengthA++, T, 0) < 0)
      goto exception;
    if (lengthA == lim) goto done;
  }
add_tail:
  T = lepus_sub_string(ctx, sp, p, s);
  if (LEPUS_IsException(T)) goto exception;
  if (LEPUS_CreateDataPropertyUint32(ctx, A, lengthA++, T, 0) < 0)
    goto exception;
done:
  LEPUS_FreeValue(ctx, S);
  LEPUS_FreeValue(ctx, R);
  return A;

exception:
  LEPUS_FreeValue(ctx, A);
  LEPUS_FreeValue(ctx, S);
  LEPUS_FreeValue(ctx, R);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_string_substring(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  LEPUSValue str, ret;
  int a, b, start, end;
  LEPUSString *p;

  str = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  p = LEPUS_VALUE_GET_STRING(str);
  if (LEPUS_ToInt32Clamp(ctx, &a, argv[0], 0, p->len, 0)) {
    LEPUS_FreeValue(ctx, str);
    return LEPUS_EXCEPTION;
  }
  b = p->len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (LEPUS_ToInt32Clamp(ctx, &b, argv[1], 0, p->len, 0)) {
      LEPUS_FreeValue(ctx, str);
      return LEPUS_EXCEPTION;
    }
  }
  if (a < b) {
    start = a;
    end = b;
  } else {
    start = b;
    end = a;
  }
  ret = lepus_sub_string(ctx, p, start, end);
  LEPUS_FreeValue(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue lepus_string_substr(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue str, ret;
  int a, len, n;
  LEPUSString *p;

  str = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  p = LEPUS_VALUE_GET_STRING(str);
  len = p->len;
  if (LEPUS_ToInt32Clamp(ctx, &a, argv[0], 0, len, len)) {
    LEPUS_FreeValue(ctx, str);
    return LEPUS_EXCEPTION;
  }
  n = len - a;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (LEPUS_ToInt32Clamp(ctx, &n, argv[1], 0, len - a, 0)) {
      LEPUS_FreeValue(ctx, str);
      return LEPUS_EXCEPTION;
    }
  }
  ret = lepus_sub_string(ctx, p, a, a + n);
  LEPUS_FreeValue(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue lepus_string_slice(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValue str, ret;
  int len, start, end;
  LEPUSString *p;

  str = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  p = LEPUS_VALUE_GET_STRING(str);
  len = p->len;
  if (LEPUS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len)) {
    LEPUS_FreeValue(ctx, str);
    return LEPUS_EXCEPTION;
  }
  end = len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (LEPUS_ToInt32Clamp(ctx, &end, argv[1], 0, len, len)) {
      LEPUS_FreeValue(ctx, str);
      return LEPUS_EXCEPTION;
    }
  }
  ret = lepus_sub_string(ctx, p, start, max_int(end, start));
  LEPUS_FreeValue(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue lepus_string_pad(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv, int padEnd) {
  LEPUSValue str, v = LEPUS_UNDEFINED;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *p, *p1 = NULL;
  int n, len, c = ' ';

  str = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) goto fail1;
  if (LEPUS_ToInt32Sat(ctx, &n, argv[0])) goto fail2;
  p = LEPUS_VALUE_GET_STRING(str);
  len = p->len;
  if (len >= n) return str;
  if (n > LEPUS_STRING_LEN_MAX) {
    LEPUS_ThrowInternalError(ctx, "string too long");
    goto fail2;
  }
  if (argc > 1 && !LEPUS_IsUndefined(argv[1])) {
    v = LEPUS_ToString(ctx, argv[1]);
    if (LEPUS_IsException(v)) goto fail2;
    p1 = LEPUS_VALUE_GET_STRING(v);
    if (p1->len == 0) {
      LEPUS_FreeValue(ctx, v);
      return str;
    }
    if (p1->len == 1) {
      c = string_get(p1, 0);
      p1 = NULL;
    }
  }
  if (string_buffer_init(ctx, b, n)) goto fail3;
  n -= len;
  if (padEnd) {
    if (string_buffer_concat(b, p, 0, len)) goto fail;
  }
  if (p1) {
    while (n > 0) {
      int chunk = min_int(n, p1->len);
      if (string_buffer_concat(b, p1, 0, chunk)) goto fail;
      n -= chunk;
    }
  } else {
    if (string_buffer_fill(b, c, n)) goto fail;
  }
  if (!padEnd) {
    if (string_buffer_concat(b, p, 0, len)) goto fail;
  }
  LEPUS_FreeValue(ctx, v);
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
fail3:
  LEPUS_FreeValue(ctx, v);
fail2:
  LEPUS_FreeValue(ctx, str);
fail1:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_string_repeat(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *p;
  int64_t val;
  int n, len;

  str = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) goto fail;
  if (LEPUS_ToInt64Sat(ctx, &val, argv[0])) goto fail;
  if (val < 0 || val > 2147483647) {
    LEPUS_ThrowRangeError(ctx, "invalid repeat count");
    goto fail;
  }
  n = val;
  p = LEPUS_VALUE_GET_STRING(str);
  len = p->len;
  if (len == 0 || n == 1) return str;
  if (val * len > LEPUS_STRING_LEN_MAX) {
    LEPUS_ThrowInternalError(ctx, "string too long");
    goto fail;
  }
  if (string_buffer_init2(ctx, b, n * len, p->is_wide_char)) goto fail;
  if (len == 1) {
    string_buffer_fill(b, string_get(p, 0), n);
  } else {
    while (n-- > 0) {
      string_buffer_concat(b, p, 0, len);
    }
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

fail:
  LEPUS_FreeValue(ctx, str);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_string_trim(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv, int magic) {
  LEPUSValue str, ret;
  int a, b, len;
  LEPUSString *p;

  str = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return str;
  p = LEPUS_VALUE_GET_STRING(str);
  a = 0;
  b = len = p->len;
  if (magic & 1) {
    while (a < len && lre_is_space(string_get(p, a))) a++;
  }
  if (magic & 2) {
    while (b > a && lre_is_space(string_get(p, b - 1))) b--;
  }
  ret = lepus_sub_string(ctx, p, a, b);
  LEPUS_FreeValue(ctx, str);
  return ret;
}

QJS_STATIC LEPUSValue lepus_string___quote(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  return LEPUS_ToQuotedString(ctx, this_val);
}

/* return 0 if before the first char */
QJS_STATIC int string_prevc(LEPUSString *p, int *pidx) {
  int idx, c, c1;

  idx = *pidx;
  if (idx <= 0) return 0;
  idx--;
  if (p->is_wide_char) {
    c = p->u.str16[idx];
    if (c >= 0xdc00 && c < 0xe000 && idx > 0) {
      c1 = p->u.str16[idx - 1];
      if (c1 >= 0xd800 && c1 <= 0xdc00) {
        c = (((c1 & 0x3ff) << 10) | (c & 0x3ff)) + 0x10000;
        idx--;
      }
    }
  } else {
    c = p->u.str8[idx];
  }
  *pidx = idx;
  return c;
}

QJS_STATIC BOOL test_final_sigma(LEPUSString *p, int sigma_pos) {
  int k, c1;

  /* before C: skip case ignorable chars and check there is
     a cased letter */
  k = sigma_pos;
  for (;;) {
    c1 = string_prevc(p, &k);
    if (!lre_is_case_ignorable(c1)) break;
  }
  if (!lre_is_cased(c1)) return FALSE;

  /* after C: skip case ignorable chars and check there is
     no cased letter */
  k = sigma_pos + 1;
  for (;;) {
    if (k >= p->len) return TRUE;
    c1 = string_getc(p, &k);
    if (!lre_is_case_ignorable(c1)) break;
  }
  return !lre_is_cased(c1);
}

QJS_STATIC LEPUSValue lepus_string_localeCompare(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  LEPUSValue a, b;
  int cmp;

  a = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(a)) return LEPUS_EXCEPTION;
  b = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(b)) {
    LEPUS_FreeValue(ctx, a);
    return LEPUS_EXCEPTION;
  }
  cmp = lepus_string_compare(ctx, LEPUS_VALUE_GET_STRING(a),
                             LEPUS_VALUE_GET_STRING(b));
  LEPUS_FreeValue(ctx, a);
  LEPUS_FreeValue(ctx, b);
  return LEPUS_NewInt32(ctx, cmp);
}

QJS_STATIC LEPUSValue lepus_string_toLowerCase(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv,
                                               int to_lower) {
  LEPUSValue val;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *p;
  int i, c, j, l;
  uint32_t res[LRE_CC_RES_LEN_MAX];

  val = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = LEPUS_VALUE_GET_STRING(val);
  if (p->len == 0) return val;
  if (string_buffer_init(ctx, b, p->len)) goto fail;
  for (i = 0; i < p->len;) {
    c = string_getc(p, &i);
    if (c == 0x3a3 && to_lower && test_final_sigma(p, i - 1)) {
      res[0] = 0x3c2; /* final sigma */
      l = 1;
    } else {
      l = lre_case_conv(res, c, to_lower);
    }
    for (j = 0; j < l; j++) {
      if (string_buffer_putc(b, res[j])) goto fail;
    }
  }
  LEPUS_FreeValue(ctx, val);
  return string_buffer_end(b);
fail:
  LEPUS_FreeValue(ctx, val);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

#ifdef CONFIG_ALL_UNICODE

/* return (-1, NULL) if exception, otherwise (len, buf) */
QJS_STATIC int LEPUS_ToUTF32String(LEPUSContext *ctx, uint32_t **pbuf,
                                   LEPUSValueConst val1) {
  LEPUSValue val;
  LEPUSString *p;
  uint32_t *buf;
  int i, j, len;

  val = LEPUS_ToString(ctx, val1);
  if (LEPUS_IsException(val)) return -1;
  p = LEPUS_VALUE_GET_STRING(val);
  len = p->len;
  /* UTF32 buffer length is len minus the number of correct surrogates pairs */
  buf = static_cast<uint32_t *>(
      lepus_malloc(ctx, sizeof(buf[0]) * max_int(len, 1)));
  if (!buf) {
    LEPUS_FreeValue(ctx, val);
    goto fail;
  }
  for (i = j = 0; i < len;) buf[j++] = string_getc(p, &i);
  LEPUS_FreeValue(ctx, val);
  *pbuf = buf;
  return j;
fail:
  *pbuf = NULL;
  return -1;
}

QJS_STATIC LEPUSValue LEPUS_NewUTF32String(LEPUSContext *ctx,
                                           const uint32_t *buf, int len) {
  int i;
  StringBuffer b_s, *b = &b_s;
  if (string_buffer_init(ctx, b, len)) return LEPUS_EXCEPTION;
  for (i = 0; i < len; i++) {
    if (string_buffer_putc(b, buf[i])) goto fail;
  }
  return string_buffer_end(b);
fail:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_string_normalize(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  const char *form, *p;
  size_t form_len;
  int is_compat, buf_len, out_len;
  UnicodeNormalizationEnum n_type;
  LEPUSValue val;
  uint32_t *buf, *out_buf;

  val = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  buf_len = LEPUS_ToUTF32String(ctx, &buf, val);
  LEPUS_FreeValue(ctx, val);
  if (buf_len < 0) return LEPUS_EXCEPTION;

  if (argc == 0 || LEPUS_IsUndefined(argv[0])) {
    n_type = UNICODE_NFC;
  } else {
    form = LEPUS_ToCStringLen(ctx, &form_len, argv[0]);
    if (!form) goto fail1;
    p = form;
    if (p[0] != 'N' || p[1] != 'F') goto bad_form;
    p += 2;
    is_compat = FALSE;
    if (*p == 'K') {
      is_compat = TRUE;
      p++;
    }
    if (*p == 'C' || *p == 'D') {
      n_type = static_cast<UnicodeNormalizationEnum>(
          UNICODE_NFC + is_compat * 2 + (*p - 'C'));
      if ((p + 1 - form) != form_len) goto bad_form;
    } else {
    bad_form:
      LEPUS_FreeCString(ctx, form);
      LEPUS_ThrowRangeError(ctx, "bad normalization form");
    fail1:
      lepus_free(ctx, buf);
      return LEPUS_EXCEPTION;
    }
    LEPUS_FreeCString(ctx, form);
  }

  out_len = unicode_normalize(&out_buf, buf, buf_len, n_type, ctx->rt,
                              (DynBufReallocFunc *)lepus_realloc_rt);
  lepus_free(ctx, buf);
  if (out_len < 0) return LEPUS_EXCEPTION;
  val = LEPUS_NewUTF32String(ctx, out_buf, out_len);
  lepus_free(ctx, out_buf);
  return val;
}
#endif /* CONFIG_ALL_UNICODE */

/* also used for String.prototype.valueOf */
QJS_STATIC LEPUSValue lepus_string_toString(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  return lepus_thisStringValue(ctx, this_val);
}

#if 0
static LEPUSValue lepus_string___toStringCheckObject(LEPUSContext *ctx, LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv)
{
    return LEPUS_ToStringCheckObject(ctx, argv[0]);
}

static LEPUSValue lepus_string___toString(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv)
{
    return LEPUS_ToString(ctx, argv[0]);
}

static LEPUSValue lepus_string___advanceStringIndex(LEPUSContext *ctx, LEPUSValueConst
                                              this_val,
                                              int argc, LEPUSValueConst *argv)
{
    LEPUSValue str;
    int idx;
    BOOL is_unicode;
    LEPUSString *p;

    str = LEPUS_ToString(ctx, argv[0]);
    if (LEPUS_IsException(str))
        return str;
    if (LEPUS_ToInt32Sat(ctx, &idx, argv[1])) {
        LEPUS_FreeValue(ctx, str);
        return LEPUS_EXCEPTION;
    }
    is_unicode = LEPUS_ToBool(ctx, argv[2]);
    p = LEPUS_VALUE_GET_STRING(str);
    if (!is_unicode || (unsigned)idx >= p->len || !p->is_wide_char) {
        idx++;
    } else {
        string_getc(p, &idx);
    }
    LEPUS_FreeValue(ctx, str);
    return LEPUS_NewInt32(ctx, idx);
}
#endif

/* String Iterator */

QJS_STATIC LEPUSValue lepus_string_iterator_next(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv,
                                                 BOOL *pdone, int magic) {
  LEPUSArrayIteratorData *it;
  uint32_t idx, c, start;
  LEPUSString *p;

  it = static_cast<LEPUSArrayIteratorData *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_STRING_ITERATOR));
  if (!it) {
    *pdone = FALSE;
    return LEPUS_EXCEPTION;
  }
  if (LEPUS_IsUndefined(it->obj)) goto done;
  p = LEPUS_VALUE_GET_STRING(it->obj);
  idx = it->idx;
  if (idx >= p->len) {
    LEPUS_FreeValue(ctx, it->obj);
    it->obj = LEPUS_UNDEFINED;
  done:
    *pdone = TRUE;
    return LEPUS_UNDEFINED;
  }

  start = idx;
  c = string_getc(p, (int *)&idx);
  it->idx = idx;
  *pdone = FALSE;
  if (c <= 0xffff) {
    return lepus_new_string_char(ctx, c);
  } else {
    return lepus_new_string16(ctx, p->u.str16 + start, 2);
  }
}

/* ES6 Annex B 2.3.2 etc. */
enum {
  magic_string_anchor,
  magic_string_big,
  magic_string_blink,
  magic_string_bold,
  magic_string_fixed,
  magic_string_fontcolor,
  magic_string_fontsize,
  magic_string_italics,
  magic_string_link,
  magic_string_small,
  magic_string_strike,
  magic_string_sub,
  magic_string_sup,
};

QJS_STATIC LEPUSValue lepus_string_CreateHTML(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv,
                                              int magic) {
  LEPUSValue str;
  const LEPUSString *p;
  StringBuffer b_s, *b = &b_s;
  static struct {
    const char *tag, *attr;
  } const defs[] = {
      {"a", "name"}, {"big", NULL},     {"blink", NULL},  {"b", NULL},
      {"tt", NULL},  {"font", "color"}, {"font", "size"}, {"i", NULL},
      {"a", "href"}, {"small", NULL},   {"strike", NULL}, {"sub", NULL},
      {"sup", NULL},
  };

  str = LEPUS_ToStringCheckObject(ctx, this_val);
  if (LEPUS_IsException(str)) return LEPUS_EXCEPTION;
  string_buffer_init(ctx, b, 7);
  string_buffer_putc8(b, '<');
  string_buffer_puts8(b, defs[magic].tag);
  if (defs[magic].attr) {
    // r += " " + attr + "=\"" + value + "\"";
    LEPUSValue value;
    int i;

    string_buffer_putc8(b, ' ');
    string_buffer_puts8(b, defs[magic].attr);
    string_buffer_puts8(b, "=\"");
    value = LEPUS_ToStringCheckObject(ctx, argv[0]);
    if (LEPUS_IsException(value)) {
      LEPUS_FreeValue(ctx, str);
      string_buffer_free(b);
      return LEPUS_EXCEPTION;
    }
    p = LEPUS_VALUE_GET_STRING(value);
    for (i = 0; i < p->len; i++) {
      int c = string_get(p, i);
      if (c == '"') {
        string_buffer_puts8(b, "&quot;");
      } else {
        string_buffer_putc16(b, c);
      }
    }
    LEPUS_FreeValue(ctx, value);
    string_buffer_putc8(b, '\"');
  }
  // return r + ">" + str + "</" + tag + ">";
  string_buffer_putc8(b, '>');
  string_buffer_concat_value_free(b, str);
  string_buffer_puts8(b, "</");
  string_buffer_puts8(b, defs[magic].tag);
  string_buffer_putc8(b, '>');
  return string_buffer_end(b);
}

static const LEPUSCFunctionListEntry lepus_string_funcs[] = {
    LEPUS_CFUNC_DEF("fromCharCode", 1, lepus_string_fromCharCode),
    LEPUS_CFUNC_DEF("fromCodePoint", 1, lepus_string_fromCodePoint),
    LEPUS_CFUNC_DEF("raw", 1, lepus_string_raw),
    // LEPUS_CFUNC_DEF("__toString", 1, lepus_string___toString ),
    // LEPUS_CFUNC_DEF("__isSpace", 1, lepus_string___isSpace ),
    // LEPUS_CFUNC_DEF("__toStringCheckObject", 1,
    // lepus_string___toStringCheckObject
    // ), LEPUS_CFUNC_DEF("__advanceStringIndex", 3,
    // lepus_string___advanceStringIndex
    // ), LEPUS_CFUNC_DEF("__GetSubstitution", 6, lepus_string___GetSubstitution
    // ),
};

static const LEPUSCFunctionListEntry lepus_string_proto_funcs[] = {
    LEPUS_PROP_INT32_DEF("length", 0, LEPUS_PROP_CONFIGURABLE),
    LEPUS_CFUNC_DEF("charCodeAt", 1, lepus_string_charCodeAt),
    LEPUS_CFUNC_DEF("charAt", 1, lepus_string_charAt),
    LEPUS_CFUNC_DEF("concat", 1, lepus_string_concat),
    LEPUS_CFUNC_DEF("codePointAt", 1, lepus_string_codePointAt),
    LEPUS_CFUNC_MAGIC_DEF("indexOf", 1, lepus_string_indexOf, 0),
    LEPUS_CFUNC_MAGIC_DEF("lastIndexOf", 1, lepus_string_indexOf, 1),
    LEPUS_CFUNC_MAGIC_DEF("includes", 1, lepus_string_includes, 0),
    LEPUS_CFUNC_MAGIC_DEF("endsWith", 1, lepus_string_includes, 2),
    LEPUS_CFUNC_MAGIC_DEF("startsWith", 1, lepus_string_includes, 1),
    LEPUS_CFUNC_MAGIC_DEF("match", 1, lepus_string_match,
                          LEPUS_ATOM_Symbol_match),
    LEPUS_CFUNC_MAGIC_DEF("matchAll", 1, lepus_string_match,
                          LEPUS_ATOM_Symbol_matchAll),
    LEPUS_CFUNC_MAGIC_DEF("search", 1, lepus_string_match,
                          LEPUS_ATOM_Symbol_search),
    LEPUS_CFUNC_DEF("split", 2, lepus_string_split),
    LEPUS_CFUNC_DEF("substring", 2, lepus_string_substring),
    LEPUS_CFUNC_DEF("substr", 2, lepus_string_substr),
    LEPUS_CFUNC_DEF("slice", 2, lepus_string_slice),
    LEPUS_CFUNC_DEF("repeat", 1, lepus_string_repeat),
    LEPUS_CFUNC_DEF("replace", 2, lepus_string_replace),
    LEPUS_CFUNC_MAGIC_DEF("padEnd", 1, lepus_string_pad, 1),
    LEPUS_CFUNC_MAGIC_DEF("padStart", 1, lepus_string_pad, 0),
    LEPUS_CFUNC_MAGIC_DEF("trim", 0, lepus_string_trim, 3),
    LEPUS_CFUNC_MAGIC_DEF("trimEnd", 0, lepus_string_trim, 2),
    LEPUS_ALIAS_DEF("trimRight", "trimEnd"),
    LEPUS_CFUNC_MAGIC_DEF("trimStart", 0, lepus_string_trim, 1),
    LEPUS_ALIAS_DEF("trimLeft", "trimStart"),
    LEPUS_CFUNC_DEF("toString", 0, lepus_string_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, lepus_string_toString),
    LEPUS_CFUNC_DEF("__quote", 1, lepus_string___quote),
    LEPUS_CFUNC_DEF("localeCompare", 1, lepus_string_localeCompare),
    LEPUS_CFUNC_MAGIC_DEF("toLowerCase", 0, lepus_string_toLowerCase, 1),
    LEPUS_CFUNC_MAGIC_DEF("toUpperCase", 0, lepus_string_toLowerCase, 0),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleLowerCase", 0, lepus_string_toLowerCase, 1),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleUpperCase", 0, lepus_string_toLowerCase, 0),
    LEPUS_CFUNC_MAGIC_DEF("[Symbol.iterator]", 0, lepus_create_array_iterator,
                          LEPUS_ITERATOR_KIND_VALUE | 4),
    /* ES6 Annex B 2.3.2 etc. */
    LEPUS_CFUNC_MAGIC_DEF("anchor", 1, lepus_string_CreateHTML,
                          magic_string_anchor),
    LEPUS_CFUNC_MAGIC_DEF("big", 0, lepus_string_CreateHTML, magic_string_big),
    LEPUS_CFUNC_MAGIC_DEF("blink", 0, lepus_string_CreateHTML,
                          magic_string_blink),
    LEPUS_CFUNC_MAGIC_DEF("bold", 0, lepus_string_CreateHTML,
                          magic_string_bold),
    LEPUS_CFUNC_MAGIC_DEF("fixed", 0, lepus_string_CreateHTML,
                          magic_string_fixed),
    LEPUS_CFUNC_MAGIC_DEF("fontcolor", 1, lepus_string_CreateHTML,
                          magic_string_fontcolor),
    LEPUS_CFUNC_MAGIC_DEF("fontsize", 1, lepus_string_CreateHTML,
                          magic_string_fontsize),
    LEPUS_CFUNC_MAGIC_DEF("italics", 0, lepus_string_CreateHTML,
                          magic_string_italics),
    LEPUS_CFUNC_MAGIC_DEF("link", 1, lepus_string_CreateHTML,
                          magic_string_link),
    LEPUS_CFUNC_MAGIC_DEF("small", 0, lepus_string_CreateHTML,
                          magic_string_small),
    LEPUS_CFUNC_MAGIC_DEF("strike", 0, lepus_string_CreateHTML,
                          magic_string_strike),
    LEPUS_CFUNC_MAGIC_DEF("sub", 0, lepus_string_CreateHTML, magic_string_sub),
    LEPUS_CFUNC_MAGIC_DEF("sup", 0, lepus_string_CreateHTML, magic_string_sup),
};

static const LEPUSCFunctionListEntry lepus_string_iterator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 0, lepus_string_iterator_next, 0),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "String Iterator",
                          LEPUS_PROP_CONFIGURABLE),
};

#ifdef CONFIG_ALL_UNICODE
static const LEPUSCFunctionListEntry lepus_string_proto_normalize[] = {
    LEPUS_CFUNC_DEF("normalize", 0, lepus_string_normalize),
};
#endif

void LEPUS_AddIntrinsicStringNormalize(LEPUSContext *ctx) {
#ifdef CONFIG_ALL_UNICODE
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_STRING],
                                lepus_string_proto_normalize,
                                countof(lepus_string_proto_normalize));
#endif
}

/* Math */

/* precondition: a and b are not NaN */
QJS_STATIC double lepus_fmin(double a, double b) {
  if (a == 0 && b == 0) {
    LEPUSFloat64Union a1, b1;
    a1.d = a;
    b1.d = b;
    a1.u64 |= b1.u64;
    return a1.d;
  } else {
    return fmin(a, b);
  }
}

/* precondition: a and b are not NaN */
QJS_STATIC double lepus_fmax(double a, double b) {
  if (a == 0 && b == 0) {
    LEPUSFloat64Union a1, b1;
    a1.d = a;
    b1.d = b;
    a1.u64 &= b1.u64;
    return a1.d;
  } else {
    return fmax(a, b);
  }
}

#ifdef CONFIG_BIGNUM

enum {
  MATH_OP_ABS,
  MATH_OP_FLOOR,
  MATH_OP_CEIL,
  MATH_OP_ROUND,
  MATH_OP_TRUNC,
  MATH_OP_SQRT,
  MATH_OP_FPROUND,
  MATH_OP_ACOS,
  MATH_OP_ASIN,
  MATH_OP_ATAN,
  MATH_OP_ATAN2,
  MATH_OP_COS,
  MATH_OP_EXP,
  MATH_OP_LOG,
  MATH_OP_POW,
  MATH_OP_SIN,
  MATH_OP_TAN,
  MATH_OP_FMOD,
  MATH_OP_REM,
  MATH_OP_SIGN,

  MATH_OP_ADD,
  MATH_OP_SUB,
  MATH_OP_MUL,
  MATH_OP_DIV,
};

static LEPUSValue lepus_math_fop(LEPUSContext *ctx, LEPUSValueConst this_val,
                                 int argc, LEPUSValueConst *argv, int magic) {
  bf_t a_s, *a, r_s, *r = &r_s;
  BOOL is_float;
  LEPUSFloatEnv *fe;
  int rnd_mode;
  LEPUSValue op1;

  op1 = LEPUS_ToNumber(ctx, argv[0]);
  if (LEPUS_IsException(op1)) return op1;
  a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
  fe = &ctx->fp_env;
  if (argc > 1) {
    fe = static_cast<LEPUSFloatEnv *>(
        LEPUS_GetOpaque2(ctx, argv[1], LEPUS_CLASS_FLOAT_ENV));
    if (!fe) {
      if (a == &a_s) bf_delete(a);
      LEPUS_FreeValue(ctx, op1);
      return LEPUS_EXCEPTION;
    }
  }

  bf_init(ctx->bf_ctx, r);
  switch (magic) {
    case MATH_OP_ABS:
      bf_set(r, a);
      r->sign = 0;
      break;
    case MATH_OP_FLOOR:
      rnd_mode = BF_RNDD;
      goto rint;
    case MATH_OP_CEIL:
      rnd_mode = BF_RNDU;
      goto rint;
    case MATH_OP_ROUND:
      rnd_mode = BF_RNDNU;
      goto rint;
    case MATH_OP_TRUNC:
      rnd_mode = BF_RNDZ;
    rint:
      bf_set(r, a);
      fe->status |= bf_rint(r, fe->prec, (fe->flags & ~BF_RND_MASK) | rnd_mode);
      break;
    case MATH_OP_SQRT:
      fe->status |= bf_sqrt(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_FPROUND:
      bf_set(r, a);
      fe->status |= bf_round(r, fe->prec, fe->flags);
      break;
    case MATH_OP_ACOS:
      fe->status |= bf_acos(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_ASIN:
      fe->status |= bf_asin(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_ATAN:
      fe->status |= bf_atan(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_COS:
      fe->status |= bf_cos(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_EXP:
      fe->status |= bf_exp(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_LOG:
      fe->status |= bf_log(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_SIN:
      fe->status |= bf_sin(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_TAN:
      fe->status |= bf_tan(r, a, fe->prec, fe->flags);
      break;
    case MATH_OP_SIGN:
      if (bf_is_nan(a) || bf_is_zero(a)) {
        bf_set(r, a);
      } else {
        bf_set_si(r, 1 - 2 * a->sign);
      }
      break;
    default:
      abort();
  }
  if (a == &a_s) bf_delete(a);
  LEPUS_FreeValue(ctx, op1);
  return LEPUS_NewBigFloat(ctx, r);
}

static LEPUSValue lepus_math_fop2(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv, int magic) {
  bf_t a_s, *a, b_s, *b, r_s, *r = &r_s;
  BOOL is_float;
  LEPUSFloatEnv *fe;
  LEPUSValue op1, op2;

  op1 = LEPUS_ToNumber(ctx, argv[0]);
  if (LEPUS_IsException(op1)) return op1;
  op2 = LEPUS_ToNumber(ctx, argv[1]);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    return op2;
  }
  a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, op1);
  b = LEPUS_ToBigFloat(ctx, &is_float, &b_s, op2);
  fe = &ctx->fp_env;
  if (argc > 2) {
    fe = static_cast<LEPUSFloatEnv *>(
        LEPUS_GetOpaque2(ctx, (argv[2]), LEPUS_CLASS_FLOAT_ENV));
    if (!fe) {
      if (a == &a_s) bf_delete(a);
      if (b == &b_s) bf_delete(b);
      LEPUS_FreeValue(ctx, op1);
      LEPUS_FreeValue(ctx, op2);
      return LEPUS_EXCEPTION;
    }
  }

  bf_init(ctx->bf_ctx, r);
  switch (magic) {
    case MATH_OP_ATAN2:
      fe->status |= bf_atan2(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_POW:
      fe->status |= bf_pow(r, a, b, fe->prec, fe->flags | BF_POW_JS_QUICKS);
      break;
    case MATH_OP_FMOD:
      fe->status |= bf_fmod(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_REM:
      fe->status |= bf_remainder(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_ADD:
      fe->status |= bf_add(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_SUB:
      fe->status |= bf_sub(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_MUL:
      fe->status |= bf_mul(r, a, b, fe->prec, fe->flags);
      break;
    case MATH_OP_DIV:
      fe->status |= bf_div(r, a, b, fe->prec, fe->flags);
      break;
    default:
      abort();
  }
  if (a == &a_s) bf_delete(a);
  if (b == &b_s) bf_delete(b);
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return LEPUS_NewBigFloat(ctx, r);
}

static LEPUSValue lepus_math_min_max(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int magic) {
  BOOL is_max = magic;
  LEPUSValue val, ret;
  int i;
  uint32_t tag;

  if (unlikely(argc == 0)) {
    return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
  }

  tag = LEPUS_VALUE_GET_TAG(argv[0]);
  if (tag == LEPUS_TAG_INT) {
    int a1, r1 = LEPUS_VALUE_GET_INT(argv[0]);
    for (i = 1; i < argc; i++) {
      tag = LEPUS_VALUE_GET_TAG(argv[i]);
      if (tag != LEPUS_TAG_INT) {
        ret = LEPUS_NewInt32(ctx, r1);
        goto generic_case;
      }
      a1 = LEPUS_VALUE_GET_INT(argv[i]);
      if (is_max)
        r1 = max_int(r1, a1);
      else
        r1 = min_int(r1, a1);
    }
    ret = LEPUS_NewInt32(ctx, r1);
  } else {
    ret = LEPUS_ToNumber(ctx, argv[0]);
    if (LEPUS_IsException(ret)) return ret;
    i = 1;
  generic_case:
    for (; i < argc; i++) {
      val = LEPUS_ToNumber(ctx, argv[i]);
      if (LEPUS_IsException(val)) {
        LEPUS_FreeValue(ctx, ret);
        return val;
      }
      if (LEPUS_TAG_IS_FLOAT64(LEPUS_VALUE_GET_TAG(ret)) &&
          LEPUS_TAG_IS_FLOAT64(LEPUS_VALUE_GET_TAG(val))) {
        double r, a;
        r = LEPUS_VALUE_GET_FLOAT64(ret);
        a = LEPUS_VALUE_GET_FLOAT64(val);
        if (!isnan(r)) {
          if (isnan(a)) {
            r = a;
          } else {
            if (is_max)
              r = lepus_fmax(r, a);
            else
              r = lepus_fmin(r, a);
          }
          ret = __JS_NewFloat64(ctx, r);
        }
      } else {
        bf_t a_s, *a, r_s, *r;
        BOOL is_float;
        int res;

        r = LEPUS_ToBigFloat(ctx, &is_float, &r_s, ret);
        if (!bf_is_nan(r)) {
          a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, val);
          res = bf_cmp_full(a, r);
          if (is_max) res = -res;
          if (bf_is_nan(a) || res < 0) {
            LEPUS_FreeValue(ctx, ret);
            ret = LEPUS_DupValue(ctx, val);
          }
          if (a == &a_s) bf_delete(a);
        }
        if (r == &r_s) bf_delete(r);
      }
    }
  }
  return ret;
}

static LEPUSValue lepus_math_abs(LEPUSContext *ctx, LEPUSValueConst this_val,
                                 int argc, LEPUSValueConst *argv) {
  LEPUSValue val;
  int32_t tag;

  val = LEPUS_ToNumeric(ctx, argv[0]);
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
      if (LEPUS_VALUE_GET_INT(val) < 0)
        val = LEPUS_NewInt64(ctx, -(int64_t)LEPUS_VALUE_GET_INT(val));
      break;
    case LEPUS_TAG_FLOAT64:
      val = __JS_NewFloat64(ctx, fabs(LEPUS_VALUE_GET_FLOAT64(val)));
      break;
    case LEPUS_TAG_BIG_FLOAT:
    case LEPUS_TAG_BIG_INT: {
      LEPUSBigFloat *p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
      bf_t r_s, *r = &r_s;
      bf_init(ctx->bf_ctx, r);
      bf_set(r, &p->num);
      r->sign = 0;
      LEPUS_FreeValue(ctx, val);
      if (tag == LEPUS_TAG_BIG_FLOAT)
        val = LEPUS_NewBigFloat(ctx, r);
      else
        val = LEPUS_NewBigInt2(ctx, r, TRUE);
    } break;
    default:
      break;
  }
  return val;
}

#if 0
/* XXX: should give exact rounding */
/* XXX: correct NaN/Infinity handling */
static LEPUSValue lepus_math_hypot(LEPUSContext *ctx, LEPUSValueConst this_val,
                             int argc, LEPUSValueConst *argv)
{
    bf_t a_s, *a, r_s, *r = &r_s, r2_s, *r2 = &r2_s;
    LEPUSValue val;
    int i;
    BOOL is_float;

    bf_init(ctx->bf_ctx, r);
    bf_set_si(r, 0);
    for(i = 0; i < argc; i++) {
        val = LEPUS_ToNumber(ctx, argv[i]);
        if (LEPUS_IsException(val)) {
            bf_delete(r);
            return val;
        }
        a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, val);
        bf_add(r, r, a, ctx->fp_env.prec, ctx->fp_env.flags);
        if (a == &a_s)
            bf_delete(a);
    }
    bf_init(ctx->bf_ctx, r2);
    bf_sqrt(r2, r, ctx->fp_env.prec, ctx->fp_env.flags);
    bf_delete(r);
    return LEPUS_NewBigFloat(ctx, r2);
}
#endif

#else

QJS_STATIC LEPUSValue lepus_math_min_max(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv, int magic) {
  BOOL is_max = magic;
  double r, a;
  int i;

  if (unlikely(argc == 0)) {
    return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
  }

  if (LEPUS_VALUE_IS_INT(argv[0])) {
    int a1, r1 = LEPUS_VALUE_GET_INT(argv[0]);
    for (i = 1; i < argc; i++) {
      if (!LEPUS_VALUE_IS_INT(argv[i])) {
        r = r1;
        goto generic_case;
      }
      a1 = LEPUS_VALUE_GET_INT(argv[i]);
      if (is_max)
        r1 = max_int(r1, a1);
      else
        r1 = min_int(r1, a1);
    }
    return LEPUS_NewInt32(ctx, r1);
  } else {
    if (LEPUS_ToFloat64(ctx, &r, argv[0])) return LEPUS_EXCEPTION;
    i = 1;
  generic_case:
    while (i < argc) {
      if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
      if (!isnan(r)) {
        if (isnan(a)) {
          r = a;
        } else {
          if (is_max)
            r = lepus_fmax(r, a);
          else
            r = lepus_fmin(r, a);
        }
      }
      i++;
    }
    return LEPUS_NewFloat64(ctx, r);
  }
}

#endif /* !CONFIG_BIGNUM */

QJS_STATIC double lepus_math_sign(double a) {
  if (isnan(a) || a == 0.0) return a;
  if (a < 0)
    return -1;
  else
    return 1;
}

QJS_STATIC double lepus_math_round(double a) {
  LEPUSFloat64Union u;
  uint64_t frac_mask, one;
  unsigned int e, s;

  u.d = a;
  e = (u.u64 >> 52) & 0x7ff;
  if (e < 1023) {
    /* abs(a) < 1 */
    if (e == (1023 - 1) && u.u64 != 0xbfe0000000000000) {
      /* abs(a) > 0.5 or a = 0.5: return +/-1.0 */
      u.u64 = (u.u64 & ((uint64_t)1 << 63)) | ((uint64_t)1023 << 52);
    } else {
      /* return +/-0.0 */
      u.u64 &= (uint64_t)1 << 63;
    }
  } else if (e < (1023 + 52)) {
    s = u.u64 >> 63;
    one = (uint64_t)1 << (52 - (e - 1023));
    frac_mask = one - 1;
    u.u64 += (one >> 1) - s;
    u.u64 &= ~frac_mask; /* truncate to an integer */
  }
  /* otherwise: abs(a) >= 2^52, or NaN, +/-Infinity: no change */
  return u.d;
}

QJS_STATIC LEPUSValue lepus_math_hypot(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  double r, a, b;
  int i;

  if (argc == 2) {
    /* use the more precise built-in function when possible */
    if (LEPUS_ToFloat64(ctx, &a, argv[0])) return LEPUS_EXCEPTION;
    if (LEPUS_ToFloat64(ctx, &b, argv[1])) return LEPUS_EXCEPTION;
    r = hypot(a, b);
  } else {
    r = 0;
    for (i = 0; i < argc; i++) {
      if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
      r += a;
    }
    r = sqrt(r);
  }
  return LEPUS_NewFloat64(ctx, r);
}

QJS_STATIC double lepus_math_fround(double a) { return (float)a; }

QJS_STATIC LEPUSValue lepus_math_imul(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv) {
  int a, b;

  if (LEPUS_ToInt32(ctx, &a, argv[0])) return LEPUS_EXCEPTION;
  if (LEPUS_ToInt32(ctx, &b, argv[1])) return LEPUS_EXCEPTION;
  /* purposely ignoring overflow */
  return LEPUS_NewInt32(ctx, a * b);
}

QJS_STATIC LEPUSValue lepus_math_clz32(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  uint32_t a, r;

  if (LEPUS_ToUint32(ctx, &a, argv[0])) return LEPUS_EXCEPTION;
  if (a == 0)
    r = 32;
  else
    r = clz32(a);
  return LEPUS_NewInt32(ctx, r);
}

/* xorshift* random number generator by Marsaglia */
QJS_STATIC uint64_t xorshift64star(uint64_t *pstate) {
  uint64_t x;
  x = *pstate;
  x ^= x >> 12;
  x ^= x << 25;
  x ^= x >> 27;
  *pstate = x;
  return x * 0x2545F4914F6CDD1D;
}

QJS_STATIC void lepus_random_init(LEPUSContext *ctx) {
  struct timeval tv;
  gettimeofday(&tv, NULL);
  ctx->random_state = ((int64_t)tv.tv_sec * 1000000) + tv.tv_usec;
  /* the state must be non zero */
  if (ctx->random_state == 0) ctx->random_state = 1;
}

QJS_STATIC LEPUSValue lepus_math_random(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSFloat64Union u;
  uint64_t v;

  v = xorshift64star(&ctx->random_state);
  /* 1.0 <= u.d < 2 */
  u.u64 = ((uint64_t)0x3ff << 52) | (v >> 12);
  return __JS_NewFloat64(ctx, u.d - 1.0);
}

static const LEPUSCFunctionListEntry lepus_math_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("min", 2, lepus_math_min_max, 0),
    LEPUS_CFUNC_MAGIC_DEF("max", 2, lepus_math_min_max, 1),
#ifdef CONFIG_BIGNUM
    LEPUS_CFUNC_DEF("abs", 1, lepus_math_abs),
#else
    LEPUS_CFUNC_SPECIAL_DEF("abs", 1, f_f, fabs),
#endif
    LEPUS_CFUNC_SPECIAL_DEF("floor", 1, f_f, floor),
    LEPUS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, ceil),
    LEPUS_CFUNC_SPECIAL_DEF("round", 1, f_f, lepus_math_round),
    LEPUS_CFUNC_SPECIAL_DEF("sqrt", 1, f_f, sqrt),

    LEPUS_CFUNC_SPECIAL_DEF("acos", 1, f_f, acos),
    LEPUS_CFUNC_SPECIAL_DEF("asin", 1, f_f, asin),
    LEPUS_CFUNC_SPECIAL_DEF("atan", 1, f_f, atan),
    LEPUS_CFUNC_SPECIAL_DEF("atan2", 2, f_f_f, atan2),
    LEPUS_CFUNC_SPECIAL_DEF("cos", 1, f_f, cos),
    LEPUS_CFUNC_SPECIAL_DEF("exp", 1, f_f, exp),
    LEPUS_CFUNC_SPECIAL_DEF("log", 1, f_f, log),
    LEPUS_CFUNC_SPECIAL_DEF("pow", 2, f_f_f, lepus_pow),
    LEPUS_CFUNC_SPECIAL_DEF("sin", 1, f_f, sin),
    LEPUS_CFUNC_SPECIAL_DEF("tan", 1, f_f, tan),
    /* ES6 */
    LEPUS_CFUNC_SPECIAL_DEF("trunc", 1, f_f, trunc),
    LEPUS_CFUNC_SPECIAL_DEF("sign", 1, f_f, lepus_math_sign),
    LEPUS_CFUNC_SPECIAL_DEF("cosh", 1, f_f, cosh),
    LEPUS_CFUNC_SPECIAL_DEF("sinh", 1, f_f, sinh),
    LEPUS_CFUNC_SPECIAL_DEF("tanh", 1, f_f, tanh),
    LEPUS_CFUNC_SPECIAL_DEF("acosh", 1, f_f, acosh),
    LEPUS_CFUNC_SPECIAL_DEF("asinh", 1, f_f, asinh),
    LEPUS_CFUNC_SPECIAL_DEF("atanh", 1, f_f, atanh),
    LEPUS_CFUNC_SPECIAL_DEF("expm1", 1, f_f, expm1),
    LEPUS_CFUNC_SPECIAL_DEF("log1p", 1, f_f, log1p),
    LEPUS_CFUNC_SPECIAL_DEF("log2", 1, f_f, log2),
    LEPUS_CFUNC_SPECIAL_DEF("log10", 1, f_f, log10),
    LEPUS_CFUNC_SPECIAL_DEF("cbrt", 1, f_f, cbrt),
    LEPUS_CFUNC_DEF("hypot", 2, lepus_math_hypot),
    LEPUS_CFUNC_DEF("random", 0, lepus_math_random),
    LEPUS_CFUNC_SPECIAL_DEF("fround", 1, f_f, lepus_math_fround),
    LEPUS_CFUNC_DEF("imul", 2, lepus_math_imul),
    LEPUS_CFUNC_DEF("clz32", 1, lepus_math_clz32),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Math",
                          LEPUS_PROP_CONFIGURABLE),
    LEPUS_PROP_DOUBLE_DEF("E", 2.718281828459045, 0),
    LEPUS_PROP_DOUBLE_DEF("LN10", 2.302585092994046, 0),
    LEPUS_PROP_DOUBLE_DEF("LN2", 0.6931471805599453, 0),
    LEPUS_PROP_DOUBLE_DEF("LOG2E", 1.4426950408889634, 0),
    LEPUS_PROP_DOUBLE_DEF("LOG10E", 0.4342944819032518, 0),
    LEPUS_PROP_DOUBLE_DEF("PI", 3.141592653589793, 0),
    LEPUS_PROP_DOUBLE_DEF("SQRT1_2", 0.7071067811865476, 0),
    LEPUS_PROP_DOUBLE_DEF("SQRT2", 1.4142135623730951, 0),
};

static const LEPUSCFunctionListEntry lepus_math_obj[] = {
    LEPUS_OBJECT_DEF("Math", lepus_math_funcs, countof(lepus_math_funcs),
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

/* Date */

#if 0
/* OS dependent: return the UTC time in ms since 1970. */
static LEPUSValue lepus___date_now(LEPUSContext *ctx, LEPUSValueConst this_val,
                             int argc, LEPUSValueConst *argv)
{
    int64_t d;
    struct timeval tv;
    gettimeofday(&tv, NULL);
    d = (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);
    return LEPUS_NewInt64(ctx, d);
}
#endif

/* OS dependent: return the UTC time in microseconds since 1970. */
QJS_STATIC LEPUSValue lepus___date_clock(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  int64_t d;
  struct timeval tv;
  gettimeofday(&tv, NULL);
  d = (int64_t)tv.tv_sec * 1000000 + tv.tv_usec;
  return LEPUS_NewInt64(ctx, d);
}

/* OS dependent. d = argv[0] is in ms from 1970. Return the difference
   between local time and UTC time 'd' in minutes */
QJS_STATIC int getTimezoneOffset(int64_t time) {
#if defined(_WIN32)
  /* XXX: TODO */
  return 0;
#else
  time_t ti;
  struct tm tm;

  time /= 1000; /* convert to seconds */
  if (sizeof(time_t) == 4) {
    /* on 32-bit systems, we need to clamp the time value to the
       range of `time_t`. This is better than truncating values to
       32 bits and hopefully provides the same result as 64-bit
       implementation of localtime_r.
     */
    if ((time_t)-1 < 0) {
      if (time < INT32_MIN) {
        time = INT32_MIN;
      } else if (time > INT32_MAX) {
        time = INT32_MAX;
      }
    } else {
      if (time < 0) {
        time = 0;
      } else if (time > UINT32_MAX) {
        time = UINT32_MAX;
      }
    }
  }
  ti = time;
  localtime_r(&ti, &tm);
  return -tm.tm_gmtoff / 60;
#endif
}

#if 0
static LEPUSValue lepus___date_getTimezoneOffset(LEPUSContext *ctx, LEPUSValueConst this_val,
                                           int argc, LEPUSValueConst *argv)
{
    double dd;

    if (LEPUS_ToFloat64(ctx, &dd, argv[0]))
        return LEPUS_EXCEPTION;
    if (isnan(dd))
        return __JS_NewFloat64(ctx, dd);
    else
        return LEPUS_NewInt32(ctx, getTimezoneOffset((int64_t)dd));
}

static LEPUSValue lepus_get_prototype_from_ctor(LEPUSContext *ctx, LEPUSValueConst ctor,
                                          LEPUSValueConst def_proto)
{
    LEPUSValue proto;
    proto = LEPUS_GetProperty(ctx, ctor, LEPUS_ATOM_prototype);
    if (LEPUS_IsException(proto))
        return proto;
    if (!LEPUS_IsObject(proto)) {
        LEPUS_FreeValue(ctx, proto);
        proto = LEPUS_DupValue(ctx, def_proto);
    }
    return proto;
}

/* create a new date object */
static LEPUSValue lepus___date_create(LEPUSContext *ctx, LEPUSValueConst this_val,
                                int argc, LEPUSValueConst *argv)
{
    LEPUSValue obj, proto;
    proto = lepus_get_prototype_from_ctor(ctx, argv[0], argv[1]);
    if (LEPUS_IsException(proto))
        return proto;
    obj = LEPUS_NewObjectProtoClass(ctx, proto, LEPUS_CLASS_DATE);
    LEPUS_FreeValue(ctx, proto);
    if (!LEPUS_IsException(obj))
        LEPUS_SetObjectData(ctx, obj, LEPUS_DupValue(ctx, argv[2]));
    return obj;
}
#endif

/* RegExp */

QJS_STATIC void lepus_regexp_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSRegExp *re = &p->u.regexp;
  LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_STRING, re->bytecode));
  LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_STRING, re->pattern));
}

/* create a string containing the RegExp bytecode */
QJS_STATIC LEPUSValue lepus_compile_regexp(LEPUSContext *ctx,
                                           LEPUSValueConst pattern,
                                           LEPUSValueConst flags) {
  const char *str;
  int re_flags, mask;
  uint8_t *re_bytecode_buf;
  size_t i, len;
  int re_bytecode_len;
  LEPUSValue ret;
  char error_msg[64];

  re_flags = 0;
  if (!LEPUS_IsUndefined(flags)) {
    str = LEPUS_ToCStringLen(ctx, &len, flags);
    if (!str) return LEPUS_EXCEPTION;
    /* XXX: re_flags = LRE_FLAG_OCTAL unless strict mode? */
    for (i = 0; i < len; i++) {
      switch (str[i]) {
        case 'g':
          mask = LRE_FLAG_GLOBAL;
          break;
        case 'i':
          mask = LRE_FLAG_IGNORECASE;
          break;
        case 'm':
          mask = LRE_FLAG_MULTILINE;
          break;
        case 's':
          mask = LRE_FLAG_DOTALL;
          break;
        case 'u':
          mask = LRE_FLAG_UTF16;
          break;
        case 'y':
          mask = LRE_FLAG_STICKY;
          break;
        default:
          goto bad_flags;
      }
      if ((re_flags & mask) != 0) {
      bad_flags:
        LEPUS_FreeCString(ctx, str);
        return LEPUS_ThrowSyntaxError(ctx, "invalid regular expression flags");
      }
      re_flags |= mask;
    }
    LEPUS_FreeCString(ctx, str);
  }

  str = LEPUS_ToCStringLen2(ctx, &len, pattern, !(re_flags & LRE_FLAG_UTF16));
  if (!str) return LEPUS_EXCEPTION;
  re_bytecode_buf = lre_compile(&re_bytecode_len, error_msg, sizeof(error_msg),
                                str, len, re_flags, ctx);
  LEPUS_FreeCString(ctx, str);
  if (!re_bytecode_buf) {
    LEPUS_ThrowSyntaxError(ctx, "%s", error_msg);
    return LEPUS_EXCEPTION;
  }

  ret = lepus_new_string8(ctx, re_bytecode_buf, re_bytecode_len);
  lepus_free(ctx, re_bytecode_buf);
  return ret;
}

/* create a RegExp object from a string containing the RegExp bytecode
   and the source pattern */
LEPUSValue lepus_regexp_constructor_internal(LEPUSContext *ctx,
                                             LEPUSValueConst ctor,
                                             LEPUSValue pattern,
                                             LEPUSValue bc) {
  LEPUSValue obj;
  LEPUSObject *p;
  LEPUSRegExp *re;

  /* sanity check */
  if (!LEPUS_VALUE_IS_STRING(bc) || !LEPUS_VALUE_IS_STRING(pattern)) {
    LEPUS_ThrowTypeError(ctx, "string expected");
  fail:
    LEPUS_FreeValue(ctx, bc);
    LEPUS_FreeValue(ctx, pattern);
    return LEPUS_EXCEPTION;
  }

  obj = lepus_create_from_ctor(ctx, ctor, LEPUS_CLASS_REGEXP);
  if (LEPUS_IsException(obj)) goto fail;
  p = LEPUS_VALUE_GET_OBJ(obj);
  re = &p->u.regexp;
  re->pattern = LEPUS_VALUE_GET_STRING(pattern);
  re->bytecode = LEPUS_VALUE_GET_STRING(bc);
  LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_lastIndex,
                            LEPUS_NewInt32(ctx, 0), LEPUS_PROP_WRITABLE);
  return obj;
}

QJS_HIDE LEPUSRegExp *lepus_get_regexp(LEPUSContext *ctx, LEPUSValueConst obj,
                                       BOOL throw_error) {
  if (LEPUS_VALUE_IS_OBJECT(obj)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
    if (p->class_id == LEPUS_CLASS_REGEXP) return &p->u.regexp;
  }
  if (throw_error) {
    LEPUS_ThrowTypeErrorInvalidClass(ctx, LEPUS_CLASS_REGEXP);
  }
  return NULL;
}

/* return < 0 if exception or TRUE/FALSE */
QJS_HIDE int lepus_is_regexp(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSValue m;

  if (!LEPUS_IsObject(obj)) return FALSE;
  m = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_Symbol_match);
  if (LEPUS_IsException(m)) return -1;
  if (!LEPUS_IsUndefined(m)) return LEPUS_ToBoolFree(ctx, m);
  return lepus_get_regexp(ctx, obj, FALSE) != NULL;
}

QJS_STATIC LEPUSValue lepus_regexp_constructor(LEPUSContext *ctx,
                                               LEPUSValueConst new_target,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue pattern, flags, bc, val;
  LEPUSValueConst pat, flags1;
  LEPUSRegExp *re;
  int pat_is_regexp;

  pat = argv[0];
  flags1 = argv[1];
  pat_is_regexp = lepus_is_regexp(ctx, pat);
  if (pat_is_regexp < 0) return LEPUS_EXCEPTION;
  if (LEPUS_IsUndefined(new_target)) {
    /* called as a function */
    new_target = LEPUS_GetActiveFunction(ctx);
    if (pat_is_regexp && LEPUS_IsUndefined(flags1)) {
      LEPUSValue ctor;
      BOOL res;
      ctor = LEPUS_GetProperty(ctx, pat, LEPUS_ATOM_constructor);
      if (LEPUS_IsException(ctor)) return ctor;
      res = lepus_same_value(ctx, ctor, new_target);
      LEPUS_FreeValue(ctx, ctor);
      if (res) return LEPUS_DupValue(ctx, pat);
    }
  }
  re = lepus_get_regexp(ctx, pat, FALSE);
  if (re) {
    pattern = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->pattern));
    if (LEPUS_IsUndefined(flags1)) {
      bc = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->bytecode));
      goto no_compilation;
    } else {
      flags = LEPUS_ToString(ctx, flags1);
      if (LEPUS_IsException(flags)) goto fail;
    }
  } else {
    flags = LEPUS_UNDEFINED;
    if (pat_is_regexp) {
      pattern = LEPUS_GetProperty(ctx, pat, LEPUS_ATOM_source);
      if (LEPUS_IsException(pattern)) goto fail;
      if (LEPUS_IsUndefined(flags1)) {
        flags = LEPUS_GetProperty(ctx, pat, LEPUS_ATOM_flags);
        if (LEPUS_IsException(flags)) goto fail;
      } else {
        flags = LEPUS_DupValue(ctx, flags1);
      }
    } else {
      pattern = LEPUS_DupValue(ctx, pat);
      flags = LEPUS_DupValue(ctx, flags1);
    }
    if (LEPUS_IsUndefined(pattern)) {
      pattern = LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string);
    } else {
      val = pattern;
      pattern = LEPUS_ToString(ctx, val);
      LEPUS_FreeValue(ctx, val);
      if (LEPUS_IsException(pattern)) goto fail;
    }
  }
  bc = lepus_compile_regexp(ctx, pattern, flags);
  if (LEPUS_IsException(bc)) goto fail;
  LEPUS_FreeValue(ctx, flags);
no_compilation:
  return lepus_regexp_constructor_internal(ctx, new_target, pattern, bc);
fail:
  LEPUS_FreeValue(ctx, pattern);
  LEPUS_FreeValue(ctx, flags);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_regexp_compile(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSRegExp *re1, *re;
  LEPUSValueConst pattern1, flags1;
  LEPUSValue bc, pattern;

  re = lepus_get_regexp(ctx, this_val, TRUE);
  if (!re) return LEPUS_EXCEPTION;
  pattern1 = argv[0];
  flags1 = argv[1];
  re1 = lepus_get_regexp(ctx, pattern1, FALSE);
  if (re1) {
    if (!LEPUS_IsUndefined(flags1))
      return LEPUS_ThrowTypeError(ctx, "flags must be undefined");
    pattern = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re1->pattern));
    bc = LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re1->bytecode));
  } else {
    bc = LEPUS_UNDEFINED;
    if (LEPUS_IsUndefined(pattern1))
      pattern = LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string);
    else
      pattern = LEPUS_ToString(ctx, pattern1);
    if (LEPUS_IsException(pattern)) goto fail;
    bc = lepus_compile_regexp(ctx, pattern, flags1);
    if (LEPUS_IsException(bc)) goto fail;
  }
  LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->pattern));
  LEPUS_FreeValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->bytecode));
  re->pattern = LEPUS_VALUE_GET_STRING(pattern);
  re->bytecode = LEPUS_VALUE_GET_STRING(bc);
  if (LEPUS_SetProperty(ctx, this_val, LEPUS_ATOM_lastIndex,
                        LEPUS_NewInt32(ctx, 0)) < 0)
    return LEPUS_EXCEPTION;
  return LEPUS_DupValue(ctx, this_val);
fail:
  LEPUS_FreeValue(ctx, pattern);
  LEPUS_FreeValue(ctx, bc);
  return LEPUS_EXCEPTION;
}

#if 0
static LEPUSValue lepus_regexp_get___source(LEPUSContext *ctx, LEPUSValueConst this_val)
{
    LEPUSRegExp *re = lepus_get_regexp(ctx, this_val, TRUE);
    if (!re)
        return LEPUS_EXCEPTION;
    return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, re->pattern));
}

static LEPUSValue lepus_regexp_get___flags(LEPUSContext *ctx, LEPUSValueConst this_val)
{
    LEPUSRegExp *re = lepus_get_regexp(ctx, this_val, TRUE);
    int flags;

    if (!re)
        return LEPUS_EXCEPTION;
    flags = lre_get_flags(re->bytecode->u.str8);
    return LEPUS_NewInt32(ctx, flags);
}
#endif

QJS_STATIC LEPUSValue lepus_regexp_get_source(LEPUSContext *ctx,
                                              LEPUSValueConst this_val) {
  LEPUSRegExp *re;
  LEPUSString *p;
  StringBuffer b_s, *b = &b_s;
  int i, n, c, c2, bra;

  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  if (lepus_same_value(ctx, this_val, ctx->class_proto[LEPUS_CLASS_REGEXP]))
    goto empty_regex;

  re = lepus_get_regexp(ctx, this_val, TRUE);
  if (!re) return LEPUS_EXCEPTION;

  p = re->pattern;

  if (p->len == 0) {
  empty_regex:
    return LEPUS_NewString(ctx, "(?:)");
  }
  string_buffer_init2(ctx, b, p->len, p->is_wide_char);

  /* Escape '/' and newline sequences as needed */
  bra = 0;
  for (i = 0, n = p->len; i < n;) {
    c2 = -1;
    switch (c = string_get(p, i++)) {
      case '\\':
        if (i < n) c2 = string_get(p, i++);
        break;
      case ']':
        bra = 0;
        break;
      case '[':
        if (!bra) {
          if (i < n && string_get(p, i) == ']') c2 = string_get(p, i++);
          bra = 1;
        }
        break;
      case '\n':
        c = '\\';
        c2 = 'n';
        break;
      case '\r':
        c = '\\';
        c2 = 'r';
        break;
      case '/':
        if (!bra) {
          c = '\\';
          c2 = '/';
        }
        break;
    }
    string_buffer_putc16(b, c);
    if (c2 >= 0) string_buffer_putc16(b, c2);
  }
  return string_buffer_end(b);
}

QJS_STATIC LEPUSValue lepus_regexp_get_flag(LEPUSContext *ctx,
                                            LEPUSValueConst this_val,
                                            int mask) {
  LEPUSRegExp *re;
  int flags;

  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  if (lepus_same_value(ctx, this_val, ctx->class_proto[LEPUS_CLASS_REGEXP]))
    return LEPUS_UNDEFINED;

  re = lepus_get_regexp(ctx, this_val, TRUE);
  if (!re) return LEPUS_EXCEPTION;

  flags = lre_get_flags(re->bytecode->u.str8);
  return LEPUS_NewBool(ctx, (flags & mask) != 0);
}

QJS_STATIC LEPUSValue lepus_regexp_get_flags(LEPUSContext *ctx,
                                             LEPUSValueConst this_val) {
  char str[8], *p = str;
  int res;

  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  res = LEPUS_ToBoolFree(ctx,
                         LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_global));
  if (res < 0) goto exception;
  if (res) *p++ = 'g';
  res =
      LEPUS_ToBoolFree(ctx, LEPUS_GetPropertyStr(ctx, this_val, "ignoreCase"));
  if (res < 0) goto exception;
  if (res) *p++ = 'i';
  res = LEPUS_ToBoolFree(ctx, LEPUS_GetPropertyStr(ctx, this_val, "multiline"));
  if (res < 0) goto exception;
  if (res) *p++ = 'm';
  res = LEPUS_ToBoolFree(ctx, LEPUS_GetPropertyStr(ctx, this_val, "dotAll"));
  if (res < 0) goto exception;
  if (res) *p++ = 's';
  res = LEPUS_ToBoolFree(ctx,
                         LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_unicode));
  if (res < 0) goto exception;
  if (res) *p++ = 'u';
  res = LEPUS_ToBoolFree(ctx, LEPUS_GetPropertyStr(ctx, this_val, "sticky"));
  if (res < 0) goto exception;
  if (res) *p++ = 'y';
  return LEPUS_NewStringLen(ctx, str, p - str);

exception:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_regexp_toString(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue pattern, flags;
  StringBuffer b_s, *b = &b_s;

  if (!LEPUS_IsObject(this_val)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  string_buffer_init(ctx, b, 0);
  string_buffer_putc8(b, '/');
  pattern = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_source);
  if (string_buffer_concat_value_free(b, pattern)) goto fail;
  string_buffer_putc8(b, '/');
  flags = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_flags);
  if (string_buffer_concat_value_free(b, flags)) goto fail;
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

BOOL lre_check_stack_overflow(void *opaque, size_t alloca_size) {
  LEPUSContext *ctx = static_cast<LEPUSContext *>(opaque);
  return lepus_check_stack_overflow(ctx, alloca_size);
}

void *lre_realloc(void *opaque, void *ptr, size_t size) {
  LEPUSContext *ctx = static_cast<LEPUSContext *>(opaque);
  /* No LEPUS exception is raised here */
  return lepus_realloc_rt(ctx->rt, ptr, size);
}

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
QJS_STATIC void lepus_clear_regexp_caputre_property(LEPUSContext *ctx,
                                                    LEPUSValue constructor,
                                                    uint32_t caputre_count) {
  if (LEPUS_IsUndefined(constructor) || LEPUS_IsException(constructor)) return;
  char regexp_capture_name[] = {'$', '0', 0};
  LEPUSValue null_string = LEPUS_NewString(ctx, "");
  uint32_t i;

  int32_t prop_flags = LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE;
  if (caputre_count == 0) {
    LEPUS_DefinePropertyValueStr(ctx, constructor, "$&",
                                 LEPUS_DupValue(ctx, null_string), prop_flags);
    caputre_count = 1;
  }

  for (i = caputre_count, regexp_capture_name[1] += i; i < 10;
       ++i, ++regexp_capture_name[1]) {
    LEPUS_DefinePropertyValueStr(ctx, constructor, regexp_capture_name,
                                 LEPUS_DupValue(ctx, null_string), prop_flags);
  }
  LEPUS_FreeValue(ctx, null_string);
}
#endif

QJS_STATIC LEPUSValue lepus_regexp_exec(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSRegExp *re = lepus_get_regexp(ctx, this_val, TRUE);
  LEPUSString *str;
  LEPUSValue str_val, obj, val, groups = LEPUS_UNDEFINED;
  uint8_t *re_bytecode;
  int ret;
  uint8_t **capture, *str_buf;
  int capture_count, shift, i, re_flags;
  int64_t last_index;
  const char *group_name_ptr;
  LEPUSValue regexp_obj = LEPUS_UNDEFINED;

  if (!re) return LEPUS_EXCEPTION;
  str_val = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(str_val)) return str_val;
  val = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_lastIndex);
  if (LEPUS_IsException(val) || LEPUS_ToLengthFree(ctx, &last_index, val)) {
    LEPUS_FreeValue(ctx, str_val);
    return LEPUS_EXCEPTION;
  }
  re_bytecode = re->bytecode->u.str8;
  re_flags = lre_get_flags(re_bytecode);
  if ((re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) == 0) {
    last_index = 0;
  }
  str = LEPUS_VALUE_GET_STRING(str_val);
  capture_count = lre_get_capture_count(re_bytecode);
  capture = NULL;
  if (capture_count > 0) {
    capture = static_cast<uint8_t **>(
        lepus_malloc(ctx, sizeof(capture[0]) * capture_count * 2));
    if (!capture) {
      LEPUS_FreeValue(ctx, str_val);
      return LEPUS_EXCEPTION;
    }
  }
  shift = str->is_wide_char;
  str_buf = str->u.str8;
  if (last_index > str->len) {
    ret = 2;
  } else {
    ret = lre_exec(capture, re_bytecode, str_buf, last_index, str->len, shift,
                   ctx);
  }
  obj = LEPUS_NULL;
  if (ret != 1) {
    if (ret >= 0) {
      if (ret == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {
        if (LEPUS_SetProperty(ctx, this_val, LEPUS_ATOM_lastIndex,
                              LEPUS_NewInt32(ctx, 0)) < 0)
          goto fail;
      }
    } else {
      LEPUS_ThrowInternalError(ctx, "out of memory in regexp execution");
      goto fail;
    }
    LEPUS_FreeValue(ctx, str_val);
  } else {
    int prop_flags;
    if (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) {
      if (LEPUS_SetProperty(
              ctx, this_val, LEPUS_ATOM_lastIndex,
              LEPUS_NewInt32(ctx, (capture[1] - str_buf) >> shift)) < 0)
        goto fail;
    }
    obj = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(obj)) goto fail;
    prop_flags = LEPUS_PROP_C_W_E | LEPUS_PROP_THROW;
    group_name_ptr = NULL;
    if (re_flags & LRE_FLAG_NAMED_GROUPS) {
      uint32_t re_bytecode_len;
      groups = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
      if (LEPUS_IsException(groups)) goto fail;
      re_bytecode_len = get_u32(re_bytecode + 3);
      group_name_ptr = (char *)(re_bytecode + 7 + re_bytecode_len);
    }

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
    static constexpr const char *regexp_capture_name[] = {
        "$&", "$1", "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9"};
    regexp_obj = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_constructor);
    bool regexp_invalid =
        LEPUS_IsUndefined(regexp_obj) || LEPUS_IsException(regexp_obj);
#endif

    for (i = 0; i < capture_count; i++) {
      int start, end;
      LEPUSValue val;
      if (capture[2 * i] == NULL || capture[2 * i + 1] == NULL) {
        val = LEPUS_UNDEFINED;
      } else {
        start = (capture[2 * i] - str_buf) >> shift;
        end = (capture[2 * i + 1] - str_buf) >> shift;
        val = lepus_sub_string(ctx, str, start, end);
        if (LEPUS_IsException(val)) goto fail;
      }

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
      if (!regexp_invalid &&
          i < (sizeof(regexp_capture_name) / sizeof(regexp_capture_name[0]))) {
        LEPUS_DefinePropertyValueStr(ctx, regexp_obj, regexp_capture_name[i],
                                     LEPUS_DupValue(ctx, val), prop_flags);
      }
#endif

      if (group_name_ptr && i > 0) {
        if (*group_name_ptr) {
          if (LEPUS_DefinePropertyValueStr(ctx, groups, group_name_ptr,
                                           LEPUS_DupValue(ctx, val),
                                           prop_flags) < 0) {
            LEPUS_FreeValue(ctx, val);
            goto fail;
          }
        }
        group_name_ptr += strlen(group_name_ptr) + 1;
      }
      if (LEPUS_DefinePropertyValueUint32(ctx, obj, i, val, prop_flags) < 0)
        goto fail;
    }

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
    lepus_clear_regexp_caputre_property(ctx, regexp_obj, capture_count);
#endif

    if (LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_groups, groups,
                                  prop_flags) < 0)
      goto fail;
    if (LEPUS_DefinePropertyValue(
            ctx, obj, LEPUS_ATOM_index,
            LEPUS_NewInt32(ctx, (capture[0] - str_buf) >> shift),
            prop_flags) < 0)
      goto fail;
    if (LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_input, str_val,
                                  prop_flags) < 0)
      goto fail1;
  }
  LEPUS_FreeValue(ctx, regexp_obj);
  lepus_free(ctx, capture);
  return obj;
fail:
  LEPUS_FreeValue(ctx, regexp_obj);
  LEPUS_FreeValue(ctx, groups);
  LEPUS_FreeValue(ctx, str_val);
fail1:
  LEPUS_FreeValue(ctx, obj);
  lepus_free(ctx, capture);
  return LEPUS_EXCEPTION;
}

/* delete partions of a string that match a given regex */
QJS_STATIC LEPUSValue LEPUS_RegExpDelete(LEPUSContext *ctx,
                                         LEPUSValueConst this_val,
                                         LEPUSValueConst arg) {
  LEPUSRegExp *re = lepus_get_regexp(ctx, this_val, TRUE);
  LEPUSString *str;
  LEPUSValue str_val, val;
  uint8_t *re_bytecode;
  int ret;
  uint8_t **capture, *str_buf;
  int capture_count, shift, re_flags;
  int next_src_pos, start, end;
  int64_t last_index;
  StringBuffer b_s, *b = &b_s;

  if (!re) return LEPUS_EXCEPTION;

  string_buffer_init(ctx, b, 0);

  capture = NULL;
  str_val = LEPUS_ToString(ctx, arg);
  if (LEPUS_IsException(str_val)) goto fail;
  str = LEPUS_VALUE_GET_STRING(str_val);
  re_bytecode = re->bytecode->u.str8;
  re_flags = lre_get_flags(re_bytecode);
  if ((re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) == 0) {
    last_index = 0;
  } else {
    val = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_lastIndex);
    if (LEPUS_IsException(val) || LEPUS_ToLengthFree(ctx, &last_index, val))
      goto fail;
  }
  capture_count = lre_get_capture_count(re_bytecode);
  if (capture_count > 0) {
    capture = static_cast<uint8_t **>(
        lepus_malloc(ctx, sizeof(capture[0]) * capture_count * 2));
    if (!capture) goto fail;
  }
  shift = str->is_wide_char;
  str_buf = str->u.str8;
  next_src_pos = 0;
  for (;;) {
    if (last_index > str->len) break;

    ret = lre_exec(capture, re_bytecode, str_buf, last_index, str->len, shift,
                   ctx);
    if (ret != 1) {
      if (ret >= 0) {
        if (ret == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {
          if (LEPUS_SetProperty(ctx, this_val, LEPUS_ATOM_lastIndex,
                                LEPUS_NewInt32(ctx, 0)) < 0)
            goto fail;
        }
      } else {
        LEPUS_ThrowInternalError(ctx, "out of memory in regexp execution");
        goto fail;
      }
      break;
    }
    start = (capture[0] - str_buf) >> shift;
    end = (capture[1] - str_buf) >> shift;
    last_index = end;
    if (next_src_pos < start) {
      if (string_buffer_concat(b, str, next_src_pos, start)) goto fail;
    }
    next_src_pos = end;
    if (!(re_flags & LRE_FLAG_GLOBAL)) {
      if (LEPUS_SetProperty(ctx, this_val, LEPUS_ATOM_lastIndex,
                            LEPUS_NewInt32(ctx, end)) < 0)
        goto fail;
      break;
    }
    if (end == start) {
      if (!(re_flags & LRE_FLAG_UTF16) || (unsigned)end >= str->len ||
          !str->is_wide_char) {
        end++;
      } else {
        string_getc(str, &end);
      }
    }
    last_index = end;
  }
  if (string_buffer_concat(b, str, next_src_pos, str->len)) goto fail;
  LEPUS_FreeValue(ctx, str_val);
  lepus_free(ctx, capture);
  return string_buffer_end(b);
fail:
  LEPUS_FreeValue(ctx, str_val);
  lepus_free(ctx, capture);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue LEPUS_RegExpExec(LEPUSContext *ctx, LEPUSValueConst r,
                                       LEPUSValueConst s) {
  LEPUSValue method, ret;

  method = LEPUS_GetProperty(ctx, r, LEPUS_ATOM_exec);
  if (LEPUS_IsException(method)) return method;
  if (LEPUS_IsFunction(ctx, method)) {
    ret = LEPUS_CallFree(ctx, method, r, 1, &s);
    if (LEPUS_IsException(ret)) return ret;
    if (!LEPUS_IsObject(ret) && !LEPUS_IsNull(ret)) {
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_ThrowTypeError(
          ctx, "RegExp exec method must return an object or null");
    }
    return ret;
  }
  LEPUS_FreeValue(ctx, method);
  return lepus_regexp_exec(ctx, r, 1, &s);
}

#if 0
static LEPUSValue lepus_regexp___RegExpExec(LEPUSContext *ctx, LEPUSValueConst this_val,
                                      int argc, LEPUSValueConst *argv)
{
    return LEPUS_RegExpExec(ctx, argv[0], argv[1]);
}
static LEPUSValue lepus_regexp___RegExpDelete(LEPUSContext *ctx, LEPUSValueConst this_val,
                                        int argc, LEPUSValueConst *argv)
{
    return LEPUS_RegExpDelete(ctx, argv[0], argv[1]);
}
#endif

QJS_STATIC LEPUSValue lepus_regexp_test(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValue val;
  BOOL ret;

  val = LEPUS_RegExpExec(ctx, this_val, argv[0]);
  if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;
  ret = !LEPUS_IsNull(val);
  LEPUS_FreeValue(ctx, val);
  return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue lepus_regexp_Symbol_match(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc,
                                                LEPUSValueConst *argv) {
  // [Symbol.match](str)
  LEPUSValueConst rx = this_val;
  LEPUSValue A, S, result, matchStr;
  int global, n, fullUnicode, isEmpty;
  LEPUSString *p;

  if (!LEPUS_IsObject(rx)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  A = LEPUS_UNDEFINED;
  result = LEPUS_UNDEFINED;
  matchStr = LEPUS_UNDEFINED;
  S = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(S)) goto exception;

  global = LEPUS_ToBoolFree(ctx, LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_global));
  if (global < 0) goto exception;

  if (!global) {
    A = LEPUS_RegExpExec(ctx, rx, S);
  } else {
    fullUnicode =
        LEPUS_ToBoolFree(ctx, LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_unicode));
    if (fullUnicode < 0) goto exception;

    if (LEPUS_SetProperty(ctx, rx, LEPUS_ATOM_lastIndex,
                          LEPUS_NewInt32(ctx, 0)) < 0)
      goto exception;
    A = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(A)) goto exception;
    n = 0;
    for (;;) {
      LEPUS_FreeValue(ctx, result);
      result = LEPUS_RegExpExec(ctx, rx, S);
      if (LEPUS_IsException(result)) goto exception;
      if (LEPUS_IsNull(result)) break;
      matchStr =
          LEPUS_ToStringFree(ctx, LEPUS_GetPropertyInt64(ctx, result, 0));
      if (LEPUS_IsException(matchStr)) goto exception;
      isEmpty = LEPUS_IsEmptyString(matchStr);
      if (LEPUS_SetPropertyInt64(ctx, A, n++, matchStr) < 0) goto exception;
      if (isEmpty) {
        int64_t thisIndex, nextIndex;
        if (LEPUS_ToLengthFree(
                ctx, &thisIndex,
                LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_lastIndex)) < 0)
          goto exception;
        p = LEPUS_VALUE_GET_STRING(S);
        nextIndex = thisIndex + 1;
        if (thisIndex < p->len)
          nextIndex = string_advance_index(p, thisIndex, fullUnicode);
        if (LEPUS_SetProperty(ctx, rx, LEPUS_ATOM_lastIndex,
                              LEPUS_NewInt64(ctx, nextIndex)) < 0)
          goto exception;
      }
    }
    if (n == 0) {
      LEPUS_FreeValue(ctx, A);
      A = LEPUS_NULL;
    }
  }
  LEPUS_FreeValue(ctx, result);
  LEPUS_FreeValue(ctx, S);
  return A;

exception:
  LEPUS_FreeValue(ctx, A);
  LEPUS_FreeValue(ctx, result);
  LEPUS_FreeValue(ctx, S);
  return LEPUS_EXCEPTION;
}

typedef struct LEPUSRegExpStringIteratorData {
  LEPUSValue iterating_regexp;
  LEPUSValue iterated_string;
  BOOL global;
  BOOL unicode;
  BOOL done;
} LEPUSRegExpStringIteratorData;

QJS_STATIC void lepus_regexp_string_iterator_finalizer(LEPUSRuntime *rt,
                                                       LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSRegExpStringIteratorData *it = p->u.regexp_string_iterator_data;
  if (it) {
    LEPUS_FreeValueRT(rt, it->iterating_regexp);
    LEPUS_FreeValueRT(rt, it->iterated_string);
    lepus_free_rt(rt, it);
  }
}

QJS_STATIC void lepus_regexp_string_iterator_mark(LEPUSRuntime *rt,
                                                  LEPUSValueConst val,
                                                  LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSRegExpStringIteratorData *it = p->u.regexp_string_iterator_data;
  if (it) {
    LEPUS_MarkValue(rt, it->iterating_regexp, mark_func);
    LEPUS_MarkValue(rt, it->iterated_string, mark_func);
  }
}

QJS_STATIC LEPUSValue lepus_regexp_string_iterator_next(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, BOOL *pdone, int magic) {
  LEPUSRegExpStringIteratorData *it;
  LEPUSValueConst R, S;
  LEPUSValue matchStr = LEPUS_UNDEFINED, match = LEPUS_UNDEFINED;
  LEPUSString *sp;

  it = static_cast<LEPUSRegExpStringIteratorData *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_REGEXP_STRING_ITERATOR));
  if (!it) goto exception;
  if (it->done) {
    *pdone = TRUE;
    return LEPUS_UNDEFINED;
  }
  R = it->iterating_regexp;
  S = it->iterated_string;
  match = LEPUS_RegExpExec(ctx, R, S);
  if (LEPUS_IsException(match)) goto exception;
  if (LEPUS_IsNull(match)) {
    it->done = TRUE;
    *pdone = TRUE;
    return LEPUS_UNDEFINED;
  } else if (it->global) {
    matchStr = LEPUS_ToStringFree(ctx, LEPUS_GetPropertyInt64(ctx, match, 0));
    if (LEPUS_IsException(matchStr)) goto exception;
    if (LEPUS_IsEmptyString(matchStr)) {
      int64_t thisIndex, nextIndex;
      if (LEPUS_ToLengthFree(ctx, &thisIndex,
                             LEPUS_GetProperty(ctx, R, LEPUS_ATOM_lastIndex)) <
          0)
        goto exception;
      sp = LEPUS_VALUE_GET_STRING(S);
      nextIndex = string_advance_index(sp, thisIndex, it->unicode);
      if (LEPUS_SetProperty(ctx, R, LEPUS_ATOM_lastIndex,
                            LEPUS_NewInt32(ctx, nextIndex)) < 0)
        goto exception;
    }
    LEPUS_FreeValue(ctx, matchStr);
  } else {
    it->done = TRUE;
  }
  *pdone = FALSE;
  return match;
exception:
  LEPUS_FreeValue(ctx, match);
  LEPUS_FreeValue(ctx, matchStr);
  *pdone = FALSE;
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_regexp_Symbol_matchAll(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   int argc,
                                                   LEPUSValueConst *argv) {
  // [Symbol.matchAll](str)
  LEPUSValueConst R = this_val;
  LEPUSValue S, C, flags, matcher, iter;
  LEPUSValueConst args[2];
  LEPUSString *strp;
  int64_t lastIndex;
  LEPUSRegExpStringIteratorData *it;

  if (!LEPUS_IsObject(R)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  C = LEPUS_UNDEFINED;
  flags = LEPUS_UNDEFINED;
  matcher = LEPUS_UNDEFINED;
  iter = LEPUS_UNDEFINED;

  S = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(S)) goto exception;
  C = LEPUS_SpeciesConstructor(ctx, R, ctx->regexp_ctor);
  if (LEPUS_IsException(C)) goto exception;
  flags = LEPUS_ToStringFree(ctx, LEPUS_GetProperty(ctx, R, LEPUS_ATOM_flags));
  if (LEPUS_IsException(flags)) goto exception;
  args[0] = R;
  args[1] = flags;
  matcher = LEPUS_CallConstructor(ctx, C, 2, args);
  if (LEPUS_IsException(matcher)) goto exception;
  if (LEPUS_ToLengthFree(ctx, &lastIndex,
                         LEPUS_GetProperty(ctx, R, LEPUS_ATOM_lastIndex)))
    goto exception;
  if (LEPUS_SetProperty(ctx, matcher, LEPUS_ATOM_lastIndex,
                        LEPUS_NewInt32(ctx, lastIndex)) < 0)
    goto exception;

  iter = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_REGEXP_STRING_ITERATOR);
  if (LEPUS_IsException(iter)) goto exception;
  it = static_cast<LEPUSRegExpStringIteratorData *>(
      lepus_malloc(ctx, sizeof(*it)));
  if (!it) goto exception;
  it->iterating_regexp = matcher;
  it->iterated_string = S;
  strp = LEPUS_VALUE_GET_STRING(flags);
  it->global = string_indexof_char(strp, 'g', 0) >= 0;
  it->unicode = string_indexof_char(strp, 'u', 0) >= 0;
  it->done = FALSE;
  LEPUS_SetOpaque(iter, it);

  LEPUS_FreeValue(ctx, C);
  LEPUS_FreeValue(ctx, flags);
  return iter;
exception:
  LEPUS_FreeValue(ctx, S);
  LEPUS_FreeValue(ctx, C);
  LEPUS_FreeValue(ctx, flags);
  LEPUS_FreeValue(ctx, matcher);
  LEPUS_FreeValue(ctx, iter);
  return LEPUS_EXCEPTION;
}

typedef struct ValueBuffer {
  LEPUSContext *ctx;
  LEPUSValue *arr;
  LEPUSValue def[4];
  int len;
  int size;
  int error_status;
} ValueBuffer;

QJS_STATIC int value_buffer_init(LEPUSContext *ctx, ValueBuffer *b) {
  b->ctx = ctx;
  b->len = 0;
  b->size = 4;
  b->error_status = 0;
  b->arr = b->def;
  return 0;
}

QJS_STATIC void value_buffer_free(ValueBuffer *b) {
  while (b->len > 0) LEPUS_FreeValue(b->ctx, b->arr[--b->len]);
  if (b->arr != b->def) lepus_free(b->ctx, b->arr);
  b->arr = b->def;
  b->size = 4;
}

QJS_STATIC int value_buffer_append(ValueBuffer *b, LEPUSValue val) {
  if (b->error_status) return -1;

  if (b->len >= b->size) {
    int new_size = (b->len + (b->len >> 1) + 31) & ~16;
    size_t slack;
    LEPUSValue *new_arr;

    if (b->arr == b->def) {
      new_arr = static_cast<LEPUSValue *>(
          lepus_realloc2(b->ctx, NULL, sizeof(*b->arr) * new_size, &slack));
      if (new_arr) memcpy(new_arr, b->def, sizeof b->def);
    } else {
      new_arr = static_cast<LEPUSValue *>(
          lepus_realloc2(b->ctx, b->arr, sizeof(*b->arr) * new_size, &slack));
    }
    if (!new_arr) {
      value_buffer_free(b);
      LEPUS_FreeValue(b->ctx, val);
      b->error_status = -1;
      return -1;
    }
    new_size += slack / sizeof(*new_arr);
    b->arr = new_arr;
    b->size = new_size;
  }
  b->arr[b->len++] = val;
  return 0;
}

QJS_STATIC int lepus_is_standard_regexp(LEPUSContext *ctx, LEPUSValueConst rx) {
  LEPUSValue val;
  int res;

  val = LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_constructor);
  if (LEPUS_IsException(val)) return -1;
  // rx.constructor === RegExp
  res = lepus_same_value(ctx, val, ctx->regexp_ctor);
  LEPUS_FreeValue(ctx, val);
  if (res) {
    val = LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_exec);
    if (LEPUS_IsException(val)) return -1;
    // rx.exec === RE_exec
    res = LEPUS_IsCFunction(ctx, val, lepus_regexp_exec, 0);
    LEPUS_FreeValue(ctx, val);
  }
  return res;
}

QJS_STATIC LEPUSValue lepus_regexp_Symbol_replace(LEPUSContext *ctx,
                                                  LEPUSValueConst this_val,
                                                  int argc,
                                                  LEPUSValueConst *argv) {
  // [Symbol.replace](str, rep)
  LEPUSValueConst rx = this_val, rep = argv[1];
  LEPUSValueConst args[6];
  LEPUSValue str, rep_val, matched, tab, rep_str, namedCaptures, res;
  LEPUSString *sp, *rp;
  StringBuffer b_s, *b = &b_s;
  ValueBuffer v_b, *results = &v_b;
  int nextSourcePosition, n, j, functionalReplace, is_global, fullUnicode;
  uint32_t nCaptures;
  int64_t position;

  if (!LEPUS_IsObject(rx)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  string_buffer_init(ctx, b, 0);
  value_buffer_init(ctx, results);

  rep_val = LEPUS_UNDEFINED;
  matched = LEPUS_UNDEFINED;
  tab = LEPUS_UNDEFINED;
  rep_str = LEPUS_UNDEFINED;
  namedCaptures = LEPUS_UNDEFINED;

  str = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(str)) goto exception;

  sp = LEPUS_VALUE_GET_STRING(str);
  rp = NULL;
  functionalReplace = LEPUS_IsFunction(ctx, rep);
  if (!functionalReplace) {
    rep_val = LEPUS_ToString(ctx, rep);
    if (LEPUS_IsException(rep_val)) goto exception;
    rp = LEPUS_VALUE_GET_STRING(rep_val);
  }
  fullUnicode = 0;
  is_global =
      LEPUS_ToBoolFree(ctx, LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_global));
  if (is_global < 0) goto exception;
  if (is_global) {
    fullUnicode =
        LEPUS_ToBoolFree(ctx, LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_unicode));
    if (fullUnicode < 0) goto exception;
    if (LEPUS_SetProperty(ctx, rx, LEPUS_ATOM_lastIndex,
                          LEPUS_NewInt32(ctx, 0)) < 0)
      goto exception;
  }

  if (rp && rp->len == 0 && is_global && lepus_is_standard_regexp(ctx, rx)) {
    /* use faster version for simple cases */
    res = LEPUS_RegExpDelete(ctx, rx, str);
    goto done;
  }
  for (;;) {
    LEPUSValue result;
    result = LEPUS_RegExpExec(ctx, rx, str);
    if (LEPUS_IsException(result)) goto exception;
    if (LEPUS_IsNull(result)) break;
    if (value_buffer_append(results, result) < 0) goto exception;
    if (!is_global) break;
    LEPUS_FreeValue(ctx, matched);
    matched = LEPUS_ToStringFree(ctx, LEPUS_GetPropertyInt64(ctx, result, 0));
    if (LEPUS_IsException(matched)) goto exception;
    if (LEPUS_IsEmptyString(matched)) {
      /* always advance of at least one char */
      int64_t thisIndex, nextIndex;
      if (LEPUS_ToLengthFree(ctx, &thisIndex,
                             LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_lastIndex)) <
          0)
        goto exception;
      nextIndex = string_advance_index(sp, thisIndex, fullUnicode);
      if (LEPUS_SetProperty(ctx, rx, LEPUS_ATOM_lastIndex,
                            LEPUS_NewInt32(ctx, nextIndex)) < 0)
        goto exception;
    }
  }
  nextSourcePosition = 0;
  for (j = 0; j < results->len; j++) {
    LEPUSValueConst result;
    result = results->arr[j];
    if (lepus_get_length32(ctx, &nCaptures, result) < 0) goto exception;
    LEPUS_FreeValue(ctx, matched);
    matched = LEPUS_ToStringFree(ctx, LEPUS_GetPropertyInt64(ctx, result, 0));
    if (LEPUS_IsException(matched)) goto exception;
    if (LEPUS_ToLengthFree(ctx, &position,
                           LEPUS_GetProperty(ctx, result, LEPUS_ATOM_index)))
      goto exception;
    if (position > sp->len)
      position = sp->len;
    else if (position < 0)
      position = 0;
    /* ignore substition if going backward (can happen
       with custom regexp object) */
    LEPUS_FreeValue(ctx, tab);
    tab = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(tab)) goto exception;
    if (LEPUS_SetPropertyInt64(ctx, tab, 0, LEPUS_DupValue(ctx, matched)) < 0)
      goto exception;
    for (n = 1; n < nCaptures; n++) {
      LEPUSValue capN;
      capN = LEPUS_GetPropertyInt64(ctx, result, n);
      if (LEPUS_IsException(capN)) goto exception;
      if (!LEPUS_IsUndefined(capN)) {
        capN = LEPUS_ToStringFree(ctx, capN);
        if (LEPUS_IsException(capN)) goto exception;
      }
      if (LEPUS_SetPropertyInt64(ctx, tab, n, capN) < 0) goto exception;
    }
    LEPUS_FreeValue(ctx, namedCaptures);
    namedCaptures = LEPUS_GetProperty(ctx, result, LEPUS_ATOM_groups);
    if (LEPUS_IsException(namedCaptures)) goto exception;
    if (functionalReplace) {
      if (LEPUS_SetPropertyInt64(ctx, tab, n++, LEPUS_NewInt32(ctx, position)) <
          0)
        goto exception;
      if (LEPUS_SetPropertyInt64(ctx, tab, n++, LEPUS_DupValue(ctx, str)) < 0)
        goto exception;
      if (!LEPUS_IsUndefined(namedCaptures)) {
        if (LEPUS_SetPropertyInt64(ctx, tab, n++,
                                   LEPUS_DupValue(ctx, namedCaptures)) < 0)
          goto exception;
      }
      args[0] = LEPUS_UNDEFINED;
      args[1] = tab;
      LEPUS_FreeValue(ctx, rep_str);
      rep_str =
          LEPUS_ToStringFree(ctx, lepus_function_apply(ctx, rep, 2, args, 0));
    } else {
      args[0] = matched;
      args[1] = str;
      args[2] = LEPUS_NewInt32(ctx, position);
      args[3] = tab;
      args[4] = namedCaptures;
      args[5] = rep_val;
      LEPUS_FreeValue(ctx, rep_str);
      rep_str = lepus_string___GetSubstitution(ctx, LEPUS_UNDEFINED, 6, args);
    }
    if (LEPUS_IsException(rep_str)) goto exception;
    if (position >= nextSourcePosition) {
      string_buffer_concat(b, sp, nextSourcePosition, position);
      string_buffer_concat_value(b, rep_str);
      nextSourcePosition = position + LEPUS_VALUE_GET_STRING(matched)->len;
    }
  }
  string_buffer_concat(b, sp, nextSourcePosition, sp->len);
  res = string_buffer_end(b);
  goto done1;

exception:
  res = LEPUS_EXCEPTION;
done:
  string_buffer_free(b);
done1:
  value_buffer_free(results);
  LEPUS_FreeValue(ctx, rep_val);
  LEPUS_FreeValue(ctx, matched);
  LEPUS_FreeValue(ctx, tab);
  LEPUS_FreeValue(ctx, rep_str);
  LEPUS_FreeValue(ctx, namedCaptures);
  LEPUS_FreeValue(ctx, str);
  return res;
}

QJS_STATIC LEPUSValue lepus_regexp_Symbol_search(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  LEPUSValueConst rx = this_val;
  LEPUSValue str, previousLastIndex, currentLastIndex, result, index;

  if (!LEPUS_IsObject(rx)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  result = LEPUS_UNDEFINED;
  currentLastIndex = LEPUS_UNDEFINED;
  previousLastIndex = LEPUS_UNDEFINED;
  str = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(str)) goto exception;

  previousLastIndex = LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_lastIndex);
  if (LEPUS_IsException(previousLastIndex)) goto exception;

  if (!lepus_same_value(ctx, previousLastIndex, LEPUS_NewInt32(ctx, 0))) {
    if (LEPUS_SetProperty(ctx, rx, LEPUS_ATOM_lastIndex,
                          LEPUS_NewInt32(ctx, 0)) < 0) {
      goto exception;
    }
  }
  result = LEPUS_RegExpExec(ctx, rx, str);
  if (LEPUS_IsException(result)) goto exception;
  currentLastIndex = LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_lastIndex);
  if (LEPUS_IsException(currentLastIndex)) goto exception;
  if (lepus_same_value(ctx, currentLastIndex, previousLastIndex)) {
    LEPUS_FreeValue(ctx, previousLastIndex);
  } else {
    if (LEPUS_SetProperty(ctx, rx, LEPUS_ATOM_lastIndex, previousLastIndex) <
        0) {
      previousLastIndex = LEPUS_UNDEFINED;
      goto exception;
    }
  }
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, currentLastIndex);

  if (LEPUS_IsNull(result)) {
    return LEPUS_NewInt32(ctx, -1);
  } else {
    index = LEPUS_GetProperty(ctx, result, LEPUS_ATOM_index);
    LEPUS_FreeValue(ctx, result);
    return index;
  }

exception:
  LEPUS_FreeValue(ctx, result);
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, currentLastIndex);
  LEPUS_FreeValue(ctx, previousLastIndex);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_regexp_Symbol_split(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc,
                                                LEPUSValueConst *argv) {
  // [Symbol.split](str, limit)
  LEPUSValueConst rx = this_val;
  LEPUSValueConst args[2];
  LEPUSValue str, ctor, splitter, A, flags, z, sub;
  LEPUSString *strp;
  uint32_t lim, size, p, q;
  int unicodeMatching;
  int64_t lengthA, e, numberOfCaptures, i;

  if (!LEPUS_IsObject(rx)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  ctor = LEPUS_UNDEFINED;
  splitter = LEPUS_UNDEFINED;
  A = LEPUS_UNDEFINED;
  flags = LEPUS_UNDEFINED;
  z = LEPUS_UNDEFINED;
  str = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(str)) goto exception;
  ctor = LEPUS_SpeciesConstructor(ctx, rx, ctx->regexp_ctor);
  if (LEPUS_IsException(ctor)) goto exception;
  flags = LEPUS_ToStringFree(ctx, LEPUS_GetProperty(ctx, rx, LEPUS_ATOM_flags));
  if (LEPUS_IsException(flags)) goto exception;
  strp = LEPUS_VALUE_GET_STRING(flags);
  unicodeMatching = string_indexof_char(strp, 'u', 0) >= 0;
  if (string_indexof_char(strp, 'y', 0) < 0) {
    flags = LEPUS_ConcatString3(ctx, "", flags, "y");
    if (LEPUS_IsException(flags)) goto exception;
  }
  args[0] = rx;
  args[1] = flags;
  splitter = LEPUS_CallConstructor(ctx, ctor, 2, args);
  if (LEPUS_IsException(splitter)) goto exception;
  A = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(A)) goto exception;
  lengthA = 0;
  if (LEPUS_IsUndefined(argv[1])) {
    lim = 0xffffffff;
  } else {
    if (LEPUS_ToUint32(ctx, &lim, argv[1]) < 0) goto exception;
    if (lim == 0) goto done;
  }
  strp = LEPUS_VALUE_GET_STRING(str);
  p = q = 0;
  size = strp->len;
  if (size == 0) {
    z = LEPUS_RegExpExec(ctx, splitter, str);
    if (LEPUS_IsException(z)) goto exception;
    if (LEPUS_IsNull(z)) goto add_tail;
    goto done;
  }
  while (q < size) {
    if (LEPUS_SetProperty(ctx, splitter, LEPUS_ATOM_lastIndex,
                          LEPUS_NewInt32(ctx, q)) < 0)
      goto exception;
    LEPUS_FreeValue(ctx, z);
    z = LEPUS_RegExpExec(ctx, splitter, str);
    if (LEPUS_IsException(z)) goto exception;
    if (LEPUS_IsNull(z)) {
      q = string_advance_index(strp, q, unicodeMatching);
    } else {
      if (LEPUS_ToLengthFree(
              ctx, &e, LEPUS_GetProperty(ctx, splitter, LEPUS_ATOM_lastIndex)))
        goto exception;
      if (e > size) e = size;
      if (e == p) {
        q = string_advance_index(strp, q, unicodeMatching);
      } else {
        sub = lepus_sub_string(ctx, strp, p, q);
        if (LEPUS_IsException(sub)) goto exception;
        if (LEPUS_SetPropertyInt64(ctx, A, lengthA++, sub) < 0) goto exception;
        if (lengthA == lim) goto done;
        p = e;
        if (lepus_get_length64(ctx, &numberOfCaptures, z)) goto exception;
        for (i = 1; i < numberOfCaptures; i++) {
          sub = LEPUS_ToStringFree(ctx, LEPUS_GetPropertyInt64(ctx, z, i));
          if (LEPUS_IsException(sub)) goto exception;
          if (LEPUS_SetPropertyInt64(ctx, A, lengthA++, sub) < 0)
            goto exception;
          if (lengthA == lim) goto done;
        }
        q = p;
      }
    }
  }
add_tail:
  if (p > size) p = size;
  sub = lepus_sub_string(ctx, strp, p, size);
  if (LEPUS_IsException(sub)) goto exception;
  if (LEPUS_SetPropertyInt64(ctx, A, lengthA++, sub) < 0) goto exception;
  goto done;
exception:
  LEPUS_FreeValue(ctx, A);
  A = LEPUS_EXCEPTION;
done:
  LEPUS_FreeValue(ctx, str);
  LEPUS_FreeValue(ctx, ctor);
  LEPUS_FreeValue(ctx, splitter);
  LEPUS_FreeValue(ctx, flags);
  LEPUS_FreeValue(ctx, z);
  return A;
}

static const LEPUSCFunctionListEntry lepus_regexp_funcs[] = {
    LEPUS_CGETSET_DEF("[Symbol.species]", lepus_get_this, NULL),
    // LEPUS_CFUNC_DEF("__RegExpExec", 2, lepus_regexp___RegExpExec ),
    // LEPUS_CFUNC_DEF("__RegExpDelete", 2, lepus_regexp___RegExpDelete ),
};

static const LEPUSCFunctionListEntry lepus_regexp_proto_funcs[] = {
    LEPUS_CGETSET_DEF("flags", lepus_regexp_get_flags, NULL),
    LEPUS_CGETSET_DEF("source", lepus_regexp_get_source, NULL),
    LEPUS_CGETSET_MAGIC_DEF("global", lepus_regexp_get_flag, NULL, 1),
    LEPUS_CGETSET_MAGIC_DEF("ignoreCase", lepus_regexp_get_flag, NULL, 2),
    LEPUS_CGETSET_MAGIC_DEF("multiline", lepus_regexp_get_flag, NULL, 4),
    LEPUS_CGETSET_MAGIC_DEF("dotAll", lepus_regexp_get_flag, NULL, 8),
    LEPUS_CGETSET_MAGIC_DEF("unicode", lepus_regexp_get_flag, NULL, 16),
    LEPUS_CGETSET_MAGIC_DEF("sticky", lepus_regexp_get_flag, NULL, 32),
    LEPUS_CFUNC_DEF("exec", 1, lepus_regexp_exec),
    LEPUS_CFUNC_DEF("compile", 2, lepus_regexp_compile),
    LEPUS_CFUNC_DEF("test", 1, lepus_regexp_test),
    LEPUS_CFUNC_DEF("toString", 0, lepus_regexp_toString),
    LEPUS_CFUNC_DEF("[Symbol.replace]", 2, lepus_regexp_Symbol_replace),
    LEPUS_CFUNC_DEF("[Symbol.match]", 1, lepus_regexp_Symbol_match),
    LEPUS_CFUNC_DEF("[Symbol.matchAll]", 1, lepus_regexp_Symbol_matchAll),
    LEPUS_CFUNC_DEF("[Symbol.search]", 1, lepus_regexp_Symbol_search),
    LEPUS_CFUNC_DEF("[Symbol.split]", 2, lepus_regexp_Symbol_split),
    // LEPUS_CGETSET_DEF("__source", lepus_regexp_get___source, NULL ),
    // LEPUS_CGETSET_DEF("__flags", lepus_regexp_get___flags, NULL ),
};

static const LEPUSCFunctionListEntry
    lepus_regexp_string_iterator_proto_funcs[] = {
        LEPUS_ITERATOR_NEXT_DEF("next", 0, lepus_regexp_string_iterator_next,
                                0),
        LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "RegExp String Iterator",
                              LEPUS_PROP_CONFIGURABLE),
    };

void LEPUS_AddIntrinsicRegExpCompiler(LEPUSContext *ctx) {
  ctx->compile_regexp = lepus_compile_regexp;
}

void LEPUS_AddIntrinsicRegExp(LEPUSContext *ctx) {
  LEPUSValueConst obj;

  LEPUS_AddIntrinsicRegExpCompiler(ctx);

  ctx->class_proto[LEPUS_CLASS_REGEXP] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_REGEXP],
                                lepus_regexp_proto_funcs,
                                countof(lepus_regexp_proto_funcs));
  obj = LEPUS_NewGlobalCConstructor(ctx, "RegExp", lepus_regexp_constructor, 2,
                                    ctx->class_proto[LEPUS_CLASS_REGEXP]);
  ctx->regexp_ctor = LEPUS_DupValue(ctx, obj);

#if defined(__WASI_SDK__) || defined(QJS_UNITTEST)
  lepus_clear_regexp_caputre_property(ctx, obj, 0);
#endif

  LEPUS_SetPropertyFunctionList(ctx, obj, lepus_regexp_funcs,
                                countof(lepus_regexp_funcs));

  ctx->class_proto[LEPUS_CLASS_REGEXP_STRING_ITERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
  LEPUS_SetPropertyFunctionList(
      ctx, ctx->class_proto[LEPUS_CLASS_REGEXP_STRING_ITERATOR],
      lepus_regexp_string_iterator_proto_funcs,
      countof(lepus_regexp_string_iterator_proto_funcs));
}

/* JSON */
#ifndef NO_QUICKJS_COMPILER
/* XXX: this parser is less strict than the JSON standard because we
   reuse the Javascript tokenizer. It could be improved by adding a
   specific JSON parse flag. */
QJS_STATIC LEPUSValue json_parse_value(LEPUSParseState *s) {
  LEPUSContext *ctx = s->ctx;
  LEPUSValue val = LEPUS_NULL;
  BOOL is_neg;
  int ret;

  switch (s->token.val) {
    case '{': {
      LEPUSValue prop_val, prop_str;

      if (next_token(s)) goto fail;
      val = LEPUS_NewObject(ctx);
      if (LEPUS_IsException(val)) goto fail;
      if (s->token.val != '}') {
        for (;;) {
          if (s->token.val != TOK_STRING) {
            lepus_parse_error(s, "expecting property name");
            goto fail;
          }
          prop_str = LEPUS_DupValue(ctx, s->token.u.str.str);
          if (next_token(s)) {
            LEPUS_FreeValue(ctx, prop_str);
            goto fail;
          }
          if (lepus_parse_expect(s, ':')) {
            LEPUS_FreeValue(ctx, prop_str);
            goto fail;
          }
          prop_val = json_parse_value(s);
          if (LEPUS_IsException(prop_val)) {
            LEPUS_FreeValue(ctx, prop_str);
            goto fail;
          }
          ret = LEPUS_DefinePropertyValueValue(ctx, val, prop_str, prop_val,
                                               LEPUS_PROP_C_W_E);
          if (ret < 0) goto fail;

          if (s->token.val != ',') break;
          if (next_token(s)) goto fail;
        }
      }
      if (lepus_parse_expect(s, '}')) goto fail;
    } break;
    case '[': {
      LEPUSValue el;
      uint32_t idx;

      if (next_token(s)) goto fail;
      val = LEPUS_NewArray(ctx);
      if (LEPUS_IsException(val)) goto fail;
      if (s->token.val != ']') {
        idx = 0;
        for (;;) {
          el = json_parse_value(s);
          if (LEPUS_IsException(el)) goto fail;
          ret = LEPUS_DefinePropertyValueUint32(ctx, val, idx, el,
                                                LEPUS_PROP_C_W_E);
          if (ret < 0) goto fail;
          if (s->token.val != ',') break;
          if (next_token(s)) goto fail;
          idx++;
        }
      }
      if (lepus_parse_expect(s, ']')) goto fail;
    } break;
    case TOK_STRING:
      val = LEPUS_DupValue(ctx, s->token.u.str.str);
      if (next_token(s)) goto fail;
      break;
    case TOK_NUMBER:
      is_neg = 0;
      goto number;
    case '-':
      if (next_token(s)) goto fail;
      if (s->token.val != TOK_NUMBER) {
        lepus_parse_error(s, "number expected");
        goto fail;
      }
      is_neg = 1;
    number:
#ifdef CONFIG_BIGNUM
      val = LEPUS_DupValue(ctx, s->token.u.num.val);
      if (is_neg) {
        switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
          case LEPUS_TAG_BIG_INT:
          case LEPUS_TAG_BIG_FLOAT: {
            LEPUSBigFloat *p;
            p = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
            bf_neg(&p->num);
          } break;
          case LEPUS_TAG_FLOAT64: {
            double d;
            d = LEPUS_VALUE_GET_FLOAT64(val);
            val = __JS_NewFloat64(ctx, -d);
          } break;
          default:
          case LEPUS_TAG_INT: {
            int v;
            v = LEPUS_VALUE_GET_INT(val);
            if (v == 0 && !is_bignum_mode(s->ctx))
              val = __JS_NewFloat64(ctx, -0.0);
            else
              val = LEPUS_NewInt64(ctx, -(int64_t)v);
          } break;
        }
      }
#else
      val = s->token.u.num.val;
      if (is_neg) {
        double d;
        LEPUS_ToFloat64(ctx, &d, val); /* no exception possible */
        val = LEPUS_NewFloat64(ctx, -d);
      }
#endif
      if (next_token(s)) goto fail;
      break;
    case TOK_FALSE:
    case TOK_TRUE:
      val = LEPUS_NewBool(ctx, s->token.val - TOK_FALSE);
      if (next_token(s)) goto fail;
      break;
    case TOK_NULL:
      if (next_token(s)) goto fail;
      break;
    default:
      if (s->token.val == TOK_EOF) {
        lepus_parse_error(s, "unexpected end of input");
      } else {
        lepus_parse_error(s, "unexpected token: '%.*s'",
                          (int)(s->buf_ptr - s->token.ptr), s->token.ptr);
      }
      goto fail;
  }
  return val;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}
#endif

LEPUSValue LEPUS_ParseJSON(LEPUSContext *ctx, const char *buf, size_t buf_len,
                           const char *filename) {
#ifndef NO_QUICKJS_COMPILER
  LEPUSParseState s1, *s = &s1;
  LEPUSValue val;

  lepus_parse_init(ctx, s, buf, buf_len, filename);

  if (next_token(s)) goto fail;
  val = json_parse_value(s);
  if (LEPUS_IsException(val)) goto fail;
  if (s->token.val != TOK_EOF) {
    if (lepus_parse_error(s, "unexpected data at the end")) goto fail;
  }
  return val;
fail:
  free_token(s, &s->token);
  return LEPUS_EXCEPTION;
#else
  return LEPUS_UNDEFINED;
#endif
}

QJS_STATIC LEPUSValue internalize_json_property(LEPUSContext *ctx,
                                                LEPUSValueConst holder,
                                                LEPUSAtom name,
                                                LEPUSValueConst reviver) {
  LEPUSValue val, new_el, name_val, res;
  LEPUSValueConst args[2];
  int ret, is_array;
  uint32_t i, len = 0;
  LEPUSAtom prop;
  LEPUSPropertyEnum *atoms = NULL;

  if (lepus_check_stack_overflow(ctx, 0)) {
    return LEPUS_ThrowStackOverflow(ctx);
  }

  val = LEPUS_GetProperty(ctx, holder, name);
  if (LEPUS_IsException(val)) return val;
  if (LEPUS_IsObject(val)) {
    is_array = LEPUS_IsArray(ctx, val);
    if (is_array < 0) goto fail;
    if (is_array) {
      if (lepus_get_length32(ctx, &len, val)) goto fail;
    } else {
      ret = LEPUS_GetOwnPropertyNamesInternal(
          ctx, &atoms, &len, LEPUS_VALUE_GET_OBJ(val),
          LEPUS_GPN_ENUM_ONLY | LEPUS_GPN_STRING_MASK);
      if (ret < 0) goto fail;
    }
    for (i = 0; i < len; i++) {
      if (is_array) {
        prop = LEPUS_NewAtomUInt32(ctx, i);
        if (prop == LEPUS_ATOM_NULL) goto fail;
      } else {
        prop = LEPUS_DupAtom(ctx, atoms[i].atom);
      }
      new_el = internalize_json_property(ctx, val, prop, reviver);
      if (LEPUS_IsException(new_el)) {
        LEPUS_FreeAtom(ctx, prop);
        goto fail;
      }
      if (LEPUS_IsUndefined(new_el)) {
        ret = LEPUS_DeleteProperty(ctx, val, prop, 0);
      } else {
        ret =
            LEPUS_DefinePropertyValue(ctx, val, prop, new_el, LEPUS_PROP_C_W_E);
      }
      LEPUS_FreeAtom(ctx, prop);
      if (ret < 0) goto fail;
    }
  }
  lepus_free_prop_enum(ctx, atoms, len);
  atoms = NULL;
  name_val = LEPUS_AtomToValue(ctx, name);
  if (LEPUS_IsException(name_val)) goto fail;
  args[0] = name_val;
  args[1] = val;
  res = LEPUS_Call(ctx, reviver, holder, 2, args);
  LEPUS_FreeValue(ctx, name_val);
  LEPUS_FreeValue(ctx, val);
  return res;
fail:
  lepus_free_prop_enum(ctx, atoms, len);
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_json_parse(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue obj, root;
  LEPUSValueConst reviver;
  const char *str;
  size_t len;

  str = LEPUS_ToCStringLen(ctx, &len, argv[0]);
  if (!str) return LEPUS_EXCEPTION;
  obj = LEPUS_ParseJSON(ctx, str, len, "<input>");
  LEPUS_FreeCString(ctx, str);
  if (LEPUS_IsException(obj)) return obj;
  if (argc > 1 && LEPUS_IsFunction(ctx, argv[1])) {
    reviver = argv[1];
    root = LEPUS_NewObject(ctx);
    if (LEPUS_IsException(root)) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
    if (LEPUS_DefinePropertyValue(ctx, root, LEPUS_ATOM_empty_string, obj,
                                  LEPUS_PROP_C_W_E) < 0) {
      LEPUS_FreeValue(ctx, root);
      return LEPUS_EXCEPTION;
    }
    obj =
        internalize_json_property(ctx, root, LEPUS_ATOM_empty_string, reviver);
    LEPUS_FreeValue(ctx, root);
  }
  return obj;
}

typedef struct JSONStringifyContext {
  LEPUSValueConst replacer_func;
  LEPUSValue stack;
  LEPUSValue property_list;
  LEPUSValue gap;
  LEPUSValue empty;
  StringBuffer *b;
} JSONStringifyContext;

QJS_STATIC LEPUSValue LEPUS_ToQuotedStringFree(LEPUSContext *ctx,
                                               LEPUSValue val) {
  LEPUSValue r = LEPUS_ToQuotedString(ctx, val);
  LEPUS_FreeValue(ctx, val);
  return r;
}

#ifdef CONFIG_BIGNUM
static inline BOOL LEPUS_IsBigInt(LEPUSContext *ctx, LEPUSValueConst v);
#endif

QJS_STATIC LEPUSValue lepus_json_check(LEPUSContext *ctx,
                                       JSONStringifyContext *lepusc,
                                       LEPUSValueConst holder, LEPUSValue val,
                                       LEPUSValueConst key) {
  LEPUSValue v;
  LEPUSValueConst args[2];

  if (LEPUS_IsObject(val)
#ifdef CONFIG_BIGNUM
      || LEPUS_IsBigInt(ctx, val) /* XXX: probably useless */
#endif
  ) {
    LEPUSValue f = LEPUS_GetProperty(ctx, val, LEPUS_ATOM_toJSON);
    if (LEPUS_IsException(f)) goto exception;
    if (LEPUS_IsFunction(ctx, f)) {
      v = LEPUS_CallFree(ctx, f, val, 1, &key);
      LEPUS_FreeValue(ctx, val);
      val = v;
      if (LEPUS_IsException(val)) goto exception;
    } else {
      LEPUS_FreeValue(ctx, f);
    }
  }

  if (!LEPUS_IsUndefined(lepusc->replacer_func)) {
    args[0] = key;
    args[1] = val;
    v = LEPUS_Call(ctx, lepusc->replacer_func, holder, 2, args);
    LEPUS_FreeValue(ctx, val);
    val = v;
    if (LEPUS_IsException(val)) goto exception;
  }

  switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
    case LEPUS_TAG_OBJECT:
      if (LEPUS_IsFunction(ctx, val)) break;
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64:
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
#endif
    case LEPUS_TAG_BOOL:
    case LEPUS_TAG_NULL:
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
#endif
    case LEPUS_TAG_EXCEPTION:
      return val;
    default:
      break;
  }
  LEPUS_FreeValue(ctx, val);
  return LEPUS_UNDEFINED;

exception:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

QJS_STATIC int lepus_json_to_str(LEPUSContext *ctx,
                                 JSONStringifyContext *lepusc,
                                 LEPUSValueConst holder, LEPUSValue val,
                                 LEPUSValueConst indent) {
  LEPUSValue indent1, sep, sep1, tab, v, prop;
  LEPUSObject *p;
  int64_t i, len;
  int cl, ret;

  indent1 = LEPUS_UNDEFINED;
  sep = LEPUS_UNDEFINED;
  sep1 = LEPUS_UNDEFINED;
  tab = LEPUS_UNDEFINED;
  prop = LEPUS_UNDEFINED;

  BOOL has_content = FALSE;

  switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
    case LEPUS_TAG_OBJECT:
      p = LEPUS_VALUE_GET_OBJ(val);
      cl = p->class_id;
      if (cl == LEPUS_CLASS_STRING) {
        val = LEPUS_ToStringFree(ctx, val);
        if (LEPUS_IsException(val)) goto exception;
        val = LEPUS_ToQuotedStringFree(ctx, val);
        if (LEPUS_IsException(val)) goto exception;
        return string_buffer_concat_value_free(lepusc->b, val);
      } else if (cl == LEPUS_CLASS_NUMBER) {
        val = LEPUS_ToNumberFree(ctx, val);
        if (LEPUS_IsException(val)) goto exception;
        return string_buffer_concat_value_free(lepusc->b, val);
      } else if (cl == LEPUS_CLASS_BOOLEAN) {
        ret = string_buffer_concat_value(lepusc->b, p->u.object_data);
        LEPUS_FreeValue(ctx, val);
        return ret;
      }
#ifdef CONFIG_BIGNUM
      else if (cl == LEPUS_CLASS_BIG_FLOAT) {
        return string_buffer_concat_value_free(lepusc->b, val);
      } else if (cl == LEPUS_CLASS_BIG_INT) {
        LEPUS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
        goto exception;
      }
#endif
      v = lepus_array_includes(ctx, lepusc->stack, 1, (LEPUSValueConst *)&val);
      if (LEPUS_IsException(v)) goto exception;
      if (LEPUS_ToBoolFree(ctx, v)) {
        LEPUS_ThrowTypeError(ctx, "circular reference");
        goto exception;
      }
      indent1 = LEPUS_ConcatString(ctx, LEPUS_DupValue(ctx, indent),
                                   LEPUS_DupValue(ctx, lepusc->gap));
      if (LEPUS_IsException(indent1)) goto exception;
      if (!LEPUS_IsEmptyString(lepusc->gap)) {
        sep = LEPUS_ConcatString3(ctx, "\n", LEPUS_DupValue(ctx, indent1), "");
        if (LEPUS_IsException(sep)) goto exception;
        sep1 = LEPUS_NewString(ctx, " ");
        if (LEPUS_IsException(sep1)) goto exception;
      } else {
        sep = LEPUS_DupValue(ctx, lepusc->empty);
        sep1 = LEPUS_DupValue(ctx, lepusc->empty);
      }
      v = lepus_array_push(ctx, lepusc->stack, 1, (LEPUSValueConst *)&val, 0);
      if (check_exception_free(ctx, v)) goto exception;
      ret = LEPUS_IsArray(ctx, val);
      if (ret < 0) goto exception;
      if (ret) {
        if (lepus_get_length64(ctx, &len, val)) goto exception;
        string_buffer_putc8(lepusc->b, '[');
        for (i = 0; i < len; i++) {
          if (i > 0) string_buffer_putc8(lepusc->b, ',');
          string_buffer_concat_value(lepusc->b, sep);
          v = LEPUS_GetPropertyInt64(ctx, val, i);
          if (LEPUS_IsException(v)) goto exception;
          /* XXX: could do this string conversion only when needed */
          prop = LEPUS_ToStringFree(ctx, LEPUS_NewInt64(ctx, i));
          if (LEPUS_IsException(prop)) goto exception;
#ifdef ENABLE_LEPUSNG
          if (LEPUS_IsLepusRef(v)) {
            LEPUSValue oldv = v;
            v = ctx->rt->lepus_callbacks_.convert_to_object(ctx, v);
            LEPUS_DupValue(ctx, v);
            LEPUS_FreeValue(ctx, oldv);
          }
#endif
          v = lepus_json_check(ctx, lepusc, val, v, prop);
          LEPUS_FreeValue(ctx, prop);
          prop = LEPUS_UNDEFINED;
          if (LEPUS_IsException(v)) goto exception;
          if (LEPUS_IsUndefined(v)) v = LEPUS_NULL;
          if (lepus_json_to_str(ctx, lepusc, val, v, indent1)) goto exception;
        }
        if (len > 0 && !LEPUS_IsEmptyString(lepusc->gap)) {
          string_buffer_putc8(lepusc->b, '\n');
          string_buffer_concat_value(lepusc->b, indent);
        }
        string_buffer_putc8(lepusc->b, ']');
      } else {
        if (!LEPUS_IsUndefined(lepusc->property_list))
          tab = LEPUS_DupValue(ctx, lepusc->property_list);
        else
          tab = lepus_object_keys(ctx, LEPUS_UNDEFINED, 1,
                                  (LEPUSValueConst *)&val,
                                  LEPUS_ITERATOR_KIND_KEY);
        if (LEPUS_IsException(tab)) goto exception;
        if (lepus_get_length64(ctx, &len, tab)) goto exception;
        string_buffer_putc8(lepusc->b, '{');
        has_content = FALSE;
        for (i = 0; i < len; i++) {
          LEPUS_FreeValue(ctx, prop);
          prop = LEPUS_GetPropertyInt64(ctx, tab, i);
          if (LEPUS_IsException(prop)) goto exception;
          v = LEPUS_GetPropertyValue(ctx, val, LEPUS_DupValue(ctx, prop));
          if (LEPUS_IsException(v)) goto exception;
            // <ByteDance begin>
#ifdef ENABLE_LEPUSNG
          if (LEPUS_IsLepusRef(v)) {
            LEPUSValue oldv = v;
            v = ctx->rt->lepus_callbacks_.convert_to_object(ctx, v);
            LEPUS_DupValue(ctx, v);
            LEPUS_FreeValue(ctx, oldv);
          }
#endif
          // <ByteDance end>
          v = lepus_json_check(ctx, lepusc, val, v, prop);
          if (LEPUS_IsException(v)) goto exception;
          if (!LEPUS_IsUndefined(v)) {
            if (has_content) string_buffer_putc8(lepusc->b, ',');
            prop = LEPUS_ToQuotedStringFree(ctx, prop);
            if (LEPUS_IsException(prop)) {
              LEPUS_FreeValue(ctx, v);
              goto exception;
            }
            string_buffer_concat_value(lepusc->b, sep);
            string_buffer_concat_value(lepusc->b, prop);
            string_buffer_putc8(lepusc->b, ':');
            string_buffer_concat_value(lepusc->b, sep1);
            if (lepus_json_to_str(ctx, lepusc, val, v, indent1)) goto exception;
            has_content = TRUE;
          }
        }
        if (has_content && LEPUS_VALUE_GET_STRING(lepusc->gap)->len != 0) {
          string_buffer_putc8(lepusc->b, '\n');
          string_buffer_concat_value(lepusc->b, indent);
        }
        string_buffer_putc8(lepusc->b, '}');
      }
      if (check_exception_free(ctx,
                               lepus_array_pop(ctx, lepusc->stack, 0, NULL, 0)))
        goto exception;
      LEPUS_FreeValue(ctx, val);
      LEPUS_FreeValue(ctx, tab);
      LEPUS_FreeValue(ctx, sep);
      LEPUS_FreeValue(ctx, sep1);
      LEPUS_FreeValue(ctx, indent1);
      LEPUS_FreeValue(ctx, prop);
      return 0;
    case LEPUS_TAG_STRING:
      val = LEPUS_ToQuotedStringFree(ctx, val);
      if (LEPUS_IsException(val)) goto exception;
      return string_buffer_concat_value_free(lepusc->b, val);
    case LEPUS_TAG_FLOAT64:
      if (!isfinite(LEPUS_VALUE_GET_FLOAT64(val))) {
        val = LEPUS_NULL;
      }
      return string_buffer_concat_value_free(lepusc->b, val);
    case LEPUS_TAG_INT:
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_FLOAT:
#endif
    case LEPUS_TAG_BOOL:
    case LEPUS_TAG_NULL:
      return string_buffer_concat_value_free(lepusc->b, val);
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
      LEPUS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
      goto exception;
#endif
    default:
      LEPUS_FreeValue(ctx, val);
      return 0;
  }

exception:
  LEPUS_FreeValue(ctx, val);
  LEPUS_FreeValue(ctx, tab);
  LEPUS_FreeValue(ctx, sep);
  LEPUS_FreeValue(ctx, sep1);
  LEPUS_FreeValue(ctx, indent1);
  LEPUS_FreeValue(ctx, prop);
  return -1;
}

QJS_STATIC LEPUSValue lepus_json_stringify(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  // stringify(val, replacer, space)
  StringBuffer b_s;
  JSONStringifyContext lepusc_s, *lepusc = &lepusc_s;
  LEPUSValueConst replacer = argv[1];
  LEPUSValue val, v, space, ret, wrapper;
  int res;
  int64_t i, j, n;

  lepusc->replacer_func = LEPUS_UNDEFINED;
  lepusc->stack = LEPUS_UNDEFINED;
  lepusc->property_list = LEPUS_UNDEFINED;
  lepusc->gap = LEPUS_UNDEFINED;
  lepusc->b = &b_s;
  lepusc->empty = LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string);
  ret = LEPUS_UNDEFINED;
  wrapper = LEPUS_UNDEFINED;

  string_buffer_init(ctx, lepusc->b, 0);
  lepusc->stack = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(lepusc->stack)) goto exception;
  if (LEPUS_IsFunction(ctx, replacer)) {
    lepusc->replacer_func = replacer;
  } else {
    res = LEPUS_IsArray(ctx, replacer);
    if (res < 0) goto exception;
    if (res == 0 && LEPUS_IsLepusRef(replacer) && ctx) {
      res = LEPUS_LepusRefIsArray(ctx->rt, replacer);
    }
    if (res) {
      /* XXX: enumeration is not fully correct */
      lepusc->property_list = LEPUS_NewArray(ctx);
      if (LEPUS_IsException(lepusc->property_list)) goto exception;
      if (lepus_get_length64(ctx, &n, replacer)) goto exception;
      for (i = j = 0; i < n; i++) {
        LEPUSValue present;
        v = LEPUS_GetPropertyInt64(ctx, replacer, i);
        if (LEPUS_IsException(v)) goto exception;
        if (LEPUS_IsObject(v)) {
          LEPUSObject *p = LEPUS_VALUE_GET_OBJ(v);
          if (p->class_id == LEPUS_CLASS_STRING ||
              p->class_id == LEPUS_CLASS_NUMBER) {
            v = LEPUS_ToStringFree(ctx, v);
            if (LEPUS_IsException(v)) goto exception;
          } else {
            LEPUS_FreeValue(ctx, v);
            continue;
          }
        } else if (LEPUS_IsNumber(v)) {
          v = LEPUS_ToStringFree(ctx, v);
          if (LEPUS_IsException(v)) goto exception;
        } else if (!LEPUS_IsString(v)) {
          LEPUS_FreeValue(ctx, v);
          continue;
        }
        present = lepus_array_includes(ctx, lepusc->property_list, 1,
                                       (LEPUSValueConst *)&v);
        if (LEPUS_IsException(present)) {
          LEPUS_FreeValue(ctx, v);
          goto exception;
        }
        if (!LEPUS_ToBoolFree(ctx, present)) {
          LEPUS_SetPropertyInt64(ctx, lepusc->property_list, j++, v);
        } else {
          LEPUS_FreeValue(ctx, v);
        }
      }
    }
  }
  space = LEPUS_DupValue(ctx, argv[2]);
  if (LEPUS_IsObject(space)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(space);
    if (p->class_id == LEPUS_CLASS_NUMBER) {
      space = LEPUS_ToNumberFree(ctx, space);
    } else if (p->class_id == LEPUS_CLASS_STRING) {
      space = LEPUS_ToStringFree(ctx, space);
    }
    if (LEPUS_IsException(space)) {
      LEPUS_FreeValue(ctx, space);
      goto exception;
    }
  }
  if (LEPUS_IsNumber(space)) {
    int n;
    if (LEPUS_ToInt32Clamp(ctx, &n, space, 0, 10, 0)) goto exception;
    lepusc->gap = LEPUS_NewStringLen(ctx, "          ", n);
  } else if (LEPUS_IsString(space)) {
    LEPUSString *p = LEPUS_VALUE_GET_STRING(space);
    lepusc->gap = lepus_sub_string(ctx, p, 0, min_int(p->len, 10));
  } else {
    lepusc->gap = LEPUS_DupValue(ctx, lepusc->empty);
  }
  LEPUS_FreeValue(ctx, space);
  if (LEPUS_IsException(lepusc->gap)) goto exception;
  wrapper = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(wrapper)) goto exception;
  if (LEPUS_DefinePropertyValue(ctx, wrapper, LEPUS_ATOM_empty_string,
                                LEPUS_DupValue(ctx, argv[0]),
                                LEPUS_PROP_C_W_E) < 0) {
    goto exception;
  }
  val = LEPUS_DupValue(ctx, argv[0]);
// <ByteDance begin>
#ifdef ENABLE_LEPUSNG
  if (LEPUS_IsLepusRef(val)) {
    LEPUSValue tmp = ctx->rt->lepus_callbacks_.convert_to_object(ctx, val);
    LEPUS_DupValue(ctx, tmp);
    LEPUS_FreeValue(ctx, val);
    val = tmp;
  }
#endif
  // <ByteDance end>
  val = lepus_json_check(ctx, lepusc, wrapper, val, lepusc->empty);
  if (LEPUS_IsException(val)) goto exception;
  if (LEPUS_IsUndefined(val)) {
    ret = LEPUS_UNDEFINED;
    goto done1;
  }
  if (lepus_json_to_str(ctx, lepusc, wrapper, val, lepusc->empty))
    goto exception;

  ret = string_buffer_end(lepusc->b);
  goto done;

exception:
  ret = LEPUS_EXCEPTION;
done1:
  string_buffer_free(lepusc->b);
done:
  LEPUS_FreeValue(ctx, wrapper);
  LEPUS_FreeValue(ctx, lepusc->empty);
  LEPUS_FreeValue(ctx, lepusc->gap);
  LEPUS_FreeValue(ctx, lepusc->property_list);
  LEPUS_FreeValue(ctx, lepusc->stack);
  return ret;
}

static const LEPUSCFunctionListEntry lepus_json_funcs[] = {
    LEPUS_CFUNC_DEF("parse", 2, lepus_json_parse),
    LEPUS_CFUNC_DEF("stringify", 3, lepus_json_stringify),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "JSON",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry lepus_json_obj[] = {
    LEPUS_OBJECT_DEF("JSON", lepus_json_funcs, countof(lepus_json_funcs),
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

void LEPUS_AddIntrinsicJSON(LEPUSContext *ctx) {
  /* add JSON as autoinit object */
  LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, lepus_json_obj,
                                countof(lepus_json_obj));
}

/* Reflect */

QJS_STATIC LEPUSValue lepus_reflect_apply(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  return lepus_function_apply(ctx, argv[0], max_int(0, argc - 1), argv + 1, 0);
}

QJS_STATIC LEPUSValue lepus_reflect_construct(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValueConst func, array_arg, new_target;
  LEPUSValue *tab, ret;
  uint32_t len;

  func = argv[0];
  array_arg = argv[1];
  if (argc > 2) {
    new_target = argv[2];
    if (!LEPUS_IsConstructor(ctx, new_target))
      return LEPUS_ThrowTypeError(ctx, "not a constructor");
  } else {
    new_target = func;
  }
  tab = build_arg_list(ctx, &len, array_arg);
  if (!tab) return LEPUS_EXCEPTION;
  ret = LEPUS_CallConstructor2(ctx, func, new_target, len,
                               (LEPUSValueConst *)tab);
  free_arg_list(ctx, tab, len);
  return ret;
}

QJS_STATIC LEPUSValue lepus_reflect_deleteProperty(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   int argc,
                                                   LEPUSValueConst *argv) {
  LEPUSValueConst obj;
  LEPUSAtom atom;
  int ret;

  obj = argv[0];
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  atom = lepus_value_to_atom(ctx, argv[1]);
  if (unlikely(atom == LEPUS_ATOM_NULL)) return LEPUS_EXCEPTION;
  ret = LEPUS_DeleteProperty(ctx, obj, atom, 0);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue lepus_reflect_get(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValueConst obj, prop, receiver;
  LEPUSAtom atom;
  LEPUSValue ret;

  obj = argv[0];
  prop = argv[1];
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  if (argc > 2)
    receiver = argv[2];
  else
    receiver = obj;
  atom = lepus_value_to_atom(ctx, prop);
  if (unlikely(atom == LEPUS_ATOM_NULL)) return LEPUS_EXCEPTION;
  ret = LEPUS_GetPropertyInternal(ctx, obj, atom, receiver, FALSE);
  LEPUS_FreeAtom(ctx, atom);
  return ret;
}

QJS_STATIC LEPUSValue lepus_reflect_has(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValueConst obj, prop;
  LEPUSAtom atom;
  int ret;

  obj = argv[0];
  prop = argv[1];
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  atom = lepus_value_to_atom(ctx, prop);
  if (unlikely(atom == LEPUS_ATOM_NULL)) return LEPUS_EXCEPTION;
  ret = LEPUS_HasProperty(ctx, obj, atom);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue lepus_reflect_set(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValueConst obj, prop, val, receiver;
  int ret;
  LEPUSAtom atom;

  obj = argv[0];
  prop = argv[1];
  val = argv[2];
  if (argc > 3)
    receiver = argv[3];
  else
    receiver = obj;
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  atom = lepus_value_to_atom(ctx, prop);
  if (unlikely(atom == LEPUS_ATOM_NULL)) return LEPUS_EXCEPTION;
  ret = LEPUS_SetPropertyGeneric(ctx, LEPUS_VALUE_GET_OBJ(obj), atom,
                                 LEPUS_DupValue(ctx, val), receiver, 0);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue lepus_reflect_setPrototypeOf(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   int argc,
                                                   LEPUSValueConst *argv) {
  int ret;
  ret = LEPUS_SetPrototypeInternal(ctx, argv[0], argv[1], FALSE);
  if (ret < 0)
    return LEPUS_EXCEPTION;
  else
    return LEPUS_NewBool(ctx, ret);
}

QJS_STATIC LEPUSValue lepus_reflect_ownKeys(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  if (LEPUS_VALUE_IS_NOT_OBJECT(argv[0]))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  return LEPUS_GetOwnPropertyNames2(
      ctx, argv[0], LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK,
      LEPUS_ITERATOR_KIND_KEY);
}

static const LEPUSCFunctionListEntry lepus_reflect_funcs[] = {
    LEPUS_CFUNC_DEF("apply", 3, lepus_reflect_apply),
    LEPUS_CFUNC_DEF("construct", 2, lepus_reflect_construct),
    LEPUS_CFUNC_MAGIC_DEF("defineProperty", 3, lepus_object_defineProperty, 1),
    LEPUS_CFUNC_DEF("deleteProperty", 2, lepus_reflect_deleteProperty),
    LEPUS_CFUNC_DEF("get", 2, lepus_reflect_get),
    LEPUS_CFUNC_MAGIC_DEF("getOwnPropertyDescriptor", 2,
                          lepus_object_getOwnPropertyDescriptor, 1),
    LEPUS_CFUNC_MAGIC_DEF("getPrototypeOf", 1, lepus_object_getPrototypeOf, 1),
    LEPUS_CFUNC_DEF("has", 2, lepus_reflect_has),
    LEPUS_CFUNC_MAGIC_DEF("isExtensible", 1, lepus_object_isExtensible, 1),
    LEPUS_CFUNC_DEF("ownKeys", 1, lepus_reflect_ownKeys),
    LEPUS_CFUNC_MAGIC_DEF("preventExtensions", 1,
                          lepus_object_preventExtensions, 1),
    LEPUS_CFUNC_DEF("set", 3, lepus_reflect_set),
    LEPUS_CFUNC_DEF("setPrototypeOf", 2, lepus_reflect_setPrototypeOf),
};

static const LEPUSCFunctionListEntry lepus_reflect_obj[] = {
    LEPUS_OBJECT_DEF("Reflect", lepus_reflect_funcs,
                     countof(lepus_reflect_funcs),
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

/* Proxy */

QJS_STATIC void lepus_proxy_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSProxyData *s =
      static_cast<LEPUSProxyData *>(LEPUS_GetOpaque(val, LEPUS_CLASS_PROXY));
  if (s) {
    LEPUS_FreeValueRT(rt, s->target);
    LEPUS_FreeValueRT(rt, s->handler);
    LEPUS_FreeValueRT(rt, s->proto);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void lepus_proxy_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                 LEPUS_MarkFunc *mark_func) {
  LEPUSProxyData *s =
      static_cast<LEPUSProxyData *>(LEPUS_GetOpaque(val, LEPUS_CLASS_PROXY));
  if (s) {
    LEPUS_MarkValue(rt, s->target, mark_func);
    LEPUS_MarkValue(rt, s->handler, mark_func);
    LEPUS_MarkValue(rt, s->proto, mark_func);
  }
}

QJS_STATIC LEPUSValue LEPUS_ThrowTypeErrorRevokedProxy(LEPUSContext *ctx) {
  return LEPUS_ThrowTypeError(ctx, "revoked proxy");
}

QJS_STATIC LEPUSProxyData *get_proxy_method(LEPUSContext *ctx,
                                            LEPUSValue *pmethod,
                                            LEPUSValueConst obj,
                                            LEPUSAtom name) {
  LEPUSProxyData *s =
      static_cast<LEPUSProxyData *>(LEPUS_GetOpaque(obj, LEPUS_CLASS_PROXY));
  LEPUSValue method;

  /* safer to test recursion in all proxy methods */
  if (lepus_check_stack_overflow(ctx, 0)) {
    LEPUS_ThrowStackOverflow(ctx);
    return NULL;
  }

  /* 's' should never be NULL */
  if (s->is_revoked) {
    LEPUS_ThrowTypeErrorRevokedProxy(ctx);
    return NULL;
  }
  method = LEPUS_GetProperty(ctx, s->handler, name);
  if (LEPUS_IsException(method)) return NULL;
  if (LEPUS_IsNull(method)) method = LEPUS_UNDEFINED;
  *pmethod = method;
  return s;
}

QJS_STATIC LEPUSValueConst lepus_proxy_getPrototypeOf(LEPUSContext *ctx,
                                                      LEPUSValueConst obj) {
  LEPUSProxyData *s;
  LEPUSValue method, ret;
  LEPUSValueConst proto1;
  int res;

  /* must check for timeout to avoid infinite loop in instanceof */
  if (lepus_poll_interrupts(ctx)) return LEPUS_EXCEPTION;

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_getPrototypeOf);
  if (!s) return LEPUS_EXCEPTION;
  if (LEPUS_IsUndefined(method)) return LEPUS_GetPrototype(ctx, s->target);
  ret =
      LEPUS_CallFree(ctx, method, s->handler, 1, (LEPUSValueConst *)&s->target);
  if (LEPUS_IsException(ret)) return ret;
  if (!LEPUS_VALUE_IS_NULL(ret) && LEPUS_VALUE_IS_NOT_OBJECT(ret)) {
    goto fail;
  }
  res = LEPUS_IsExtensible(ctx, s->target);
  if (res < 0) {
    LEPUS_FreeValue(ctx, ret);
    return LEPUS_EXCEPTION;
  }
  if (!res) {
    /* check invariant */
    proto1 = LEPUS_GetPrototype(ctx, s->target);
    if (LEPUS_IsException(proto1)) {
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    }
    if (LEPUS_VALUE_GET_OBJ(proto1) != LEPUS_VALUE_GET_OBJ(ret)) {
    fail:
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_ThrowTypeError(ctx, "proxy: inconsistent prototype");
    }
  }
  /* store the prototype in the proxy so that its refcount is at least 1 */
  set_value(ctx, &s->proto, ret);
  return (LEPUSValueConst)ret;
}

QJS_STATIC int lepus_proxy_setPrototypeOf(LEPUSContext *ctx,
                                          LEPUSValueConst obj,
                                          LEPUSValueConst proto_val,
                                          BOOL throw_flag) {
  LEPUSProxyData *s;
  LEPUSValue method, ret, proto1;
  LEPUSValueConst args[2];
  BOOL res;
  int res2;

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_setPrototypeOf);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method))
    return LEPUS_SetPrototypeInternal(ctx, s->target, proto_val, throw_flag);
  args[0] = s->target;
  args[1] = proto_val;
  ret = LEPUS_CallFree(ctx, method, s->handler, 2, args);
  if (LEPUS_IsException(ret)) return -1;
  res = LEPUS_ToBoolFree(ctx, ret);
  if (!res) {
    if (throw_flag) {
      LEPUS_ThrowTypeError(ctx, "proxy: bad prototype");
      return -1;
    } else {
      return FALSE;
    }
  }
  res2 = LEPUS_IsExtensible(ctx, s->target);
  if (res2 < 0) return -1;
  if (!res2) {
    proto1 = LEPUS_GetPrototype(ctx, s->target);
    if (LEPUS_IsException(proto1)) return -1;
    if (LEPUS_VALUE_GET_OBJ(proto_val) != LEPUS_VALUE_GET_OBJ(proto1)) {
      LEPUS_ThrowTypeError(ctx, "proxy: inconsistent prototype");
      return -1;
    }
  }
  return TRUE;
}

QJS_STATIC int lepus_proxy_isExtensible(LEPUSContext *ctx,
                                        LEPUSValueConst obj) {
  LEPUSProxyData *s;
  LEPUSValue method, ret;
  BOOL res;
  int res2;

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_isExtensible);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) return LEPUS_IsExtensible(ctx, s->target);
  ret =
      LEPUS_CallFree(ctx, method, s->handler, 1, (LEPUSValueConst *)&s->target);
  if (LEPUS_IsException(ret)) return -1;
  res = LEPUS_ToBoolFree(ctx, ret);
  res2 = LEPUS_IsExtensible(ctx, s->target);
  if (res2 < 0) return res2;
  if (res != res2) {
    LEPUS_ThrowTypeError(ctx, "proxy: inconsistent isExtensible");
    return -1;
  }
  return res;
}

QJS_STATIC int lepus_proxy_preventExtensions(LEPUSContext *ctx,
                                             LEPUSValueConst obj) {
  LEPUSProxyData *s;
  LEPUSValue method, ret;
  BOOL res;
  int res2;

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_preventExtensions);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) return LEPUS_PreventExtensions(ctx, s->target);
  ret =
      LEPUS_CallFree(ctx, method, s->handler, 1, (LEPUSValueConst *)&s->target);
  if (LEPUS_IsException(ret)) return -1;
  res = LEPUS_ToBoolFree(ctx, ret);
  if (res) {
    res2 = LEPUS_IsExtensible(ctx, s->target);
    if (res2 < 0) return res2;
    if (res2) {
      LEPUS_ThrowTypeError(ctx, "proxy: inconsistent preventExtensions");
      return -1;
    }
  }
  return res;
}

QJS_STATIC int lepus_proxy_has(LEPUSContext *ctx, LEPUSValueConst obj,
                               LEPUSAtom atom) {
  LEPUSProxyData *s;
  LEPUSValue method, ret1, atom_val;
  int ret, res;
  LEPUSObject *p;
  LEPUSValueConst args[2];
  BOOL res2;

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_has);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) return LEPUS_HasProperty(ctx, s->target, atom);
  atom_val = LEPUS_AtomToValue(ctx, atom);
  if (LEPUS_IsException(atom_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = atom_val;
  ret1 = LEPUS_CallFree(ctx, method, s->handler, 2, args);
  LEPUS_FreeValue(ctx, atom_val);
  if (LEPUS_IsException(ret1)) return -1;
  ret = LEPUS_ToBoolFree(ctx, ret1);
  if (!ret) {
    LEPUSPropertyDescriptor desc;
    p = LEPUS_VALUE_GET_OBJ(s->target);
    res = LEPUS_GetOwnPropertyInternal(ctx, &desc, p, atom);
    if (res < 0) return -1;
    if (res) {
      res2 = !(desc.flags & LEPUS_PROP_CONFIGURABLE);
      lepus_free_desc(ctx, &desc);
      if (res2 || !p->extensible) {
        LEPUS_ThrowTypeError(ctx, "proxy: inconsistent has");
        return -1;
      }
    }
  }
  return ret;
}

QJS_STATIC LEPUSValue lepus_proxy_get(LEPUSContext *ctx, LEPUSValueConst obj,
                                      LEPUSAtom atom,
                                      LEPUSValueConst receiver) {
  LEPUSProxyData *s;
  LEPUSValue method, ret, atom_val;
  int res;
  LEPUSValueConst args[3];
  LEPUSPropertyDescriptor desc;

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_get);
  if (!s) return LEPUS_EXCEPTION;
  /* Note: recursion is possible thru the prototype of s->target */
  if (LEPUS_IsUndefined(method))
    return LEPUS_GetPropertyInternal(ctx, s->target, atom, receiver, FALSE);
  atom_val = LEPUS_AtomToValue(ctx, atom);
  if (LEPUS_IsException(atom_val)) {
    LEPUS_FreeValue(ctx, method);
    return LEPUS_EXCEPTION;
  }
  args[0] = s->target;
  args[1] = atom_val;
  args[2] = receiver;
  ret = LEPUS_CallFree(ctx, method, s->handler, 3, args);
  LEPUS_FreeValue(ctx, atom_val);
  if (LEPUS_IsException(ret)) return LEPUS_EXCEPTION;
  res = LEPUS_GetOwnPropertyInternal(ctx, &desc, LEPUS_VALUE_GET_OBJ(s->target),
                                     atom);
  if (res < 0) return LEPUS_EXCEPTION;
  if (res) {
    if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE |
                       LEPUS_PROP_WRITABLE)) == 0) {
      if (!lepus_same_value(ctx, desc.value, ret)) {
        goto fail;
      }
    } else if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE)) ==
               LEPUS_PROP_GETSET) {
      if (LEPUS_IsUndefined(desc.getter) && !LEPUS_IsUndefined(ret)) {
      fail:
        lepus_free_desc(ctx, &desc);
        LEPUS_FreeValue(ctx, ret);
        return LEPUS_ThrowTypeError(ctx, "proxy: inconsistent get");
      }
    }
    lepus_free_desc(ctx, &desc);
  }
  return ret;
}

QJS_STATIC int lepus_proxy_set(LEPUSContext *ctx, LEPUSValueConst obj,
                               LEPUSAtom atom, LEPUSValueConst value,
                               LEPUSValueConst receiver, int flags) {
  LEPUSProxyData *s;
  LEPUSValue method, ret1, atom_val;
  int ret, res;
  LEPUSValueConst args[4];

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_set);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) {
    return LEPUS_SetPropertyGeneric(ctx, LEPUS_VALUE_GET_OBJ(s->target), atom,
                                    LEPUS_DupValue(ctx, value), receiver,
                                    flags);
  }
  atom_val = LEPUS_AtomToValue(ctx, atom);
  if (LEPUS_IsException(atom_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = atom_val;
  args[2] = value;
  args[3] = receiver;
  ret1 = LEPUS_CallFree(ctx, method, s->handler, 4, args);
  LEPUS_FreeValue(ctx, atom_val);
  if (LEPUS_IsException(ret1)) return -1;
  ret = LEPUS_ToBoolFree(ctx, ret1);
  if (ret) {
    LEPUSPropertyDescriptor desc;
    res = LEPUS_GetOwnPropertyInternal(ctx, &desc,
                                       LEPUS_VALUE_GET_OBJ(s->target), atom);
    if (res < 0) return -1;
    if (res) {
      if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE |
                         LEPUS_PROP_WRITABLE)) == 0) {
        if (!lepus_same_value(ctx, desc.value, value)) {
          goto fail;
        }
      } else if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE)) ==
                     LEPUS_PROP_GETSET &&
                 LEPUS_IsUndefined(desc.setter)) {
      fail:
        lepus_free_desc(ctx, &desc);
        LEPUS_ThrowTypeError(ctx, "proxy: inconsistent set");
        return -1;
      }
      lepus_free_desc(ctx, &desc);
    }
  } else {
    if ((flags & LEPUS_PROP_THROW) ||
        ((flags & LEPUS_PROP_THROW_STRICT) && is_strict_mode(ctx))) {
      LEPUS_ThrowTypeError(ctx, "proxy: cannot set property");
      return -1;
    }
  }
  return ret;
}

QJS_STATIC LEPUSValue lepus_create_desc(LEPUSContext *ctx, LEPUSValueConst val,
                                        LEPUSValueConst getter,
                                        LEPUSValueConst setter, int flags) {
  LEPUSValue ret;
  ret = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(ret)) return ret;
  if (flags & LEPUS_PROP_HAS_GET) {
    LEPUS_DefinePropertyValue(ctx, ret, LEPUS_ATOM_get,
                              LEPUS_DupValue(ctx, getter), LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_SET) {
    LEPUS_DefinePropertyValue(ctx, ret, LEPUS_ATOM_set,
                              LEPUS_DupValue(ctx, setter), LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_VALUE) {
    LEPUS_DefinePropertyValue(ctx, ret, LEPUS_ATOM_value,
                              LEPUS_DupValue(ctx, val), LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_WRITABLE) {
    LEPUS_DefinePropertyValue(
        ctx, ret, LEPUS_ATOM_writable,
        LEPUS_NewBool(ctx, (flags & LEPUS_PROP_WRITABLE) != 0),
        LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_ENUMERABLE) {
    LEPUS_DefinePropertyValue(
        ctx, ret, LEPUS_ATOM_enumerable,
        LEPUS_NewBool(ctx, (flags & LEPUS_PROP_ENUMERABLE) != 0),
        LEPUS_PROP_C_W_E);
  }
  if (flags & LEPUS_PROP_HAS_CONFIGURABLE) {
    LEPUS_DefinePropertyValue(
        ctx, ret, LEPUS_ATOM_configurable,
        LEPUS_NewBool(ctx, (flags & LEPUS_PROP_CONFIGURABLE) != 0),
        LEPUS_PROP_C_W_E);
  }
  return ret;
}

QJS_STATIC int lepus_proxy_get_own_property(LEPUSContext *ctx,
                                            LEPUSPropertyDescriptor *pdesc,
                                            LEPUSValueConst obj,
                                            LEPUSAtom prop) {
  LEPUSProxyData *s;
  LEPUSValue method, ret1, prop_val;
  int res, target_res, ret;
  LEPUSObject *p;
  LEPUSValueConst args[2];
  LEPUSPropertyDescriptor desc, target_desc;

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_getOwnPropertyDescriptor);
  if (!s) return -1;
  p = LEPUS_VALUE_GET_OBJ(s->target);
  if (LEPUS_IsUndefined(method)) {
    return LEPUS_GetOwnPropertyInternal(ctx, pdesc, p, prop);
  }
  prop_val = LEPUS_AtomToValue(ctx, prop);
  if (LEPUS_IsException(prop_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = prop_val;
  ret1 = LEPUS_CallFree(ctx, method, s->handler, 2, args);
  LEPUS_FreeValue(ctx, prop_val);
  if (LEPUS_IsException(ret1)) return -1;
  if (!LEPUS_IsObject(ret1) && !LEPUS_IsUndefined(ret1)) {
    LEPUS_FreeValue(ctx, ret1);
    goto fail;
  }
  target_res = LEPUS_GetOwnPropertyInternal(ctx, &target_desc, p, prop);
  if (target_res < 0) {
    LEPUS_FreeValue(ctx, ret1);
    return -1;
  }
  if (target_res) lepus_free_desc(ctx, &target_desc);
  if (LEPUS_IsUndefined(ret1)) {
    if (target_res) {
      if (!(target_desc.flags & LEPUS_PROP_CONFIGURABLE) || !p->extensible)
        goto fail;
    }
    ret = FALSE;
  } else {
    int flags1;

    res = lepus_obj_to_desc(ctx, &desc, ret1);
    LEPUS_FreeValue(ctx, ret1);
    if (res < 0) return -1;
    if (target_res) {
      /* convert desc.flags to defineProperty flags */
      flags1 =
          desc.flags | LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_HAS_ENUMERABLE;
      if (desc.flags & LEPUS_PROP_GETSET)
        flags1 |= LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET;
      else
        flags1 |= LEPUS_PROP_HAS_VALUE | LEPUS_PROP_HAS_WRITABLE;
      /* XXX: not complete check: need to compare value &
         getter/setter as in defineproperty */
      if (!check_define_prop_flags(target_desc.flags, flags1)) goto fail1;
    } else {
      if (!p->extensible) goto fail1;
    }
    res = (!(desc.flags & LEPUS_PROP_CONFIGURABLE) &&
           (!target_res || (target_desc.flags & LEPUS_PROP_CONFIGURABLE)));
    if (res) {
    fail1:
      lepus_free_desc(ctx, &desc);
    fail:
      LEPUS_ThrowTypeError(ctx, "proxy: inconsistent getOwnPropertyDescriptor");
      return -1;
    }
    ret = TRUE;
    if (pdesc) {
      *pdesc = desc;
    } else {
      lepus_free_desc(ctx, &desc);
    }
  }
  return ret;
}

QJS_STATIC int lepus_proxy_define_own_property(
    LEPUSContext *ctx, LEPUSValueConst obj, LEPUSAtom prop, LEPUSValueConst val,
    LEPUSValueConst getter, LEPUSValueConst setter, int flags) {
  LEPUSProxyData *s;
  LEPUSValue method, ret1, prop_val, desc_val;
  int res, ret;
  LEPUSObject *p;
  LEPUSValueConst args[3];
  LEPUSPropertyDescriptor desc;
  BOOL setting_not_configurable;

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_defineProperty);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) {
    return LEPUS_DefineProperty(ctx, s->target, prop, val, getter, setter,
                                flags);
  }
  prop_val = LEPUS_AtomToValue(ctx, prop);
  if (LEPUS_IsException(prop_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  desc_val = lepus_create_desc(ctx, val, getter, setter, flags);
  if (LEPUS_IsException(desc_val)) {
    LEPUS_FreeValue(ctx, prop_val);
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = prop_val;
  args[2] = desc_val;
  ret1 = LEPUS_CallFree(ctx, method, s->handler, 3, args);
  LEPUS_FreeValue(ctx, prop_val);
  LEPUS_FreeValue(ctx, desc_val);
  if (LEPUS_IsException(ret1)) return -1;
  ret = LEPUS_ToBoolFree(ctx, ret1);
  if (!ret) {
    if (flags & LEPUS_PROP_THROW) {
      LEPUS_ThrowTypeError(ctx, "proxy: defineProperty exception");
      return -1;
    } else {
      return 0;
    }
  }
  p = LEPUS_VALUE_GET_OBJ(s->target);
  res = LEPUS_GetOwnPropertyInternal(ctx, &desc, p, prop);
  if (res < 0) return -1;
  setting_not_configurable =
      ((flags & (LEPUS_PROP_HAS_CONFIGURABLE | LEPUS_PROP_CONFIGURABLE)) ==
       LEPUS_PROP_HAS_CONFIGURABLE);
  if (!res) {
    if (!p->extensible || setting_not_configurable) goto fail;
  } else {
    if (!check_define_prop_flags(desc.flags, flags) ||
        ((desc.flags & LEPUS_PROP_CONFIGURABLE) && setting_not_configurable)) {
      goto fail1;
    }
    if (flags & (LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET)) {
      if ((desc.flags & (LEPUS_PROP_GETSET | LEPUS_PROP_CONFIGURABLE)) ==
          LEPUS_PROP_GETSET) {
        if ((flags & LEPUS_PROP_HAS_GET) &&
            !lepus_same_value(ctx, getter, desc.getter)) {
          goto fail1;
        }
        if ((flags & LEPUS_PROP_HAS_SET) &&
            !lepus_same_value(ctx, setter, desc.setter)) {
          goto fail1;
        }
      }
    } else if (flags & LEPUS_PROP_HAS_VALUE) {
      if ((desc.flags & (LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE)) == 0 &&
          !lepus_same_value(ctx, val, desc.value)) {
      fail1:
        lepus_free_desc(ctx, &desc);
      fail:
        LEPUS_ThrowTypeError(ctx, "proxy: inconsistent defineProperty");
        return -1;
      }
    }
    lepus_free_desc(ctx, &desc);
  }
  return 1;
}

QJS_STATIC int lepus_proxy_delete_property(LEPUSContext *ctx,
                                           LEPUSValueConst obj,
                                           LEPUSAtom atom) {
  LEPUSProxyData *s;
  LEPUSValue method, ret, atom_val;
  int res, res2;
  LEPUSValueConst args[2];

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_deleteProperty);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) {
    return LEPUS_DeleteProperty(ctx, s->target, atom, 0);
  }
  atom_val = LEPUS_AtomToValue(ctx, atom);
  ;
  if (LEPUS_IsException(atom_val)) {
    LEPUS_FreeValue(ctx, method);
    return -1;
  }
  args[0] = s->target;
  args[1] = atom_val;
  ret = LEPUS_CallFree(ctx, method, s->handler, 2, args);
  LEPUS_FreeValue(ctx, atom_val);
  if (LEPUS_IsException(ret)) return -1;
  res = LEPUS_ToBoolFree(ctx, ret);
  if (res) {
    LEPUSPropertyDescriptor desc;
    res2 = LEPUS_GetOwnPropertyInternal(ctx, &desc,
                                        LEPUS_VALUE_GET_OBJ(s->target), atom);
    if (res2 < 0) return -1;
    if (res2) {
      res2 = !(desc.flags & LEPUS_PROP_CONFIGURABLE);
      lepus_free_desc(ctx, &desc);
      if (res2) {
        LEPUS_ThrowTypeError(ctx, "proxy: inconsistent deleteProperty");
        return -1;
      }
    }
  }
  return res;
}

/* return the index of the property or -1 if not found */
QJS_STATIC int find_prop_key(const LEPUSPropertyEnum *tab, int n,
                             LEPUSAtom atom) {
  int i;
  for (i = 0; i < n; i++) {
    if (tab[i].atom == atom) return i;
  }
  return -1;
}

QJS_STATIC int lepus_proxy_get_own_property_names(LEPUSContext *ctx,
                                                  LEPUSPropertyEnum **ptab,
                                                  uint32_t *plen,
                                                  LEPUSValueConst obj) {
  LEPUSProxyData *s;
  LEPUSValue method, prop_array, val;
  uint32_t len, i, len2;
  LEPUSPropertyEnum *tab, *tab2;
  LEPUSAtom atom;
  LEPUSPropertyDescriptor desc;
  int res, is_extensible, idx;

  s = get_proxy_method(ctx, &method, obj, LEPUS_ATOM_ownKeys);
  if (!s) return -1;
  if (LEPUS_IsUndefined(method)) {
    return LEPUS_GetOwnPropertyNamesInternal(
        ctx, ptab, plen, LEPUS_VALUE_GET_OBJ(s->target),
        LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK);
  }
  prop_array =
      LEPUS_CallFree(ctx, method, s->handler, 1, (LEPUSValueConst *)&s->target);
  if (LEPUS_IsException(prop_array)) return -1;
  tab = NULL;
  len = 0;
  tab2 = NULL;
  len2 = 0;
  if (lepus_get_length32(ctx, &len, prop_array)) goto fail;
  if (len > 0) {
    tab = static_cast<LEPUSPropertyEnum *>(
        lepus_mallocz(ctx, sizeof(tab[0]) * len));
    if (!tab) goto fail;
  }
  for (i = 0; i < len; i++) {
    val = LEPUS_GetPropertyUint32(ctx, prop_array, i);
    if (LEPUS_IsException(val)) goto fail;
    if (!LEPUS_IsString(val) && !LEPUS_IsSymbol(val)) {
      LEPUS_FreeValue(ctx, val);
      LEPUS_ThrowTypeError(ctx, "proxy: properties must be strings or symbols");
      goto fail;
    }
    atom = lepus_value_to_atom(ctx, val);
    LEPUS_FreeValue(ctx, val);
    if (atom == LEPUS_ATOM_NULL) goto fail;
    tab[i].atom = atom;
    tab[i].is_enumerable = FALSE; /* XXX: redundant? */
  }

  /* check duplicate properties (XXX: inefficient, could store the
   * properties an a temporary object to use the hash) */
  for (i = 1; i < len; i++) {
    if (find_prop_key(tab, i, tab[i].atom) >= 0) {
      LEPUS_ThrowTypeError(ctx, "proxy: duplicate property");
      goto fail;
    }
  }

  is_extensible = LEPUS_IsExtensible(ctx, s->target);
  if (is_extensible < 0) goto fail;

  /* check if there are non configurable properties */
  if (s->is_revoked) {
    LEPUS_ThrowTypeErrorRevokedProxy(ctx);
    goto fail;
  }
  if (LEPUS_GetOwnPropertyNamesInternal(
          ctx, &tab2, &len2, LEPUS_VALUE_GET_OBJ(s->target),
          LEPUS_GPN_STRING_MASK | LEPUS_GPN_SYMBOL_MASK))
    goto fail;
  for (i = 0; i < len2; i++) {
    if (s->is_revoked) {
      LEPUS_ThrowTypeErrorRevokedProxy(ctx);
      goto fail;
    }
    res = LEPUS_GetOwnPropertyInternal(
        ctx, &desc, LEPUS_VALUE_GET_OBJ(s->target), tab2[i].atom);
    if (res < 0) goto fail;
    if (res) { /* safety, property should be found */
      lepus_free_desc(ctx, &desc);
      if (!(desc.flags & LEPUS_PROP_CONFIGURABLE) || !is_extensible) {
        idx = find_prop_key(tab, len, tab2[i].atom);
        if (idx < 0) {
          LEPUS_ThrowTypeError(
              ctx, "proxy: target property must be present in proxy ownKeys");
          goto fail;
        }
        /* mark the property as found */
        if (!is_extensible) tab[idx].is_enumerable = TRUE;
      }
    }
  }
  if (!is_extensible) {
    /* check that all property in 'tab' were checked */
    for (i = 0; i < len; i++) {
      if (!tab[i].is_enumerable) {
        LEPUS_ThrowTypeError(
            ctx,
            "proxy: property not present in target were returned "
            "by non extensible proxy");
        goto fail;
      }
    }
  }

  lepus_free_prop_enum(ctx, tab2, len2);
  LEPUS_FreeValue(ctx, prop_array);
  *ptab = tab;
  *plen = len;
  return 0;
fail:
  lepus_free_prop_enum(ctx, tab2, len2);
  lepus_free_prop_enum(ctx, tab, len);
  LEPUS_FreeValue(ctx, prop_array);
  return -1;
}

QJS_STATIC LEPUSValue lepus_proxy_call_constructor(LEPUSContext *ctx,
                                                   LEPUSValueConst func_obj,
                                                   LEPUSValueConst new_target,
                                                   int argc,
                                                   LEPUSValueConst *argv) {
  LEPUSProxyData *s;
  LEPUSValue method, arg_array, ret;
  LEPUSValueConst args[3];

  s = get_proxy_method(ctx, &method, func_obj, LEPUS_ATOM_construct);
  if (!s) return LEPUS_EXCEPTION;
  if (!LEPUS_IsConstructor(ctx, s->target))
    return LEPUS_ThrowTypeError(ctx, "not a constructor");
  if (LEPUS_IsUndefined(method))
    return LEPUS_CallConstructor2(ctx, s->target, new_target, argc, argv);
  arg_array = lepus_create_array(ctx, argc, argv);
  if (LEPUS_IsException(arg_array)) {
    ret = LEPUS_EXCEPTION;
    goto fail;
  }
  args[0] = s->target;
  args[1] = arg_array;
  args[2] = new_target;
  ret = LEPUS_Call(ctx, method, s->handler, 3, args);
  if (!LEPUS_IsException(ret) && LEPUS_VALUE_IS_NOT_OBJECT(ret)) {
    LEPUS_FreeValue(ctx, ret);
    ret = LEPUS_ThrowTypeErrorNotAnObject(ctx);
  }
fail:
  LEPUS_FreeValue(ctx, method);
  LEPUS_FreeValue(ctx, arg_array);
  return ret;
}

QJS_STATIC LEPUSValue lepus_proxy_call(LEPUSContext *ctx,
                                       LEPUSValueConst func_obj,
                                       LEPUSValueConst this_obj, int argc,
                                       LEPUSValueConst *argv, int flags) {
  LEPUSProxyData *s;
  LEPUSValue method, arg_array, ret;
  LEPUSValueConst args[3];

  if (flags & LEPUS_CALL_FLAG_CONSTRUCTOR)
    return lepus_proxy_call_constructor(ctx, func_obj, this_obj, argc, argv);

  s = get_proxy_method(ctx, &method, func_obj, LEPUS_ATOM_apply);
  if (!s) return LEPUS_EXCEPTION;
  if (!s->is_func) {
    LEPUS_FreeValue(ctx, method);
    return LEPUS_ThrowTypeError(ctx, "not a function");
  }
  if (LEPUS_IsUndefined(method))
    return LEPUS_Call(ctx, s->target, this_obj, argc, argv);
  arg_array = lepus_create_array(ctx, argc, argv);
  if (LEPUS_IsException(arg_array)) {
    ret = LEPUS_EXCEPTION;
    goto fail;
  }
  args[0] = s->target;
  args[1] = this_obj;
  args[2] = arg_array;
  ret = LEPUS_Call(ctx, method, s->handler, 3, args);
fail:
  LEPUS_FreeValue(ctx, method);
  LEPUS_FreeValue(ctx, arg_array);
  return ret;
}

QJS_STATIC int lepus_proxy_isArray(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSProxyData *s =
      static_cast<LEPUSProxyData *>(LEPUS_GetOpaque(obj, LEPUS_CLASS_PROXY));
  if (!s) return FALSE;
  if (s->is_revoked) {
    LEPUS_ThrowTypeErrorRevokedProxy(ctx);
    return -1;
  }
  return LEPUS_IsArray(ctx, s->target);
}

QJS_STATIC LEPUSValue lepus_proxy_constructor(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValueConst target, handler;
  LEPUSValue obj;
  LEPUSProxyData *s;

  target = argv[0];
  handler = argv[1];
  if (LEPUS_VALUE_IS_NOT_OBJECT(target) || LEPUS_VALUE_IS_NOT_OBJECT(handler))
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  s = static_cast<LEPUSProxyData *>(LEPUS_GetOpaque(target, LEPUS_CLASS_PROXY));
  if (s && s->is_revoked) goto revoked_proxy;
  s = static_cast<LEPUSProxyData *>(
      LEPUS_GetOpaque(handler, LEPUS_CLASS_PROXY));
  if (s && s->is_revoked) {
  revoked_proxy:
    return LEPUS_ThrowTypeErrorRevokedProxy(ctx);
  }

  obj = LEPUS_NewObjectProtoClass(ctx, LEPUS_NULL, LEPUS_CLASS_PROXY);
  if (LEPUS_IsException(obj)) return obj;
  s = static_cast<LEPUSProxyData *>(lepus_malloc(ctx, sizeof(LEPUSProxyData)));
  if (!s) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  s->target = LEPUS_DupValue(ctx, target);
  s->handler = LEPUS_DupValue(ctx, handler);
  s->proto = LEPUS_NULL;
  s->is_func = LEPUS_IsFunction(ctx, target);
  s->is_revoked = FALSE;
  LEPUS_SetOpaque(obj, s);
  LEPUS_SetConstructorBit(ctx, obj, LEPUS_IsConstructor(ctx, target));
  return obj;
}

QJS_STATIC LEPUSValue lepus_proxy_revoke(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv, int magic,
                                         LEPUSValue *func_data) {
  LEPUSProxyData *s = static_cast<LEPUSProxyData *>(
      LEPUS_GetOpaque(func_data[0], LEPUS_CLASS_PROXY));
  if (s) {
    /* We do not free the handler and target in case they are
       referenced as constants in the C call stack */
    s->is_revoked = TRUE;
    LEPUS_FreeValue(ctx, func_data[0]);
    func_data[0] = LEPUS_NULL;
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue
lepus_proxy_revoke_constructor(LEPUSContext *ctx, LEPUSValueConst proxy_obj) {
  return LEPUS_NewCFunctionData(ctx, lepus_proxy_revoke, 0, 0, 1, &proxy_obj);
}

QJS_STATIC LEPUSValue lepus_proxy_revocable(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue proxy_obj, revoke_obj = LEPUS_UNDEFINED, obj;

  proxy_obj = lepus_proxy_constructor(ctx, LEPUS_UNDEFINED, argc, argv);
  if (LEPUS_IsException(proxy_obj)) goto fail;
  revoke_obj = lepus_proxy_revoke_constructor(ctx, proxy_obj);
  if (LEPUS_IsException(revoke_obj)) goto fail;
  obj = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(obj)) goto fail;
  // XXX: exceptions?
  LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_proxy, proxy_obj,
                            LEPUS_PROP_C_W_E);
  LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_revoke, revoke_obj,
                            LEPUS_PROP_C_W_E);
  return obj;
fail:
  LEPUS_FreeValue(ctx, proxy_obj);
  LEPUS_FreeValue(ctx, revoke_obj);
  return LEPUS_EXCEPTION;
}

static const LEPUSCFunctionListEntry lepus_proxy_funcs[] = {
    LEPUS_CFUNC_DEF("revocable", 2, lepus_proxy_revocable),
};

static const LEPUSClassShortDef lepus_proxy_class_def[] = {
    {LEPUS_ATOM_Object, lepus_proxy_finalizer,
     lepus_proxy_mark}, /* LEPUS_CLASS_PROXY */
};

void LEPUS_AddIntrinsicProxy(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSValue obj1;

  if (!LEPUS_IsRegisteredClass(rt, LEPUS_CLASS_PROXY)) {
    init_class_range(rt, lepus_proxy_class_def, LEPUS_CLASS_PROXY,
                     countof(lepus_proxy_class_def));
    rt->class_array[LEPUS_CLASS_PROXY].exotic = &lepus_proxy_exotic_methods;
    rt->class_array[LEPUS_CLASS_PROXY].call = lepus_proxy_call;
  }

  obj1 = LEPUS_NewCFunction2(ctx, lepus_proxy_constructor, "Proxy", 2,
                             LEPUS_CFUNC_constructor, 0);
  LEPUS_SetConstructorBit(ctx, obj1, TRUE);
  LEPUS_SetPropertyFunctionList(ctx, obj1, lepus_proxy_funcs,
                                countof(lepus_proxy_funcs));
  LEPUS_DefinePropertyValueStr(ctx, ctx->global_obj, "Proxy", obj1,
                               LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
}

/* Symbol */

QJS_STATIC LEPUSValue lepus_symbol_constructor(LEPUSContext *ctx,
                                               LEPUSValueConst new_target,
                                               int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue str;
  LEPUSString *p;

  if (!LEPUS_IsUndefined(new_target))
    return LEPUS_ThrowTypeError(ctx, "not a constructor");
  if (argc == 0 || LEPUS_IsUndefined(argv[0])) {
    p = NULL;
  } else {
    str = LEPUS_ToString(ctx, argv[0]);
    if (LEPUS_IsException(str)) return LEPUS_EXCEPTION;
    p = LEPUS_VALUE_GET_STRING(str);
  }
  return LEPUS_NewSymbol(ctx, p, LEPUS_ATOM_TYPE_SYMBOL);
}

QJS_STATIC LEPUSValue lepus_thisSymbolValue(LEPUSContext *ctx,
                                            LEPUSValueConst this_val) {
  if (LEPUS_VALUE_IS_SYMBOL(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == LEPUS_CLASS_SYMBOL) {
      if (LEPUS_VALUE_IS_SYMBOL(p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a symbol");
}

QJS_STATIC LEPUSValue lepus_symbol_toString(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue val, ret;
  val = lepus_thisSymbolValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  /* XXX: use LEPUS_ToStringInternal() with a flags */
  ret = lepus_string_constructor(ctx, LEPUS_UNDEFINED, 1,
                                 (LEPUSValueConst *)&val);
  LEPUS_FreeValue(ctx, val);
  return ret;
}

QJS_STATIC LEPUSValue lepus_symbol_valueOf(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  return lepus_thisSymbolValue(ctx, this_val);
}

QJS_STATIC LEPUSValue lepus_symbol_get_description(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val) {
  LEPUSValue val, ret;
  LEPUSAtomStruct *p;

  val = lepus_thisSymbolValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  p = static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
  if (p->len == 0 && p->is_wide_char != 0) {
    ret = LEPUS_UNDEFINED;
  } else {
    ret = LEPUS_AtomToString(ctx, lepus_get_atom_index(ctx->rt, p));
  }
  LEPUS_FreeValue(ctx, val);
  return ret;
}

static const LEPUSCFunctionListEntry lepus_symbol_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, lepus_symbol_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, lepus_symbol_valueOf),
    // XXX: should have writable: false
    LEPUS_CFUNC_DEF("[Symbol.toPrimitive]", 1, lepus_symbol_valueOf),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Symbol",
                          LEPUS_PROP_CONFIGURABLE),
    LEPUS_CGETSET_DEF("description", lepus_symbol_get_description, NULL),
};

QJS_STATIC LEPUSValue lepus_symbol_for(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  LEPUSValue str;

  str = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(str)) return LEPUS_EXCEPTION;
  return LEPUS_NewSymbol(ctx, LEPUS_VALUE_GET_STRING(str),
                         LEPUS_ATOM_TYPE_GLOBAL_SYMBOL);
}

QJS_STATIC LEPUSValue lepus_symbol_keyFor(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSAtomStruct *p;

  if (!LEPUS_IsSymbol(argv[0]))
    return LEPUS_ThrowTypeError(ctx, "not a symbol");
  p = static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(argv[0]));
  if (p->atom_type != LEPUS_ATOM_TYPE_GLOBAL_SYMBOL) return LEPUS_UNDEFINED;
  return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
}

static const LEPUSCFunctionListEntry lepus_symbol_funcs[] = {
    LEPUS_CFUNC_DEF("for", 1, lepus_symbol_for),
    LEPUS_CFUNC_DEF("keyFor", 1, lepus_symbol_keyFor),
};

QJS_STATIC void free_weakref_prop(LEPUSRuntime *rt, LEPUSObject *p,
                                  LEPUSShape *sh) {
  LEPUSShapeProperty *pr = get_shape_prop(sh);
  lepus_free_rt(rt, p->prop);
  lepus_free_shape(rt, sh);  // p->shape
  p->shape = NULL;
  p->prop = NULL;
}

QJS_STATIC void lepus_weakref_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSShape *sh = p->shape;
  if (sh == NULL) return;
  assert(sh->prop_count == 1);
  LEPUSValue referent = p->prop[0].u.value;
  if (LEPUS_IsUndefined(referent)) {
    free_weakref_prop(rt, p, sh);
    return;
  }

  LEPUSObject *obj = LEPUS_VALUE_GET_OBJ(referent);
  if (obj->first_weak_ref == NULL) return;
  ReferenceRecord *records = obj->first_weak_ref->record;
  for (int i = 0; i < records->length; i++) {
    LEPUSValue item = records->references[i];
    if (LEPUS_VALUE_GET_TAG(item) == LEPUS_VALUE_GET_TAG(val) &&
        LEPUS_VALUE_GET_PTR(item) == LEPUS_VALUE_GET_PTR(val)) {
      records->references[i] = LEPUS_NULL;
      free_weakref_prop(rt, p, sh);
      return;
    }
  }
}

QJS_STATIC void lepus_finalizationRegistry_finalizer(LEPUSRuntime *rt,
                                                     LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  lepus_free_rt(rt, p->u.opaque);
}

QJS_STATIC void lepus_finalizationRegistry_mark(LEPUSRuntime *rt,
                                                LEPUSValueConst val,
                                                LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSValue ccb = p->prop[0].u.value;
  if (!LEPUS_IsNull(ccb)) return;
  LEPUS_MarkValue(rt, ccb, mark_func);
}

QJS_STATIC LEPUSValue lepus_map_constructor(LEPUSContext *ctx,
                                            LEPUSValueConst new_target,
                                            int argc, LEPUSValueConst *argv,
                                            int magic) {
  LEPUSMapState *s;
  LEPUSValue obj, adder = LEPUS_UNDEFINED, iter = LEPUS_UNDEFINED,
                  next_method = LEPUS_UNDEFINED;
  LEPUSValueConst arr;
  BOOL is_set, is_weak;

  is_set = magic & MAGIC_SET;
  is_weak = ((magic & MAGIC_WEAK) != 0);
  obj = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_MAP + magic);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  s = static_cast<LEPUSMapState *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) goto fail;
  init_list_head(&s->records);
  s->is_weak = is_weak;
  LEPUS_SetOpaque(obj, s);
  s->hash_size = 1;
  s->hash_table = static_cast<struct list_head *>(
      lepus_malloc(ctx, sizeof(s->hash_table[0]) * s->hash_size));
  if (!s->hash_table) goto fail;
  init_list_head(&s->hash_table[0]);
  s->record_count_threshold = 4;

  arr = LEPUS_UNDEFINED;
  if (argc > 0) arr = argv[0];
  if (!LEPUS_IsUndefined(arr) && !LEPUS_IsNull(arr)) {
    LEPUSValue item, ret;
    BOOL done;

    adder =
        LEPUS_GetProperty(ctx, obj, is_set ? LEPUS_ATOM_add : LEPUS_ATOM_set);
    if (LEPUS_IsException(adder)) goto fail;
    if (!LEPUS_IsFunction(ctx, adder)) {
      LEPUS_ThrowTypeError(ctx, "set/add is not a function");
      goto fail;
    }

    iter = LEPUS_GetIterator(ctx, arr, FALSE);
    if (LEPUS_IsException(iter)) goto fail;
    next_method = LEPUS_GetProperty(ctx, iter, LEPUS_ATOM_next);
    if (LEPUS_IsException(next_method)) goto fail;

    for (;;) {
      item = LEPUS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
      if (LEPUS_IsException(item)) goto fail;
      if (done) {
        LEPUS_FreeValue(ctx, item);
        break;
      }
      if (is_set) {
        ret = LEPUS_Call(ctx, adder, obj, 1, (LEPUSValueConst *)&item);
        if (LEPUS_IsException(ret)) {
          LEPUS_FreeValue(ctx, item);
          goto fail;
        }
      } else {
        LEPUSValue key, value;
        LEPUSValueConst args[2];
        key = LEPUS_UNDEFINED;
        value = LEPUS_UNDEFINED;
        if (!LEPUS_IsObject(item)) {
          LEPUS_ThrowTypeErrorNotAnObject(ctx);
          goto fail1;
        }
        key = LEPUS_GetPropertyUint32(ctx, item, 0);
        if (LEPUS_IsException(key)) goto fail1;
        value = LEPUS_GetPropertyUint32(ctx, item, 1);
        if (LEPUS_IsException(value)) goto fail1;
        args[0] = key;
        args[1] = value;
        ret = LEPUS_Call(ctx, adder, obj, 2, args);
        if (LEPUS_IsException(ret)) {
        fail1:
          LEPUS_FreeValue(ctx, item);
          LEPUS_FreeValue(ctx, key);
          LEPUS_FreeValue(ctx, value);
          goto fail;
        }
        LEPUS_FreeValue(ctx, key);
        LEPUS_FreeValue(ctx, value);
      }
      LEPUS_FreeValue(ctx, ret);
      LEPUS_FreeValue(ctx, item);
    }
    LEPUS_FreeValue(ctx, next_method);
    LEPUS_FreeValue(ctx, iter);
    LEPUS_FreeValue(ctx, adder);
  }
  return obj;
fail:
  if (LEPUS_IsObject(iter)) {
    /* close the iterator object, preserving pending exception */
    LEPUS_IteratorClose(ctx, iter, TRUE);
  }
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, adder);
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

/* XXX: could normalize strings to speed up comparison */
QJS_STATIC LEPUSValueConst map_normalize_key(LEPUSContext *ctx,
                                             LEPUSValueConst key) {
  /* convert -0.0 to +0.0 */
  if (LEPUS_VALUE_IS_FLOAT64(key) && LEPUS_VALUE_GET_FLOAT64(key) == 0.0) {
    key = LEPUS_NewInt32(ctx, 0);
  }
  return key;
}

#ifdef ENABLE_LEPUSNG
void LEPUS_FreeRefCountedWeakRef(LEPUSRuntime *rt,
                                 struct LEPUSMapRecord *first_mr) {
  LEPUSMapRecord *mr, *mr_next;
  LEPUSMapState *s;
  for (mr = first_mr; mr != nullptr; mr = mr->next_weak_ref) {
    s = mr->map;
    assert(s->is_weak);
    assert(!mr->empty);
    list_del(&mr->hash_link);
    list_del(&mr->link);
  }

  for (mr = first_mr; mr != nullptr; mr = mr_next) {
    mr_next = mr->next_weak_ref;
    LEPUS_FreeValueRT(rt, mr->value);
    lepus_free_rt(rt, mr);
  }
  return;
}

QJS_STATIC BOOL IsRefCountedValue(LEPUSContext *ctx, LEPUSValue val) {
  if (LEPUS_IsLepusRef(val)) {
    return LEPUS_GetLepusRefTag(val) == ctx->rt->lepus_type_.refcounted_typeid_;
  }
  return FALSE;
}
#endif

/* XXX: better hash ? */
QJS_STATIC uint32_t map_hash_key(LEPUSContext *ctx, LEPUSValueConst key) {
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(key);
  uint32_t h;
  double d;
  LEPUSFloat64Union u;

  switch (tag) {
    case LEPUS_TAG_BOOL:
      h = LEPUS_VALUE_GET_BOOL(key);
      break;
    case LEPUS_TAG_STRING:
      h = hash_string(LEPUS_VALUE_GET_STRING(key), 0);
      break;
    case LEPUS_TAG_OBJECT:
    case LEPUS_TAG_LEPUS_CPOINTER:
    case LEPUS_TAG_SYMBOL:
      h = (uintptr_t)LEPUS_VALUE_GET_PTR(key) * 3163;
      break;
    case LEPUS_TAG_INT:
      d = LEPUS_VALUE_GET_INT(key) * 3163;
      goto hash_float64;
    case LEPUS_TAG_FLOAT64:
      d = LEPUS_VALUE_GET_FLOAT64(key);
      /* normalize the NaN */
      if (isnan(d)) d = LEPUS_FLOAT64_NAN;
    hash_float64:
      u.d = d;
      h = (u.u32[0] ^ u.u32[1]) * 3163;
      break;
    default:
      h = 0; /* XXX: bignum support */
      break;
  }
  h ^= tag;
  return h;
}

QJS_STATIC LEPUSMapRecord *map_find_record(LEPUSContext *ctx, LEPUSMapState *s,
                                           LEPUSValueConst key) {
  struct list_head *el;
  LEPUSMapRecord *mr;
  uint32_t h;

#ifdef ENABLE_LEPUSNG
  if (s->is_weak && IsRefCountedValue(ctx, key)) {
    key = LEPUS_MKPTR(LEPUS_TAG_LEPUS_CPOINTER, LEPUS_GetLepusRefPoint(key));
  }
#endif

  h = map_hash_key(ctx, key) & (s->hash_size - 1);
  list_for_each(el, &s->hash_table[h]) {
    mr = list_entry(el, LEPUSMapRecord, hash_link);
    if (lepus_same_value_zero(ctx, mr->key, key)) return mr;
  }
  return NULL;
}

QJS_STATIC void map_hash_resize(LEPUSContext *ctx, LEPUSMapState *s) {
  uint32_t new_hash_size, i, h;
  size_t slack;
  struct list_head *new_hash_table, *el;
  LEPUSMapRecord *mr;

  /* XXX: no reporting of memory allocation failure */
  if (s->hash_size == 1)
    new_hash_size = 4;
  else
    new_hash_size = s->hash_size * 2;
  new_hash_table = static_cast<struct list_head *>(lepus_realloc2(
      ctx, s->hash_table, sizeof(new_hash_table[0]) * new_hash_size, &slack));
  if (!new_hash_table) return;
  new_hash_size += slack / sizeof(*new_hash_table);

  for (i = 0; i < new_hash_size; i++) init_list_head(&new_hash_table[i]);

  list_for_each(el, &s->records) {
    mr = list_entry(el, LEPUSMapRecord, link);
    if (!mr->empty) {
      h = map_hash_key(ctx, mr->key) & (new_hash_size - 1);
      list_add_tail(&mr->hash_link, &new_hash_table[h]);
    }
  }
  s->hash_table = new_hash_table;
  s->hash_size = new_hash_size;
  s->record_count_threshold = new_hash_size * 2;
}

QJS_STATIC LEPUSMapRecord *map_add_record(LEPUSContext *ctx, LEPUSMapState *s,
                                          LEPUSValueConst key) {
  uint32_t h;
  LEPUSMapRecord *mr;

  mr = static_cast<LEPUSMapRecord *>(lepus_malloc(ctx, sizeof(*mr)));
  if (!mr) return NULL;
  mr->ref_count = 1;
  mr->map = s;
  mr->empty = FALSE;
  mr->record = NULL;
  mr->is_ref = FALSE;
  mr->registry = NULL;
  if (s->is_weak) {
#ifdef ENABLE_LEPUSNG
    if (IsRefCountedValue(ctx, key)) {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(LEPUSRef2Value(ctx, key));
      if (p == nullptr) return nullptr;
      key = LEPUS_MKPTR(LEPUS_TAG_LEPUS_CPOINTER, p->u.opaque);
      auto ref_counted_weak_ref_value =
          ctx->rt->class_array[p->class_id].exotic->get_property(
              ctx, key, LEPUS_ATOM_NULL, LEPUS_UNDEFINED);
      LEPUSMapRecord **first_weak_ref = reinterpret_cast<LEPUSMapRecord **>(
          LEPUS_VALUE_GET_PTR(ref_counted_weak_ref_value));
      mr->next_weak_ref = *first_weak_ref;
      *first_weak_ref = mr;
    } else {
#endif
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(key);
      if (p->first_weak_ref && p->first_weak_ref->registry) {
        mr->registry = p->first_weak_ref->registry;
        p->first_weak_ref->registry = NULL;
      }
      /* Add the weak reference */
      mr->next_weak_ref = p->first_weak_ref;
      p->first_weak_ref = mr;
#ifdef ENABLE_LEPUSNG
    }
#endif
  } else {
    LEPUS_DupValue(ctx, key);
  }
  mr->key = (LEPUSValue)key;
  h = map_hash_key(ctx, key) & (s->hash_size - 1);
  list_add_tail(&mr->hash_link, &s->hash_table[h]);
  list_add_tail(&mr->link, &s->records);
  s->record_count++;
  if (s->record_count >= s->record_count_threshold) {
    map_hash_resize(ctx, s);
  }
  return mr;
}

/* Remove the weak reference from the object weak
   reference list. we don't use a doubly linked list to
   save space, assuming a given object has few weak
       references to it */
QJS_STATIC void delete_weak_ref(LEPUSRuntime *rt, LEPUSMapRecord *mr) {
  LEPUSMapRecord **pmr, *mr1;
  LEPUSObject *p;

#ifdef ENABLE_LEPUSNG
  if (LEPUS_VALUE_GET_NORM_TAG(mr->key) == LEPUS_TAG_LEPUS_CPOINTER) {
    if (rt->lepus_type_.refcounted_cid_ <= 0) return;
    pmr = reinterpret_cast<LEPUSMapRecord **>(LEPUS_VALUE_GET_PTR(
        rt->class_array[rt->lepus_type_.refcounted_cid_].exotic->get_property(
            nullptr, mr->key, LEPUS_ATOM_NULL, LEPUS_UNDEFINED)));
  } else {
#endif

    p = LEPUS_VALUE_GET_OBJ(mr->key);
    pmr = &p->first_weak_ref;

#ifdef ENABLE_LEPUSNG
  }
#endif

  for (;;) {
    mr1 = *pmr;
    assert(mr1 != NULL);
    if (mr1 == mr) break;
    pmr = &mr1->next_weak_ref;
  }
  *pmr = mr1->next_weak_ref;
}

QJS_STATIC void map_delete_record(LEPUSRuntime *rt, LEPUSMapState *s,
                                  LEPUSMapRecord *mr) {
  if (mr->empty) return;
  list_del(&mr->hash_link);
  if (s->is_weak) {
    delete_weak_ref(rt, mr);
  } else {
    LEPUS_FreeValueRT(rt, mr->key);
  }
  LEPUS_FreeValueRT(rt, mr->value);
  if (--mr->ref_count == 0) {
    list_del(&mr->link);
    lepus_free_rt(rt, mr);
  } else {
    /* keep a zombie record for iterators */
    mr->empty = TRUE;
    mr->key = LEPUS_UNDEFINED;
    mr->value = LEPUS_UNDEFINED;
  }
  s->record_count--;
}

QJS_STATIC void map_decref_record(LEPUSRuntime *rt, LEPUSMapRecord *mr) {
  if (--mr->ref_count == 0) {
    /* the record can be safely removed */
    assert(mr->empty);
    list_del(&mr->link);
    lepus_free_rt(rt, mr);
  }
}

QJS_STATIC void reset_weak_ref(LEPUSRuntime *rt, LEPUSObject *p) {
  LEPUSMapRecord *mr, *mr_next;
  LEPUSMapState *s;

  /* first pass to remove the records from the WeakMap/WeakSet
     lists */
  for (mr = p->first_weak_ref; mr != NULL; mr = mr->next_weak_ref) {
    s = mr->map;
    assert(s->is_weak);
    assert(!mr->empty); /* no iterator on WeakMap/WeakSet */
    list_del(&mr->hash_link);
    list_del(&mr->link);
  }

  /* second pass to free the values to avoid modifying the weak
     reference list while traversing it. */
  for (mr = p->first_weak_ref; mr != NULL; mr = mr_next) {
    mr_next = mr->next_weak_ref;
    LEPUS_FreeValueRT(rt, mr->value);
    lepus_free_rt(rt, mr);
  }
}

QJS_STATIC void reset_weakref_record(LEPUSRuntime *rt, LEPUSObject *p) {
  LEPUSMapRecord *mr = p->first_weak_ref;
  ReferenceRecord *record = mr->record;
  for (int i = 0; i < record->length; i++) {
    LEPUSValue reference = record->references[i];
    if (LEPUS_IsNull(reference)) continue;
    LEPUSObject *reference_obj = LEPUS_VALUE_GET_OBJ(reference);
    LEPUSShape *sh = reference_obj->shape;
    assert(sh->prop_count == 1);
    reference_obj->prop[0].u.value = LEPUS_UNDEFINED;
  }
  lepus_free_rt(rt, record->references);
  lepus_free_rt(rt, record);
  lepus_free_rt(rt, mr);
}

QJS_STATIC void reset_fg_registry(LEPUSRuntime *rt, LEPUSObject *p) {
  RegistryRecord *&reg = p->first_weak_ref->registry;
  if (reg->entry != NULL) {
    list_del(&reg->entry->link);
    lepus_free_rt(rt, reg->entry);
    reg->entry = NULL;
  }
  if (reg->registra != NULL) {
    for (int i = 0; i < reg->registra->length; i++) {
      LEPUSValue registry = reg->registra->references[i];
      if (!LEPUS_IsObject(registry) || LEPUS_IsNull(registry)) continue;
      LEPUSValue arg = reg->heldvalue->references[i];
      FinalizerOpaque *fo = (FinalizerOpaque *)LEPUS_GetOpaque(
          registry, LEPUS_CLASS_FinalizationRegistry);
      LEPUSContext *ctx = fo->ctx;
      LEPUSAtom ccbs = LEPUS_NewAtom(ctx, "cleanCallback");
      LEPUSValue ccb = LEPUS_GetProperty(ctx, registry, ccbs);
      LEPUS_Call(ctx, ccb, LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&arg);
      LEPUS_FreeAtom(ctx, ccbs);
      LEPUS_FreeValue(ctx, registry);
      LEPUS_FreeValue(ctx, arg);
      LEPUS_FreeValue(ctx, ccb);
    }
    lepus_free_rt(rt, reg->registra->references);
    lepus_free_rt(rt, reg->heldvalue->references);
    lepus_free_rt(rt, reg->registra);
    lepus_free_rt(rt, reg->heldvalue);
  }
  if (reg->target != NULL) {
    lepus_free_rt(rt, reg->target->references);
    lepus_free_rt(rt, reg->token->references);
    lepus_free_rt(rt, reg->target);
    lepus_free_rt(rt, reg->token);
    lepus_free_rt(rt, reg->idx);
  }
  lepus_free_rt(rt, reg);
}

QJS_STATIC LEPUSValue lepus_map_set(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int magic) {
  LEPUSMapState *s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP + magic));
  LEPUSMapRecord *mr;
  LEPUSValueConst key, value;

  if (!s) return LEPUS_EXCEPTION;
  key = map_normalize_key(ctx, argv[0]);

  if (s->is_weak && !LEPUS_IsObject(key)
#ifdef ENABLE_LEPUSNG
      && !IsRefCountedValue(ctx, key)
#endif
  )
    return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  if (magic & MAGIC_SET)
    value = LEPUS_UNDEFINED;
  else
    value = argv[1];
  mr = map_find_record(ctx, s, key);
  if (mr) {
    LEPUS_FreeValue(ctx, mr->value);
  } else {
    mr = map_add_record(ctx, s, key);
    if (!mr) return LEPUS_EXCEPTION;
  }
  mr->value = LEPUS_DupValue(ctx, value);
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue lepus_map_get(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int magic) {
  LEPUSMapState *s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP + magic));
  LEPUSMapRecord *mr;
  LEPUSValueConst key;

  if (!s) return LEPUS_EXCEPTION;
  key = map_normalize_key(ctx, argv[0]);
  mr = map_find_record(ctx, s, key);
  if (!mr)
    return LEPUS_UNDEFINED;
  else
    return LEPUS_DupValue(ctx, mr->value);
}

QJS_STATIC LEPUSValue lepus_map_has(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int magic) {
  LEPUSMapState *s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP + magic));
  LEPUSMapRecord *mr;
  LEPUSValueConst key;

  if (!s) return LEPUS_EXCEPTION;
  key = map_normalize_key(ctx, argv[0]);
  mr = map_find_record(ctx, s, key);
  return LEPUS_NewBool(ctx, (mr != NULL));
}

QJS_STATIC LEPUSValue lepus_map_delete(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv, int magic) {
  LEPUSMapState *s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP + magic));
  LEPUSMapRecord *mr;
  LEPUSValueConst key;

  if (!s) return LEPUS_EXCEPTION;
  key = map_normalize_key(ctx, argv[0]);
  mr = map_find_record(ctx, s, key);
  if (!mr) return LEPUS_FALSE;
  map_delete_record(ctx->rt, s, mr);
  return LEPUS_TRUE;
}

QJS_STATIC LEPUSValue lepus_map_clear(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv, int magic) {
  LEPUSMapState *s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP + magic));
  struct list_head *el, *el1;
  LEPUSMapRecord *mr;

  if (!s) return LEPUS_EXCEPTION;
  list_for_each_safe(el, el1, &s->records) {
    mr = list_entry(el, LEPUSMapRecord, link);
    map_delete_record(ctx->rt, s, mr);
  }
  return LEPUS_UNDEFINED;
}

QJS_HIDE LEPUSValue lepus_map_get_size(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int magic) {
  LEPUSMapState *s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP + magic));
  if (!s) return LEPUS_EXCEPTION;
  return LEPUS_NewUint32(ctx, s->record_count);
}

QJS_STATIC LEPUSValue lepus_map_forEach(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv, int magic) {
  LEPUSMapState *s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP + magic));
  LEPUSValueConst func, this_arg;
  LEPUSValue ret;
  LEPUSValue args[3];
  struct list_head *el;
  LEPUSMapRecord *mr;

  if (!s) return LEPUS_EXCEPTION;
  func = argv[0];
  if (argc > 1)
    this_arg = argv[1];
  else
    this_arg = LEPUS_UNDEFINED;
  if (check_function(ctx, func)) return LEPUS_EXCEPTION;
  /* Note: the list can be modified while traversing it, but the
     current element is locked */
  el = s->records.next;
  while (el != &s->records) {
    mr = list_entry(el, LEPUSMapRecord, link);
    if (!mr->empty) {
      mr->ref_count++;
      /* must duplicate in case the record is deleted */

      args[1] = LEPUS_DupValue(ctx, mr->key);
      if (magic)
        args[0] = args[1];
      else
        args[0] = LEPUS_DupValue(ctx, mr->value);
      args[2] = (LEPUSValue)this_val;
      ret = LEPUS_Call(ctx, func, this_arg, 3, (LEPUSValueConst *)args);
      LEPUS_FreeValue(ctx, args[0]);
      if (!magic) LEPUS_FreeValue(ctx, args[1]);
      el = el->next;
      map_decref_record(ctx->rt, mr);
      if (LEPUS_IsException(ret)) return ret;
      LEPUS_FreeValue(ctx, ret);
    } else {
      el = el->next;
    }
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC void lepus_map_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p;
  LEPUSMapState *s;
  struct list_head *el, *el1;
  LEPUSMapRecord *mr;

  p = LEPUS_VALUE_GET_OBJ(val);
  s = p->u.map_state;
  if (s) {
    /* if the object is deleted we are sure that no iterator is
       using it */
    list_for_each_safe(el, el1, &s->records) {
      mr = list_entry(el, LEPUSMapRecord, link);
      if (!mr->empty) {
        if (s->is_weak)
          delete_weak_ref(rt, mr);
        else
          LEPUS_FreeValueRT(rt, mr->key);
        LEPUS_FreeValueRT(rt, mr->value);
      }
      lepus_free_rt(rt, mr);
    }
    lepus_free_rt(rt, s->hash_table);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void lepus_map_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                               LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSMapState *s;
  struct list_head *el;
  LEPUSMapRecord *mr;

  s = p->u.map_state;
  if (s) {
    list_for_each(el, &s->records) {
      mr = list_entry(el, LEPUSMapRecord, link);
      if (!s->is_weak) LEPUS_MarkValue(rt, mr->key, mark_func);
      LEPUS_MarkValue(rt, mr->value, mark_func);
    }
  }
}

/* Map Iterator */

typedef struct LEPUSMapIteratorData {
  LEPUSValue obj;
  LEPUSIteratorKindEnum kind;
  LEPUSMapRecord *cur_record;
} LEPUSMapIteratorData;

QJS_STATIC void lepus_map_iterator_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p;
  LEPUSMapIteratorData *it;

  p = LEPUS_VALUE_GET_OBJ(val);
  it = p->u.map_iterator_data;
  if (it) {
    /* During the GC sweep phase the Map finalizer may be
       called before the Map iterator finalizer */
    if (LEPUS_IsLiveObject(rt, it->obj) && it->cur_record) {
      map_decref_record(rt, it->cur_record);
    }
    LEPUS_FreeValueRT(rt, it->obj);
    lepus_free_rt(rt, it);
  }
}

QJS_STATIC void lepus_map_iterator_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                        LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSMapIteratorData *it;
  it = p->u.map_iterator_data;
  if (it) {
    /* the record is already marked by the object */
    LEPUS_MarkValue(rt, it->obj, mark_func);
  }
}

QJS_STATIC LEPUSValue lepus_create_map_iterator(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc, LEPUSValueConst *argv,
                                                int magic) {
  LEPUSIteratorKindEnum kind;
  LEPUSMapState *s;
  LEPUSMapIteratorData *it;
  LEPUSValue enum_obj;

  kind = static_cast<LEPUSIteratorKindEnum>(magic >> 2);
  magic &= 3;
  s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP + magic));
  if (!s) return LEPUS_EXCEPTION;
  enum_obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_MAP_ITERATOR + magic);
  if (LEPUS_IsException(enum_obj)) goto fail;
  it = static_cast<LEPUSMapIteratorData *>(lepus_malloc(ctx, sizeof(*it)));
  if (!it) {
    LEPUS_FreeValue(ctx, enum_obj);
    goto fail;
  }
  it->obj = LEPUS_DupValue(ctx, this_val);
  it->kind = kind;
  it->cur_record = NULL;
  LEPUS_SetOpaque(enum_obj, it);
  return enum_obj;
fail:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_map_iterator_next(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv,
                                              BOOL *pdone, int magic) {
  LEPUSMapIteratorData *it;
  LEPUSMapState *s;
  LEPUSMapRecord *mr;
  struct list_head *el;

  it = static_cast<LEPUSMapIteratorData *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP_ITERATOR + magic));
  if (!it) {
    *pdone = FALSE;
    return LEPUS_EXCEPTION;
  }
  if (LEPUS_IsUndefined(it->obj)) goto done;
  s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque(it->obj, LEPUS_CLASS_MAP + magic));
  assert(s != NULL);
  if (!it->cur_record) {
    el = s->records.next;
  } else {
    mr = it->cur_record;
    el = mr->link.next;
    map_decref_record(ctx->rt, mr); /* the record can be freed here */
  }
  for (;;) {
    if (el == &s->records) {
      /* no more record  */
      it->cur_record = NULL;
      LEPUS_FreeValue(ctx, it->obj);
      it->obj = LEPUS_UNDEFINED;
    done:
      /* end of enumeration */
      *pdone = TRUE;
      return LEPUS_UNDEFINED;
    }
    mr = list_entry(el, LEPUSMapRecord, link);
    if (!mr->empty) break;
    /* get the next record */
    el = mr->link.next;
  }

  /* lock the record so that it won't be freed */
  mr->ref_count++;
  it->cur_record = mr;
  *pdone = FALSE;

  if (it->kind == LEPUS_ITERATOR_KIND_KEY) {
    return LEPUS_DupValue(ctx, mr->key);
  } else {
    LEPUSValueConst args[2];
    args[0] = mr->key;
    if (magic)
      args[1] = mr->key;
    else
      args[1] = mr->value;
    if (it->kind == LEPUS_ITERATOR_KIND_VALUE) {
      return LEPUS_DupValue(ctx, args[1]);
    } else {
      return lepus_create_array(ctx, 2, args);
    }
  }
}

static const LEPUSCFunctionListEntry lepus_map_funcs[] = {
    LEPUS_CGETSET_DEF("[Symbol.species]", lepus_get_this, NULL),
};

static const LEPUSCFunctionListEntry lepus_map_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("set", 2, lepus_map_set, 0),
    LEPUS_CFUNC_MAGIC_DEF("get", 1, lepus_map_get, 0),
    LEPUS_CFUNC_MAGIC_DEF("has", 1, lepus_map_has, 0),
    LEPUS_CFUNC_MAGIC_DEF("delete", 1, lepus_map_delete, 0),
    LEPUS_CFUNC_MAGIC_DEF("clear", 0, lepus_map_clear, 0),
    LEPUS_CGETSET_MAGIC_DEF("size", lepus_map_get_size, NULL, 0),
    LEPUS_CFUNC_MAGIC_DEF("forEach", 1, lepus_map_forEach, 0),
    LEPUS_CFUNC_MAGIC_DEF("values", 0, lepus_create_map_iterator,
                          (LEPUS_ITERATOR_KIND_VALUE << 2) | 0),
    LEPUS_CFUNC_MAGIC_DEF("keys", 0, lepus_create_map_iterator,
                          (LEPUS_ITERATOR_KIND_KEY << 2) | 0),
    LEPUS_CFUNC_MAGIC_DEF("entries", 0, lepus_create_map_iterator,
                          (LEPUS_ITERATOR_KIND_KEY_AND_VALUE << 2) | 0),
    LEPUS_ALIAS_DEF("[Symbol.iterator]", "entries"),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Map",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry lepus_map_iterator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 0, lepus_map_iterator_next, 0),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Map Iterator",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry lepus_set_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("add", 1, lepus_map_set, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("has", 1, lepus_map_has, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("delete", 1, lepus_map_delete, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("clear", 0, lepus_map_clear, MAGIC_SET),
    LEPUS_CGETSET_MAGIC_DEF("size", lepus_map_get_size, NULL, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("forEach", 1, lepus_map_forEach, MAGIC_SET),
    LEPUS_CFUNC_MAGIC_DEF("values", 0, lepus_create_map_iterator,
                          (LEPUS_ITERATOR_KIND_KEY << 2) | MAGIC_SET),
    LEPUS_ALIAS_DEF("keys", "values"),
    LEPUS_ALIAS_DEF("[Symbol.iterator]", "values"),
    LEPUS_CFUNC_MAGIC_DEF("entries", 0, lepus_create_map_iterator,
                          (LEPUS_ITERATOR_KIND_KEY_AND_VALUE << 2) | MAGIC_SET),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Set",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry lepus_set_iterator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 0, lepus_map_iterator_next, MAGIC_SET),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Set Iterator",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry lepus_weak_map_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("set", 2, lepus_map_set, MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("get", 1, lepus_map_get, MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("has", 1, lepus_map_has, MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("delete", 1, lepus_map_delete, MAGIC_WEAK),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "WeakMap",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry lepus_weak_set_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("add", 1, lepus_map_set, MAGIC_SET | MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("has", 1, lepus_map_has, MAGIC_SET | MAGIC_WEAK),
    LEPUS_CFUNC_MAGIC_DEF("delete", 1, lepus_map_delete,
                          MAGIC_SET | MAGIC_WEAK),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "WeakSet",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry *const lepus_map_proto_funcs_ptr[6] = {
    lepus_map_proto_funcs,          lepus_set_proto_funcs,
    lepus_weak_map_proto_funcs,     lepus_weak_set_proto_funcs,
    lepus_map_iterator_proto_funcs, lepus_set_iterator_proto_funcs,
};

static const uint8_t lepus_map_proto_funcs_count[6] = {
    countof(lepus_map_proto_funcs),
    countof(lepus_set_proto_funcs),
    countof(lepus_weak_map_proto_funcs),
    countof(lepus_weak_set_proto_funcs),
    countof(lepus_map_iterator_proto_funcs),
    countof(lepus_set_iterator_proto_funcs),
};

void LEPUS_AddIntrinsicMapSet(LEPUSContext *ctx) {
  int i;
  LEPUSValue obj1;
  char buf[ATOM_GET_STR_BUF_SIZE];

  for (i = 0; i < 4; i++) {
    const char *name =
        LEPUS_AtomGetStr(ctx, buf, sizeof(buf), LEPUS_ATOM_Map + i);
    ctx->class_proto[LEPUS_CLASS_MAP + i] = LEPUS_NewObject(ctx);
    LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_MAP + i],
                                  lepus_map_proto_funcs_ptr[i],
                                  lepus_map_proto_funcs_count[i]);
    obj1 = LEPUS_NewCFunctionMagic(ctx, lepus_map_constructor, name, 0,
                                   LEPUS_CFUNC_constructor_magic, i);
    if (i < 2) {
      LEPUS_SetPropertyFunctionList(ctx, obj1, lepus_map_funcs,
                                    countof(lepus_map_funcs));
    }
    LEPUS_NewGlobalCConstructor2(ctx, obj1, name,
                                 ctx->class_proto[LEPUS_CLASS_MAP + i]);
  }

  for (i = 0; i < 2; i++) {
    ctx->class_proto[LEPUS_CLASS_MAP_ITERATOR + i] =
        LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
    LEPUS_SetPropertyFunctionList(
        ctx, ctx->class_proto[LEPUS_CLASS_MAP_ITERATOR + i],
        lepus_map_proto_funcs_ptr[i + 4], lepus_map_proto_funcs_count[i + 4]);
  }
}

/* Generator */
static const LEPUSCFunctionListEntry lepus_generator_function_proto_funcs[] = {
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "GeneratorFunction",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry lepus_generator_proto_funcs[] = {
    LEPUS_ITERATOR_NEXT_DEF("next", 1, lepus_generator_next, GEN_MAGIC_NEXT),
    LEPUS_ITERATOR_NEXT_DEF("return", 1, lepus_generator_next,
                            GEN_MAGIC_RETURN),
    LEPUS_ITERATOR_NEXT_DEF("throw", 1, lepus_generator_next, GEN_MAGIC_THROW),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Generator",
                          LEPUS_PROP_CONFIGURABLE),
};

/* WeakRef */
QJS_STATIC LEPUSValue lepus_weakref_deref(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  if (argc != 0) {
    return LEPUS_ThrowTypeError(ctx, "WeakRefDeref: argc should be 0");
  }
  // read from this_val
  LEPUSValue val = LEPUS_GetPropertyStr(ctx, this_val, "referent");
  return val;
}

static const LEPUSCFunctionListEntry lepus_weakref_proto_funcs[] = {
    LEPUS_CFUNC_DEF("deref", 0, lepus_weakref_deref),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "WeakRef",
                          LEPUS_PROP_CONFIGURABLE),
};

QJS_STATIC void AddReferenceRecord(LEPUSContext *ctx, LEPUSObject *obj,
                                   LEPUSValue val) {
  if (obj->first_weak_ref == NULL) {
    // init reference record
    obj->first_weak_ref = static_cast<LEPUSMapRecord *>(
        lepus_mallocz(ctx, sizeof(LEPUSMapRecord)));
    if (obj->first_weak_ref == NULL) {
      LEPUS_ThrowInternalError(ctx, "malloc LEPUSMapRecord failed");
      return;
    }
    obj->first_weak_ref->record = static_cast<ReferenceRecord *>(
        lepus_mallocz(ctx, sizeof(ReferenceRecord)));
    if (obj->first_weak_ref->record == NULL) {
      LEPUS_ThrowInternalError(ctx, "malloc ReferenceRecord failed");
      return;
    }
    obj->first_weak_ref->record->references =
        (LEPUSValue *)lepus_mallocz(ctx, 4 * sizeof(LEPUSValue));
    if (obj->first_weak_ref->record->references == NULL) {
      LEPUS_ThrowInternalError(ctx, "malloc references failed");
      return;
    }
    obj->first_weak_ref->record->max_size = 4;
    obj->first_weak_ref->is_ref = TRUE;
  }
  LEPUSMapRecord *mr = obj->first_weak_ref;
  if (mr->record->max_size == mr->record->length) {
    // expand reference record
    int new_size = mr->record->max_size * 2;
    mr->record->references = reinterpret_cast<LEPUSValue *>(lepus_realloc(
        ctx, mr->record->references, new_size * sizeof(LEPUSValue)));
    if (obj->first_weak_ref->record->references == NULL) {
      LEPUS_ThrowInternalError(ctx, "realloc references failed");
      return;
    }
    mr->record->max_size = new_size;
  }
  // add reference record
  mr->record->references[mr->record->length++] = val;
}

QJS_STATIC LEPUSValue lepus_weakref_constructor(LEPUSContext *ctx,
                                                LEPUSValueConst new_target,
                                                int argc, LEPUSValueConst *argv,
                                                int magic) {
  if (argc < 1 || LEPUS_VALUE_IS_NOT_OBJECT(argv[0])) {
    return LEPUS_ThrowTypeError(ctx, "WeakRef: target must be an object");
  }

  LEPUSValue val = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_WeakRef);
  if (LEPUS_IsException(val)) return val;
  LEPUSValue referent = argv[0];
  LEPUSObject *obj = LEPUS_VALUE_GET_OBJ(referent);
  AddReferenceRecord(ctx, obj, val);
  LEPUSAtom referent_atom = LEPUS_NewAtom(ctx, "referent");
  LEPUS_DefinePropertyValue(ctx, val, referent_atom, referent,
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeAtom(ctx, referent_atom);
  return val;
}

QJS_STATIC void LEPUS_AddIntrinsicWeakRef(LEPUSContext *ctx) {
  LEPUSAtom LEPUS_ATOM_WeakRef = LEPUS_NewAtom(ctx, "WeakRef");
  LEPUSClassShortDef const lepus_weak_ref_def[] = {
      {LEPUS_ATOM_WeakRef, lepus_weakref_finalizer, NULL},
  };

  LEPUSRuntime *rt = ctx->rt;
  if (!LEPUS_IsRegisteredClass(rt, LEPUS_CLASS_WeakRef)) {
    init_class_range(rt, lepus_weak_ref_def, LEPUS_CLASS_WeakRef,
                     countof(lepus_weak_ref_def));
  }
  char buf[ATOM_GET_STR_BUF_SIZE];
  // weakref
  const char *name =
      LEPUS_AtomGetStr(ctx, buf, sizeof(buf), LEPUS_ATOM_WeakRef);
  ctx->class_proto[LEPUS_CLASS_WeakRef] = LEPUS_NewObject(ctx);
  LEPUSObject *tmp = LEPUS_VALUE_GET_OBJ(ctx->class_proto[LEPUS_CLASS_WeakRef]);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_WeakRef],
                                lepus_weakref_proto_funcs, 2);
  LEPUSValue obj1 =
      LEPUS_NewCFunctionMagic(ctx, lepus_weakref_constructor, name, 1,
                              LEPUS_CFUNC_constructor_magic, 0);

  LEPUS_SetPropertyFunctionList(ctx, obj1, lepus_map_funcs,
                                countof(lepus_map_funcs));  // Symbol.species

  LEPUS_NewGlobalCConstructor2(ctx, obj1, name,
                               ctx->class_proto[LEPUS_CLASS_WeakRef]);
  LEPUS_FreeAtom(ctx, LEPUS_ATOM_WeakRef);
}

void Init_ReferenceRecord(LEPUSContext *ctx, ReferenceRecord **record1,
                          LEPUSValue val, RegistryRecord *registry) {
  ReferenceRecord *record = *record1;
  if (record == NULL) {
    record = static_cast<ReferenceRecord *>(
        lepus_mallocz(ctx, sizeof(ReferenceRecord)));
    if (record == NULL) {
      LEPUS_ThrowInternalError(ctx, "malloc record failed");
    }
    record->references =
        (LEPUSValue *)lepus_malloc(ctx, 4 * sizeof(LEPUSValue));
    if (record->references == NULL) {
      LEPUS_ThrowInternalError(ctx, "malloc references failed");
    }
    record->max_size = 4;
    if (registry != NULL) {
      registry->idx =
          (int *)(lepus_malloc(ctx, record->max_size * sizeof(int)));
      if (registry->idx == NULL) {
        LEPUS_ThrowInternalError(ctx, "malloc idx failed");
      }
    }
  } else if (record->max_size == record->length) {
    int new_size = record->max_size * 2;
    LEPUSValue *new_references =
        (LEPUSValue *)lepus_malloc(ctx, new_size * sizeof(LEPUSValue));
    if (new_references == NULL) {
      LEPUS_ThrowInternalError(ctx, "malloc references failed");
    }
    for (int i = 0; i < record->max_size; i++) {
      new_references[i] = record->references[i];
    }
    record->max_size = new_size;
    lepus_free(ctx, record->references);
    record->references = new_references;
    if (registry != NULL) {
      int *t = (int *)(lepus_malloc(ctx, record->max_size * sizeof(int)));
      if (t == NULL) {
        LEPUS_ThrowInternalError(ctx, "malloc idx failed");
      }
      for (int i = 0; i < record->max_size / 2; i++) t[i] = registry->idx[i];
      registry->idx = t;
    }
  }
  record->references[record->length++] = val;
  *record1 = record;
}

QJS_STATIC LEPUSValue
lepus_finalizationRegistry_register(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv) {
  LEPUSValue target_val = argv[0];
  LEPUSObject *target_obj = LEPUS_VALUE_GET_OBJ(target_val);
  LEPUSValue heldvalue_val = argv[1];
  LEPUSObject *heldvalue_obj = LEPUS_VALUE_GET_OBJ(heldvalue_val);
  if (!LEPUS_IsObject(this_val) || LEPUS_IsNull(this_val))
    return LEPUS_ThrowTypeError(
        ctx, "FinalizationRegistry.prototype.register: this must be an object");
  LEPUSObject *this_obj = LEPUS_VALUE_GET_OBJ(this_val);
  if (this_obj->class_id != LEPUS_CLASS_FinalizationRegistry)
    return LEPUS_ThrowTypeError(ctx,
                                "FinalizationRegistry.prototype.register: "
                                "called on incompatible receiver");
  if (!LEPUS_IsObject(target_val) || LEPUS_IsNull(target_val))
    return LEPUS_ThrowTypeError(
        ctx,
        "FinalizationRegistry.prototype.register: target must be an object");
  if (LEPUS_VALUE_GET_TAG(target_val) == LEPUS_VALUE_GET_TAG(heldvalue_val) &&
      LEPUS_VALUE_GET_PTR(target_val) == LEPUS_VALUE_GET_PTR(heldvalue_val))
    return LEPUS_ThrowTypeError(ctx,
                                "FinalizationRegistry.prototype.register: "
                                "target and holdings must not be same");

  if (target_obj->first_weak_ref == NULL) {
    // init reference record
    target_obj->first_weak_ref = static_cast<LEPUSMapRecord *>(
        lepus_mallocz(ctx, sizeof(LEPUSMapRecord)));
    if (target_obj->first_weak_ref == NULL) {
      LEPUS_ThrowInternalError(ctx, "malloc LEPUSMapRecord failed");
    }
  }
  RegistryRecord *&target_reg = target_obj->first_weak_ref->registry;
  if (target_reg == NULL) {
    target_reg = static_cast<RegistryRecord *>(
        lepus_mallocz(ctx, sizeof(RegistryRecord)));
    if (target_reg == NULL) {
      LEPUS_ThrowInternalError(ctx, "malloc registry failed");
    }
  }
  if (target_reg->entry == NULL) {
    LEPUSFinalizationRegistryEntry *el;
    el = static_cast<LEPUSFinalizationRegistryEntry *>(
        lepus_malloc(ctx, sizeof(LEPUSFinalizationRegistryEntry)));
    el->obj = target_obj;
    list_add_tail(&el->link, &ctx->finalization_registries);
    target_reg->entry = el;
  }
  Init_ReferenceRecord(ctx, &target_reg->registra, this_val, NULL);
  LEPUS_DupValue(ctx, this_val);

  Init_ReferenceRecord(ctx, &target_reg->heldvalue, heldvalue_val, NULL);
  LEPUS_DupValue(ctx, heldvalue_val);

  if (argc == 3) {
    LEPUSValue token = argv[2];
    if (!LEPUS_IsObject(token))
      return LEPUS_ThrowTypeError(ctx, "unregisterToken must be an object");

    if (this_obj->first_weak_ref == NULL) {
      // init reference record
      this_obj->first_weak_ref = static_cast<LEPUSMapRecord *>(
          lepus_mallocz(ctx, sizeof(LEPUSMapRecord)));
      if (this_obj->first_weak_ref == NULL) {
        LEPUS_ThrowInternalError(ctx, "malloc LEPUSMapRecord failed");
      }
    }

    RegistryRecord *&this_reg = this_obj->first_weak_ref->registry;
    if (this_reg == NULL) {
      this_reg = static_cast<RegistryRecord *>(
          lepus_mallocz(ctx, sizeof(RegistryRecord)));
      if (this_reg == NULL) {
        LEPUS_ThrowInternalError(ctx, "malloc registry failed");
      }
    }

    Init_ReferenceRecord(ctx, &this_reg->target, target_val, this_reg);
    Init_ReferenceRecord(ctx, &this_reg->token, token, NULL);
    this_reg->idx[this_reg->target->length - 1] =
        target_reg->heldvalue->length - 1;
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue lepus_finalizationRegistry_unregister(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv) {
  // val: registerToken
  LEPUSValue val = argv[0];
  if (!LEPUS_IsObject(this_val) || LEPUS_IsNull(this_val))
    return LEPUS_ThrowTypeError(ctx, "this must be an object");
  LEPUSObject *obj = LEPUS_VALUE_GET_OBJ(this_val);
  LEPUSValue ret_val = LEPUS_FALSE;
  if (obj->class_id != LEPUS_CLASS_FinalizationRegistry)
    return LEPUS_ThrowTypeError(ctx,
                                "FinalizationRegistry.prototype.unregister: "
                                "called on incompatible receiver");

  if (!LEPUS_IsObject(val) || LEPUS_IsNull(val))
    return LEPUS_ThrowTypeError(ctx, "unregisterToken must be an object");

  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) {
    return LEPUS_UNDEFINED;
  }

  if (obj->first_weak_ref != NULL && obj->first_weak_ref->registry != NULL &&
      obj->first_weak_ref->registry->target != NULL) {
    RegistryRecord *&obj_reg = obj->first_weak_ref->registry;
    for (int i = 0; i < obj_reg->target->length; i++) {
      if (LEPUS_VALUE_GET_TAG(obj_reg->token->references[i]) !=
              LEPUS_VALUE_GET_TAG(val) ||
          LEPUS_VALUE_GET_PTR(obj_reg->token->references[i]) !=
              LEPUS_VALUE_GET_PTR(val))
        continue;
      LEPUSValue target = obj_reg->target->references[i];
      LEPUSObject *target_obj = LEPUS_VALUE_GET_OBJ(target);
      if (LEPUS_IsNull(target) || !LEPUS_IsObject(target) ||
          target_obj->first_weak_ref == NULL)
        break;
      RegistryRecord *&target_reg = target_obj->first_weak_ref->registry;
      if (target_reg->entry != NULL) {
        list_del(&target_reg->entry->link);
        lepus_free(ctx, target_reg->entry);
        target_reg->entry = NULL;
      }
      ret_val = LEPUS_TRUE;
      int32_t target_reg_idx = obj_reg->idx[i];
      LEPUS_FreeValue(ctx, target_reg->registra->references[target_reg_idx]);
      target_reg->registra->references[target_reg_idx] = LEPUS_NULL;
      LEPUS_FreeValue(ctx, target_reg->heldvalue->references[target_reg_idx]);
      target_reg->heldvalue->references[target_reg_idx] = LEPUS_NULL;
      obj_reg->target->references[i] = LEPUS_NULL;
    }
  }

  return ret_val;
}

QJS_STATIC LEPUSValue lepus_finalizationRegistry_constructor(
    LEPUSContext *ctx, LEPUSValueConst new_target, int argc,
    LEPUSValueConst *argv, int magic) {
  LEPUSValue executor;
  LEPUSValue val;

  executor = argv[0];
  if (check_function(ctx, executor))
    return LEPUS_ThrowTypeError(
        ctx, "FinalizationRegistry: cleanup must be callable");
  val =
      lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_FinalizationRegistry);
  if (LEPUS_IsException(val)) return LEPUS_EXCEPTION;

  FinalizerOpaque *fo =
      (FinalizerOpaque *)lepus_malloc(ctx, sizeof(FinalizerOpaque));
  fo->ctx = ctx;
  LEPUS_SetOpaque(val, fo);
  LEPUSAtom ccb = LEPUS_NewAtom(ctx, "cleanCallback");
  LEPUS_DefinePropertyValue(ctx, val, ccb, LEPUS_DupValue(ctx, executor),
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeAtom(ctx, ccb);

  return val;
}

QJS_STATIC const LEPUSCFunctionListEntry
    lepus_finalizationRegistry_proto_funcs[] = {
        LEPUS_CFUNC_DEF("register", 3, lepus_finalizationRegistry_register),
        LEPUS_CFUNC_DEF("unregister", 1, lepus_finalizationRegistry_unregister),
        LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "FinalizationRegistry",
                              LEPUS_PROP_CONFIGURABLE),
    };

void LEPUS_AddIntrinsicFinalizationRegistry(LEPUSContext *ctx) {
  LEPUSAtom LEPUS_ATOM_FinalizationRegistry =
      LEPUS_NewAtom(ctx, "FinalizationRegistry");
  LEPUSClassShortDef const lepus_finalization_ref_def[] = {
      {LEPUS_ATOM_FinalizationRegistry, lepus_finalizationRegistry_finalizer,
       lepus_finalizationRegistry_mark},
  };

  LEPUSRuntime *rt = ctx->rt;
  if (!LEPUS_IsRegisteredClass(rt, LEPUS_CLASS_FinalizationRegistry)) {
    init_class_range(rt, lepus_finalization_ref_def,
                     LEPUS_CLASS_FinalizationRegistry,
                     countof(lepus_finalization_ref_def));
  }

  char buf[ATOM_GET_STR_BUF_SIZE];
  const char *name =
      LEPUS_AtomGetStr(ctx, buf, sizeof(buf), LEPUS_ATOM_FinalizationRegistry);
  ctx->class_proto[LEPUS_CLASS_FinalizationRegistry] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(
      ctx, ctx->class_proto[LEPUS_CLASS_FinalizationRegistry],
      lepus_finalizationRegistry_proto_funcs,
      countof(lepus_finalizationRegistry_proto_funcs));
  LEPUSValue obj1 =
      LEPUS_NewCFunctionMagic(ctx, lepus_finalizationRegistry_constructor, name,
                              1, LEPUS_CFUNC_constructor_magic, 0);
  LEPUS_SetPropertyFunctionList(ctx, obj1, lepus_map_funcs,
                                countof(lepus_map_funcs));
  LEPUS_NewGlobalCConstructor2(
      ctx, obj1, name, ctx->class_proto[LEPUS_CLASS_FinalizationRegistry]);
  LEPUS_FreeAtom(ctx, LEPUS_ATOM_FinalizationRegistry);
}

/* Promise */

int LEPUS_MoveUnhandledRejectionToException(LEPUSContext *ctx) {
  //  assert(LEPUS_IsNull(ctx->rt->current_exception));
  if (!LEPUS_IsNull(ctx->rt->current_exception)) {
    LEPUS_FreeValue(ctx, LEPUS_GetException(ctx));
  }
  struct list_head *el = ctx->rt->unhandled_rejections.next;
  if (el == &ctx->rt->unhandled_rejections) return 0;
  LEPUSUnhandledRejectionEntry *e =
      list_entry(el, LEPUSUnhandledRejectionEntry, link);
  ctx->rt->current_exception = e->error;
  list_del(el);
  lepus_free_rt(ctx->rt, el);
  return 1;
}

typedef enum LEPUSPromiseStateEnum {
  LEPUS_PROMISE_PENDING,
  LEPUS_PROMISE_FULFILLED,
  LEPUS_PROMISE_REJECTED,
} LEPUSPromiseStateEnum;

typedef struct LEPUSPromiseData {
  LEPUSPromiseStateEnum promise_state;
  /* 0=fulfill, 1=reject, list of LEPUSPromiseReactionData.link */
  struct list_head promise_reactions[2];
  BOOL is_handled; /* Note: only useful to debug */
  LEPUSValue promise_result;
} LEPUSPromiseData;

typedef struct LEPUSPromiseFunctionDataResolved {
  int ref_count;
  BOOL already_resolved;
} LEPUSPromiseFunctionDataResolved;

typedef struct LEPUSPromiseFunctionData {
  LEPUSValue promise;
  LEPUSPromiseFunctionDataResolved *presolved;
} LEPUSPromiseFunctionData;

typedef struct LEPUSPromiseReactionData {
  struct list_head link; /* not used in promise_reaction_job */
  LEPUSValue resolving_funcs[2];
  LEPUSValue handler;
} LEPUSPromiseReactionData;

QJS_STATIC int lepus_create_resolving_functions(LEPUSContext *ctx,
                                                LEPUSValue *args,
                                                LEPUSValueConst promise);

QJS_STATIC void promise_reaction_data_free(LEPUSRuntime *rt,
                                           LEPUSPromiseReactionData *rd) {
  LEPUS_FreeValueRT(rt, rd->resolving_funcs[0]);
  LEPUS_FreeValueRT(rt, rd->resolving_funcs[1]);
  LEPUS_FreeValueRT(rt, rd->handler);
  lepus_free_rt(rt, rd);
}

QJS_STATIC LEPUSValue promise_reaction_job(LEPUSContext *ctx, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValueConst handler, arg, func;
  LEPUSValue res, res2;
  BOOL is_reject;

  assert(argc == 5);
#ifdef BUILD_ASYNC_STACK
  ctx->rt->current_micro_task = argv;
#endif
  handler = argv[2];
  is_reject = LEPUS_ToBool(ctx, argv[3]);
  arg = argv[4];
#ifdef DUMP_PROMISE
  printf("promise_reaction_job: is_reject=%d\n", is_reject);
#endif

  if (LEPUS_IsUndefined(handler)) {
    if (is_reject) {
      res = LEPUS_Throw(ctx, LEPUS_DupValue(ctx, arg));
    } else {
      res = LEPUS_DupValue(ctx, arg);
    }
  } else {
    res = LEPUS_Call(ctx, handler, LEPUS_UNDEFINED, 1, &arg);
  }
  is_reject = LEPUS_IsException(res);
  if (is_reject) res = LEPUS_GetException(ctx);
  func = argv[is_reject];
  /* as an extension, we support undefined as value to avoid
     creating a dummy promise in the 'await' implementation of async
     functions */
  if (!LEPUS_IsUndefined(func)) {
    res2 = LEPUS_Call(ctx, func, LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&res);
  } else {
    res2 = LEPUS_UNDEFINED;
  }
  LEPUS_FreeValue(ctx, res);
#ifdef BUILD_ASYNC_STACK
  ctx->rt->current_micro_task = NULL;
#endif
  return res2;
}

QJS_STATIC void fulfill_or_reject_promise(LEPUSContext *ctx,
                                          LEPUSValueConst promise,
                                          LEPUSValueConst value,
                                          BOOL is_reject) {
  LEPUSPromiseData *s = static_cast<LEPUSPromiseData *>(
      LEPUS_GetOpaque(promise, LEPUS_CLASS_PROMISE));
  struct list_head *el, *el1;
  LEPUSPromiseReactionData *rd;
  LEPUSValueConst args[5];

  if (!s || s->promise_state != LEPUS_PROMISE_PENDING)
    return; /* should never happen */
  set_value(ctx, &s->promise_result, LEPUS_DupValue(ctx, value));
  s->promise_state =
      static_cast<LEPUSPromiseStateEnum>(LEPUS_PROMISE_FULFILLED + is_reject);
#ifdef DUMP_PROMISE
  printf("fulfill_or_reject_promise: is_reject=%d\n", is_reject);
#endif
  BOOL rejection_handled = FALSE;
  /* Note: could call HostPromiseRejectTracker */
  list_for_each_safe(el, el1, &s->promise_reactions[is_reject]) {
    rd = list_entry(el, LEPUSPromiseReactionData, link);
    rejection_handled = TRUE;
    args[0] = rd->resolving_funcs[0];
    args[1] = rd->resolving_funcs[1];
    args[2] = rd->handler;
    args[3] = LEPUS_NewBool(ctx, is_reject);
    args[4] = value;
    LEPUS_EnqueueJob(ctx, promise_reaction_job, 5, args);
    list_del(&rd->link);
    promise_reaction_data_free(ctx->rt, rd);
  }

  list_for_each_safe(el, el1, &s->promise_reactions[1 - is_reject]) {
    rd = list_entry(el, LEPUSPromiseReactionData, link);
    list_del(&rd->link);
    promise_reaction_data_free(ctx->rt, rd);
  }

  if (is_reject && !rejection_handled) {
    /* Unhandled rejection detected */
    LEPUSUnhandledRejectionEntry *e;
    e = static_cast<LEPUSUnhandledRejectionEntry *>(
        lepus_malloc(ctx, sizeof(*e)));
    // only promises handled later will use this value, thus its refcount always
    // > 0 when using
    e->promise = promise;

    if (LEPUS_IsError(ctx, value)) {
      e->error = LEPUS_DupValue(ctx, value);
    } else {
      e->error = lepus_error_constructor(ctx, promise, 1, &value, -1);
    }
    list_add_tail(&e->link, &ctx->rt->unhandled_rejections);
  }
}

QJS_STATIC void reject_promise(LEPUSContext *ctx, LEPUSValueConst promise,
                               LEPUSValueConst value) {
  fulfill_or_reject_promise(ctx, promise, value, TRUE);
}

QJS_STATIC LEPUSValue lepus_promise_resolve_thenable_job(
    LEPUSContext *ctx, int argc, LEPUSValueConst *argv) {
  LEPUSValueConst promise, thenable, then;
  LEPUSValue res;
  LEPUSValue args[2];

#ifdef DUMP_PROMISE
  printf("lepus_promise_resolve_thenable_job\n");
#endif
  assert(argc == 3);
  promise = argv[0];
  thenable = argv[1];
  then = argv[2];
  if (lepus_create_resolving_functions(ctx, args, promise) < 0)
    return LEPUS_EXCEPTION;
  res = LEPUS_Call(ctx, then, thenable, 2, (LEPUSValueConst *)args);
  if (LEPUS_IsException(res)) {
    LEPUSValue error = LEPUS_GetException(ctx);
    res =
        LEPUS_Call(ctx, args[1], LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
  }
  LEPUS_FreeValue(ctx, args[0]);
  LEPUS_FreeValue(ctx, args[1]);
  return res;
}

QJS_STATIC void lepus_promise_resolve_function_free_resolved(
    LEPUSRuntime *rt, LEPUSPromiseFunctionDataResolved *sr) {
  if (--sr->ref_count == 0) {
    lepus_free_rt(rt, sr);
  }
}

QJS_STATIC int lepus_create_resolving_functions(LEPUSContext *ctx,
                                                LEPUSValue *resolving_funcs,
                                                LEPUSValueConst promise)

{
  LEPUSValue obj;
  LEPUSPromiseFunctionData *s;
  LEPUSPromiseFunctionDataResolved *sr;
  int i, ret;

  sr = static_cast<LEPUSPromiseFunctionDataResolved *>(
      lepus_malloc(ctx, sizeof(*sr)));
  if (!sr) return -1;
  sr->ref_count = 1;
  sr->already_resolved = FALSE; /* must be shared between the two functions */
  ret = 0;
  for (i = 0; i < 2; i++) {
    obj = LEPUS_NewObjectProtoClass(ctx, ctx->function_proto,
                                    LEPUS_CLASS_PROMISE_RESOLVE_FUNCTION + i);
    if (LEPUS_IsException(obj)) goto fail;
    s = static_cast<LEPUSPromiseFunctionData *>(lepus_malloc(ctx, sizeof(*s)));
    if (!s) {
      LEPUS_FreeValue(ctx, obj);
    fail:

      if (i != 0) LEPUS_FreeValue(ctx, resolving_funcs[0]);
      ret = -1;
      break;
    }
    sr->ref_count++;
    s->presolved = sr;
    s->promise = LEPUS_DupValue(ctx, promise);
    LEPUS_SetOpaque(obj, s);
    lepus_function_set_properties(ctx, obj, LEPUS_ATOM_empty_string, 1);
    resolving_funcs[i] = obj;
  }
  lepus_promise_resolve_function_free_resolved(ctx->rt, sr);
  return ret;
}

QJS_STATIC void lepus_promise_resolve_function_finalizer(LEPUSRuntime *rt,
                                                         LEPUSValue val) {
  LEPUSPromiseFunctionData *s =
      LEPUS_VALUE_GET_OBJ(val)->u.promise_function_data;
  if (s) {
    lepus_promise_resolve_function_free_resolved(rt, s->presolved);
    LEPUS_FreeValueRT(rt, s->promise);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void lepus_promise_resolve_function_mark(LEPUSRuntime *rt,
                                                    LEPUSValueConst val,
                                                    LEPUS_MarkFunc *mark_func) {
  LEPUSPromiseFunctionData *s =
      LEPUS_VALUE_GET_OBJ(val)->u.promise_function_data;
  if (s) {
    LEPUS_MarkValue(rt, s->promise, mark_func);
  }
}

QJS_STATIC LEPUSValue lepus_promise_resolve_function_call(
    LEPUSContext *ctx, LEPUSValueConst func_obj, LEPUSValueConst this_val,
    int argc, LEPUSValueConst *argv, int flags) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(func_obj);
  LEPUSPromiseFunctionData *s;
  LEPUSValueConst resolution;
  LEPUSValue args[3];
  LEPUSValue then;
  BOOL is_reject;

  s = p->u.promise_function_data;
  if (!s || s->presolved->already_resolved) return LEPUS_UNDEFINED;
  s->presolved->already_resolved = TRUE;
  is_reject = p->class_id - LEPUS_CLASS_PROMISE_RESOLVE_FUNCTION;
  if (argc > 0)
    resolution = argv[0];
  else
    resolution = LEPUS_UNDEFINED;
#ifdef DUMP_PROMISE
  printf("lepus_promise_resolving_function_call: is_reject=%d resolution=",
         is_reject);
  LEPUS_DumpValue(ctx, resolution);
  printf("\n");
#endif
  if (is_reject || !LEPUS_IsObject(resolution)) {
    goto done;
  } else if (lepus_same_value(ctx, resolution, s->promise)) {
    LEPUS_ThrowTypeError(ctx, "promise self resolution");
    goto fail_reject;
  }
  then = LEPUS_GetProperty(ctx, resolution, LEPUS_ATOM_then);
  if (LEPUS_IsException(then)) {
    LEPUSValue error;
  fail_reject:
    error = LEPUS_GetException(ctx);
    reject_promise(ctx, s->promise, error);
    LEPUS_FreeValue(ctx, error);
  } else if (!LEPUS_IsFunction(ctx, then)) {
    LEPUS_FreeValue(ctx, then);
  done:
    fulfill_or_reject_promise(ctx, s->promise, resolution, is_reject);
  } else {
    args[0] = s->promise;
    args[1] = resolution;
    args[2] = then;
    LEPUS_EnqueueJob(ctx, lepus_promise_resolve_thenable_job, 3, args);
    LEPUS_FreeValue(ctx, then);
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC void lepus_promise_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSPromiseData *s = static_cast<LEPUSPromiseData *>(
      LEPUS_GetOpaque(val, LEPUS_CLASS_PROMISE));
  struct list_head *el, *el1;
  int i;

  if (!s) return;
  for (i = 0; i < 2; i++) {
    list_for_each_safe(el, el1, &s->promise_reactions[i]) {
      LEPUSPromiseReactionData *rd =
          list_entry(el, LEPUSPromiseReactionData, link);
      promise_reaction_data_free(rt, rd);
    }
  }
  list_for_each_safe(el, el1, &rt->unhandled_rejections) {
    LEPUSUnhandledRejectionEntry *e =
        list_entry(el, LEPUSUnhandledRejectionEntry, link);
    if (LEPUS_VALUE_GET_PTR(e->promise) == LEPUS_VALUE_GET_PTR(val)) {
      e->promise = LEPUS_NULL;
      break;
    }
  }
  LEPUS_FreeValueRT(rt, s->promise_result);
  lepus_free_rt(rt, s);
}

QJS_STATIC void lepus_promise_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                   LEPUS_MarkFunc *mark_func) {
  LEPUSPromiseData *s = static_cast<LEPUSPromiseData *>(
      LEPUS_GetOpaque(val, LEPUS_CLASS_PROMISE));
  struct list_head *el;
  int i;

  if (!s) return;
  for (i = 0; i < 2; i++) {
    list_for_each(el, &s->promise_reactions[i]) {
      LEPUSPromiseReactionData *rd =
          list_entry(el, LEPUSPromiseReactionData, link);
      LEPUS_MarkValue(rt, rd->resolving_funcs[0], mark_func);
      LEPUS_MarkValue(rt, rd->resolving_funcs[1], mark_func);
      LEPUS_MarkValue(rt, rd->handler, mark_func);
    }
  }
  LEPUS_MarkValue(rt, s->promise_result, mark_func);
}

QJS_STATIC LEPUSValue lepus_promise_constructor(LEPUSContext *ctx,
                                                LEPUSValueConst new_target,
                                                int argc,
                                                LEPUSValueConst *argv) {
  LEPUSValueConst executor;
  LEPUSValue obj;
  LEPUSPromiseData *s;
  LEPUSValue args[2], ret;
  int i;

  executor = argv[0];
  if (check_function(ctx, executor)) return LEPUS_EXCEPTION;
  obj = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_PROMISE);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  s = static_cast<LEPUSPromiseData *>(lepus_mallocz(ctx, sizeof(*s)));
  if (!s) goto fail;
  s->promise_state = LEPUS_PROMISE_PENDING;
  s->is_handled = FALSE;
  for (i = 0; i < 2; i++) init_list_head(&s->promise_reactions[i]);
  s->promise_result = LEPUS_UNDEFINED;
  LEPUS_SetOpaque(obj, s);
  if (lepus_create_resolving_functions(ctx, args, obj)) goto fail;
  ret = LEPUS_Call(ctx, executor, LEPUS_UNDEFINED, 2, (LEPUSValueConst *)args);
  if (LEPUS_IsException(ret)) {
    LEPUSValue ret2, error;
    error = LEPUS_GetException(ctx);
    ret2 =
        LEPUS_Call(ctx, args[1], LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
    if (LEPUS_IsException(ret2)) goto fail1;
    LEPUS_FreeValue(ctx, ret2);
  }
  LEPUS_FreeValue(ctx, ret);
  LEPUS_FreeValue(ctx, args[0]);
  LEPUS_FreeValue(ctx, args[1]);
  return obj;
fail1:
  LEPUS_FreeValue(ctx, args[0]);
  LEPUS_FreeValue(ctx, args[1]);
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_promise_executor(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv, int magic,
                                             LEPUSValue *func_data) {
  int i;

  for (i = 0; i < 2; i++) {
    if (!LEPUS_IsUndefined(func_data[i]))
      return LEPUS_ThrowTypeError(ctx, "resolving function already set");
    func_data[i] = LEPUS_DupValue(ctx, argv[i]);
  }
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue lepus_promise_executor_new(LEPUSContext *ctx) {
  LEPUSValueConst func_data[2];

  func_data[0] = LEPUS_UNDEFINED;
  func_data[1] = LEPUS_UNDEFINED;
  return LEPUS_NewCFunctionData(ctx, lepus_promise_executor, 2, 0, 2,
                                func_data);
}

QJS_STATIC LEPUSValue lepus_new_promise_capability(LEPUSContext *ctx,
                                                   LEPUSValue *resolving_funcs,
                                                   LEPUSValueConst ctor) {
  LEPUSValue executor, result_promise;
  LEPUSCFunctionDataRecord *s;
  int i;

  executor = lepus_promise_executor_new(ctx);
  if (LEPUS_IsException(executor)) return executor;

  if (LEPUS_IsUndefined(ctor)) {
    result_promise =
        lepus_promise_constructor(ctx, ctor, 1, (LEPUSValueConst *)&executor);
  } else {
    result_promise =
        LEPUS_CallConstructor(ctx, ctor, 1, (LEPUSValueConst *)&executor);
  }
  if (LEPUS_IsException(result_promise)) goto fail;
  s = static_cast<LEPUSCFunctionDataRecord *>(
      LEPUS_GetOpaque(executor, LEPUS_CLASS_C_FUNCTION_DATA));
  for (i = 0; i < 2; i++) {
    if (check_function(ctx, s->data[i])) goto fail;
  }
  for (i = 0; i < 2; i++) resolving_funcs[i] = LEPUS_DupValue(ctx, s->data[i]);
  LEPUS_FreeValue(ctx, executor);
  return result_promise;
fail:
  LEPUS_FreeValue(ctx, executor);
  LEPUS_FreeValue(ctx, result_promise);
  return LEPUS_EXCEPTION;
}

LEPUSValue LEPUS_NewPromiseCapability(LEPUSContext *ctx,
                                      LEPUSValue *resolving_funcs) {
  return lepus_new_promise_capability(ctx, resolving_funcs, LEPUS_UNDEFINED);
}

QJS_STATIC LEPUSValue lepus_promise_resolve(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv, int magic) {
  LEPUSValue result_promise, resolving_funcs[2], ret;
  BOOL is_reject = magic;

  if (!LEPUS_IsObject(this_val)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  if (!is_reject && LEPUS_GetOpaque(argv[0], LEPUS_CLASS_PROMISE)) {
    LEPUSValue ctor;
    BOOL is_same;
    ctor = LEPUS_GetProperty(ctx, argv[0], LEPUS_ATOM_constructor);
    if (LEPUS_IsException(ctor)) return ctor;
    is_same = lepus_same_value(ctx, ctor, this_val);
    LEPUS_FreeValue(ctx, ctor);
    if (is_same) return LEPUS_DupValue(ctx, argv[0]);
  }
  result_promise = lepus_new_promise_capability(ctx, resolving_funcs, this_val);
  if (LEPUS_IsException(result_promise)) return result_promise;
  ret = LEPUS_Call(ctx, resolving_funcs[is_reject], LEPUS_UNDEFINED, 1, argv);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  if (LEPUS_IsException(ret)) {
    LEPUS_FreeValue(ctx, result_promise);
    return ret;
  }
  LEPUS_FreeValue(ctx, ret);
  return result_promise;
}

#if 0
static LEPUSValue lepus_promise___newPromiseCapability(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc, LEPUSValueConst *argv)
{
    LEPUSValue result_promise, resolving_funcs[2], obj;
    LEPUSValueConst ctor;
    ctor = argv[0];
    if (!LEPUS_IsObject(ctor))
        return LEPUS_ThrowTypeErrorNotAnObject(ctx);
    result_promise = lepus_new_promise_capability(ctx, resolving_funcs, ctor);
    if (LEPUS_IsException(result_promise))
        return result_promise;
    obj = LEPUS_NewObject(ctx);
    if (LEPUS_IsException(obj)) {
        LEPUS_FreeValue(ctx, resolving_funcs[0]);
        LEPUS_FreeValue(ctx, resolving_funcs[1]);
        LEPUS_FreeValue(ctx, result_promise);
        return LEPUS_EXCEPTION;
    }
    LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_promise, result_promise, LEPUS_PROP_C_W_E);
    LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_resolve, resolving_funcs[0], LEPUS_PROP_C_W_E);
    LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_reject, resolving_funcs[1], LEPUS_PROP_C_W_E);
    return obj;
}
#endif

QJS_STATIC __exception int remainingElementsCount_add(
    LEPUSContext *ctx, LEPUSValueConst resolve_element_env, int addend) {
  LEPUSValue val;
  int remainingElementsCount;

  val = LEPUS_GetPropertyUint32(ctx, resolve_element_env, 0);
  if (LEPUS_IsException(val)) return -1;
  if (LEPUS_ToInt32Free(ctx, &remainingElementsCount, val)) return -1;
  remainingElementsCount += addend;
  if (LEPUS_SetPropertyUint32(ctx, resolve_element_env, 0,
                              LEPUS_NewInt32(ctx, remainingElementsCount)) < 0)
    return -1;
  return (remainingElementsCount == 0);
}

#ifdef BUILD_ASYNC_STACK
QJS_STATIC void build_async_backtrace(LEPUSContext *ctx, const uint8_t *cur_pc,
                                      DynBuf *dbuf, BOOL is_debug_mode,
                                      LEPUSValueConst error_obj) {
  if (ctx->rt->current_micro_task == NULL) return;
  struct list_head *el, *el1;
  LEPUSValue handler = ctx->rt->current_micro_task[2];
  LEPUSValue new_handler = LEPUS_UNDEFINED;
  LEPUSValue func_obj;
  LEPUSStackFrame *sf;
  for (;;) {
    if (!LEPUS_IsObject(handler)) break;
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(handler);
    if (p->class_id == LEPUS_CLASS_ASYNC_FUNCTION_RESOLVE ||
        p->class_id == LEPUS_CLASS_ASYNC_FUNCTION_REJECT) {
      /* async function */
      LEPUSAsyncFunctionData *s = p->u.async_function_data;
      if (s == NULL) break;
      func_obj = s->resolving_funcs[1];
    } else if (p->class_id == LEPUS_CLASS_C_FUNCTION_DATA) {
      /* async generator */
      LEPUSCFunctionDataRecord *s0 = static_cast<LEPUSCFunctionDataRecord *>(
          LEPUS_GetOpaque(handler, LEPUS_CLASS_C_FUNCTION_DATA));
      LEPUSAsyncGeneratorData *s = static_cast<LEPUSAsyncGeneratorData *>(
          LEPUS_GetOpaque(s0->data[0], LEPUS_CLASS_ASYNC_GENERATOR));
      if (s == NULL) break;
      if (list_empty(&(s->queue))) break;
      LEPUSAsyncGeneratorRequest *next =
          list_entry(s->queue.next, LEPUSAsyncGeneratorRequest, link);
      func_obj = next->resolving_funcs[1];
    } else if (p->class_id == LEPUS_CLASS_BYTECODE_FUNCTION) {
      /* then */
      func_obj = ctx->rt->current_micro_task[1];
    } else
      break;

  retry:
    if (!LEPUS_IsObject(func_obj)) break;
    p = LEPUS_VALUE_GET_OBJ(func_obj);
    LEPUSPromiseFunctionData *s1 = p->u.promise_function_data;
    if (s1 == NULL) break;
    LEPUSValue promise = s1->promise;
    LEPUSPromiseData *s2 = static_cast<LEPUSPromiseData *>(
        LEPUS_GetOpaque(promise, LEPUS_CLASS_PROMISE));
    if (s2 == NULL) break;

    int count = 0;
    list_for_each_safe(el, el1, &s2->promise_reactions[1]) { count++; }
    if (count > 1) {
#if defined(ANDROID) || defined(__ANDROID__)
      __android_log_print(ANDROID_LOG_ERROR, "VMSDK",
                          "==== multiple reaction of promise ====\n%d%s\n",
                          count, (char *)dbuf->buf);
#endif
    }
    if (count == 0) break;

    el = s2->promise_reactions[1].next;
    LEPUSPromiseReactionData *rd =
        list_entry(el, LEPUSPromiseReactionData, link);
    new_handler = rd->handler;
    handler = new_handler;
    if (!LEPUS_IsObject(handler)) {
      if (LEPUS_IsUndefined(handler)) {
        func_obj = rd->resolving_funcs[1];
        goto retry;
      } else {
        break;
      }
    }
    if (!LEPUS_IsObject(handler)) break;

    p = LEPUS_VALUE_GET_OBJ(handler);

    if (p->class_id == LEPUS_CLASS_ASYNC_FUNCTION_RESOLVE ||
        p->class_id == LEPUS_CLASS_ASYNC_FUNCTION_REJECT) {
      /* async function */
      if (p->u.async_function_data != NULL)
        sf = &p->u.async_function_data->func_state.frame;
      else
        break;
    } else if (p->class_id == LEPUS_CLASS_C_FUNCTION_DATA) {
      LEPUSCFunctionDataRecord *s0 = static_cast<LEPUSCFunctionDataRecord *>(
          LEPUS_GetOpaque(handler, LEPUS_CLASS_C_FUNCTION_DATA));
      if (s0->magic == 1) {
        /* async generator */
        LEPUSAsyncGeneratorData *s = static_cast<LEPUSAsyncGeneratorData *>(
            LEPUS_GetOpaque(s0->data[0], LEPUS_CLASS_ASYNC_GENERATOR));
        if (s != NULL)
          sf = &s->func_state.frame;
        else
          break;
      } else if (s0->magic == 2) {
        /* Promise.any */
        dbuf_printf(dbuf, "    at (async)Promise.any\n");
        func_obj = s0->data[3];
        goto retry;
      } else if (s0->magic == 5) {
        /* Promise.allSettled */
        dbuf_printf(dbuf, "    at (async)Promise.allSettled\n");
        func_obj = s0->data[3];
        goto retry;
      } else
        break;
    } else if (p->class_id == LEPUS_CLASS_PROMISE_REJECT_FUNCTION) {
      /* Promise.all */
      dbuf_printf(dbuf, "    at (async)Promise.all\n");
      func_obj = handler;
      goto retry;
    } else
      break;

    if (!LEPUS_IsObject(sf->cur_func)) break;

    build_backtrace_frame(ctx, sf, dbuf, cur_pc, TRUE, is_debug_mode,
                          error_obj);
  }
}
#endif

/* used by C code. */
QJS_STATIC LEPUSValue
lepus_aggregate_error_constructor(LEPUSContext *ctx, LEPUSValueConst errors) {
  LEPUSValue obj;

  obj = LEPUS_NewObjectProtoClass(
      ctx, ctx->native_error_proto[LEPUS_AGGREGATE_ERROR], LEPUS_CLASS_ERROR);
  if (LEPUS_IsException(obj)) return obj;
  LEPUSAtom atom_errors = LEPUS_NewAtom(ctx, "errors");
  LEPUS_DefinePropertyValue(ctx, obj, atom_errors, LEPUS_DupValue(ctx, errors),
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeAtom(ctx, atom_errors);
  return obj;
}

#define PROMISE_MAGIC_all 0
#define PROMISE_MAGIC_allSettled 1
#define PROMISE_MAGIC_any 2

QJS_STATIC LEPUSValue lepus_promise_all_resolve_element(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  int resolve_type = magic & 3;
  int is_reject = magic & 4;
  BOOL alreadyCalled = LEPUS_ToBool(ctx, func_data[0]);
  LEPUSValueConst values = func_data[2];
  LEPUSValueConst resolve = func_data[3];
  LEPUSValueConst resolve_element_env = func_data[4];
  LEPUSValue ret, obj;
  int is_zero, index;

  if (LEPUS_ToInt32(ctx, &index, func_data[1])) return LEPUS_EXCEPTION;
  if (alreadyCalled) return LEPUS_UNDEFINED;
  func_data[0] = LEPUS_NewBool(ctx, TRUE);

  if (resolve_type == PROMISE_MAGIC_allSettled) {
    LEPUSValue str;

    obj = LEPUS_NewObject(ctx);
    if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
    str = LEPUS_NewString(ctx, is_reject ? "rejected" : "fulfilled");
    if (LEPUS_IsException(str)) goto fail1;
    if (LEPUS_DefinePropertyValue(ctx, obj, LEPUS_ATOM_status, str,
                                  LEPUS_PROP_C_W_E) < 0)
      goto fail1;
    if (LEPUS_DefinePropertyValue(
            ctx, obj, is_reject ? LEPUS_ATOM_reason : LEPUS_ATOM_value,
            LEPUS_DupValue(ctx, argv[0]), LEPUS_PROP_C_W_E) < 0) {
    fail1:
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
  } else {
    obj = LEPUS_DupValue(ctx, argv[0]);
  }
  if (LEPUS_DefinePropertyValueUint32(ctx, values, index, obj,
                                      LEPUS_PROP_C_W_E) < 0)
    return LEPUS_EXCEPTION;

  is_zero = remainingElementsCount_add(ctx, resolve_element_env, -1);
  if (is_zero < 0) return LEPUS_EXCEPTION;
  if (is_zero) {
    if (resolve_type == PROMISE_MAGIC_any) {
      LEPUSValue error;
      error = lepus_aggregate_error_constructor(ctx, values);
      if (LEPUS_IsException(error)) return LEPUS_EXCEPTION;
      ret = LEPUS_Call(ctx, resolve, LEPUS_UNDEFINED, 1,
                       (LEPUSValueConst *)&error);
      LEPUS_FreeValue(ctx, error);
    } else {
      ret = LEPUS_Call(ctx, resolve, LEPUS_UNDEFINED, 1,
                       (LEPUSValueConst *)&values);
    }

    if (LEPUS_IsException(ret)) return ret;
    LEPUS_FreeValue(ctx, ret);
  }
  return LEPUS_UNDEFINED;
}

/* magic = 0: Promise.all 1: Promise.allSettled */
QJS_STATIC LEPUSValue lepus_promise_all(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv, int magic) {
  LEPUSValue result_promise, resolving_funcs[2], item, next_promise, ret;
  LEPUSValue next_method = LEPUS_UNDEFINED, values = LEPUS_UNDEFINED;
  LEPUSValue resolve_element_env = LEPUS_UNDEFINED, resolve_element,
             reject_element;
  LEPUSValue promise_resolve = LEPUS_UNDEFINED, iter = LEPUS_UNDEFINED;
  LEPUSValueConst then_args[2];
  LEPUSValueConst resolve_element_data[5];
  BOOL done;
  int index, is_zero, is_promise_any = (magic == PROMISE_MAGIC_any);

  if (!LEPUS_IsObject(this_val)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  result_promise = lepus_new_promise_capability(ctx, resolving_funcs, this_val);
  if (LEPUS_IsException(result_promise)) return result_promise;
  promise_resolve = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_resolve);
  if (LEPUS_IsException(promise_resolve) ||
      check_function(ctx, promise_resolve))
    goto fail_reject;
  iter = LEPUS_GetIterator(ctx, argv[0], FALSE);
  if (LEPUS_IsException(iter)) {
    LEPUSValue error;
  fail_reject:
    error = LEPUS_GetException(ctx);
    ret = LEPUS_Call(ctx, resolving_funcs[1], LEPUS_UNDEFINED, 1,
                     (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
    if (LEPUS_IsException(ret)) goto fail;
    LEPUS_FreeValue(ctx, ret);
  } else {
    next_method = LEPUS_GetProperty(ctx, iter, LEPUS_ATOM_next);
    if (LEPUS_IsException(next_method)) goto fail_reject;
    values = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(values)) goto fail_reject;
    resolve_element_env = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(resolve_element_env)) goto fail_reject;
    /* remainingElementsCount field */
    if (LEPUS_DefinePropertyValueUint32(
            ctx, resolve_element_env, 0, LEPUS_NewInt32(ctx, 1),
            LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_ENUMERABLE |
                LEPUS_PROP_WRITABLE) < 0)
      goto fail_reject;

    index = 0;
    for (;;) {
      /* XXX: conformance: should close the iterator if error on 'done'
         access, but not on 'value' access */
      item = LEPUS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
      if (LEPUS_IsException(item)) goto fail_reject;
      if (done) break;
      next_promise = LEPUS_Call(ctx, promise_resolve, this_val, 1,
                                (LEPUSValueConst *)&item);
      LEPUS_FreeValue(ctx, item);
      if (LEPUS_IsException(next_promise)) {
      fail_reject1:
        LEPUS_IteratorClose(ctx, iter, TRUE);
        goto fail_reject;
      }
      resolve_element_data[0] = LEPUS_NewBool(ctx, FALSE);
      resolve_element_data[1] = (LEPUSValueConst)LEPUS_NewInt32(ctx, index);
      resolve_element_data[2] = values;
      resolve_element_data[3] = resolving_funcs[is_promise_any];
      resolve_element_data[4] = resolve_element_env;
      resolve_element =
          LEPUS_NewCFunctionData(ctx, lepus_promise_all_resolve_element, 1,
                                 magic, 5, resolve_element_data);
      if (LEPUS_IsException(resolve_element)) {
        LEPUS_FreeValue(ctx, next_promise);
        goto fail_reject1;
      }

      if (magic == PROMISE_MAGIC_allSettled) {
        reject_element =
            LEPUS_NewCFunctionData(ctx, lepus_promise_all_resolve_element, 1,
                                   magic | 4, 5, resolve_element_data);
        if (LEPUS_IsException(reject_element)) {
          LEPUS_FreeValue(ctx, next_promise);
          goto fail_reject1;
        }
      } else if (magic == PROMISE_MAGIC_any) {
        if (LEPUS_DefinePropertyValueUint32(ctx, values, index, LEPUS_UNDEFINED,
                                            LEPUS_PROP_C_W_E) < 0)
          goto fail_reject1;
        reject_element = resolve_element;
        resolve_element = LEPUS_DupValue(ctx, resolving_funcs[0]);
      } else {
        reject_element = LEPUS_DupValue(ctx, resolving_funcs[1]);
      }

      if (remainingElementsCount_add(ctx, resolve_element_env, 1) < 0) {
        LEPUS_FreeValue(ctx, next_promise);
        LEPUS_FreeValue(ctx, resolve_element);
        LEPUS_FreeValue(ctx, reject_element);
        goto fail_reject1;
      }
      then_args[0] = resolve_element;
      then_args[1] = reject_element;
      ret = LEPUS_InvokeFree(ctx, next_promise, LEPUS_ATOM_then, 2, then_args);
      LEPUS_FreeValue(ctx, resolve_element);
      LEPUS_FreeValue(ctx, reject_element);
      if (check_exception_free(ctx, ret)) goto fail_reject1;
      index++;
    }

    is_zero = remainingElementsCount_add(ctx, resolve_element_env, -1);
    if (is_zero < 0) goto fail_reject;
    if (is_zero) {
      if (magic == PROMISE_MAGIC_any) {
        LEPUSValue error;
        error = lepus_aggregate_error_constructor(ctx, values);
        if (LEPUS_IsException(error)) goto fail_reject;
        LEPUS_FreeValue(ctx, values);
        values = error;
      }
      ret = LEPUS_Call(ctx, resolving_funcs[is_promise_any], LEPUS_UNDEFINED, 1,
                       (LEPUSValueConst *)&values);
      if (check_exception_free(ctx, ret)) goto fail_reject;
    }
  }
done:
  LEPUS_FreeValue(ctx, promise_resolve);
  LEPUS_FreeValue(ctx, resolve_element_env);
  LEPUS_FreeValue(ctx, values);
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  return result_promise;
fail:
  LEPUS_FreeValue(ctx, result_promise);
  result_promise = LEPUS_EXCEPTION;
  goto done;
}

QJS_STATIC LEPUSValue lepus_promise_race(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValue result_promise, resolving_funcs[2], item, next_promise, ret;
  LEPUSValue next_method = LEPUS_UNDEFINED, iter = LEPUS_UNDEFINED;
  LEPUSValue promise_resolve = LEPUS_UNDEFINED;
  BOOL done;

  if (!LEPUS_IsObject(this_val)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);
  result_promise = lepus_new_promise_capability(ctx, resolving_funcs, this_val);
  if (LEPUS_IsException(result_promise)) return result_promise;
  promise_resolve = LEPUS_GetProperty(ctx, this_val, LEPUS_ATOM_resolve);
  if (LEPUS_IsException(promise_resolve) ||
      check_function(ctx, promise_resolve))
    goto fail_reject;
  iter = LEPUS_GetIterator(ctx, argv[0], FALSE);
  if (LEPUS_IsException(iter)) {
    LEPUSValue error;
  fail_reject:
    error = LEPUS_GetException(ctx);
    ret = LEPUS_Call(ctx, resolving_funcs[1], LEPUS_UNDEFINED, 1,
                     (LEPUSValueConst *)&error);
    LEPUS_FreeValue(ctx, error);
    if (LEPUS_IsException(ret)) goto fail;
    LEPUS_FreeValue(ctx, ret);
  } else {
    next_method = LEPUS_GetProperty(ctx, iter, LEPUS_ATOM_next);
    if (LEPUS_IsException(next_method)) goto fail_reject;

    for (;;) {
      /* XXX: conformance: should close the iterator if error on 'done'
         access, but not on 'value' access */
      item = LEPUS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
      if (LEPUS_IsException(item)) goto fail_reject;
      if (done) break;
      next_promise = LEPUS_Call(ctx, promise_resolve, this_val, 1,
                                (LEPUSValueConst *)&item);
      LEPUS_FreeValue(ctx, item);
      if (LEPUS_IsException(next_promise)) {
      fail_reject1:
        LEPUS_IteratorClose(ctx, iter, TRUE);
        goto fail_reject;
      }
      ret = LEPUS_InvokeFree(ctx, next_promise, LEPUS_ATOM_then, 2,
                             (LEPUSValueConst *)resolving_funcs);
      if (check_exception_free(ctx, ret)) goto fail_reject1;
    }
  }
done:
  LEPUS_FreeValue(ctx, promise_resolve);
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  return result_promise;
fail:
  // LEPUS_FreeValue(ctx, next_method); // why not???
  LEPUS_FreeValue(ctx, result_promise);
  result_promise = LEPUS_EXCEPTION;
  goto done;
}

QJS_STATIC __exception int perform_promise_then(
    LEPUSContext *ctx, LEPUSValueConst promise, LEPUSValueConst *resolve_reject,
    LEPUSValueConst *cap_resolving_funcs) {
  LEPUSPromiseData *s = static_cast<LEPUSPromiseData *>(
      LEPUS_GetOpaque(promise, LEPUS_CLASS_PROMISE));
  LEPUSPromiseReactionData *rd_array[2], *rd;
  int i, j;

  rd_array[0] = NULL;
  rd_array[1] = NULL;
  for (i = 0; i < 2; i++) {
    LEPUSValueConst handler;
    rd = static_cast<LEPUSPromiseReactionData *>(
        lepus_mallocz(ctx, sizeof(*rd)));
    if (!rd) {
      if (i == 1) promise_reaction_data_free(ctx->rt, rd_array[0]);
      return -1;
    }
    for (j = 0; j < 2; j++)
      rd->resolving_funcs[j] = LEPUS_DupValue(ctx, cap_resolving_funcs[j]);
    handler = resolve_reject[i];
    if (!LEPUS_IsFunction(ctx, handler)) handler = LEPUS_UNDEFINED;
    rd->handler = LEPUS_DupValue(ctx, handler);
    rd_array[i] = rd;
  }

  if (s->promise_state == LEPUS_PROMISE_PENDING) {
    for (i = 0; i < 2; i++)
      list_add_tail(&rd_array[i]->link, &s->promise_reactions[i]);
  } else {
    LEPUSValueConst args[5];
    i = s->promise_state - LEPUS_PROMISE_FULFILLED;
    rd = rd_array[i];
    args[0] = rd->resolving_funcs[0];
    args[1] = rd->resolving_funcs[1];
    args[2] = rd->handler;
    args[3] = LEPUS_NewBool(ctx, i);
    args[4] = s->promise_result;
    LEPUS_EnqueueJob(ctx, promise_reaction_job, 5, args);
    for (i = 0; i < 2; i++) promise_reaction_data_free(ctx->rt, rd_array[i]);
  }

  if (s->promise_state == LEPUS_PROMISE_REJECTED) {
    struct list_head *el, *el1;
    list_for_each_safe(el, el1, &ctx->rt->unhandled_rejections) {
      LEPUSUnhandledRejectionEntry *e =
          list_entry(el, LEPUSUnhandledRejectionEntry, link);
      if (!LEPUS_IsNull(e->promise) &&
          LEPUS_GetOpaque(e->promise, LEPUS_CLASS_PROMISE) == s) {
        LEPUS_FreeValue(ctx, e->error);
        list_del(el);
        lepus_free_rt(ctx->rt, el);
        break;
      }
    }
  }

  s->is_handled = TRUE;
  return 0;
}

QJS_STATIC LEPUSValue lepus_promise_then(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  LEPUSValue ctor, result_promise, resolving_funcs[2];
  LEPUSPromiseData *s;
  int i, ret;

  s = static_cast<LEPUSPromiseData *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_PROMISE));
  if (!s) return LEPUS_EXCEPTION;

  ctor = LEPUS_SpeciesConstructor(ctx, this_val, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return ctor;
  result_promise = lepus_new_promise_capability(ctx, resolving_funcs, ctor);
  LEPUS_FreeValue(ctx, ctor);
  if (LEPUS_IsException(result_promise)) return result_promise;
  ret = perform_promise_then(ctx, this_val, argv,
                             (LEPUSValueConst *)resolving_funcs);
  for (i = 0; i < 2; i++) LEPUS_FreeValue(ctx, resolving_funcs[i]);
  if (ret) {
    LEPUS_FreeValue(ctx, result_promise);
    return LEPUS_EXCEPTION;
  }
  return result_promise;
}

QJS_STATIC LEPUSValue lepus_promise_catch(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValueConst args[2];
  args[0] = LEPUS_UNDEFINED;
  args[1] = argv[0];
  return LEPUS_Invoke(ctx, this_val, LEPUS_ATOM_then, 2, args);
}

QJS_STATIC LEPUSValue lepus_promise_finally_value_thunk(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  return LEPUS_DupValue(ctx, func_data[0]);
}

QJS_STATIC LEPUSValue lepus_promise_finally_thrower(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  return LEPUS_Throw(ctx, LEPUS_DupValue(ctx, func_data[0]));
}

QJS_STATIC LEPUSValue lepus_promise_then_finally_func(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  LEPUSValueConst ctor = func_data[0];
  LEPUSValueConst onFinally = func_data[1];
  LEPUSValue res, promise, resolving_funcs[2], ret, then_func;

  res = LEPUS_Call(ctx, onFinally, LEPUS_UNDEFINED, 0, NULL);
  if (LEPUS_IsException(res)) return res;

  promise = lepus_promise_resolve(ctx, ctor, 1, (LEPUSValueConst *)&res, 0);
  LEPUS_FreeValue(ctx, res);
  if (LEPUS_IsException(promise)) return promise;
  if (magic == 0) {
    then_func = LEPUS_NewCFunctionData(ctx, lepus_promise_finally_value_thunk,
                                       0, 0, 1, argv);
  } else {
    then_func = LEPUS_NewCFunctionData(ctx, lepus_promise_finally_thrower, 0, 0,
                                       1, argv);
  }
  if (LEPUS_IsException(then_func)) {
    LEPUS_FreeValue(ctx, promise);
    return then_func;
  }
  ret = LEPUS_InvokeFree(ctx, promise, LEPUS_ATOM_then, 1,
                         (LEPUSValueConst *)&then_func);
  LEPUS_FreeValue(ctx, then_func);
  return ret;
}

QJS_STATIC LEPUSValue lepus_promise_finally(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValueConst onFinally = argv[0];
  LEPUSValue ctor, ret;
  LEPUSValue then_funcs[2];
  LEPUSValueConst func_data[2];
  int i;

  ctor = LEPUS_SpeciesConstructor(ctx, this_val, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return ctor;
  if (!LEPUS_IsFunction(ctx, onFinally)) {
    then_funcs[0] = LEPUS_DupValue(ctx, onFinally);
    then_funcs[1] = LEPUS_DupValue(ctx, onFinally);
  } else {
    func_data[0] = ctor;
    func_data[1] = onFinally;
    for (i = 0; i < 2; i++) {
      then_funcs[i] = LEPUS_NewCFunctionData(
          ctx, lepus_promise_then_finally_func, 1, i, 2, func_data);
      if (LEPUS_IsException(then_funcs[i])) {
        if (i == 1) LEPUS_FreeValue(ctx, then_funcs[0]);
        LEPUS_FreeValue(ctx, ctor);
        return LEPUS_EXCEPTION;
      }
    }
  }
  LEPUS_FreeValue(ctx, ctor);
  ret = LEPUS_Invoke(ctx, this_val, LEPUS_ATOM_then, 2,
                     (LEPUSValueConst *)then_funcs);
  LEPUS_FreeValue(ctx, then_funcs[0]);
  LEPUS_FreeValue(ctx, then_funcs[1]);
  return ret;
}

static const LEPUSCFunctionListEntry lepus_promise_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("resolve", 1, lepus_promise_resolve, 0),
    LEPUS_CFUNC_MAGIC_DEF("reject", 1, lepus_promise_resolve, 1),
    LEPUS_CFUNC_MAGIC_DEF("all", 1, lepus_promise_all, PROMISE_MAGIC_all),
    LEPUS_CFUNC_MAGIC_DEF("allSettled", 1, lepus_promise_all,
                          PROMISE_MAGIC_allSettled),
    LEPUS_CFUNC_MAGIC_DEF("any", 1, lepus_promise_all, PROMISE_MAGIC_any),
    LEPUS_CFUNC_DEF("race", 1, lepus_promise_race),
    // LEPUS_CFUNC_DEF("__newPromiseCapability", 1,
    // lepus_promise___newPromiseCapability ),
    LEPUS_CGETSET_DEF("[Symbol.species]", lepus_get_this, NULL),
};

static const LEPUSCFunctionListEntry lepus_promise_proto_funcs[] = {
    LEPUS_CFUNC_DEF("then", 2, lepus_promise_then),
    LEPUS_CFUNC_DEF("catch", 1, lepus_promise_catch),
    LEPUS_CFUNC_DEF("finally", 1, lepus_promise_finally),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Promise",
                          LEPUS_PROP_CONFIGURABLE),
};

/* AsyncFunction */
static const LEPUSCFunctionListEntry lepus_async_function_proto_funcs[] = {
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "AsyncFunction",
                          LEPUS_PROP_CONFIGURABLE),
};

QJS_STATIC LEPUSValue lepus_async_from_async_iterator_unwrap(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic, LEPUSValue *func_data) {
  return lepus_create_iterator_result(ctx, LEPUS_DupValue(ctx, func_data[0]),
                                      LEPUS_ToBool(ctx, func_data[1]));
}

QJS_STATIC LEPUSValue lepus_async_from_async_iterator_unwrap_func_create(
    LEPUSContext *ctx, LEPUSValueConst value, BOOL done) {
  LEPUSValueConst func_data[2];

  func_data[0] = value;
  func_data[1] = (LEPUSValueConst)LEPUS_NewBool(ctx, done);
  return LEPUS_NewCFunctionData(ctx, lepus_async_from_async_iterator_unwrap, 0,
                                0, 2, func_data);
}

/* AsyncIteratorPrototype */

static const LEPUSCFunctionListEntry lepus_async_iterator_proto_funcs[] = {
    LEPUS_CFUNC_DEF("[Symbol.asyncIterator]", 0, lepus_iterator_proto_iterator),
};

/* AsyncFromSyncIteratorPrototype */

typedef struct LEPUSAsyncFromSyncIteratorData {
  LEPUSValue sync_iter;
  LEPUSValue next_method;
} LEPUSAsyncFromSyncIteratorData;

QJS_STATIC void lepus_async_from_sync_iterator_finalizer(LEPUSRuntime *rt,
                                                         LEPUSValue val) {
  LEPUSAsyncFromSyncIteratorData *s =
      static_cast<LEPUSAsyncFromSyncIteratorData *>(
          LEPUS_GetOpaque(val, LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR));
  if (s) {
    LEPUS_FreeValueRT(rt, s->sync_iter);
    LEPUS_FreeValueRT(rt, s->next_method);
    lepus_free_rt(rt, s);
  }
}

QJS_STATIC void lepus_async_from_sync_iterator_mark(LEPUSRuntime *rt,
                                                    LEPUSValueConst val,
                                                    LEPUS_MarkFunc *mark_func) {
  LEPUSAsyncFromSyncIteratorData *s =
      static_cast<LEPUSAsyncFromSyncIteratorData *>(
          LEPUS_GetOpaque(val, LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR));
  if (s) {
    LEPUS_MarkValue(rt, s->sync_iter, mark_func);
    LEPUS_MarkValue(rt, s->next_method, mark_func);
  }
}

QJS_STATIC LEPUSValue LEPUS_CreateAsyncFromSyncIterator(
    LEPUSContext *ctx, LEPUSValueConst sync_iter) {
  LEPUSValue async_iter, next_method;
  LEPUSAsyncFromSyncIteratorData *s;

  next_method = LEPUS_GetProperty(ctx, sync_iter, LEPUS_ATOM_next);
  if (LEPUS_IsException(next_method)) return LEPUS_EXCEPTION;
  async_iter = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR);
  if (LEPUS_IsException(async_iter)) {
    LEPUS_FreeValue(ctx, next_method);
    return async_iter;
  }
  s = static_cast<LEPUSAsyncFromSyncIteratorData *>(
      lepus_mallocz(ctx, sizeof(*s)));
  if (!s) {
    LEPUS_FreeValue(ctx, async_iter);
    LEPUS_FreeValue(ctx, next_method);
    return LEPUS_EXCEPTION;
  }
  s->sync_iter = LEPUS_DupValue(ctx, sync_iter);
  s->next_method = next_method;
  LEPUS_SetOpaque(async_iter, s);
  return async_iter;
}

QJS_STATIC LEPUSValue lepus_async_from_sync_iterator_next(
    LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
    LEPUSValueConst *argv, int magic) {
  LEPUSValue promise, resolving_funcs[2], value, err, method;
  LEPUSAsyncFromSyncIteratorData *s;
  int done;
  int is_reject;

  promise = LEPUS_NewPromiseCapability(ctx, resolving_funcs);
  if (LEPUS_IsException(promise)) return LEPUS_EXCEPTION;
  s = static_cast<LEPUSAsyncFromSyncIteratorData *>(
      LEPUS_GetOpaque(this_val, LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR));
  if (!s) {
    LEPUS_ThrowTypeError(ctx, "not an Async-from-Sync Iterator");
    goto reject;
  }

  if (magic == GEN_MAGIC_NEXT) {
    method = LEPUS_DupValue(ctx, s->next_method);
  } else {
    method = LEPUS_GetProperty(
        ctx, s->sync_iter,
        magic == GEN_MAGIC_RETURN ? LEPUS_ATOM_return : LEPUS_ATOM_throw);
    if (LEPUS_IsException(method)) goto reject;
    if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
      if (magic == GEN_MAGIC_RETURN) {
        err = lepus_create_iterator_result(ctx, LEPUS_DupValue(ctx, argv[0]),
                                           TRUE);
        is_reject = 0;
      } else {
        err = LEPUS_DupValue(ctx, argv[0]);
        is_reject = 1;
      }
      goto done_resolve;
    }
  }
  value = LEPUS_IteratorNext2(ctx, s->sync_iter, method, 1, argv, &done);
  LEPUS_FreeValue(ctx, method);
  if (LEPUS_IsException(value)) goto reject;
  if (done == 2) {
    LEPUSValue obj = value;
    value = LEPUS_IteratorGetCompleteValue(ctx, obj, &done);
    LEPUS_FreeValue(ctx, obj);
    if (LEPUS_IsException(value)) goto reject;
  }

  if (LEPUS_IsException(value)) {
    LEPUSValue res2;
  reject:
    err = LEPUS_GetException(ctx);
    is_reject = 1;
  done_resolve:
    res2 = LEPUS_Call(ctx, resolving_funcs[is_reject], LEPUS_UNDEFINED, 1,
                      (LEPUSValueConst *)&err);
    LEPUS_FreeValue(ctx, err);
    LEPUS_FreeValue(ctx, res2);
    LEPUS_FreeValue(ctx, resolving_funcs[0]);
    LEPUS_FreeValue(ctx, resolving_funcs[1]);
    return promise;
  }
  {
    LEPUSValue value_wrapper_promise, resolve_reject[2];
    int res;

    value_wrapper_promise = lepus_promise_resolve(ctx, ctx->promise_ctor, 1,
                                                  (LEPUSValueConst *)&value, 0);
    if (LEPUS_IsException(value_wrapper_promise)) {
      LEPUS_FreeValue(ctx, value);
      goto reject;
    }

    resolve_reject[0] =
        lepus_async_from_async_iterator_unwrap_func_create(ctx, value, done);
    if (LEPUS_IsException(resolve_reject[0])) {
      LEPUS_FreeValue(ctx, value_wrapper_promise);
      goto fail;
    }
    LEPUS_FreeValue(ctx, value);
    resolve_reject[1] = LEPUS_UNDEFINED;

    res = perform_promise_then(ctx, value_wrapper_promise,
                               (LEPUSValueConst *)resolve_reject,
                               (LEPUSValueConst *)resolving_funcs);
    LEPUS_FreeValue(ctx, resolve_reject[0]);
    LEPUS_FreeValue(ctx, value_wrapper_promise);
    LEPUS_FreeValue(ctx, resolving_funcs[0]);
    LEPUS_FreeValue(ctx, resolving_funcs[1]);
    if (res) {
      LEPUS_FreeValue(ctx, promise);
      return LEPUS_EXCEPTION;
    }
  }
  return promise;
fail:
  LEPUS_FreeValue(ctx, value);
  LEPUS_FreeValue(ctx, resolving_funcs[0]);
  LEPUS_FreeValue(ctx, resolving_funcs[1]);
  LEPUS_FreeValue(ctx, promise);
  return LEPUS_EXCEPTION;
}

static const LEPUSCFunctionListEntry
    lepus_async_from_sync_iterator_proto_funcs[] = {
        LEPUS_CFUNC_MAGIC_DEF("next", 1, lepus_async_from_sync_iterator_next,
                              GEN_MAGIC_NEXT),
        LEPUS_CFUNC_MAGIC_DEF("return", 1, lepus_async_from_sync_iterator_next,
                              GEN_MAGIC_RETURN),
        LEPUS_CFUNC_MAGIC_DEF("throw", 1, lepus_async_from_sync_iterator_next,
                              GEN_MAGIC_THROW),
    };

/* AsyncGeneratorFunction */

static const LEPUSCFunctionListEntry
    lepus_async_generator_function_proto_funcs[] = {
        LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "AsyncGeneratorFunction",
                              LEPUS_PROP_CONFIGURABLE),
    };

/* AsyncGenerator prototype */

static const LEPUSCFunctionListEntry lepus_async_generator_proto_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("next", 1, lepus_async_generator_next,
                          GEN_MAGIC_NEXT),
    LEPUS_CFUNC_MAGIC_DEF("return", 1, lepus_async_generator_next,
                          GEN_MAGIC_RETURN),
    LEPUS_CFUNC_MAGIC_DEF("throw", 1, lepus_async_generator_next,
                          GEN_MAGIC_THROW),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "AsyncGenerator",
                          LEPUS_PROP_CONFIGURABLE),
};

static LEPUSClassShortDef const lepus_async_class_def[] = {
    {LEPUS_ATOM_Promise, lepus_promise_finalizer,
     lepus_promise_mark}, /* LEPUS_CLASS_PROMISE */
    {LEPUS_ATOM_PromiseResolveFunction,
     lepus_promise_resolve_function_finalizer,
     lepus_promise_resolve_function_mark}, /* LEPUS_CLASS_PROMISE_RESOLVE_FUNCTION
                                            */
    {LEPUS_ATOM_PromiseRejectFunction, lepus_promise_resolve_function_finalizer,
     lepus_promise_resolve_function_mark}, /* LEPUS_CLASS_PROMISE_REJECT_FUNCTION
                                            */
    {LEPUS_ATOM_AsyncFunction, lepus_bytecode_function_finalizer,
     lepus_bytecode_function_mark}, /* LEPUS_CLASS_ASYNC_FUNCTION */
    {LEPUS_ATOM_AsyncFunctionResolve, lepus_async_function_resolve_finalizer,
     lepus_async_function_resolve_mark}, /* LEPUS_CLASS_ASYNC_FUNCTION_RESOLVE
                                          */
    {LEPUS_ATOM_AsyncFunctionReject, lepus_async_function_resolve_finalizer,
     lepus_async_function_resolve_mark}, /* LEPUS_CLASS_ASYNC_FUNCTION_REJECT */
    {LEPUS_ATOM_empty_string, lepus_async_from_sync_iterator_finalizer,
     lepus_async_from_sync_iterator_mark}, /* LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR
                                            */
    {LEPUS_ATOM_AsyncGeneratorFunction, lepus_bytecode_function_finalizer,
     lepus_bytecode_function_mark}, /* LEPUS_CLASS_ASYNC_GENERATOR_FUNCTION */
    {LEPUS_ATOM_AsyncGenerator, lepus_async_generator_finalizer,
     lepus_async_generator_mark}, /* LEPUS_CLASS_ASYNC_GENERATOR */
};

void LEPUS_AddIntrinsicPromise(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
  LEPUSValue obj1;

  if (!LEPUS_IsRegisteredClass(rt, LEPUS_CLASS_PROMISE)) {
    init_class_range(rt, lepus_async_class_def, LEPUS_CLASS_PROMISE,
                     countof(lepus_async_class_def));
    rt->class_array[LEPUS_CLASS_PROMISE_RESOLVE_FUNCTION].call =
        lepus_promise_resolve_function_call;
    rt->class_array[LEPUS_CLASS_PROMISE_REJECT_FUNCTION].call =
        lepus_promise_resolve_function_call;
    rt->class_array[LEPUS_CLASS_ASYNC_FUNCTION].call =
        lepus_async_function_call;
    rt->class_array[LEPUS_CLASS_ASYNC_FUNCTION_RESOLVE].call =
        lepus_async_function_resolve_call;
    rt->class_array[LEPUS_CLASS_ASYNC_FUNCTION_REJECT].call =
        lepus_async_function_resolve_call;
    rt->class_array[LEPUS_CLASS_ASYNC_GENERATOR_FUNCTION].call =
        lepus_async_generator_function_call;
  }

  /* Promise */
  ctx->class_proto[LEPUS_CLASS_PROMISE] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_PROMISE],
                                lepus_promise_proto_funcs,
                                countof(lepus_promise_proto_funcs));
  obj1 = LEPUS_NewCFunction2(ctx, lepus_promise_constructor, "Promise", 1,
                             LEPUS_CFUNC_constructor, 0);
  ctx->promise_ctor = LEPUS_DupValue(ctx, obj1);
  LEPUS_SetPropertyFunctionList(ctx, obj1, lepus_promise_funcs,
                                countof(lepus_promise_funcs));
  LEPUS_NewGlobalCConstructor2(ctx, obj1, "Promise",
                               ctx->class_proto[LEPUS_CLASS_PROMISE]);

  /* AsyncFunction */
  ctx->class_proto[LEPUS_CLASS_ASYNC_FUNCTION] =
      LEPUS_NewObjectProto(ctx, ctx->function_proto);
  obj1 = LEPUS_NewCFunction3(ctx, (LEPUSCFunction *)lepus_function_constructor,
                             "AsyncFunction", 1,
                             LEPUS_CFUNC_constructor_or_func_magic,
                             LEPUS_FUNC_ASYNC, ctx->function_ctor);
  LEPUS_SetPropertyFunctionList(ctx,
                                ctx->class_proto[LEPUS_CLASS_ASYNC_FUNCTION],
                                lepus_async_function_proto_funcs,
                                countof(lepus_async_function_proto_funcs));
  LEPUS_SetConstructor2(ctx, obj1, ctx->class_proto[LEPUS_CLASS_ASYNC_FUNCTION],
                        0, LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(ctx, obj1);

  /* AsyncIteratorPrototype */
  ctx->async_iterator_proto = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->async_iterator_proto,
                                lepus_async_iterator_proto_funcs,
                                countof(lepus_async_iterator_proto_funcs));

  /* AsyncFromSyncIteratorPrototype */
  ctx->class_proto[LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->async_iterator_proto);
  LEPUS_SetPropertyFunctionList(
      ctx, ctx->class_proto[LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR],
      lepus_async_from_sync_iterator_proto_funcs,
      countof(lepus_async_from_sync_iterator_proto_funcs));

  /* AsyncGeneratorPrototype */
  ctx->class_proto[LEPUS_CLASS_ASYNC_GENERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->async_iterator_proto);
  LEPUS_SetPropertyFunctionList(ctx,
                                ctx->class_proto[LEPUS_CLASS_ASYNC_GENERATOR],
                                lepus_async_generator_proto_funcs,
                                countof(lepus_async_generator_proto_funcs));

  /* AsyncGeneratorFunction */
  ctx->class_proto[LEPUS_CLASS_ASYNC_GENERATOR_FUNCTION] =
      LEPUS_NewObjectProto(ctx, ctx->function_proto);
  obj1 = LEPUS_NewCFunction3(ctx, (LEPUSCFunction *)lepus_function_constructor,
                             "AsyncGeneratorFunction", 1,
                             LEPUS_CFUNC_constructor_or_func_magic,
                             LEPUS_FUNC_ASYNC_GENERATOR, ctx->function_ctor);
  LEPUS_SetPropertyFunctionList(
      ctx, ctx->class_proto[LEPUS_CLASS_ASYNC_GENERATOR_FUNCTION],
      lepus_async_generator_function_proto_funcs,
      countof(lepus_async_generator_function_proto_funcs));
  LEPUS_SetConstructor2(ctx,
                        ctx->class_proto[LEPUS_CLASS_ASYNC_GENERATOR_FUNCTION],
                        ctx->class_proto[LEPUS_CLASS_ASYNC_GENERATOR],
                        LEPUS_PROP_CONFIGURABLE, LEPUS_PROP_CONFIGURABLE);
  LEPUS_SetConstructor2(ctx, obj1,
                        ctx->class_proto[LEPUS_CLASS_ASYNC_GENERATOR_FUNCTION],
                        0, LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(ctx, obj1);
}

/* URI handling */

QJS_STATIC int string_get_hex(LEPUSString *p, int k, int n) {
  int c = 0, h;
  while (n-- > 0) {
    if ((h = from_hex(string_get(p, k++))) < 0) return -1;
    c = (c << 4) | h;
  }
  return c;
}

QJS_STATIC int isURIReserved(int c) {
  return c < 0x100 &&
         memchr(";/?:@&=+$,#", c, sizeof(";/?:@&=+$,#") - 1) != NULL;
}

QJS_STATIC int __attribute__((format(printf, 2, 3)))
lepus_throw_URIError(LEPUSContext *ctx, const char *fmt, ...) {
  va_list ap;

  va_start(ap, fmt);
  LEPUS_ThrowError(ctx, LEPUS_URI_ERROR, fmt, ap);
  va_end(ap);
  return -1;
}

QJS_STATIC int hex_decode(LEPUSContext *ctx, LEPUSString *p, int k) {
  int c;

  if (k >= p->len || string_get(p, k) != '%')
    return lepus_throw_URIError(ctx, "expecting %%");
  if (k + 2 >= p->len || (c = string_get_hex(p, k + 1, 2)) < 0)
    return lepus_throw_URIError(ctx, "expecting hex digit");

  return c;
}

QJS_STATIC LEPUSValue lepus_global_decodeURI(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv,
                                             int isComponent) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *p;
  int k, c, c1, n, c_min;

  str = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(str)) return str;

  string_buffer_init(ctx, b, 0);

  p = LEPUS_VALUE_GET_STRING(str);
  for (k = 0; k < p->len;) {
    c = string_get(p, k);
    if (c == '%') {
      c = hex_decode(ctx, p, k);
      if (c < 0) goto fail;
      k += 3;
      if (c < 0x80) {
        if (!isComponent && isURIReserved(c)) {
          c = '%';
          k -= 2;
        }
      } else {
        /* Decode URI-encoded UTF-8 sequence */
        if (c >= 0xc0 && c <= 0xdf) {
          n = 1;
          c_min = 0x80;
          c &= 0x1f;
        } else if (c >= 0xe0 && c <= 0xef) {
          n = 2;
          c_min = 0x800;
          c &= 0xf;
        } else if (c >= 0xf0 && c <= 0xf7) {
          n = 3;
          c_min = 0x10000;
          c &= 0x7;
        } else {
          n = 0;
          c_min = 1;
          c = 0;
        }
        while (n-- > 0) {
          c1 = hex_decode(ctx, p, k);
          if (c1 < 0) goto fail;
          k += 3;
          if ((c1 & 0xc0) != 0x80) {
            c = 0;
            break;
          }
          c = (c << 6) | (c1 & 0x3f);
        }
        if (c < c_min || c > 0x10FFFF) {
          lepus_throw_URIError(ctx, "malformed UTF-8");
          goto fail;
        }
      }
    } else {
      k++;
    }
    string_buffer_putc(b, c);
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

fail:
  LEPUS_FreeValue(ctx, str);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC int isUnescaped(int c) {
  static char const unescaped_chars[] =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      "abcdefghijklmnopqrstuvwxyz"
      "0123456789"
      "@*_+-./";
  return c < 0x100 && memchr(unescaped_chars, c, sizeof(unescaped_chars) - 1);
}

QJS_STATIC int isURIUnescaped(int c, int isComponent) {
  return c < 0x100 &&
         ((c >= 0x61 && c <= 0x7a) || (c >= 0x41 && c <= 0x5a) ||
          (c >= 0x30 && c <= 0x39) ||
          memchr("-_.!~*'()", c, sizeof("-_.!~*'()") - 1) != NULL ||
          (!isComponent && isURIReserved(c)));
}

QJS_STATIC int encodeURI_hex(StringBuffer *b, int c) {
  uint8_t buf[6];
  int n = 0;
  const char *hex = "0123456789ABCDEF";

  buf[n++] = '%';
  if (c >= 256) {
    buf[n++] = 'u';
    buf[n++] = hex[(c >> 12) & 15];
    buf[n++] = hex[(c >> 8) & 15];
  }
  buf[n++] = hex[(c >> 4) & 15];
  buf[n++] = hex[(c >> 0) & 15];
  return string_buffer_write8(b, buf, n);
}

QJS_STATIC LEPUSValue lepus_global_encodeURI(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv,
                                             int isComponent) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *p;
  int k, c, c1;

  str = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(str)) return str;

  p = LEPUS_VALUE_GET_STRING(str);
  string_buffer_init(ctx, b, p->len);
  for (k = 0; k < p->len;) {
    c = string_get(p, k);
    k++;
    if (isURIUnescaped(c, isComponent)) {
      string_buffer_putc16(b, c);
    } else {
      if (c >= 0xdc00 && c <= 0xdfff) {
        lepus_throw_URIError(ctx, "invalid character");
        goto fail;
      } else if (c >= 0xd800 && c <= 0xdbff) {
        if (k >= p->len) {
          lepus_throw_URIError(ctx, "expecting surrogate pair");
          goto fail;
        }
        c1 = string_get(p, k);
        k++;
        if (c1 < 0xdc00 || c1 > 0xdfff) {
          lepus_throw_URIError(ctx, "expecting surrogate pair");
          goto fail;
        }
        c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
      }
      if (c < 0x80) {
        encodeURI_hex(b, c);
      } else {
        /* XXX: use C UTF-8 conversion ? */
        if (c < 0x800) {
          encodeURI_hex(b, (c >> 6) | 0xc0);
        } else {
          if (c < 0x10000) {
            encodeURI_hex(b, (c >> 12) | 0xe0);
          } else {
            encodeURI_hex(b, (c >> 18) | 0xf0);
            encodeURI_hex(b, ((c >> 12) & 0x3f) | 0x80);
          }
          encodeURI_hex(b, ((c >> 6) & 0x3f) | 0x80);
        }
        encodeURI_hex(b, (c & 0x3f) | 0x80);
      }
    }
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);

fail:
  LEPUS_FreeValue(ctx, str);
  string_buffer_free(b);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_global_escape(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *p;
  int i, len, c;

  str = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(str)) return str;

  p = LEPUS_VALUE_GET_STRING(str);
  string_buffer_init(ctx, b, p->len);
  for (i = 0, len = p->len; i < len; i++) {
    c = string_get(p, i);
    if (isUnescaped(c)) {
      string_buffer_putc16(b, c);
    } else {
      encodeURI_hex(b, c);
    }
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);
}

QJS_STATIC LEPUSValue lepus_global_unescape(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValue str;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *p;
  int i, len, c, n;

  str = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(str)) return str;

  string_buffer_init(ctx, b, 0);
  p = LEPUS_VALUE_GET_STRING(str);
  for (i = 0, len = p->len; i < len; i++) {
    c = string_get(p, i);
    if (c == '%') {
      if (i + 6 <= len && string_get(p, i + 1) == 'u' &&
          (n = string_get_hex(p, i + 2, 4)) >= 0) {
        c = n;
        i += 6 - 1;
      } else if (i + 3 <= len && (n = string_get_hex(p, i + 1, 2)) >= 0) {
        c = n;
        i += 3 - 1;
      }
    }
    string_buffer_putc16(b, c);
  }
  LEPUS_FreeValue(ctx, str);
  return string_buffer_end(b);
}

/* global object */

static LEPUSCFunctionListEntry lepus_global_funcs[] = {
    LEPUS_CFUNC_DEF("parseInt", 2, lepus_parseInt),
    LEPUS_CFUNC_DEF("parseFloat", 1, lepus_parseFloat),
    LEPUS_CFUNC_DEF("isNaN", 1, lepus_global_isNaN),
    LEPUS_CFUNC_DEF("isFinite", 1, lepus_global_isFinite),

    LEPUS_CFUNC_MAGIC_DEF("decodeURI", 1, lepus_global_decodeURI, 0),
    LEPUS_CFUNC_MAGIC_DEF("decodeURIComponent", 1, lepus_global_decodeURI, 1),
    LEPUS_CFUNC_MAGIC_DEF("encodeURI", 1, lepus_global_encodeURI, 0),
    LEPUS_CFUNC_MAGIC_DEF("encodeURIComponent", 1, lepus_global_encodeURI, 1),
    LEPUS_CFUNC_DEF("escape", 1, lepus_global_escape),
    LEPUS_CFUNC_DEF("unescape", 1, lepus_global_unescape),
    LEPUS_PROP_DOUBLE_DEF("Infinity", 1.0 / 0.0, 0),
    LEPUS_PROP_DOUBLE_DEF("NaN", LEPUS_FLOAT64_NAN, 0),
    LEPUS_PROP_UNDEFINED_DEF("undefined", 0),

    /* for the 'Date' implementation */
    LEPUS_CFUNC_DEF("__date_clock", 0, lepus___date_clock),
    // LEPUS_CFUNC_DEF("__date_now", 0, lepus___date_now ),
    // LEPUS_CFUNC_DEF("__date_getTimezoneOffset", 1,
    // lepus___date_getTimezoneOffset
    // ), LEPUS_CFUNC_DEF("__date_create", 3, lepus___date_create ),
};

/* Date */

QJS_STATIC int64_t math_mod(int64_t a, int64_t b) {
  /* return positive modulo */
  int64_t m = a % b;
  return m + (m < 0) * b;
}

QJS_STATIC int64_t floor_div(int64_t a, int64_t b) {
  /* integer division rounding toward -Infinity */
  int64_t m = a % b;
  return (a - (m + (m < 0) * b)) / b;
}

QJS_STATIC LEPUSValue lepus_Date_parse(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv);

QJS_STATIC __exception int LEPUS_ThisTimeValue(LEPUSContext *ctx, double *valp,
                                               LEPUSValueConst this_val) {
  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == LEPUS_CLASS_DATE && LEPUS_IsNumber(p->u.object_data))
      return LEPUS_ToFloat64(ctx, valp, p->u.object_data);
  }
  LEPUS_ThrowTypeError(ctx, "not a Date object");
  return -1;
}

QJS_STATIC LEPUSValue LEPUS_SetThisTimeValue(LEPUSContext *ctx,
                                             LEPUSValueConst this_val,
                                             double v) {
  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == LEPUS_CLASS_DATE) {
      LEPUS_FreeValue(ctx, p->u.object_data);
      p->u.object_data = __JS_NewFloat64(ctx, v);
      return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a Date object");
}

QJS_STATIC int64_t days_from_year(int64_t y) {
  return 365 * (y - 1970) + floor_div(y - 1969, 4) - floor_div(y - 1901, 100) +
         floor_div(y - 1601, 400);
}

QJS_STATIC int64_t days_in_year(int64_t y) {
  return 365 + !(y % 4) - !(y % 100) + !(y % 400);
}

/* return the year, update days */
QJS_STATIC int64_t year_from_days(int64_t *days) {
  int64_t y, d1, nd, d = *days;
  y = floor_div(d * 10000, 3652425) + 1970;
  /* the initial approximation is very good, so only a few
     iterations are necessary */
  for (;;) {
    d1 = d - days_from_year(y);
    if (d1 < 0) {
      y--;
      d1 += days_in_year(y);
    } else {
      nd = days_in_year(y);
      if (d1 < nd) break;
      d1 -= nd;
      y++;
    }
  }
  *days = d1;
  return y;
}

static int const month_days[] = {31, 28, 31, 30, 31, 30,
                                 31, 31, 30, 31, 30, 31};
static char const month_names[] = "JanFebMarAprMayJunJulAugSepOctNovDec";
static char const day_names[] = "SunMonTueWedThuFriSat";

QJS_STATIC __exception int get_date_fields(LEPUSContext *ctx,
                                           LEPUSValueConst obj,
                                           double fields[9], int is_local,
                                           int force) {
  double dval;
  int64_t d, days, wd, y, i, md, h, m, s, ms, tz = 0;

  if (LEPUS_ThisTimeValue(ctx, &dval, obj)) return -1;

  if (isnan(dval)) {
    if (!force) return FALSE; /* NaN */
    d = 0;                    /* initialize all fields to 0 */
  } else {
    d = dval;
    if (is_local) {
      tz = -getTimezoneOffset(d);
      d += tz * 60000;
    }
  }

  /* result is >= 0, we can use % */
  h = math_mod(d, 86400000);
  days = (d - h) / 86400000;
  ms = h % 1000;
  h = (h - ms) / 1000;
  s = h % 60;
  h = (h - s) / 60;
  m = h % 60;
  h = (h - m) / 60;
  wd = math_mod(days + 4, 7); /* week day */
  y = year_from_days(&days);

  for (i = 0; i < 11; i++) {
    md = month_days[i];
    if (i == 1) md += days_in_year(y) - 365;
    if (days < md) break;
    days -= md;
  }
  fields[0] = y;
  fields[1] = i;
  fields[2] = days + 1;
  fields[3] = h;
  fields[4] = m;
  fields[5] = s;
  fields[6] = ms;
  fields[7] = wd;
  fields[8] = tz;
  return TRUE;
}

QJS_STATIC double time_clip(double t) {
  if (t >= -8.64e15 && t <= 8.64e15)
    return trunc(t) + 0.0; /* convert -0 to +0 */
  else
    return LEPUS_FLOAT64_NAN;
}

QJS_STATIC double set_date_fields(double fields[], int is_local) {
  int64_t y;
  double days, d, h, m1;
  int i, m, md;

  m1 = fields[1];
  m = fmod(m1, 12);
  if (m < 0) m += 12;
  y = (int64_t)(fields[0] + floor(m1 / 12));
  days = days_from_year(y);

  for (i = 0; i < m; i++) {
    md = month_days[i];
    if (i == 1) md += days_in_year(y) - 365;
    days += md;
  }
  days += fields[2] - 1;
  h = fields[3] * 3600000 + fields[4] * 60000 + fields[5] * 1000 + fields[6];
  d = days * 86400000 + h;
  if (is_local) d += getTimezoneOffset(d) * 60000;
  return time_clip(d);
}

QJS_STATIC LEPUSValue get_date_field(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int magic) {
  // get_date_field(obj, n, is_local)
  double fields[9];
  int res, n, is_local;

  is_local = magic & 0x0F;
  n = (magic >> 4) & 0x0F;
  res = get_date_fields(ctx, this_val, fields, is_local, 0);
  if (res < 0) return LEPUS_EXCEPTION;
  if (!res) return LEPUS_NAN;

  if (magic & 0x100) {  // getYear
    fields[0] -= 1900;
  }
  return LEPUS_NewFloat64(ctx, fields[n]);
}

QJS_STATIC LEPUSValue set_date_field(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int magic) {
  // _field(obj, first_field, end_field, args, is_local)
  double fields[9];
  int res, first_field, end_field, is_local, i, n;
  double d, a;

  d = LEPUS_FLOAT64_NAN;
  first_field = (magic >> 8) & 0x0F;
  end_field = (magic >> 4) & 0x0F;
  is_local = magic & 0x0F;

  res = get_date_fields(ctx, this_val, fields, is_local, first_field == 0);
  if (res < 0) return LEPUS_EXCEPTION;
  if (res && argc > 0) {
    n = end_field - first_field;
    if (argc < n) n = argc;
    for (i = 0; i < n; i++) {
      if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
      if (!isfinite(a)) goto done;
      fields[first_field + i] = trunc(a);
    }
    d = set_date_fields(fields, is_local);
  }
done:
  return LEPUS_SetThisTimeValue(ctx, this_val, d);
}

/* fmt:
   0: toUTCString: "Tue, 02 Jan 2018 23:04:46 GMT"
   1: toString: "Wed Jan 03 2018 00:05:22 GMT+0100 (CET)"
   2: toISOString: "2018-01-02T23:02:56.927Z"
   3: toLocaleString: "1/2/2018, 11:40:40 PM"
   part: 1=date, 2=time 3=all
   XXX: should use a variant of strftime().
 */
QJS_HIDE LEPUSValue get_date_string(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int magic) {
  // _string(obj, fmt, part)
  char buf[64];
  double fields[9];
  int res, fmt, part, pos;
  int y, mon, d, h, m, s, ms, wd, tz;

  fmt = (magic >> 4) & 0x0F;
  part = magic & 0x0F;

  res = get_date_fields(ctx, this_val, fields, fmt & 1, 0);
  if (res < 0) return LEPUS_EXCEPTION;
  if (!res) {
    if (fmt == 2)
      return LEPUS_ThrowRangeError(ctx, "Date value is NaN");
    else
      return LEPUS_NewString(ctx, "Invalid Date");
  }

  y = fields[0];
  mon = fields[1];
  d = fields[2];
  h = fields[3];
  m = fields[4];
  s = fields[5];
  ms = fields[6];
  wd = fields[7];
  tz = fields[8];

  pos = 0;

  if (part & 1) { /* date part */
    switch (fmt) {
      case 0:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%.3s, %02d %.3s %0*d ",
                        day_names + wd * 3, d, month_names + mon * 3,
                        4 + (y < 0), y);
        break;
      case 1:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%.3s %.3s %02d %0*d",
                        day_names + wd * 3, month_names + mon * 3, d,
                        4 + (y < 0), y);
        if (part == 3) {
          buf[pos++] = ' ';
        }
        break;
      case 2:
        if (y >= 0 && y <= 9999) {
          pos += snprintf(buf + pos, sizeof(buf) - pos, "%04d", y);
        } else {
          pos += snprintf(buf + pos, sizeof(buf) - pos, "%+07d", y);
        }
        pos +=
            snprintf(buf + pos, sizeof(buf) - pos, "-%02d-%02dT", mon + 1, d);
        break;
      case 3:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d/%02d/%0*d", mon + 1,
                        d, 4 + (y < 0), y);
        if (part == 3) {
          buf[pos++] = ',';
          buf[pos++] = ' ';
        }
        break;
    }
  }
  if (part & 2) { /* time part */
    switch (fmt) {
      case 0:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d:%02d:%02d GMT", h,
                        m, s);
        break;
      case 1:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d:%02d:%02d GMT", h,
                        m, s);
        if (tz < 0) {
          buf[pos++] = '-';
          tz = -tz;
        } else {
          buf[pos++] = '+';
        }
        /* tz is >= 0, can use % */
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d%02d", tz / 60,
                        tz % 60);
        /* XXX: tack the time zone code? */
        break;
      case 2:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d:%02d:%02d.%03dZ", h,
                        m, s, ms);
        break;
      case 3:
        pos += snprintf(buf + pos, sizeof(buf) - pos, "%02d:%02d:%02d %cM",
                        (h + 1) % 12 - 1, m, s, (h < 12) ? 'A' : 'P');
        break;
    }
  }
  return LEPUS_NewStringLen(ctx, buf, pos);
}

/* OS dependent: return the UTC time in ms since 1970. */
QJS_STATIC int64_t date_now(void) {
  struct timeval tv;
  gettimeofday(&tv, NULL);
  return (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);
}

QJS_STATIC LEPUSValue lepus_date_constructor(LEPUSContext *ctx,
                                             LEPUSValueConst new_target,
                                             int argc, LEPUSValueConst *argv) {
  // Date(y, mon, d, h, m, s, ms)
  LEPUSValue rv;
  int i, n;
  double a, val;

  if (LEPUS_IsUndefined(new_target)) {
    /* invoked as function */
    argc = 0;
  }
  n = argc;
  if (n == 0) {
    val = date_now();
  } else if (n == 1) {
    LEPUSValue v, dv;
    if (LEPUS_VALUE_IS_OBJECT(argv[0])) {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(argv[0]);
      if (p->class_id == LEPUS_CLASS_DATE && LEPUS_IsNumber(p->u.object_data)) {
        if (LEPUS_ToFloat64(ctx, &val, p->u.object_data))
          return LEPUS_EXCEPTION;
        val = time_clip(val);
        goto has_val;
      }
    }
    v = LEPUS_ToPrimitive(ctx, argv[0], HINT_NONE);
    if (LEPUS_IsString(v)) {
      dv = lepus_Date_parse(ctx, LEPUS_UNDEFINED, 1, (LEPUSValueConst *)&v);
      LEPUS_FreeValue(ctx, v);
      if (LEPUS_IsException(dv)) return LEPUS_EXCEPTION;
      if (LEPUS_ToFloat64Free(ctx, &val, dv)) return LEPUS_EXCEPTION;
    } else {
      if (LEPUS_ToFloat64Free(ctx, &val, v)) return LEPUS_EXCEPTION;
    }
    val = time_clip(val);
  } else {
    double fields[] = {0, 0, 1, 0, 0, 0, 0};
    if (n > 7) n = 7;
    for (i = 0; i < n; i++) {
      if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
      if (!isfinite(a)) break;
      fields[i] = trunc(a);
      if (i == 0 && fields[0] >= 0 && fields[0] < 100) fields[0] += 1900;
    }
    val = (i == n) ? set_date_fields(fields, 1) : LEPUS_FLOAT64_NAN;
  }
has_val:
#if 0
    LEPUSValueConst args[3];
    args[0] = new_target;
    args[1] = ctx->class_proto[LEPUS_CLASS_DATE];
    args[2] = __JS_NewFloat64(ctx, val);
    rv = lepus___date_create(ctx, LEPUS_UNDEFINED, 3, args);
#else
  rv = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_DATE);
  if (!LEPUS_IsException(rv))
    LEPUS_SetObjectData(ctx, rv, __JS_NewFloat64(ctx, val));
#endif
  if (!LEPUS_IsException(rv) && LEPUS_IsUndefined(new_target)) {
    /* invoked as a function, return (new Date()).toString(); */
    LEPUSValue s;
    s = get_date_string(ctx, rv, 0, NULL, 0x13);
    LEPUS_FreeValue(ctx, rv);
    rv = s;
  }
  return rv;
}

QJS_STATIC LEPUSValue lepus_Date_UTC(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  // UTC(y, mon, d, h, m, s, ms)
  double fields[] = {0, 0, 1, 0, 0, 0, 0};
  int i, n;
  double a;

  n = argc;
  if (n == 0) return LEPUS_NAN;
  if (n > 7) n = 7;
  for (i = 0; i < n; i++) {
    if (LEPUS_ToFloat64(ctx, &a, argv[i])) return LEPUS_EXCEPTION;
    if (!isfinite(a)) return LEPUS_NAN;
    fields[i] = trunc(a);
    if (i == 0 && fields[0] >= 0 && fields[0] < 100) fields[0] += 1900;
  }
  return LEPUS_NewFloat64(ctx, set_date_fields(fields, 0));
}

QJS_STATIC void string_skip_spaces(LEPUSString *sp, int *pp) {
  while (*pp < sp->len && string_get(sp, *pp) == ' ') *pp += 1;
}

QJS_STATIC void string_skip_non_spaces(LEPUSString *sp, int *pp) {
  while (*pp < sp->len && string_get(sp, *pp) != ' ') *pp += 1;
}

/* parse a numeric field */
QJS_STATIC int string_get_field(LEPUSString *sp, int *pp, int64_t *pval) {
  int64_t v = 0;
  int c, p = *pp;

  /* skip non digits, should only skip spaces? */
  while (p < sp->len) {
    c = string_get(sp, p);
    if (c >= '0' && c <= '9') break;
    p++;
  }
  if (p >= sp->len) return -1;
  while (p < sp->len) {
    c = string_get(sp, p);
    if (!(c >= '0' && c <= '9')) break;
    v = v * 10 + c - '0';
    p++;
  }
  *pval = v;
  *pp = p;
  return 0;
}

/* parse a fixed width numeric field */
QJS_STATIC int string_get_digits(LEPUSString *sp, int *pp, int n,
                                 int64_t *pval) {
  int64_t v = 0;
  int i, c, p = *pp;

  for (i = 0; i < n; i++) {
    if (p >= sp->len) return -1;
    c = string_get(sp, p);
    if (!(c >= '0' && c <= '9')) return -1;
    v = v * 10 + c - '0';
    p++;
  }
  *pval = v;
  *pp = p;
  return 0;
}

/* parse a signed numeric field */
QJS_STATIC int string_get_signed_field(LEPUSString *sp, int *pp,
                                       int64_t *pval) {
  int sgn, res;

  if (*pp >= sp->len) return -1;

  sgn = string_get(sp, *pp);
  if (sgn == '-' || sgn == '+') *pp += 1;

  res = string_get_field(sp, pp, pval);
  if (res == 0 && sgn == '-') *pval = -*pval;
  return res;
}

QJS_STATIC int find_abbrev(LEPUSString *sp, int p, const char *list,
                           int count) {
  int n, i;

  if (p + 3 <= sp->len) {
    for (n = 0; n < count; n++) {
      for (i = 0; i < 3; i++) {
        if (string_get(sp, p + i) != month_names[n * 3 + i]) goto next;
      }
      return n;
    next:;
    }
  }
  return -1;
}

QJS_STATIC int string_get_month(LEPUSString *sp, int *pp, int64_t *pval) {
  int n;

  string_skip_spaces(sp, pp);
  n = find_abbrev(sp, *pp, month_names, 12);
  if (n < 0) return -1;

  *pval = n;
  *pp += 3;
  return 0;
}

QJS_STATIC LEPUSValue lepus_Date_parse(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  // parse(s)
  LEPUSValue s, rv;
  int64_t fields[] = {0, 1, 1, 0, 0, 0, 0};
  double fields1[7];
  int64_t tz, hh, mm;
  double d;
  int p, i, c, sgn;
  LEPUSString *sp;
  BOOL is_local = FALSE;  //  date-time forms are interpreted as a local time

  rv = LEPUS_NAN;

  s = LEPUS_ToString(ctx, argv[0]);
  if (LEPUS_IsException(s)) return LEPUS_EXCEPTION;

  sp = LEPUS_VALUE_GET_STRING(s);
  p = 0;
  if (p < sp->len &&
      (((c = string_get(sp, p)) >= '0' && c <= '9') || c == '+' || c == '-')) {
    /* ISO format */
    /* year field can be negative */
    /* XXX: could be stricter */
    if (string_get_signed_field(sp, &p, &fields[0])) goto done;

    for (i = 1; i < 6; i++) {
      if (string_get_field(sp, &p, &fields[i])) break;
    }
    is_local = (i > 3);  // more than 3 fields -> date-time form
    if (i == 6 && p < sp->len && string_get(sp, p) == '.') {
      /* parse milliseconds as a fractional part, round to nearest */
      /* XXX: the spec does not indicate which rounding should be used */
      int mul = 1000, ms = 0;
      while (++p < sp->len) {
        int c = string_get(sp, p);
        if (!(c >= '0' && c <= '9')) break;
        if (mul == 1 && c >= '5') ms += 1;
        ms += (c - '0') * (mul /= 10);
      }
      fields[6] = ms;
    }
    fields[1] -= 1;

    /* parse the time zone offset if present: [+-]HH:mm */
    tz = 0;
    if (p < sp->len &&
        ((sgn = string_get(sp, p)) == '+' || sgn == '-' || sgn == 'Z')) {
      if (sgn != 'Z') {
        if (string_get_field(sp, &p, &hh)) goto done;
        if (string_get_field(sp, &p, &mm)) goto done;
        tz = hh * 60 + mm;
        if (sgn == '-') tz = -tz;
      }
      is_local = FALSE;  // UTC offset representation, use offset
    }
  } else {
    /* toString or toUTCString format */
    /* skip the day of the week */
    string_skip_non_spaces(sp, &p);
    string_skip_spaces(sp, &p);
    if (p >= sp->len) goto done;
    c = string_get(sp, p);
    if (c >= '0' && c <= '9') {
      /* day of month first */
      if (string_get_field(sp, &p, &fields[2])) goto done;
      if (string_get_month(sp, &p, &fields[1])) goto done;
    } else {
      /* month first */
      if (string_get_month(sp, &p, &fields[1])) goto done;
      if (string_get_field(sp, &p, &fields[2])) goto done;
    }
    string_skip_spaces(sp, &p);
    if (string_get_signed_field(sp, &p, &fields[0])) goto done;

    /* hour, min, seconds */
    for (i = 0; i < 3; i++) {
      if (string_get_field(sp, &p, &fields[3 + i])) goto done;
    }
    // XXX: parse optional milliseconds?

    /* parse the time zone offset if present: [+-]HHmm */
    tz = 0;
    for (tz = 0; p < sp->len; p++) {
      sgn = string_get(sp, p);
      if (sgn == '+' || sgn == '-') {
        p++;
        if (string_get_digits(sp, &p, 2, &hh)) goto done;
        if (string_get_digits(sp, &p, 2, &mm)) goto done;
        tz = hh * 60 + mm;
        if (sgn == '-') tz = -tz;
        break;
      }
    }
  }
  for (i = 0; i < 7; i++) fields1[i] = fields[i];
  d = set_date_fields(fields1, is_local) - tz * 60000;
  rv = __JS_NewFloat64(ctx, d);

done:
  LEPUS_FreeValue(ctx, s);
  return rv;
}

QJS_STATIC LEPUSValue lepus_Date_now(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv) {
  // now()
  return LEPUS_NewInt64(ctx, date_now());
}

QJS_STATIC LEPUSValue lepus_date_Symbol_toPrimitive(LEPUSContext *ctx,
                                                    LEPUSValueConst this_val,
                                                    int argc,
                                                    LEPUSValueConst *argv) {
  // Symbol_toPrimitive(hint)
  LEPUSValueConst obj = this_val;
  LEPUSAtom hint = LEPUS_ATOM_NULL;
  int hint_num;

  if (!LEPUS_IsObject(obj)) return LEPUS_ThrowTypeErrorNotAnObject(ctx);

  if (LEPUS_IsString(argv[0])) {
    hint = lepus_value_to_atom(ctx, argv[0]);
    if (hint == LEPUS_ATOM_NULL) return LEPUS_EXCEPTION;
    LEPUS_FreeAtom(ctx, hint);
  }
  switch (hint) {
    case LEPUS_ATOM_number:
#ifdef CONFIG_BIGNUM
    case LEPUS_ATOM_integer:
#endif
      hint_num = HINT_NUMBER;
      break;
    case LEPUS_ATOM_string:
    case LEPUS_ATOM_default:
      hint_num = HINT_STRING;
      break;
    default:
      return LEPUS_ThrowTypeError(ctx, "invalid hint");
  }
  return LEPUS_ToPrimitive(ctx, obj, hint_num | HINT_FORCE_ORDINARY);
}

QJS_STATIC LEPUSValue lepus_date_getTimezoneOffset(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   int argc,
                                                   LEPUSValueConst *argv) {
  // getTimezoneOffset()
  double v;

  if (LEPUS_ThisTimeValue(ctx, &v, this_val)) return LEPUS_EXCEPTION;
  if (isnan(v))
    return LEPUS_NAN;
  else
    return LEPUS_NewInt64(ctx, getTimezoneOffset((int64_t)trunc(v)));
}

QJS_STATIC LEPUSValue lepus_date_getTime(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  // getTime()
  double v;

  if (LEPUS_ThisTimeValue(ctx, &v, this_val)) return LEPUS_EXCEPTION;
  return __JS_NewFloat64(ctx, v);
}

QJS_STATIC LEPUSValue lepus_date_setTime(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  // setTime(v)
  double v;

  if (LEPUS_ThisTimeValue(ctx, &v, this_val) ||
      LEPUS_ToFloat64(ctx, &v, argv[0]))
    return LEPUS_EXCEPTION;
  return LEPUS_SetThisTimeValue(ctx, this_val, time_clip(v));
}

QJS_STATIC LEPUSValue lepus_date_setYear(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  // setYear(y)
  double y;
  LEPUSValueConst args[1];

  if (LEPUS_ThisTimeValue(ctx, &y, this_val) ||
      LEPUS_ToFloat64(ctx, &y, argv[0]))
    return LEPUS_EXCEPTION;
  y = +y;
  if (isfinite(y)) {
    y = trunc(y);
    if (y >= 0 && y < 100) y += 1900;
  }
  args[0] = __JS_NewFloat64(ctx, y);
  return set_date_field(ctx, this_val, 1, args, 0x011);
}

QJS_STATIC LEPUSValue lepus_date_toJSON(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  // toJSON(key)
  LEPUSValue obj, tv, method, rv;
  double d;

  rv = LEPUS_EXCEPTION;
  tv = LEPUS_UNDEFINED;

  obj = LEPUS_ToObject(ctx, this_val);
  tv = LEPUS_ToPrimitive(ctx, obj, HINT_NUMBER);
  if (LEPUS_IsException(tv)) goto exception;
  if (LEPUS_IsNumber(tv)) {
    if (LEPUS_ToFloat64(ctx, &d, tv) < 0) goto exception;
    if (!isfinite(d)) {
      rv = LEPUS_NULL;
      goto done;
    }
  }
  method = LEPUS_GetPropertyStr(ctx, obj, "toISOString");
  if (LEPUS_IsException(method)) goto exception;
  if (!LEPUS_IsFunction(ctx, method)) {
    LEPUS_ThrowTypeError(ctx, "object needs toISOString method");
    LEPUS_FreeValue(ctx, method);
    goto exception;
  }
  rv = LEPUS_CallFree(ctx, method, obj, 0, NULL);
exception:
done:
  LEPUS_FreeValue(ctx, obj);
  LEPUS_FreeValue(ctx, tv);
  return rv;
}

static const LEPUSCFunctionListEntry lepus_date_funcs[] = {
    LEPUS_CFUNC_DEF("now", 0, lepus_Date_now),
    LEPUS_CFUNC_DEF("parse", 1, lepus_Date_parse),
    LEPUS_CFUNC_DEF("UTC", 7, lepus_Date_UTC),
};

static const LEPUSCFunctionListEntry lepus_date_proto_funcs[] = {
    LEPUS_CFUNC_DEF("valueOf", 0, lepus_date_getTime),
    LEPUS_CFUNC_MAGIC_DEF("toString", 0, get_date_string, 0x13),
    LEPUS_CFUNC_DEF("[Symbol.toPrimitive]", 1, lepus_date_Symbol_toPrimitive),
    LEPUS_CFUNC_MAGIC_DEF("toUTCString", 0, get_date_string, 0x03),
    LEPUS_ALIAS_DEF("toGMTString", "toUTCString"),
    LEPUS_CFUNC_MAGIC_DEF("toISOString", 0, get_date_string, 0x23),
    LEPUS_CFUNC_MAGIC_DEF("toDateString", 0, get_date_string, 0x11),
    LEPUS_CFUNC_MAGIC_DEF("toTimeString", 0, get_date_string, 0x12),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, get_date_string, 0x33),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleDateString", 0, get_date_string, 0x31),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleTimeString", 0, get_date_string, 0x32),
    LEPUS_CFUNC_DEF("getTimezoneOffset", 0, lepus_date_getTimezoneOffset),
    LEPUS_CFUNC_DEF("getTime", 0, lepus_date_getTime),
    LEPUS_CFUNC_MAGIC_DEF("getYear", 0, get_date_field, 0x101),
    LEPUS_CFUNC_MAGIC_DEF("getFullYear", 0, get_date_field, 0x01),
    LEPUS_CFUNC_MAGIC_DEF("getUTCFullYear", 0, get_date_field, 0x00),
    LEPUS_CFUNC_MAGIC_DEF("getMonth", 0, get_date_field, 0x11),
    LEPUS_CFUNC_MAGIC_DEF("getUTCMonth", 0, get_date_field, 0x10),
    LEPUS_CFUNC_MAGIC_DEF("getDate", 0, get_date_field, 0x21),
    LEPUS_CFUNC_MAGIC_DEF("getUTCDate", 0, get_date_field, 0x20),
    LEPUS_CFUNC_MAGIC_DEF("getHours", 0, get_date_field, 0x31),
    LEPUS_CFUNC_MAGIC_DEF("getUTCHours", 0, get_date_field, 0x30),
    LEPUS_CFUNC_MAGIC_DEF("getMinutes", 0, get_date_field, 0x41),
    LEPUS_CFUNC_MAGIC_DEF("getUTCMinutes", 0, get_date_field, 0x40),
    LEPUS_CFUNC_MAGIC_DEF("getSeconds", 0, get_date_field, 0x51),
    LEPUS_CFUNC_MAGIC_DEF("getUTCSeconds", 0, get_date_field, 0x50),
    LEPUS_CFUNC_MAGIC_DEF("getMilliseconds", 0, get_date_field, 0x61),
    LEPUS_CFUNC_MAGIC_DEF("getUTCMilliseconds", 0, get_date_field, 0x60),
    LEPUS_CFUNC_MAGIC_DEF("getDay", 0, get_date_field, 0x71),
    LEPUS_CFUNC_MAGIC_DEF("getUTCDay", 0, get_date_field, 0x70),
    LEPUS_CFUNC_DEF("setTime", 1, lepus_date_setTime),
    LEPUS_CFUNC_MAGIC_DEF("setMilliseconds", 1, set_date_field, 0x671),
    LEPUS_CFUNC_MAGIC_DEF("setUTCMilliseconds", 1, set_date_field, 0x670),
    LEPUS_CFUNC_MAGIC_DEF("setSeconds", 2, set_date_field, 0x571),
    LEPUS_CFUNC_MAGIC_DEF("setUTCSeconds", 2, set_date_field, 0x570),
    LEPUS_CFUNC_MAGIC_DEF("setMinutes", 3, set_date_field, 0x471),
    LEPUS_CFUNC_MAGIC_DEF("setUTCMinutes", 3, set_date_field, 0x470),
    LEPUS_CFUNC_MAGIC_DEF("setHours", 4, set_date_field, 0x371),
    LEPUS_CFUNC_MAGIC_DEF("setUTCHours", 4, set_date_field, 0x370),
    LEPUS_CFUNC_MAGIC_DEF("setDate", 1, set_date_field, 0x231),
    LEPUS_CFUNC_MAGIC_DEF("setUTCDate", 1, set_date_field, 0x230),
    LEPUS_CFUNC_MAGIC_DEF("setMonth", 2, set_date_field, 0x131),
    LEPUS_CFUNC_MAGIC_DEF("setUTCMonth", 2, set_date_field, 0x130),
    LEPUS_CFUNC_DEF("setYear", 1, lepus_date_setYear),
    LEPUS_CFUNC_MAGIC_DEF("setFullYear", 3, set_date_field, 0x031),
    LEPUS_CFUNC_MAGIC_DEF("setUTCFullYear", 3, set_date_field, 0x030),
    LEPUS_CFUNC_DEF("toJSON", 1, lepus_date_toJSON),
};

void LEPUS_AddIntrinsicDate(LEPUSContext *ctx) {
  LEPUSValueConst obj;

  /* Date */
  ctx->class_proto[LEPUS_CLASS_DATE] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_DATE],
                                lepus_date_proto_funcs,
                                countof(lepus_date_proto_funcs));
  obj = LEPUS_NewGlobalCConstructor(ctx, "Date", lepus_date_constructor, 7,
                                    ctx->class_proto[LEPUS_CLASS_DATE]);
  LEPUS_SetPropertyFunctionList(ctx, obj, lepus_date_funcs,
                                countof(lepus_date_funcs));
}

/* eval */

void LEPUS_AddIntrinsicEval(LEPUSContext *ctx) {
#ifndef NO_QUICKJS_COMPILER
  ctx->eval_internal = __JS_EvalInternal;
#else
  ctx->eval_internal = NULL;
#endif
}

#ifdef CONFIG_BIGNUM

static LEPUSValue LEPUS_ToBigIntCtorFree(LEPUSContext *ctx, LEPUSValue val) {
  int32_t tag;
  BOOL is_legacy;
  int ret;

  is_legacy = is_bignum_mode(ctx) ^ 1;
redo:
  tag = LEPUS_VALUE_GET_NORM_TAG(val);
  switch (tag) {
    case LEPUS_TAG_INT:
    case LEPUS_TAG_BOOL:
      if (is_legacy) {
        bf_t r_s, *r = &r_s;
        bf_init(ctx->bf_ctx, r);
        bf_set_si(r, LEPUS_VALUE_GET_INT(val));
        val = LEPUS_NewBigInt2(ctx, r, TRUE);
      } else {
        val = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_INT(val));
      }
      break;
    case LEPUS_TAG_BIG_INT:
      break;
    case LEPUS_TAG_FLOAT64:
    case LEPUS_TAG_BIG_FLOAT: {
      bf_t *a, a_s, r_s, *r = &r_s;
      BOOL is_float;
      a = LEPUS_ToBigFloat(ctx, &is_float, &a_s, val);
      bf_init(ctx->bf_ctx, r);
      if (!bf_is_finite(a)) {
        LEPUS_FreeValue(ctx, val);
        val = LEPUS_ThrowRangeError(ctx,
                                    "cannot convert NaN or Infinity to bigint");
      } else {
        bf_set(r, a);
        ret = bf_rint(r, BF_PREC_INF, BF_RNDZ);
        LEPUS_FreeValue(ctx, val);
        if (is_legacy && (ret & BF_ST_INEXACT)) {
          bf_delete(r);
          val = LEPUS_ThrowRangeError(
              ctx, "cannot convert to bigint: not an integer");
        } else {
          val = LEPUS_NewBigInt2(ctx, r, is_legacy);
        }
      }
      if (a == &a_s) bf_delete(a);
    } break;
    case LEPUS_TAG_STRING:
      val = LEPUS_StringToBigIntErr(ctx, val);
      if (LEPUS_IsException(val)) break;
      goto redo;
    case LEPUS_TAG_OBJECT:
      val = LEPUS_ToPrimitiveFree(ctx, val,
                                  is_legacy ? HINT_NUMBER : HINT_INTEGER);
      if (LEPUS_IsException(val)) break;
      goto redo;
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
    default:
      LEPUS_FreeValue(ctx, val);
      return LEPUS_ThrowTypeError(ctx, "cannot convert to bigint");
  }
  return val;
}

static LEPUSValue lepus_bigint_constructor(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  return LEPUS_ToBigIntCtorFree(ctx, LEPUS_DupValue(ctx, argv[0]));
}

static inline BOOL LEPUS_IsBigInt(LEPUSContext *ctx, LEPUSValueConst v) {
  int tag = LEPUS_VALUE_GET_TAG(v);
  if (tag == LEPUS_TAG_BIG_INT) return TRUE;
  if (is_bignum_mode(ctx))
    return tag == LEPUS_TAG_INT;
  else
    return FALSE;
}

static LEPUSValue lepus_thisBigIntValue(LEPUSContext *ctx,
                                        LEPUSValueConst this_val) {
  if (LEPUS_IsBigInt(ctx, this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == LEPUS_CLASS_BIG_INT) {
      /* XXX: may relax the check in case the object comes from
         bignum mode */
      if (LEPUS_IsBigInt(ctx, p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a bigint");
}

static LEPUSValue lepus_bigint_toString(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv) {
  LEPUSValue val;
  int base;
  LEPUSValue ret;

  val = lepus_thisBigIntValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (argc == 0 || LEPUS_IsUndefined(argv[0])) {
    base = 10;
  } else {
    if (LEPUS_ToInt32Sat(ctx, &base, argv[0])) goto fail;
    if (base < 2 || base > 36) {
      LEPUS_ThrowRangeError(ctx, "radix must be between 2 and 36");
      goto fail;
    }
  }
  ret = lepus_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static LEPUSValue lepus_bigint_valueOf(LEPUSContext *ctx,
                                       LEPUSValueConst this_val, int argc,
                                       LEPUSValueConst *argv) {
  return lepus_thisBigIntValue(ctx, this_val);
}

static LEPUSValue lepus_integer_div(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int magic) {
  bf_t a_s, b_s, *a, *b, r_s, *r = &r_s, q_s, *q = &q_s;
  int status;

  b = NULL;
  a = LEPUS_ToBigInt(ctx, &a_s, argv[0]);
  if (!a) return LEPUS_EXCEPTION;
  b = LEPUS_ToBigInt(ctx, &b_s, argv[1]);
  if (!b) {
    LEPUS_FreeBigInt(ctx, a, &a_s);
    return LEPUS_EXCEPTION;
  }
  bf_init(ctx->bf_ctx, q);
  bf_init(ctx->bf_ctx, r);
  status = bf_divrem(q, r, a, b, BF_PREC_INF, BF_RNDZ, magic & 0xf);
  LEPUS_FreeBigInt(ctx, a, &a_s);
  LEPUS_FreeBigInt(ctx, b, &b_s);
  if (unlikely(status)) {
    bf_delete(q);
    bf_delete(r);
    throw_bf_exception(ctx, status);
    return LEPUS_EXCEPTION;
  }
  if (magic & 0x10) {
    LEPUSValue ret;
    /* XXX: handle exceptions */
    ret = LEPUS_NewArray(ctx);
    LEPUS_SetPropertyUint32(ctx, ret, 0, LEPUS_NewBigInt(ctx, q));
    LEPUS_SetPropertyUint32(ctx, ret, 1, LEPUS_NewBigInt(ctx, r));
    return ret;
  } else {
    bf_delete(r);
    return LEPUS_NewBigInt(ctx, q);
  }
}

static LEPUSValue lepus_integer_sqrt(LEPUSContext *ctx,
                                     LEPUSValueConst this_val, int argc,
                                     LEPUSValueConst *argv, int magic) {
  bf_t a_s, *a, r_s, *r = &r_s, rem_s, *rem = &rem_s;
  int status;

  a = LEPUS_ToBigInt(ctx, &a_s, argv[0]);
  if (!a) return LEPUS_EXCEPTION;
  bf_init(ctx->bf_ctx, r);
  bf_init(ctx->bf_ctx, rem);
  status = bf_sqrtrem(r, rem, a);
  LEPUS_FreeBigInt(ctx, a, &a_s);
  if (unlikely(status & ~BF_ST_INEXACT)) {
    bf_delete(r);
    bf_delete(rem);
    return throw_bf_exception(ctx, status);
  }
  if (magic) {
    LEPUSValue ret;
    /* XXX: handle exceptions */
    ret = LEPUS_NewArray(ctx);
    LEPUS_SetPropertyUint32(ctx, ret, 0, LEPUS_NewBigInt(ctx, r));
    LEPUS_SetPropertyUint32(ctx, ret, 1, LEPUS_NewBigInt(ctx, rem));
    return ret;
  } else {
    bf_delete(rem);
    return LEPUS_NewBigInt(ctx, r);
  }
}

static LEPUSValue lepus_integer_op1(LEPUSContext *ctx, LEPUSValueConst this_val,
                                    int argc, LEPUSValueConst *argv,
                                    int magic) {
  bf_t a_s, *a;
  int64_t res;

  a = LEPUS_ToBigInt(ctx, &a_s, argv[0]);
  if (!a) return LEPUS_EXCEPTION;
  switch (magic) {
    case 0: /* floorLog2 */
      if (a->sign || a->expn <= 0) {
        res = -1;
      } else {
        res = a->expn - 1;
      }
      break;
    case 1: /* ctz */
      if (bf_is_zero(a)) {
        res = -1;
      } else {
        res = bf_get_exp_min(a);
      }
      break;
    default:
      abort();
  }
  LEPUS_FreeBigInt(ctx, a, &a_s);
  return LEPUS_NewInt64(ctx, res);
}

static LEPUSValue lepus_integer_asUintN(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int argc,
                                        LEPUSValueConst *argv, int asIntN) {
  uint64_t bits;
  bf_t a_s, *a = &a_s, r_s, *r = &r_s, mask_s, *mask = &mask_s;
  BOOL is_legacy;

  if (LEPUS_ToIndex(ctx, &bits, argv[0])) return LEPUS_EXCEPTION;
  a = LEPUS_ToBigInt(ctx, &a_s, argv[1]);
  if (!a) return LEPUS_EXCEPTION;
  /* XXX: optimize */
  bf_init(ctx->bf_ctx, r);
  bf_init(ctx->bf_ctx, mask);
  bf_set_ui(mask, 1);
  bf_mul_2exp(mask, bits, BF_PREC_INF, BF_RNDZ);
  bf_add_si(mask, mask, -1, BF_PREC_INF, BF_RNDZ);
  bf_logic_and(r, a, mask);
  if (asIntN && bits != 0) {
    bf_set_ui(mask, 1);
    bf_mul_2exp(mask, bits - 1, BF_PREC_INF, BF_RNDZ);
    if (bf_cmpu(r, mask) >= 0) {
      bf_set_ui(mask, 1);
      bf_mul_2exp(mask, bits, BF_PREC_INF, BF_RNDZ);
      bf_sub(r, r, mask, BF_PREC_INF, BF_RNDZ);
    }
  }
  bf_delete(mask);
  LEPUS_FreeBigInt(ctx, a, &a_s);
  is_legacy = is_bignum_mode(ctx) ^ 1;
  return LEPUS_NewBigInt2(ctx, r, is_legacy);
}

static const LEPUSCFunctionListEntry lepus_integer_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("tdiv", 2, lepus_integer_div, BF_RNDZ),
    LEPUS_CFUNC_MAGIC_DEF("fdiv", 2, lepus_integer_div, BF_RNDD),
    LEPUS_CFUNC_MAGIC_DEF("cdiv", 2, lepus_integer_div, BF_RNDU),
    LEPUS_CFUNC_MAGIC_DEF("ediv", 2, lepus_integer_div, BF_DIVREM_EUCLIDIAN),
    LEPUS_CFUNC_MAGIC_DEF("tdivrem", 2, lepus_integer_div, BF_RNDZ | 0x10),
    LEPUS_CFUNC_MAGIC_DEF("fdivrem", 2, lepus_integer_div, BF_RNDD | 0x10),
    LEPUS_CFUNC_MAGIC_DEF("cdivrem", 2, lepus_integer_div, BF_RNDU | 0x10),
    LEPUS_CFUNC_MAGIC_DEF("edivrem", 2, lepus_integer_div,
                          BF_DIVREM_EUCLIDIAN | 0x10),
    LEPUS_CFUNC_MAGIC_DEF("sqrt", 1, lepus_integer_sqrt, 0),
    LEPUS_CFUNC_MAGIC_DEF("sqrtrem", 1, lepus_integer_sqrt, 1),
    LEPUS_CFUNC_MAGIC_DEF("floorLog2", 1, lepus_integer_op1, 0),
    LEPUS_CFUNC_MAGIC_DEF("ctz", 1, lepus_integer_op1, 1),
    LEPUS_CFUNC_MAGIC_DEF("asUintN", 2, lepus_integer_asUintN, 0),
    LEPUS_CFUNC_MAGIC_DEF("asIntN", 2, lepus_integer_asUintN, 1),
};

static const LEPUSCFunctionListEntry lepus_bigint_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, lepus_bigint_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, lepus_bigint_valueOf),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "BigInt",
                          LEPUS_PROP_CONFIGURABLE),
};

static LEPUSValue lepus_thisBigFloatValue(LEPUSContext *ctx,
                                          LEPUSValueConst this_val) {
  if (LEPUS_IsBigFloat(this_val)) return LEPUS_DupValue(ctx, this_val);

  if (LEPUS_VALUE_IS_OBJECT(this_val)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_val);
    if (p->class_id == LEPUS_CLASS_BIG_FLOAT) {
      if (LEPUS_IsBigFloat(p->u.object_data))
        return LEPUS_DupValue(ctx, p->u.object_data);
    }
  }
  return LEPUS_ThrowTypeError(ctx, "not a bigfloat");
}

static LEPUSValue lepus_bigfloat_toString(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValue val;
  int base;
  LEPUSValue ret;

  val = lepus_thisBigFloatValue(ctx, this_val);
  if (LEPUS_IsException(val)) return val;
  if (argc == 0 || LEPUS_IsUndefined(argv[0])) {
    base = 10;
  } else {
    if (LEPUS_ToInt32Sat(ctx, &base, argv[0])) goto fail;
    if (base < 2 || base > 36) {
      LEPUS_ThrowRangeError(ctx, "radix must be between 2 and 36");
      goto fail;
    }
  }
  ret = lepus_ftoa(ctx, val, base, 0, BF_RNDN | BF_FTOA_FORMAT_FREE_MIN);
  LEPUS_FreeValue(ctx, val);
  return ret;
fail:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

static LEPUSValue lepus_bigfloat_valueOf(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  return lepus_thisBigFloatValue(ctx, this_val);
}

static const LEPUSCFunctionListEntry lepus_bigfloat_proto_funcs[] = {
    LEPUS_CFUNC_DEF("toString", 0, lepus_bigfloat_toString),
    LEPUS_CFUNC_DEF("valueOf", 0, lepus_bigfloat_valueOf),
    LEPUS_CFUNC_MAGIC_DEF("toPrecision", 1, lepus_number_toPrecision, 1),
    LEPUS_CFUNC_MAGIC_DEF("toFixed", 1, lepus_number_toFixed, 1),
    LEPUS_CFUNC_MAGIC_DEF("toExponential", 1, lepus_number_toExponential, 1),
};

static LEPUSValue lepus_bigfloat_constructor(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  LEPUSValue val;
  if (argc == 0) {
    bf_t r_s, *r = &r_s;
    bf_init(ctx->bf_ctx, r);
    bf_set_zero(r, 0);
    val = LEPUS_NewBigFloat(ctx, r);
  } else {
    val = LEPUS_DupValue(ctx, argv[0]);
  redo:
    switch (LEPUS_VALUE_GET_NORM_TAG(val)) {
      case LEPUS_TAG_BIG_FLOAT:
        break;
      case LEPUS_TAG_FLOAT64: {
        bf_t r_s, *r = &r_s;
        bf_init(ctx->bf_ctx, r);
        bf_set_float64(r, LEPUS_VALUE_GET_FLOAT64(val));
        val = LEPUS_NewBigFloat(ctx, r);
      } break;
      case LEPUS_TAG_INT: {
        bf_t r_s, *r = &r_s;
        bf_init(ctx->bf_ctx, r);
        bf_set_si(r, LEPUS_VALUE_GET_INT(val));
        val = LEPUS_NewBigFloat(ctx, r);
      } break;
      case LEPUS_TAG_BIG_INT:
        /* We keep the full precision of the integer */
        {
          LEPUSBigFloat *p =
              static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(val));
          val = LEPUS_MKPTR(LEPUS_TAG_BIG_FLOAT, p);
        }
        break;
      case LEPUS_TAG_STRING: {
        const char *str, *p;
        int err;

        str = LEPUS_ToCString(ctx, val);
        LEPUS_FreeValue(ctx, val);
        if (!str) return LEPUS_EXCEPTION;
        val = lepus_atof(
            ctx, str, &p, 0,
            BF_ATOF_BIN_OCT | BF_ATOF_NO_PREFIX_AFTER_SIGN | BF_ATOF_JS_QUIRKS);
        p += skip_spaces(p);
        err = (*p != '\0');
        LEPUS_FreeCString(ctx, str);
        if (err) {
          LEPUS_FreeValue(ctx, val);
          return LEPUS_ThrowSyntaxError(ctx, "invalid bigfloat literal");
        }
      } break;
      case LEPUS_TAG_OBJECT:
        val = LEPUS_ToPrimitiveFree(ctx, val, HINT_NUMBER);
        if (LEPUS_IsException(val)) break;
        goto redo;
      case LEPUS_TAG_NULL:
      case LEPUS_TAG_UNDEFINED:
      default:
        LEPUS_FreeValue(ctx, val);
        return LEPUS_ThrowTypeError(ctx, "cannot convert to bigfloat");
    }
  }
  return val;
}

static LEPUSValue lepus_float_get_const(LEPUSContext *ctx,
                                        LEPUSValueConst this_val, int magic) {
  bf_t r_s, *r = &r_s;
  bf_init(ctx->bf_ctx, r);
  switch (magic) {
    case 0: /* PI */
      bf_const_pi(r, ctx->fp_env.prec, ctx->fp_env.flags);
      break;
    case 1: /* LN2 */
      bf_const_log2(r, ctx->fp_env.prec, ctx->fp_env.flags);
      break;
    case 2: /* MIN_VALUE */
    case 3: /* MAX_VALUE */
    {
      slimb_t e_range, e;
      e_range = (limb_t)1 << (bf_get_exp_bits(ctx->fp_env.flags) - 1);
      bf_set_ui(r, 1);
      if (magic == 2) {
        e = -e_range + 2;
        if (ctx->fp_env.flags & BF_FLAG_SUBNORMAL) e -= ctx->fp_env.prec - 1;
        bf_mul_2exp(r, e, ctx->fp_env.prec, ctx->fp_env.flags);
      } else {
        bf_mul_2exp(r, ctx->fp_env.prec, ctx->fp_env.prec, ctx->fp_env.flags);
        bf_add_si(r, r, -1, ctx->fp_env.prec, ctx->fp_env.flags);
        bf_mul_2exp(r, e_range - ctx->fp_env.prec, ctx->fp_env.prec,
                    ctx->fp_env.flags);
      }
    } break;
    case 4: /* EPSILON */
      bf_set_ui(r, 1);
      bf_mul_2exp(r, 1 - ctx->fp_env.prec, ctx->fp_env.prec, ctx->fp_env.flags);
      break;
    default:
      abort();
  }
  return LEPUS_NewBigFloat(ctx, r);
}

static LEPUSValue lepus_float_parseFloat(LEPUSContext *ctx,
                                         LEPUSValueConst this_val, int argc,
                                         LEPUSValueConst *argv) {
  bf_t a_s, *a = &a_s;
  const char *str;
  LEPUSValue ret;
  int radix;
  LEPUSFloatEnv *fe;

  str = LEPUS_ToCString(ctx, argv[0]);
  if (!str) return LEPUS_EXCEPTION;
  if (LEPUS_ToInt32(ctx, &radix, argv[1])) {
  fail:
    LEPUS_FreeCString(ctx, str);
    return LEPUS_EXCEPTION;
  }
  if (radix != 0 && (radix < 2 || radix > 36)) {
    LEPUS_ThrowRangeError(ctx, "radix must be between 2 and 36");
    goto fail;
  }
  fe = &ctx->fp_env;
  if (argc > 2) {
    fe = static_cast<LEPUSFloatEnv *>(
        LEPUS_GetOpaque2(ctx, (argv[2]), LEPUS_CLASS_FLOAT_ENV));
    if (!fe) goto fail;
  }
  bf_init(ctx->bf_ctx, a);
  bf_atof(a, str, NULL, radix, fe->prec, BF_ATOF_JS_QUIRKS | fe->flags);
  ret = LEPUS_NewBigFloat(ctx, a);
  LEPUS_FreeCString(ctx, str);
  return ret;
}

static const LEPUSCFunctionListEntry lepus_bigfloat_funcs[] = {
    LEPUS_CGETSET_MAGIC_DEF("PI", lepus_float_get_const, NULL, 0),
    LEPUS_CGETSET_MAGIC_DEF("LN2", lepus_float_get_const, NULL, 1),
    LEPUS_CGETSET_MAGIC_DEF("MIN_VALUE", lepus_float_get_const, NULL, 2),
    LEPUS_CGETSET_MAGIC_DEF("MAX_VALUE", lepus_float_get_const, NULL, 3),
    LEPUS_CGETSET_MAGIC_DEF("EPSILON", lepus_float_get_const, NULL, 4),
    LEPUS_CFUNC_DEF("parseFloat", 1, lepus_float_parseFloat),
    LEPUS_CFUNC_MAGIC_DEF("abs", 1, lepus_math_fop, MATH_OP_ABS),
    LEPUS_CFUNC_MAGIC_DEF("fpRound", 1, lepus_math_fop, MATH_OP_FPROUND),
    LEPUS_CFUNC_MAGIC_DEF("floor", 1, lepus_math_fop, MATH_OP_FLOOR),
    LEPUS_CFUNC_MAGIC_DEF("ceil", 1, lepus_math_fop, MATH_OP_CEIL),
    LEPUS_CFUNC_MAGIC_DEF("round", 1, lepus_math_fop, MATH_OP_ROUND),
    LEPUS_CFUNC_MAGIC_DEF("trunc", 1, lepus_math_fop, MATH_OP_TRUNC),
    LEPUS_CFUNC_MAGIC_DEF("sqrt", 1, lepus_math_fop, MATH_OP_SQRT),
    LEPUS_CFUNC_MAGIC_DEF("acos", 1, lepus_math_fop, MATH_OP_ACOS),
    LEPUS_CFUNC_MAGIC_DEF("asin", 1, lepus_math_fop, MATH_OP_ASIN),
    LEPUS_CFUNC_MAGIC_DEF("atan", 1, lepus_math_fop, MATH_OP_ATAN),
    LEPUS_CFUNC_MAGIC_DEF("atan2", 2, lepus_math_fop2, MATH_OP_ATAN2),
    LEPUS_CFUNC_MAGIC_DEF("cos", 1, lepus_math_fop, MATH_OP_COS),
    LEPUS_CFUNC_MAGIC_DEF("exp", 1, lepus_math_fop, MATH_OP_EXP),
    LEPUS_CFUNC_MAGIC_DEF("log", 1, lepus_math_fop, MATH_OP_LOG),
    LEPUS_CFUNC_MAGIC_DEF("pow", 2, lepus_math_fop2, MATH_OP_POW),
    LEPUS_CFUNC_MAGIC_DEF("sin", 1, lepus_math_fop, MATH_OP_SIN),
    LEPUS_CFUNC_MAGIC_DEF("tan", 1, lepus_math_fop, MATH_OP_TAN),
    LEPUS_CFUNC_MAGIC_DEF("sign", 1, lepus_math_fop, MATH_OP_SIGN),
    LEPUS_CFUNC_MAGIC_DEF("add", 2, lepus_math_fop2, MATH_OP_ADD),
    LEPUS_CFUNC_MAGIC_DEF("sub", 2, lepus_math_fop2, MATH_OP_SUB),
    LEPUS_CFUNC_MAGIC_DEF("mul", 2, lepus_math_fop2, MATH_OP_MUL),
    LEPUS_CFUNC_MAGIC_DEF("div", 2, lepus_math_fop2, MATH_OP_DIV),
    LEPUS_CFUNC_MAGIC_DEF("fmod", 2, lepus_math_fop2, MATH_OP_FMOD),
    LEPUS_CFUNC_MAGIC_DEF("remainder", 2, lepus_math_fop2, MATH_OP_REM),
};

/* FloatEnv */

static LEPUSValue lepus_float_env_constructor(LEPUSContext *ctx,
                                              LEPUSValueConst new_target,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValue obj;
  LEPUSFloatEnv *fe;
  int64_t prec;
  int flags, rndmode;

  prec = ctx->fp_env.prec;
  flags = ctx->fp_env.flags;
  if (!LEPUS_IsUndefined(argv[0])) {
    if (LEPUS_ToInt64Sat(ctx, &prec, argv[0])) return LEPUS_EXCEPTION;
    if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)
      return LEPUS_ThrowRangeError(ctx, "invalid precision");
    flags = BF_RNDN; /* RNDN, max exponent size, no subnormal */
    if (argc > 1 && !LEPUS_IsUndefined(argv[1])) {
      if (LEPUS_ToInt32Sat(ctx, &rndmode, argv[1])) return LEPUS_EXCEPTION;
      if (rndmode < BF_RNDN || rndmode > BF_RNDF)
        return LEPUS_ThrowRangeError(ctx, "invalid rounding mode");
      flags = rndmode;
    }
  }

  obj = LEPUS_NewObjectClass(ctx, LEPUS_CLASS_FLOAT_ENV);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  fe = static_cast<LEPUSFloatEnv *>(lepus_malloc(ctx, sizeof(*fe)));
  if (!fe) return LEPUS_EXCEPTION;
  fe->prec = prec;
  fe->flags = flags;
  fe->status = 0;
  LEPUS_SetOpaque(obj, fe);
  return obj;
}

static void lepus_float_env_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSFloatEnv *fe =
      static_cast<LEPUSFloatEnv *>(LEPUS_GetOpaque(val, LEPUS_CLASS_FLOAT_ENV));
  lepus_free_rt(rt, fe);
}

static LEPUSValue lepus_float_env_get_prec(LEPUSContext *ctx,
                                           LEPUSValueConst this_val) {
  return LEPUS_NewInt64(ctx, ctx->fp_env.prec);
}

static LEPUSValue lepus_float_env_get_expBits(LEPUSContext *ctx,
                                              LEPUSValueConst this_val) {
  return LEPUS_NewInt32(ctx, bf_get_exp_bits(ctx->fp_env.flags));
}

/* temporary fix for string conversion overflows */
#define BF_EXP_BITS_MAX1 (BF_EXP_BITS_MAX - 1)

static LEPUSValue lepus_float_env_setPrec(LEPUSContext *ctx,
                                          LEPUSValueConst this_val, int argc,
                                          LEPUSValueConst *argv) {
  LEPUSValueConst func;
  int exp_bits, flags, saved_flags;
  LEPUSValue ret;
  limb_t saved_prec;
  int64_t prec;

  func = argv[0];
  if (LEPUS_ToInt64Sat(ctx, &prec, argv[1])) return LEPUS_EXCEPTION;
  if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)
    return LEPUS_ThrowRangeError(ctx, "invalid precision");
  exp_bits = BF_EXP_BITS_MAX1;

  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (LEPUS_ToInt32Sat(ctx, &exp_bits, argv[2])) return LEPUS_EXCEPTION;
    if (exp_bits < BF_EXP_BITS_MIN || exp_bits > BF_EXP_BITS_MAX1)
      return LEPUS_ThrowRangeError(ctx, "invalid number of exponent bits");
  }

  flags = BF_RNDN | bf_set_exp_bits(exp_bits);
  if (exp_bits != BF_EXP_BITS_MAX1) flags |= BF_FLAG_SUBNORMAL;

  saved_prec = ctx->fp_env.prec;
  saved_flags = ctx->fp_env.flags;

  ctx->fp_env.prec = prec;
  ctx->fp_env.flags = flags;

  ret = LEPUS_Call(ctx, func, LEPUS_UNDEFINED, 0, NULL);
  /* always restore the floating point precision */
  ctx->fp_env.prec = saved_prec;
  ctx->fp_env.flags = saved_flags;
  return ret;
}

#define FE_PREC (-1)
#define FE_EXP (-2)
#define FE_RNDMODE (-3)
#define FE_SUBNORMAL (-4)

static LEPUSValue lepus_float_env_proto_get_status(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   int magic) {
  LEPUSFloatEnv *fe;
  fe = static_cast<LEPUSFloatEnv *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_FLOAT_ENV));
  if (!fe) return LEPUS_EXCEPTION;
  switch (magic) {
    case FE_PREC:
      return LEPUS_NewInt64(ctx, fe->prec);
    case FE_EXP:
      return LEPUS_NewInt32(ctx, bf_get_exp_bits(fe->flags));
    case FE_RNDMODE:
      return LEPUS_NewInt32(ctx, fe->flags & BF_RND_MASK);
    case FE_SUBNORMAL:
      return LEPUS_NewBool(ctx, (fe->flags & BF_FLAG_SUBNORMAL) != 0);
    default:
      return LEPUS_NewBool(ctx, (fe->status & magic) != 0);
  }
}

static LEPUSValue lepus_float_env_proto_set_status(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   LEPUSValue val, int magic) {
  LEPUSFloatEnv *fe;
  int b;
  int64_t prec;

  fe = static_cast<LEPUSFloatEnv *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_FLOAT_ENV));
  if (!fe) return LEPUS_EXCEPTION;
  switch (magic) {
    case FE_PREC:
      if (LEPUS_ToInt64Sat(ctx, &prec, val)) return LEPUS_EXCEPTION;
      if (prec < BF_PREC_MIN || prec > BF_PREC_MAX)
        return LEPUS_ThrowRangeError(ctx, "invalid precision");
      fe->prec = prec;
      break;
    case FE_EXP:
      if (LEPUS_ToInt32Sat(ctx, &b, val)) return LEPUS_EXCEPTION;
      if (b < BF_EXP_BITS_MIN || b > BF_EXP_BITS_MAX1)
        return LEPUS_ThrowRangeError(ctx, "invalid number of exponent bits");
      if (b == BF_EXP_BITS_MAX1) fe->flags &= ~BF_FLAG_SUBNORMAL;
      fe->flags = (fe->flags & ~(BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT)) |
                  bf_set_exp_bits(b);
      break;
    case FE_RNDMODE:
      b = get_rnd_mode(ctx, val);
      if (b < 0) return LEPUS_EXCEPTION;
      fe->flags = (fe->flags & ~BF_RND_MASK) | b;
      break;
    case FE_SUBNORMAL:
      b = LEPUS_ToBool(ctx, val);
      if (bf_get_exp_bits(fe->flags) != BF_EXP_BITS_MAX1) {
        fe->flags =
            (fe->flags & ~BF_FLAG_SUBNORMAL) | (b ? BF_FLAG_SUBNORMAL : 0);
      }
      break;
    default:
      b = LEPUS_ToBool(ctx, val);
      fe->status = (fe->status & ~magic) & ((-b) & magic);
      break;
  }
  return LEPUS_UNDEFINED;
}

static LEPUSValue lepus_float_env_clearStatus(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSFloatEnv *fe = static_cast<LEPUSFloatEnv *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_FLOAT_ENV));
  if (!fe) return LEPUS_EXCEPTION;
  fe->status = 0;
  return LEPUS_UNDEFINED;
}

static const LEPUSCFunctionListEntry lepus_float_env_funcs[] = {
    LEPUS_CGETSET_DEF("prec", lepus_float_env_get_prec, NULL),
    LEPUS_CGETSET_DEF("expBits", lepus_float_env_get_expBits, NULL),
    LEPUS_CFUNC_DEF("setPrec", 2, lepus_float_env_setPrec),
    LEPUS_PROP_INT32_DEF("RNDN", BF_RNDN, 0),
    LEPUS_PROP_INT32_DEF("RNDZ", BF_RNDZ, 0),
    LEPUS_PROP_INT32_DEF("RNDU", BF_RNDU, 0),
    LEPUS_PROP_INT32_DEF("RNDD", BF_RNDD, 0),
    LEPUS_PROP_INT32_DEF("RNDNA", BF_RNDNA, 0),
    LEPUS_PROP_INT32_DEF("RNDNU", BF_RNDNU, 0),
    LEPUS_PROP_INT32_DEF("RNDF", BF_RNDF, 0),
    LEPUS_PROP_INT32_DEF("precMin", BF_PREC_MIN, 0),
    LEPUS_PROP_INT64_DEF("precMax", BF_PREC_MAX, 0),
    LEPUS_PROP_INT32_DEF("expBitsMin", BF_EXP_BITS_MIN, 0),
    LEPUS_PROP_INT32_DEF("expBitsMax", BF_EXP_BITS_MAX1, 0),
};

static const LEPUSCFunctionListEntry lepus_float_env_proto_funcs[] = {
    LEPUS_CGETSET_MAGIC_DEF("prec", lepus_float_env_proto_get_status,
                            lepus_float_env_proto_set_status, FE_PREC),
    LEPUS_CGETSET_MAGIC_DEF("expBits", lepus_float_env_proto_get_status,
                            lepus_float_env_proto_set_status, FE_EXP),
    LEPUS_CGETSET_MAGIC_DEF("rndMode", lepus_float_env_proto_get_status,
                            lepus_float_env_proto_set_status, FE_RNDMODE),
    LEPUS_CGETSET_MAGIC_DEF("subnormal", lepus_float_env_proto_get_status,
                            lepus_float_env_proto_set_status, FE_SUBNORMAL),
    LEPUS_CGETSET_MAGIC_DEF("invalidOperation",
                            lepus_float_env_proto_get_status,
                            lepus_float_env_proto_set_status, BF_ST_INVALID_OP),
    LEPUS_CGETSET_MAGIC_DEF("divideByZero", lepus_float_env_proto_get_status,
                            lepus_float_env_proto_set_status,
                            BF_ST_DIVIDE_ZERO),
    LEPUS_CGETSET_MAGIC_DEF("overflow", lepus_float_env_proto_get_status,
                            lepus_float_env_proto_set_status, BF_ST_OVERFLOW),
    LEPUS_CGETSET_MAGIC_DEF("underflow", lepus_float_env_proto_get_status,
                            lepus_float_env_proto_set_status, BF_ST_UNDERFLOW),
    LEPUS_CGETSET_MAGIC_DEF("inexact", lepus_float_env_proto_get_status,
                            lepus_float_env_proto_set_status, BF_ST_INEXACT),
    LEPUS_CFUNC_DEF("clearStatus", 0, lepus_float_env_clearStatus),
};

#endif /* CONFIG_BIGNUM */

/* Minimum amount of objects to be able to compile code and display
   error messages. No LEPUSAtom should be allocated by this function. */
QJS_STATIC void LEPUS_AddIntrinsicBasicObjects(LEPUSContext *ctx) {
  LEPUSValue proto;
  int i;

  ctx->class_proto[LEPUS_CLASS_OBJECT] = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
  ctx->function_proto =
      LEPUS_NewCFunction3(ctx, lepus_function_proto, "", 0, LEPUS_CFUNC_generic,
                          0, ctx->class_proto[LEPUS_CLASS_OBJECT]);
  ctx->class_proto[LEPUS_CLASS_BYTECODE_FUNCTION] =
      LEPUS_DupValue(ctx, ctx->function_proto);
  ctx->class_proto[LEPUS_CLASS_ERROR] = LEPUS_NewObject(ctx);
#if 0
    /* these are auto-initialized from lepus_error_proto_funcs,
       but delaying might be a problem */
    LEPUS_DefinePropertyValue(ctx, ctx->class_proto[LEPUS_CLASS_ERROR], LEPUS_ATOM_name,
                           LEPUS_AtomToString(ctx, LEPUS_ATOM_Error),
                           LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    LEPUS_DefinePropertyValue(ctx, ctx->class_proto[LEPUS_CLASS_ERROR], LEPUS_ATOM_message,
                           LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string),
                           LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
#endif
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_ERROR],
                                lepus_error_proto_funcs,
                                countof(lepus_error_proto_funcs));

  for (i = 0; i < LEPUS_NATIVE_ERROR_COUNT; i++) {
    proto = LEPUS_NewObjectProto(ctx, ctx->class_proto[LEPUS_CLASS_ERROR]);
    LEPUS_DefinePropertyValue(ctx, proto, LEPUS_ATOM_name,
                              LEPUS_NewAtomString(ctx, native_error_name[i]),
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    LEPUS_DefinePropertyValue(ctx, proto, LEPUS_ATOM_message,
                              LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string),
                              LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
    ctx->native_error_proto[i] = proto;
  }

  /* the array prototype is an array */
  ctx->class_proto[LEPUS_CLASS_ARRAY] = LEPUS_NewObjectProtoClass(
      ctx, ctx->class_proto[LEPUS_CLASS_OBJECT], LEPUS_CLASS_ARRAY);

  ctx->array_shape =
      lepus_new_shape2(ctx, get_proto_obj(ctx->class_proto[LEPUS_CLASS_ARRAY]),
                       LEPUS_PROP_INITIAL_HASH_SIZE, 1);
  add_shape_property(ctx, &ctx->array_shape, NULL, LEPUS_ATOM_length,
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_LENGTH);

  /* XXX: could test it on first context creation to ensure that no
     new atoms are created in LEPUS_AddIntrinsicBasicObjects(). It is
     necessary to avoid useless renumbering of atoms after
     LEPUS_EvalBinary() if it is done just after
     LEPUS_AddIntrinsicBasicObjects(). */
  //    assert(ctx->rt->atom_count == LEPUS_ATOM_END);
}

void LEPUS_AddIntrinsicBaseObjects(LEPUSContext *ctx) {
  int i;
  LEPUSValueConst obj, number_obj;
  LEPUSValue obj1;

  ctx->throw_type_error =
      LEPUS_NewCFunction(ctx, lepus_throw_type_error, NULL, 0);

  /* add caller and arguments properties to throw a TypeError */
  obj1 = LEPUS_NewCFunction(ctx, lepus_function_proto_caller, "get caller", 0);
  LEPUS_DefineProperty(ctx, ctx->function_proto, LEPUS_ATOM_caller,
                       LEPUS_UNDEFINED, obj1, ctx->throw_type_error,
                       LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET |
                           LEPUS_PROP_HAS_CONFIGURABLE |
                           LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(ctx, obj1);
  LEPUS_DefineProperty(
      ctx, ctx->function_proto, LEPUS_ATOM_arguments, LEPUS_UNDEFINED,
      ctx->throw_type_error, ctx->throw_type_error,
      LEPUS_PROP_HAS_GET | LEPUS_PROP_HAS_SET | LEPUS_PROP_HAS_CONFIGURABLE |
          LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(
      ctx, lepus_object_seal(ctx, LEPUS_UNDEFINED, 1,
                             (LEPUSValueConst *)&ctx->throw_type_error, 1));

  ctx->global_obj = LEPUS_NewObject(ctx);
  ctx->global_var_obj = LEPUS_NewObjectProto(ctx, LEPUS_NULL);

  /* Object */
  obj = LEPUS_NewGlobalCConstructor(ctx, "Object", lepus_object_constructor, 1,
                                    ctx->class_proto[LEPUS_CLASS_OBJECT]);
  LEPUS_SetPropertyFunctionList(ctx, obj, lepus_object_funcs,
                                countof(lepus_object_funcs));
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_OBJECT],
                                lepus_object_proto_funcs,
                                countof(lepus_object_proto_funcs));

  /* Function */
  LEPUS_SetPropertyFunctionList(ctx, ctx->function_proto,
                                lepus_function_proto_funcs,
                                countof(lepus_function_proto_funcs));
  ctx->function_ctor = LEPUS_NewCFunctionMagic(
      ctx, lepus_function_constructor, "Function", 1,
      LEPUS_CFUNC_constructor_or_func_magic, LEPUS_FUNC_NORMAL);
  LEPUS_NewGlobalCConstructor2(ctx, LEPUS_DupValue(ctx, ctx->function_ctor),
                               "Function", ctx->function_proto);

  /* Error */
  obj1 = LEPUS_NewCFunctionMagic(ctx, lepus_error_constructor, "Error", 1,
                                 LEPUS_CFUNC_constructor_or_func_magic, -1);
  LEPUS_NewGlobalCConstructor2(ctx, obj1, "Error",
                               ctx->class_proto[LEPUS_CLASS_ERROR]);

  for (i = 0; i < LEPUS_NATIVE_ERROR_COUNT; i++) {
    int n_args = 1 + (i == LEPUS_AGGREGATE_ERROR);
    LEPUSValue func_obj = LEPUS_NewCFunction3(
        ctx, (LEPUSCFunction *)lepus_error_constructor, native_error_name[i],
        n_args, LEPUS_CFUNC_constructor_or_func_magic, i, obj1);
    LEPUS_NewGlobalCConstructor2(ctx, func_obj, native_error_name[i],
                                 ctx->native_error_proto[i]);
  }

  /* Iterator prototype */
  ctx->iterator_proto = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->iterator_proto,
                                lepus_iterator_proto_funcs,
                                countof(lepus_iterator_proto_funcs));

  /* Array */
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_ARRAY],
                                lepus_array_proto_funcs,
                                countof(lepus_array_proto_funcs));

  obj = LEPUS_NewGlobalCConstructor(ctx, "Array", lepus_array_constructor, 1,
                                    ctx->class_proto[LEPUS_CLASS_ARRAY]);
  LEPUS_SetPropertyFunctionList(ctx, obj, lepus_array_funcs,
                                countof(lepus_array_funcs));

  /* XXX: create auto_initializer */
  {
    /* initialize Array.prototype[Symbol.unscopables] */
    char const unscopables[] =
        "copyWithin"
        "\0"
        "entries"
        "\0"
        "fill"
        "\0"
        "find"
        "\0"
        "findIndex"
        "\0"
        "flat"
        "\0"
        "flatMap"
        "\0"
        "includes"
        "\0"
        "keys"
        "\0"
        "values"
        "\0";
    const char *p = unscopables;
    obj1 = LEPUS_NewObjectProto(ctx, LEPUS_NULL);
    for (p = unscopables; *p; p += strlen(p) + 1) {
      LEPUS_DefinePropertyValueStr(ctx, obj1, p, LEPUS_TRUE, LEPUS_PROP_C_W_E);
    }
    LEPUS_DefinePropertyValue(ctx, ctx->class_proto[LEPUS_CLASS_ARRAY],
                              LEPUS_ATOM_Symbol_unscopables, obj1,
                              LEPUS_PROP_CONFIGURABLE);
  }

  /* needed to initialize arguments[Symbol.iterator] */
  ctx->array_proto_values = LEPUS_GetProperty(
      ctx, ctx->class_proto[LEPUS_CLASS_ARRAY], LEPUS_ATOM_values);

  ctx->class_proto[LEPUS_CLASS_ARRAY_ITERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
  LEPUS_SetPropertyFunctionList(ctx,
                                ctx->class_proto[LEPUS_CLASS_ARRAY_ITERATOR],
                                lepus_array_iterator_proto_funcs,
                                countof(lepus_array_iterator_proto_funcs));
  /* parseFloat and parseInteger must be defined before Number
       because of the Number.parseFloat and Number.parseInteger
       aliases */
  LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, lepus_global_funcs,
                                countof(lepus_global_funcs));

  /* Number */
  ctx->class_proto[LEPUS_CLASS_NUMBER] = LEPUS_NewObjectProtoClass(
      ctx, ctx->class_proto[LEPUS_CLASS_OBJECT], LEPUS_CLASS_NUMBER);
  LEPUS_SetObjectData(ctx, ctx->class_proto[LEPUS_CLASS_NUMBER],
                      LEPUS_NewInt32(ctx, 0));
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_NUMBER],
                                lepus_number_proto_funcs,
                                countof(lepus_number_proto_funcs));
  number_obj =
      LEPUS_NewGlobalCConstructor(ctx, "Number", lepus_number_constructor, 1,
                                  ctx->class_proto[LEPUS_CLASS_NUMBER]);
  LEPUS_SetPropertyFunctionList(ctx, number_obj, lepus_number_funcs,
                                countof(lepus_number_funcs));

  /* Boolean */
  ctx->class_proto[LEPUS_CLASS_BOOLEAN] = LEPUS_NewObjectProtoClass(
      ctx, ctx->class_proto[LEPUS_CLASS_OBJECT], LEPUS_CLASS_BOOLEAN);
  LEPUS_SetObjectData(ctx, ctx->class_proto[LEPUS_CLASS_BOOLEAN],
                      LEPUS_NewBool(ctx, FALSE));
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_BOOLEAN],
                                lepus_boolean_proto_funcs,
                                countof(lepus_boolean_proto_funcs));
  LEPUS_NewGlobalCConstructor(ctx, "Boolean", lepus_boolean_constructor, 1,
                              ctx->class_proto[LEPUS_CLASS_BOOLEAN]);

  /* String */
  ctx->class_proto[LEPUS_CLASS_STRING] = LEPUS_NewObjectProtoClass(
      ctx, ctx->class_proto[LEPUS_CLASS_OBJECT], LEPUS_CLASS_STRING);
  LEPUS_SetObjectData(ctx, ctx->class_proto[LEPUS_CLASS_STRING],
                      LEPUS_AtomToString(ctx, LEPUS_ATOM_empty_string));
  obj = LEPUS_NewGlobalCConstructor(ctx, "String", lepus_string_constructor, 1,
                                    ctx->class_proto[LEPUS_CLASS_STRING]);
  LEPUS_SetPropertyFunctionList(ctx, obj, lepus_string_funcs,
                                countof(lepus_string_funcs));
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_STRING],
                                lepus_string_proto_funcs,
                                countof(lepus_string_proto_funcs));

  ctx->class_proto[LEPUS_CLASS_STRING_ITERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
  LEPUS_SetPropertyFunctionList(ctx,
                                ctx->class_proto[LEPUS_CLASS_STRING_ITERATOR],
                                lepus_string_iterator_proto_funcs,
                                countof(lepus_string_iterator_proto_funcs));

  /* Math: create as autoinit object */
  lepus_random_init(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, lepus_math_obj,
                                countof(lepus_math_obj));

  /* ES6 Reflect: create as autoinit object */
  LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, lepus_reflect_obj,
                                countof(lepus_reflect_obj));

  /* ES6 Symbol */
  ctx->class_proto[LEPUS_CLASS_SYMBOL] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_SYMBOL],
                                lepus_symbol_proto_funcs,
                                countof(lepus_symbol_proto_funcs));
  obj = LEPUS_NewGlobalCConstructor(ctx, "Symbol", lepus_symbol_constructor, 0,
                                    ctx->class_proto[LEPUS_CLASS_SYMBOL]);
  LEPUS_SetPropertyFunctionList(ctx, obj, lepus_symbol_funcs,
                                countof(lepus_symbol_funcs));
  for (i = LEPUS_ATOM_Symbol_toPrimitive; i < LEPUS_ATOM_END; i++) {
    char buf[ATOM_GET_STR_BUF_SIZE];
    const char *str, *p;
    str = LEPUS_AtomGetStr(ctx, buf, sizeof(buf), i);
    /* skip "Symbol." */
    p = strchr(str, '.');
    if (p) str = p + 1;
    LEPUS_DefinePropertyValueStr(ctx, obj, str, LEPUS_AtomToValue(ctx, i), 0);
  }

  /* ES6 Generator */
  ctx->class_proto[LEPUS_CLASS_GENERATOR] =
      LEPUS_NewObjectProto(ctx, ctx->iterator_proto);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_GENERATOR],
                                lepus_generator_proto_funcs,
                                countof(lepus_generator_proto_funcs));

  ctx->class_proto[LEPUS_CLASS_GENERATOR_FUNCTION] =
      LEPUS_NewObjectProto(ctx, ctx->function_proto);
  obj1 = LEPUS_NewCFunctionMagic(
      ctx, lepus_function_constructor, "GeneratorFunction", 1,
      LEPUS_CFUNC_constructor_or_func_magic, LEPUS_FUNC_GENERATOR);
  LEPUS_SetPropertyFunctionList(
      ctx, ctx->class_proto[LEPUS_CLASS_GENERATOR_FUNCTION],
      lepus_generator_function_proto_funcs,
      countof(lepus_generator_function_proto_funcs));
  LEPUS_SetConstructor2(ctx, ctx->class_proto[LEPUS_CLASS_GENERATOR_FUNCTION],
                        ctx->class_proto[LEPUS_CLASS_GENERATOR],
                        LEPUS_PROP_CONFIGURABLE, LEPUS_PROP_CONFIGURABLE);
  LEPUS_SetConstructor2(ctx, obj1,
                        ctx->class_proto[LEPUS_CLASS_GENERATOR_FUNCTION], 0,
                        LEPUS_PROP_CONFIGURABLE);
  LEPUS_FreeValue(ctx, obj1);

#ifdef CONFIG_BIGNUM
  ctx->class_proto[LEPUS_CLASS_BIG_INT] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_BIG_INT],
                                lepus_bigint_proto_funcs,
                                countof(lepus_bigint_proto_funcs));
  obj1 = LEPUS_NewCFunction(ctx, lepus_bigint_constructor, "BigInt", 1);
  LEPUS_NewGlobalCConstructor2(ctx, obj1, "BigInt",
                               ctx->class_proto[LEPUS_CLASS_BIG_INT]);
  LEPUS_SetPropertyFunctionList(ctx, obj1, lepus_integer_funcs,
                                countof(lepus_integer_funcs));

  ctx->class_proto[LEPUS_CLASS_BIG_FLOAT] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_BIG_FLOAT],
                                lepus_bigfloat_proto_funcs,
                                countof(lepus_bigfloat_proto_funcs));
  obj1 = LEPUS_NewCFunction(ctx, lepus_bigfloat_constructor, "BigFloat", 1);
  LEPUS_NewGlobalCConstructor2(ctx, obj1, "BigFloat",
                               ctx->class_proto[LEPUS_CLASS_BIG_FLOAT]);
  LEPUS_SetPropertyFunctionList(ctx, obj1, lepus_bigfloat_funcs,
                                countof(lepus_bigfloat_funcs));

  ctx->class_proto[LEPUS_CLASS_FLOAT_ENV] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_FLOAT_ENV],
                                lepus_float_env_proto_funcs,
                                countof(lepus_float_env_proto_funcs));
  obj1 = LEPUS_NewGlobalCConstructorOnly(
      ctx, "BigFloatEnv", lepus_float_env_constructor, 1,
      ctx->class_proto[LEPUS_CLASS_FLOAT_ENV]);
  LEPUS_SetPropertyFunctionList(ctx, obj1, lepus_float_env_funcs,
                                countof(lepus_float_env_funcs));
#endif
  /* global properties */
  ctx->eval_obj = LEPUS_NewCFunction(ctx, lepus_global_eval, "eval", 1);
  LEPUS_DefinePropertyValue(ctx, ctx->global_obj, LEPUS_ATOM_eval,
                            LEPUS_DupValue(ctx, ctx->eval_obj),
                            LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);
  LEPUS_DefinePropertyValueStr(ctx, ctx->global_obj, "globalThis",
                               LEPUS_DupValue(ctx, ctx->global_obj),
                               LEPUS_PROP_CONFIGURABLE | LEPUS_PROP_WRITABLE);
}

QJS_STATIC LEPUSValue lepus_array_buffer_constructor3(
    LEPUSContext *ctx, LEPUSValueConst new_target, uint64_t len,
    LEPUSClassID class_id, uint8_t *buf,
    LEPUSFreeArrayBufferDataFunc *free_func, void *opaque, BOOL alloc_flag) {
  LEPUSValue obj;
  LEPUSArrayBuffer *abuf = NULL;

  obj = lepus_create_from_ctor(ctx, new_target, class_id);
  if (LEPUS_IsException(obj)) return obj;
  /* XXX: we are currently limited to 2 GB */
  if (len > INT32_MAX) {
    LEPUS_ThrowRangeError(ctx, "invalid array buffer length");
    goto fail;
  }
  abuf = static_cast<LEPUSArrayBuffer *>(lepus_malloc(ctx, sizeof(*abuf)));
  if (!abuf) goto fail;
  abuf->byte_length = len;
  if (alloc_flag) {
    /* the allocation must be done after the object creation */
    abuf->data = static_cast<uint8_t *>(lepus_mallocz(ctx, max_int(len, 1)));
    if (!abuf->data) goto fail;
  } else {
    abuf->data = buf;
  }
  init_list_head(&abuf->array_list);
  abuf->detached = FALSE;
  abuf->shared = (class_id == LEPUS_CLASS_SHARED_ARRAY_BUFFER);
  abuf->opaque = opaque;
  abuf->free_func = free_func;
  if (alloc_flag && buf) memcpy(abuf->data, buf, len);
  LEPUS_SetOpaque(obj, abuf);
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  lepus_free(ctx, abuf);
  return LEPUS_EXCEPTION;
}

QJS_STATIC void lepus_array_buffer_free(LEPUSRuntime *rt, void *opaque,
                                        void *ptr) {
  lepus_free_rt(rt, ptr);
}

QJS_STATIC LEPUSValue
lepus_array_buffer_constructor2(LEPUSContext *ctx, LEPUSValueConst new_target,
                                uint64_t len, LEPUSClassID class_id) {
  return lepus_array_buffer_constructor3(ctx, new_target, len, class_id, NULL,
                                         lepus_array_buffer_free, NULL, TRUE);
}

QJS_STATIC LEPUSValue lepus_array_buffer_constructor1(
    LEPUSContext *ctx, LEPUSValueConst new_target, uint64_t len) {
  return lepus_array_buffer_constructor2(ctx, new_target, len,
                                         LEPUS_CLASS_ARRAY_BUFFER);
}

// <ByteDance begin>
LEPUS_BOOL LEPUS_IsArrayBuffer(LEPUSValueConst v) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(v)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(v);
  if (p && p->class_id != LEPUS_CLASS_ARRAY_BUFFER &&
      p->class_id != LEPUS_CLASS_SHARED_ARRAY_BUFFER) {
    return FALSE;
  }
  return TRUE;
}

LEPUS_BOOL LEPUS_IsTypedArray(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(val)) return FALSE;
  p = LEPUS_VALUE_GET_OBJ(val);
  return (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY) &&
         (p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY);
}

LEPUS_BOOL LEPUS_StrictEq(LEPUSContext *ctx, LEPUSValueConst op1,
                          LEPUSValueConst op2) {
  return lepus_strict_eq(ctx, op1, op2);
}

LEPUS_BOOL LEPUS_SameValue(LEPUSContext *ctx, LEPUSValueConst op1,
                           LEPUSValueConst op2) {
  return lepus_same_value(ctx, op1, op2);
}
// <ByteDance end>

LEPUSValue LEPUS_NewArrayBuffer(LEPUSContext *ctx, uint8_t *buf, size_t len,
                                LEPUSFreeArrayBufferDataFunc *free_func,
                                void *opaque, BOOL is_shared) {
  return lepus_array_buffer_constructor3(
      ctx, LEPUS_UNDEFINED, len,
      is_shared ? LEPUS_CLASS_SHARED_ARRAY_BUFFER : LEPUS_CLASS_ARRAY_BUFFER,
      buf, free_func, opaque, FALSE);
}

/* create a new ArrayBuffer of length 'len' and copy 'buf' to it */
LEPUSValue LEPUS_NewArrayBufferCopy(LEPUSContext *ctx, const uint8_t *buf,
                                    size_t len) {
  return lepus_array_buffer_constructor3(
      ctx, LEPUS_UNDEFINED, len, LEPUS_CLASS_ARRAY_BUFFER, (uint8_t *)buf,
      lepus_array_buffer_free, NULL, TRUE);
}

QJS_STATIC LEPUSValue lepus_array_buffer_constructor(LEPUSContext *ctx,
                                                     LEPUSValueConst new_target,
                                                     int argc,
                                                     LEPUSValueConst *argv) {
  uint64_t len;
  if (LEPUS_ToIndex(ctx, &len, argv[0])) return LEPUS_EXCEPTION;
  return lepus_array_buffer_constructor1(ctx, new_target, len);
}

QJS_STATIC LEPUSValue lepus_shared_array_buffer_constructor(
    LEPUSContext *ctx, LEPUSValueConst new_target, int argc,
    LEPUSValueConst *argv) {
  uint64_t len;
  if (LEPUS_ToIndex(ctx, &len, argv[0])) return LEPUS_EXCEPTION;
  return lepus_array_buffer_constructor2(ctx, new_target, len,
                                         LEPUS_CLASS_SHARED_ARRAY_BUFFER);
}

/* also used for SharedArrayBuffer */
QJS_STATIC void lepus_array_buffer_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSArrayBuffer *abuf = p->u.array_buffer;
  if (abuf) {
    /* The ArrayBuffer finalizer may be called before the typed
        array finalizers using it, so abuf->array_list is not
        necessarily empty. */
    // assert(list_empty(&abuf->array_list));
    if (abuf->free_func) abuf->free_func(rt, abuf->opaque, abuf->data);
    lepus_free_rt(rt, abuf);
  }
}

QJS_STATIC LEPUSValue lepus_array_buffer_isView(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc,
                                                LEPUSValueConst *argv) {
  LEPUSObject *p;
  BOOL res;
  res = FALSE;
  if (LEPUS_VALUE_IS_OBJECT(argv[0])) {
    p = LEPUS_VALUE_GET_OBJ(argv[0]);
    if (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
        p->class_id <= LEPUS_CLASS_DATAVIEW) {
      res = TRUE;
    }
  }
  return LEPUS_NewBool(ctx, res);
}

static const LEPUSCFunctionListEntry lepus_array_buffer_funcs[] = {
    LEPUS_CFUNC_DEF("isView", 1, lepus_array_buffer_isView),
    LEPUS_CGETSET_DEF("[Symbol.species]", lepus_get_this, NULL),
};

QJS_STATIC LEPUSValue
LEPUS_ThrowTypeErrorDetachedArrayBuffer(LEPUSContext *ctx) {
  return LEPUS_ThrowTypeError(ctx, "ArrayBuffer is detached");
}

QJS_HIDE LEPUSValue lepus_array_buffer_get_byteLength(LEPUSContext *ctx,
                                                      LEPUSValueConst this_val,
                                                      int class_id) {
  LEPUSArrayBuffer *abuf = static_cast<LEPUSArrayBuffer *>(
      LEPUS_GetOpaque2(ctx, this_val, class_id));
  if (!abuf) return LEPUS_EXCEPTION;
  /* return 0 if detached */
  return LEPUS_NewUint32(ctx, abuf->byte_length);
}

void LEPUS_DetachArrayBuffer(LEPUSContext *ctx, LEPUSValueConst obj) {
  LEPUSArrayBuffer *abuf = static_cast<LEPUSArrayBuffer *>(
      LEPUS_GetOpaque(obj, LEPUS_CLASS_ARRAY_BUFFER));
  struct list_head *el;

  if (!abuf || abuf->detached) return;
  if (abuf->free_func) abuf->free_func(ctx->rt, abuf->opaque, abuf->data);
  abuf->data = NULL;
  abuf->byte_length = 0;
  abuf->detached = TRUE;

  list_for_each(el, &abuf->array_list) {
    LEPUSTypedArray *ta;
    LEPUSObject *p;

    ta = list_entry(el, LEPUSTypedArray, link);
    p = ta->obj;
    /* Note: the typed array length and offset fields are not modified */
    if (p->class_id != LEPUS_CLASS_DATAVIEW) {
      p->u.array.count = 0;
      p->u.array.u.ptr = NULL;
    }
  }
}

/* get an ArrayBuffer or SharedArrayBuffer */
QJS_STATIC LEPUSArrayBuffer *lepus_get_array_buffer(LEPUSContext *ctx,
                                                    LEPUSValueConst obj) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) goto fail;
  p = LEPUS_VALUE_GET_OBJ(obj);
  if (p->class_id != LEPUS_CLASS_ARRAY_BUFFER &&
      p->class_id != LEPUS_CLASS_SHARED_ARRAY_BUFFER) {
  fail:
    LEPUS_ThrowTypeErrorInvalidClass(ctx, LEPUS_CLASS_ARRAY_BUFFER);
    return NULL;
  }
  return p->u.array_buffer;
}

/* return NULL if exception. WARNING: any LEPUS call can detach the
   buffer and render the returned pointer invalid */
uint8_t *LEPUS_GetArrayBuffer(LEPUSContext *ctx, size_t *psize,
                              LEPUSValueConst obj) {
  LEPUSArrayBuffer *abuf = lepus_get_array_buffer(ctx, obj);
  if (!abuf) goto fail;
  if (abuf->detached) {
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  *psize = abuf->byte_length;
  return abuf->data;
fail:
  *psize = 0;
  return NULL;
}

uint8_t *LEPUS_MoveArrayBuffer(LEPUSContext *ctx, size_t *psize,
                               LEPUSValueConst obj) {
  auto *abuf = lepus_get_array_buffer(ctx, obj);
  void *ret = nullptr;
  if (!abuf) goto fail;
  if (abuf->detached) {
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  *psize = abuf->byte_length;
  ret = abuf->data;
  abuf->data = nullptr;
  abuf->byte_length = 0;
  LEPUS_DetachArrayBuffer(ctx, obj);
  return static_cast<uint8_t *>(ret);
fail:
  *psize = 0;
  return nullptr;
}

QJS_STATIC LEPUSValue lepus_array_buffer_slice(LEPUSContext *ctx,
                                               LEPUSValueConst this_val,
                                               int argc, LEPUSValueConst *argv,
                                               int class_id) {
  LEPUSArrayBuffer *abuf, *new_abuf;
  int64_t len, start, end, new_len;
  LEPUSValue ctor, new_obj;

  abuf = static_cast<LEPUSArrayBuffer *>(
      LEPUS_GetOpaque2(ctx, this_val, class_id));
  if (!abuf) return LEPUS_EXCEPTION;
  if (abuf->detached) return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  len = abuf->byte_length;

  if (LEPUS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len))
    return LEPUS_EXCEPTION;

  end = len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (LEPUS_ToInt64Clamp(ctx, &end, argv[1], 0, len, len))
      return LEPUS_EXCEPTION;
  }
  new_len = max_int64(end - start, 0);
  ctor = LEPUS_SpeciesConstructor(ctx, this_val, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return ctor;
  if (LEPUS_IsUndefined(ctor)) {
    new_obj = lepus_array_buffer_constructor2(ctx, LEPUS_UNDEFINED, new_len,
                                              class_id);
  } else {
    LEPUSValue args[1];
    args[0] = LEPUS_NewInt64(ctx, new_len);
    new_obj = LEPUS_CallConstructor(ctx, ctor, 1, (LEPUSValueConst *)args);
    LEPUS_FreeValue(ctx, ctor);
    LEPUS_FreeValue(ctx, args[0]);
  }
  if (LEPUS_IsException(new_obj)) return new_obj;
  new_abuf =
      static_cast<LEPUSArrayBuffer *>(LEPUS_GetOpaque2(ctx, new_obj, class_id));
  if (!new_abuf) goto fail;
  if (lepus_same_value(ctx, new_obj, this_val)) {
    LEPUS_ThrowTypeError(ctx, "cannot use identical ArrayBuffer");
    goto fail;
  }
  if (new_abuf->detached) {
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  if (new_abuf->byte_length < new_len) {
    LEPUS_ThrowTypeError(ctx, "new ArrayBuffer is too small");
    goto fail;
  }
  /* must test again because of side effects */
  if (abuf->detached) {
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  memcpy(new_abuf->data, abuf->data + start, new_len);
  return new_obj;
fail:
  LEPUS_FreeValue(ctx, new_obj);
  return LEPUS_EXCEPTION;
}

static const LEPUSCFunctionListEntry lepus_array_buffer_proto_funcs[] = {
    LEPUS_CGETSET_MAGIC_DEF("byteLength", lepus_array_buffer_get_byteLength,
                            NULL, LEPUS_CLASS_ARRAY_BUFFER),
    LEPUS_CFUNC_MAGIC_DEF("slice", 2, lepus_array_buffer_slice,
                          LEPUS_CLASS_ARRAY_BUFFER),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "ArrayBuffer",
                          LEPUS_PROP_CONFIGURABLE),
};

/* SharedArrayBuffer */

static const LEPUSCFunctionListEntry lepus_shared_array_buffer_funcs[] = {
    LEPUS_CGETSET_DEF("[Symbol.species]", lepus_get_this, NULL),
};

static const LEPUSCFunctionListEntry lepus_shared_array_buffer_proto_funcs[] = {
    LEPUS_CGETSET_MAGIC_DEF("byteLength", lepus_array_buffer_get_byteLength,
                            NULL, LEPUS_CLASS_SHARED_ARRAY_BUFFER),
    LEPUS_CFUNC_MAGIC_DEF("slice", 2, lepus_array_buffer_slice,
                          LEPUS_CLASS_SHARED_ARRAY_BUFFER),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "SharedArrayBuffer",
                          LEPUS_PROP_CONFIGURABLE),
};

QJS_STATIC LEPUSObject *get_typed_array(LEPUSContext *ctx,
                                        LEPUSValueConst this_val,
                                        int is_dataview) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val)) goto fail;
  p = LEPUS_VALUE_GET_OBJ(this_val);
  if (is_dataview) {
    if (p->class_id != LEPUS_CLASS_DATAVIEW) goto fail;
  } else {
    if (!(p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
          p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY)) {
    fail:
      LEPUS_ThrowTypeError(ctx, "not a %s",
                           is_dataview ? "DataView" : "TypedArray");
      return NULL;
    }
  }
  return p;
}

/* WARNING: 'p' must be a typed array */
QJS_STATIC BOOL typed_array_is_detached(LEPUSContext *ctx, LEPUSObject *p) {
  LEPUSTypedArray *ta = p->u.typed_array;
  LEPUSArrayBuffer *abuf = ta->buffer->u.array_buffer;
  /* XXX: could simplify test by ensuring that
     p->u.array.u.ptr is NULL iff it is detached */
  return abuf->detached;
}

/* WARNING: 'p' must be a typed array. Works even if the array buffer
   is detached */
QJS_STATIC uint32_t typed_array_get_length(LEPUSContext *ctx, LEPUSObject *p) {
  LEPUSTypedArray *ta = p->u.typed_array;
  int size_log2 = typed_array_size_log2(p->class_id);
  return ta->length >> size_log2;
}

QJS_STATIC int validate_typed_array(LEPUSContext *ctx,
                                    LEPUSValueConst this_val) {
  LEPUSObject *p;
  p = get_typed_array(ctx, this_val, 0);
  if (!p) return -1;
  if (typed_array_is_detached(ctx, p)) {
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    return -1;
  }
  return 0;
}

QJS_STATIC LEPUSValue lepus_typed_array_get_length(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val) {
  LEPUSObject *p;
  p = get_typed_array(ctx, this_val, 0);
  if (!p) return LEPUS_EXCEPTION;
  return LEPUS_NewInt32(ctx, p->u.array.count);
}

QJS_STATIC LEPUSValue lepus_typed_array_get_buffer(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   int is_dataview) {
  LEPUSObject *p;
  LEPUSTypedArray *ta;
  p = get_typed_array(ctx, this_val, is_dataview);
  if (!p) return LEPUS_EXCEPTION;
  ta = p->u.typed_array;
  return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer));
}

QJS_HIDE LEPUSValue lepus_typed_array_get_byteLength(LEPUSContext *ctx,
                                                     LEPUSValueConst this_val,
                                                     int is_dataview) {
  LEPUSObject *p;
  LEPUSTypedArray *ta;
  p = get_typed_array(ctx, this_val, is_dataview);
  if (!p) return LEPUS_EXCEPTION;
  if (typed_array_is_detached(ctx, p)) {
    if (is_dataview) {
      return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    } else {
      return LEPUS_NewInt32(ctx, 0);
    }
  }
  ta = p->u.typed_array;
  return LEPUS_NewInt32(ctx, ta->length);
}

QJS_STATIC LEPUSValue lepus_typed_array_get_byteOffset(LEPUSContext *ctx,
                                                       LEPUSValueConst this_val,
                                                       int is_dataview) {
  LEPUSObject *p;
  LEPUSTypedArray *ta;
  p = get_typed_array(ctx, this_val, is_dataview);
  if (!p) return LEPUS_EXCEPTION;
  if (typed_array_is_detached(ctx, p)) {
    if (is_dataview) {
      return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    } else {
      return LEPUS_NewInt32(ctx, 0);
    }
  }
  ta = p->u.typed_array;
  return LEPUS_NewInt32(ctx, ta->offset);
}

QJS_STATIC LEPUSValue
lepus_typed_array_get_toStringTag(LEPUSContext *ctx, LEPUSValueConst this_val) {
  LEPUSObject *p;
  if (LEPUS_VALUE_IS_NOT_OBJECT(this_val)) return LEPUS_UNDEFINED;
  p = LEPUS_VALUE_GET_OBJ(this_val);
  if (!(p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
        p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY))
    return LEPUS_UNDEFINED;
  return LEPUS_AtomToString(ctx, ctx->rt->class_array[p->class_id].class_name);
}

QJS_STATIC LEPUSValue lepus_typed_array_set_internal(LEPUSContext *ctx,
                                                     LEPUSValueConst dst,
                                                     LEPUSValueConst src,
                                                     LEPUSValueConst off) {
  LEPUSObject *p;
  LEPUSObject *src_p;
  uint32_t i;
  int64_t src_len, offset;
  LEPUSValue val, src_obj = LEPUS_UNDEFINED;

  p = get_typed_array(ctx, dst, 0);
  if (!p) goto fail;
  if (LEPUS_ToInt64Sat(ctx, &offset, off)) goto fail;
  if (offset < 0) goto range_error;
  if (typed_array_is_detached(ctx, p)) {
  detached:
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  src_obj = LEPUS_ToObject(ctx, src);
  if (LEPUS_IsException(src_obj)) goto fail;
  src_p = LEPUS_VALUE_GET_OBJ(src_obj);
  if (src_p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
      src_p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
    LEPUSTypedArray *dest_ta = p->u.typed_array;
    LEPUSArrayBuffer *dest_abuf = dest_ta->buffer->u.array_buffer;
    LEPUSTypedArray *src_ta = src_p->u.typed_array;
    LEPUSArrayBuffer *src_abuf = src_ta->buffer->u.array_buffer;
    int shift = typed_array_size_log2(p->class_id);

    if (src_abuf->detached) goto detached;

    src_len = src_p->u.array.count;
    if (offset > (int64_t)(p->u.array.count - src_len)) goto range_error;

    /* copying between typed objects */
    if (src_p->class_id == p->class_id) {
      /* same type, use memmove */
      memmove(dest_abuf->data + dest_ta->offset + (offset << shift),
              src_abuf->data + src_ta->offset, src_len << shift);
      goto done;
    }
    if (dest_abuf->data == src_abuf->data) {
      /* copying between the same buffer using different types of mappings
         would require a temporary buffer */
    }
    /* otherwise, default behavior is slow but correct */
  } else {
    if (lepus_get_length64(ctx, &src_len, src_obj)) goto fail;
    if (offset > (int64_t)(p->u.array.count - src_len)) {
    range_error:
      LEPUS_ThrowRangeError(ctx, "invalid array length");
      goto fail;
    }
  }
  for (i = 0; i < src_len; i++) {
    val = LEPUS_GetPropertyUint32(ctx, src_obj, i);
    if (LEPUS_IsException(val)) goto fail;
    if (LEPUS_SetPropertyUint32(ctx, dst, offset + i, val) < 0) goto fail;
  }
done:
  LEPUS_FreeValue(ctx, src_obj);
  return LEPUS_UNDEFINED;
fail:
  LEPUS_FreeValue(ctx, src_obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_typed_array_set(LEPUSContext *ctx,
                                            LEPUSValueConst this_val, int argc,
                                            LEPUSValueConst *argv) {
  LEPUSValueConst offset = LEPUS_UNDEFINED;
  if (argc > 1) {
    offset = argv[1];
  }
  return lepus_typed_array_set_internal(ctx, this_val, argv[0], offset);
}

QJS_STATIC LEPUSValue
lepus_create_typed_array_iterator(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv, int magic) {
  if (validate_typed_array(ctx, this_val)) return LEPUS_EXCEPTION;
  return lepus_create_array_iterator(ctx, this_val, argc, argv, magic);
}

/* return < 0 if exception */
QJS_STATIC int lepus_typed_array_get_length_internal(LEPUSContext *ctx,
                                                     LEPUSValueConst obj) {
  LEPUSObject *p;
  p = get_typed_array(ctx, obj, 0);
  if (!p) return -1;
  if (typed_array_is_detached(ctx, p)) {
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    return -1;
  }
  return p->u.array.count;
}

#if 0
/* validate a typed array and return its length */
static LEPUSValue lepus_typed_array___getLength(LEPUSContext *ctx,
                                          LEPUSValueConst this_val,
                                          int argc, LEPUSValueConst *argv)
{
    BOOL ignore_detached = LEPUS_ToBool(ctx, argv[1]);

    if (ignore_detached) {
        return lepus_typed_array_get_length(ctx, argv[0]);
    } else {
        int len;
        len = lepus_typed_array_get_length_internal(ctx, argv[0]);
        if (len < 0)
            return LEPUS_EXCEPTION;
        return LEPUS_NewInt32(ctx, len);
    }
}
#endif

QJS_STATIC LEPUSValue lepus_typed_array_constructor(LEPUSContext *ctx,
                                                    LEPUSValueConst this_val,
                                                    int argc,
                                                    LEPUSValueConst *argv,
                                                    int classid);

QJS_STATIC LEPUSValue lepus_typed_array_create(LEPUSContext *ctx,
                                               LEPUSValueConst ctor, int argc,
                                               LEPUSValueConst *argv) {
  LEPUSValue ret;
  int new_len;
  int64_t len;

  ret = LEPUS_CallConstructor(ctx, ctor, argc, argv);
  if (LEPUS_IsException(ret)) return ret;
  /* validate the typed array */
  new_len = lepus_typed_array_get_length_internal(ctx, ret);
  if (new_len < 0) goto fail;
  if (argc == 1) {
    /* ensure that it is large enough */
    if (LEPUS_ToLengthFree(ctx, &len, LEPUS_DupValue(ctx, argv[0]))) goto fail;
    if (new_len < len) {
      LEPUS_ThrowTypeError(ctx, "TypedArray length is too small");
    fail:
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    }
  }
  return ret;
}

#if 0
static LEPUSValue lepus_typed_array___create(LEPUSContext *ctx,
                                       LEPUSValueConst this_val,
                                       int argc, LEPUSValueConst *argv)
{
    return lepus_typed_array_create(ctx, argv[0], max_int(argc - 1, 0), argv + 1);
}
#endif

QJS_STATIC LEPUSValue
lepus_typed_array___speciesCreate(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv) {
  LEPUSValueConst obj;
  LEPUSObject *p;
  LEPUSValue ctor, ret;
  int argc1;

  obj = argv[0];
  p = get_typed_array(ctx, obj, 0);
  if (!p) return LEPUS_EXCEPTION;
  ctor = LEPUS_SpeciesConstructor(ctx, obj, LEPUS_UNDEFINED);
  if (LEPUS_IsException(ctor)) return ctor;
  argc1 = max_int(argc - 1, 0);
  if (LEPUS_IsUndefined(ctor)) {
    ret = lepus_typed_array_constructor(ctx, LEPUS_UNDEFINED, argc1, argv + 1,
                                        p->class_id);
  } else {
    ret = lepus_typed_array_create(ctx, ctor, argc1, argv + 1);
    LEPUS_FreeValue(ctx, ctor);
  }
  return ret;
}

QJS_STATIC LEPUSValue lepus_typed_array_from(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  // from(items, mapfn = void 0, this_arg = void 0)
  LEPUSValueConst items = argv[0], mapfn, this_arg;
  LEPUSValueConst args[2];
  LEPUSValue stack[2];
  LEPUSValue iter, arr, r, v, v2;
  int64_t k, len;
  int done, mapping;

  mapping = FALSE;
  mapfn = LEPUS_UNDEFINED;
  this_arg = LEPUS_UNDEFINED;
  r = LEPUS_UNDEFINED;
  arr = LEPUS_UNDEFINED;
  stack[0] = LEPUS_UNDEFINED;
  stack[1] = LEPUS_UNDEFINED;

  if (argc > 1) {
    mapfn = argv[1];
    if (!LEPUS_IsUndefined(mapfn)) {
      if (check_function(ctx, mapfn)) goto exception;
      mapping = 1;
      if (argc > 2) this_arg = argv[2];
    }
  }
  iter = LEPUS_GetProperty(ctx, items, LEPUS_ATOM_Symbol_iterator);
  if (LEPUS_IsException(iter)) goto exception;
  if (!LEPUS_IsUndefined(iter)) {
    LEPUS_FreeValue(ctx, iter);
    arr = LEPUS_NewArray(ctx);
    if (LEPUS_IsException(arr)) goto exception;
    stack[0] = LEPUS_DupValue(ctx, items);
    if (lepus_for_of_start(ctx, &stack[1], FALSE)) goto exception;
    for (k = 0;; k++) {
      v = LEPUS_IteratorNext(ctx, stack[0], stack[1], 0, NULL, &done);
      if (LEPUS_IsException(v)) goto exception_close;
      if (done) break;
      if (LEPUS_DefinePropertyValueInt64(
              ctx, arr, k, v, LEPUS_PROP_C_W_E | LEPUS_PROP_THROW) < 0)
        goto exception_close;
    }
  } else {
    arr = LEPUS_ToObject(ctx, items);
    if (LEPUS_IsException(arr)) goto exception;
  }
  if (lepus_get_length64(ctx, &len, arr) < 0) goto exception;
  v = LEPUS_NewInt64(ctx, len);
  args[0] = v;
  r = lepus_typed_array_create(ctx, this_val, 1, args);
  LEPUS_FreeValue(ctx, v);
  if (LEPUS_IsException(r)) goto exception;
  for (k = 0; k < len; k++) {
    v = LEPUS_GetPropertyInt64(ctx, arr, k);
    if (LEPUS_IsException(v)) goto exception;
    if (mapping) {
      args[0] = v;
      args[1] = LEPUS_NewInt32(ctx, k);
      v2 = LEPUS_Call(ctx, mapfn, this_arg, 2, args);
      LEPUS_FreeValue(ctx, v);
      v = v2;
      if (LEPUS_IsException(v)) goto exception;
    }
    if (LEPUS_SetPropertyInt64(ctx, r, k, v) < 0) goto exception;
  }
  goto done;

exception_close:
  if (!LEPUS_IsUndefined(stack[0])) LEPUS_IteratorClose(ctx, stack[0], TRUE);
exception:
  LEPUS_FreeValue(ctx, r);
  r = LEPUS_EXCEPTION;
done:
  LEPUS_FreeValue(ctx, arr);
  LEPUS_FreeValue(ctx, stack[0]);
  LEPUS_FreeValue(ctx, stack[1]);
  return r;
}

QJS_STATIC LEPUSValue lepus_typed_array_of(LEPUSContext *ctx,
                                           LEPUSValueConst this_val, int argc,
                                           LEPUSValueConst *argv) {
  LEPUSValue obj;
  LEPUSValueConst args[1];
  int i;

  args[0] = LEPUS_NewInt32(ctx, argc);
  obj = lepus_typed_array_create(ctx, this_val, 1, args);
  if (LEPUS_IsException(obj)) return obj;

  for (i = 0; i < argc; i++) {
    if (LEPUS_SetPropertyUint32(ctx, obj, i, LEPUS_DupValue(ctx, argv[i])) <
        0) {
      LEPUS_FreeValue(ctx, obj);
      return LEPUS_EXCEPTION;
    }
  }
  return obj;
}

QJS_STATIC LEPUSValue lepus_typed_array_copyWithin(LEPUSContext *ctx,
                                                   LEPUSValueConst this_val,
                                                   int argc,
                                                   LEPUSValueConst *argv) {
  LEPUSObject *p;
  int len, to, from, final, count, shift;

  len = lepus_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) return LEPUS_EXCEPTION;

  if (LEPUS_ToInt32Clamp(ctx, &to, argv[0], 0, len, len))
    return LEPUS_EXCEPTION;

  if (LEPUS_ToInt32Clamp(ctx, &from, argv[1], 0, len, len))
    return LEPUS_EXCEPTION;

  final = len;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (LEPUS_ToInt32Clamp(ctx, &final, argv[2], 0, len, len))
      return LEPUS_EXCEPTION;
  }

  count = min_int(final - from, len - to);
  if (count > 0) {
    p = LEPUS_VALUE_GET_OBJ(this_val);
    if (typed_array_is_detached(ctx, p))
      return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    shift = typed_array_size_log2(p->class_id);
    memmove(p->u.array.u.uint8_ptr + (to << shift),
            p->u.array.u.uint8_ptr + (from << shift), count << shift);
  }
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue lepus_typed_array_fill(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  LEPUSObject *p;
  int len, k, final, shift;
  uint64_t v64;

  len = lepus_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) return LEPUS_EXCEPTION;
  p = LEPUS_VALUE_GET_OBJ(this_val);

  if (p->class_id == LEPUS_CLASS_UINT8C_ARRAY) {
    int32_t v;
    if (LEPUS_ToUint8ClampFree(ctx, &v, LEPUS_DupValue(ctx, argv[0])))
      return LEPUS_EXCEPTION;
    v64 = v;
  } else if (p->class_id <= LEPUS_CLASS_UINT32_ARRAY) {
    uint32_t v;
    if (LEPUS_ToUint32(ctx, &v, argv[0])) return LEPUS_EXCEPTION;
    v64 = v;
  } else
#ifdef CONFIG_BIGNUM
      if (p->class_id <= LEPUS_CLASS_BIG_UINT64_ARRAY) {
    if (LEPUS_ToBigInt64(ctx, (int64_t *)&v64, argv[0])) return LEPUS_EXCEPTION;
  } else
#endif
  {
    double d;
    if (LEPUS_ToFloat64(ctx, &d, argv[0])) return LEPUS_EXCEPTION;
    if (p->class_id == LEPUS_CLASS_FLOAT32_ARRAY) {
      union {
        float f;
        uint32_t u32;
      } u;
      u.f = d;
      v64 = u.u32;
    } else {
      LEPUSFloat64Union u;
      u.d = d;
      v64 = u.u64;
    }
  }

  k = 0;
  if (argc > 1) {
    if (LEPUS_ToInt32Clamp(ctx, &k, argv[1], 0, len, len))
      return LEPUS_EXCEPTION;
  }

  final = len;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    if (LEPUS_ToInt32Clamp(ctx, &final, argv[2], 0, len, len))
      return LEPUS_EXCEPTION;
  }

  if (typed_array_is_detached(ctx, p))
    return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  shift = typed_array_size_log2(p->class_id);
  switch (shift) {
    case 0:
      if (k < final) {
        memset(p->u.array.u.uint8_ptr + k, v64, final - k);
      }
      break;
    case 1:
      for (; k < final; k++) {
        p->u.array.u.uint16_ptr[k] = v64;
      }
      break;
    case 2:
      for (; k < final; k++) {
        p->u.array.u.uint32_ptr[k] = v64;
      }
      break;
    case 3:
      for (; k < final; k++) {
        p->u.array.u.uint64_ptr[k] = v64;
      }
      break;
    default:
      abort();
  }
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue lepus_typed_array_find(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv,
                                             int findIndex) {
  LEPUSValueConst func, this_arg;
  LEPUSValueConst args[3];
  LEPUSValue val, index_val, res;
  int len, k;

  val = LEPUS_UNDEFINED;
  len = lepus_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) goto exception;

  func = argv[0];
  if (check_function(ctx, func)) goto exception;

  this_arg = LEPUS_UNDEFINED;
  if (argc > 1) this_arg = argv[1];

  for (k = 0; k < len; k++) {
    index_val = LEPUS_NewInt32(ctx, k);
    val = LEPUS_GetPropertyValue(ctx, this_val, index_val);
    if (LEPUS_IsException(val)) goto exception;
    args[0] = val;
    args[1] = index_val;
    args[2] = this_val;
    res = LEPUS_Call(ctx, func, this_arg, 3, args);
    if (LEPUS_IsException(res)) goto exception;
    if (LEPUS_ToBoolFree(ctx, res)) {
      if (findIndex) {
        LEPUS_FreeValue(ctx, val);
        return index_val;
      } else {
        return val;
      }
    }
    LEPUS_FreeValue(ctx, val);
  }
  if (findIndex)
    return LEPUS_NewInt32(ctx, -1);
  else
    return LEPUS_UNDEFINED;

exception:
  LEPUS_FreeValue(ctx, val);
  return LEPUS_EXCEPTION;
}

#define special_indexOf 0
#define special_lastIndexOf 1
#define special_includes -1

QJS_STATIC LEPUSValue lepus_typed_array_indexOf(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc, LEPUSValueConst *argv,
                                                int special) {
  LEPUSObject *p;
  int len, is_int, is_big, k, stop, inc, res = -1;
  int64_t tag;
  int64_t v64;
  double d;
  float f;

  len = lepus_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) goto exception;
  if (len == 0) goto done;

  if (special == special_lastIndexOf) {
    k = len - 1;
    if (argc > 1) {
      if (LEPUS_ToFloat64(ctx, &d, argv[1])) goto exception;
      if (isnan(d)) {
        k = 0;
      } else {
        if (d >= 0) {
          if (d < k) {
            k = d;
          }
        } else {
          d += len;
          if (d < 0) goto done;
          k = d;
        }
      }
    }
    stop = -1;
    inc = -1;
  } else {
    k = 0;
    if (argc > 1) {
      if (LEPUS_ToInt32Clamp(ctx, &k, argv[1], 0, len, len)) goto exception;
    }
    stop = len;
    inc = 1;
  }

  p = LEPUS_VALUE_GET_OBJ(this_val);
  /* if the array was detached, no need to go further (but no
     exception is raised) */
  if (typed_array_is_detached(ctx, p)) {
    /* "includes" scans all the properties, so "undefined" can match */
    if (special == special_includes && LEPUS_IsUndefined(argv[0]) && len > 0)
      res = 0;
    goto done;
  }

  is_big = 0;
  is_int = 0; /* avoid warning */
  v64 = 0;    /* avoid warning */
  tag = LEPUS_VALUE_GET_NORM_TAG(argv[0]);
  if (tag == LEPUS_TAG_INT) {
    is_int = 1;
    v64 = LEPUS_VALUE_GET_INT(argv[0]);
    d = v64;
  } else if (tag == LEPUS_TAG_FLOAT64) {
    d = LEPUS_VALUE_GET_FLOAT64(argv[0]);
    v64 = d;
    is_int = (v64 == d);
  } else
#ifdef CONFIG_BIGNUM
      if (tag == LEPUS_TAG_BIG_INT || tag == LEPUS_TAG_BIG_FLOAT) {
    /* will a generic loop for bigint and bigfloat */
    /* XXX: should use the generic loop in math_mode? */
    is_big = 1;
  } else
#endif
  {
    goto done;
  }

  p = LEPUS_VALUE_GET_OBJ(this_val);
  switch (p->class_id) {
    case LEPUS_CLASS_INT8_ARRAY:
      if (is_int && (int8_t)v64 == v64) goto scan8;
      break;
    case LEPUS_CLASS_UINT8C_ARRAY:
    case LEPUS_CLASS_UINT8_ARRAY:
      if (is_int && (uint8_t)v64 == v64) {
        const uint8_t *pv, *pp;
        uint16_t v;
      scan8:
        pv = p->u.array.u.uint8_ptr;
        v = v64;
        if (inc > 0) {
          pp = static_cast<const uint8_t *>(memchr(pv + k, v, len - k));
          if (pp) res = pp - pv;
        } else {
          for (; k != stop; k += inc) {
            if (pv[k] == v) {
              res = k;
              break;
            }
          }
        }
      }
      break;
    case LEPUS_CLASS_INT16_ARRAY:
      if (is_int && (int16_t)v64 == v64) goto scan16;
      break;
    case LEPUS_CLASS_UINT16_ARRAY:
      if (is_int && (uint16_t)v64 == v64) {
        const uint16_t *pv;
        uint16_t v;
      scan16:
        pv = p->u.array.u.uint16_ptr;
        v = v64;
        for (; k != stop; k += inc) {
          if (pv[k] == v) {
            res = k;
            break;
          }
        }
      }
      break;
    case LEPUS_CLASS_INT32_ARRAY:
      if (is_int && (int32_t)v64 == v64) goto scan32;
      break;
    case LEPUS_CLASS_UINT32_ARRAY:
      if (is_int && (uint32_t)v64 == v64) {
        const uint32_t *pv;
        uint32_t v;
      scan32:
        pv = p->u.array.u.uint32_ptr;
        v = v64;
        for (; k != stop; k += inc) {
          if (pv[k] == v) {
            res = k;
            break;
          }
        }
      }
      break;
    case LEPUS_CLASS_FLOAT32_ARRAY:
      if (is_big) break;
      if (isnan(d)) {
        const float *pv = p->u.array.u.float_ptr;
        /* special case: indexOf returns -1, includes finds NaN */
        if (special != special_includes) goto done;
        for (; k != stop; k += inc) {
          if (isnan(pv[k])) {
            res = k;
            break;
          }
        }
      } else if ((f = (float)d) == d) {
        const float *pv = p->u.array.u.float_ptr;
        for (; k != stop; k += inc) {
          if (pv[k] == f) {
            res = k;
            break;
          }
        }
      }
      break;
    case LEPUS_CLASS_FLOAT64_ARRAY:
      if (is_big) break;
      if (isnan(d)) {
        const double *pv = p->u.array.u.double_ptr;
        /* special case: indexOf returns -1, includes finds NaN */
        if (special != special_includes) goto done;
        for (; k != stop; k += inc) {
          if (isnan(pv[k])) {
            res = k;
            break;
          }
        }
      } else {
        const double *pv = p->u.array.u.double_ptr;
        for (; k != stop; k += inc) {
          if (pv[k] == d) {
            res = k;
            break;
          }
        }
      }
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_CLASS_BIG_INT64_ARRAY:
    case LEPUS_CLASS_BIG_UINT64_ARRAY:
      if (is_big || is_strict_mode(ctx)) {
        /* generic loop for bignums, argv[0] is a bignum != NaN */
        /* XXX: optimize with explicit values */
        for (; k != stop; k += inc) {
          LEPUSValue v = LEPUS_GetPropertyUint32(ctx, this_val, k);
          int ret;
          if (LEPUS_IsException(v)) goto exception;
          ret = lepus_same_value_zero(ctx, v, argv[0]);
          LEPUS_FreeValue(ctx, v);
          if (ret) {
            if (ret < 0) goto exception;
            res = k;
            break;
          }
        }
      }
      break;
#endif
  }

done:
  if (special == special_includes)
    return LEPUS_NewBool(ctx, res >= 0);
  else
    return LEPUS_NewInt32(ctx, res);

exception:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_typed_array_join(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv,
                                             int toLocaleString) {
  LEPUSValue sep = LEPUS_UNDEFINED, el;
  StringBuffer b_s, *b = &b_s;
  LEPUSString *p = NULL;
  int i, n;
  int c;

  n = lepus_typed_array_get_length_internal(ctx, this_val);
  if (n < 0) goto exception;

  c = ','; /* default separator */
  if (!toLocaleString && argc > 0 && !LEPUS_IsUndefined(argv[0])) {
    sep = LEPUS_ToString(ctx, argv[0]);
    if (LEPUS_IsException(sep)) goto exception;
    p = LEPUS_VALUE_GET_STRING(sep);
    if (p->len == 1 && !p->is_wide_char)
      c = p->u.str8[0];
    else
      c = -1;
  }
  string_buffer_init(ctx, b, 0);

  /* XXX: optimize with direct access */
  for (i = 0; i < n; i++) {
    if (i > 0) {
      if (c >= 0) {
        if (string_buffer_putc8(b, c)) goto fail;
      } else {
        if (string_buffer_concat(b, p, 0, p->len)) goto fail;
      }
    }
    el = LEPUS_GetPropertyUint32(ctx, this_val, i);
    /* Can return undefined for example if the typed array is detached */
    if (!LEPUS_IsNull(el) && !LEPUS_IsUndefined(el)) {
      if (LEPUS_IsException(el)) goto fail;
      if (toLocaleString) {
        el = LEPUS_ToLocaleStringFree(ctx, el);
      }
      if (string_buffer_concat_value_free(b, el)) goto fail;
    }
  }
  LEPUS_FreeValue(ctx, sep);
  return string_buffer_end(b);

fail:
  string_buffer_free(b);
  LEPUS_FreeValue(ctx, sep);
exception:
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_typed_array_reverse(LEPUSContext *ctx,
                                                LEPUSValueConst this_val,
                                                int argc,
                                                LEPUSValueConst *argv) {
  LEPUSObject *p;
  int len;

  len = lepus_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) return LEPUS_EXCEPTION;
  if (len > 0) {
    p = LEPUS_VALUE_GET_OBJ(this_val);
    switch (typed_array_size_log2(p->class_id)) {
      case 0: {
        uint8_t *p1 = p->u.array.u.uint8_ptr;
        uint8_t *p2 = p1 + len - 1;
        while (p1 < p2) {
          uint8_t v = *p1;
          *p1++ = *p2;
          *p2-- = v;
        }
      } break;
      case 1: {
        uint16_t *p1 = p->u.array.u.uint16_ptr;
        uint16_t *p2 = p1 + len - 1;
        while (p1 < p2) {
          uint16_t v = *p1;
          *p1++ = *p2;
          *p2-- = v;
        }
      } break;
      case 2: {
        uint32_t *p1 = p->u.array.u.uint32_ptr;
        uint32_t *p2 = p1 + len - 1;
        while (p1 < p2) {
          uint32_t v = *p1;
          *p1++ = *p2;
          *p2-- = v;
        }
      } break;
      case 3: {
        uint64_t *p1 = p->u.array.u.uint64_ptr;
        uint64_t *p2 = p1 + len - 1;
        while (p1 < p2) {
          uint64_t v = *p1;
          *p1++ = *p2;
          *p2-- = v;
        }
      } break;
      default:
        abort();
    }
  }
  return LEPUS_DupValue(ctx, this_val);
}

QJS_STATIC LEPUSValue lepus_typed_array_slice(LEPUSContext *ctx,
                                              LEPUSValueConst this_val,
                                              int argc, LEPUSValueConst *argv) {
  LEPUSValueConst args[2];
  LEPUSValue arr, val;
  LEPUSObject *p, *p1;
  int n, len, start, final, count, shift;

  arr = LEPUS_UNDEFINED;
  len = lepus_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) goto exception;

  if (LEPUS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len)) goto exception;
  final = len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (LEPUS_ToInt32Clamp(ctx, &final, argv[1], 0, len, len)) goto exception;
  }
  count = max_int(final - start, 0);

  p = get_typed_array(ctx, this_val, 0);
  if (p == NULL) goto exception;
  shift = typed_array_size_log2(p->class_id);

  args[0] = this_val;
  args[1] = LEPUS_NewInt32(ctx, count);
  arr = lepus_typed_array___speciesCreate(ctx, LEPUS_UNDEFINED, 2, args);
  if (LEPUS_IsException(arr)) goto exception;

  if (count > 0) {
    if (validate_typed_array(ctx, this_val) || validate_typed_array(ctx, arr))
      goto exception;

    p1 = get_typed_array(ctx, arr, 0);
    if (p1 != NULL && p->class_id == p1->class_id &&
        typed_array_get_length(ctx, p1) >= count &&
        typed_array_get_length(ctx, p) >= start + count) {
      memcpy(p1->u.array.u.uint8_ptr, p->u.array.u.uint8_ptr + (start << shift),
             count << shift);
    } else {
      for (n = 0; n < count; n++) {
        val = LEPUS_GetPropertyValue(ctx, this_val,
                                     LEPUS_NewInt32(ctx, start + n));
        if (LEPUS_IsException(val)) goto exception;
        if (LEPUS_SetPropertyValue(ctx, arr, LEPUS_NewInt32(ctx, n), val,
                                   LEPUS_PROP_THROW) < 0)
          goto exception;
      }
    }
  }
  return arr;

exception:
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_typed_array_subarray(LEPUSContext *ctx,
                                                 LEPUSValueConst this_val,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  LEPUSValueConst args[4];
  LEPUSValue arr, byteOffset, ta_buffer;
  LEPUSObject *p;
  int len, start, final, count, shift, offset;

  p = get_typed_array(ctx, this_val, 0);
  if (!p) goto exception;
  len = p->u.array.count;
  if (LEPUS_ToInt32Clamp(ctx, &start, argv[0], 0, len, len)) goto exception;

  final = len;
  if (!LEPUS_IsUndefined(argv[1])) {
    if (LEPUS_ToInt32Clamp(ctx, &final, argv[1], 0, len, len)) goto exception;
  }
  count = max_int(final - start, 0);
  byteOffset = lepus_typed_array_get_byteOffset(ctx, this_val, 0);
  if (LEPUS_IsException(byteOffset)) goto exception;
  shift = typed_array_size_log2(p->class_id);
  offset = LEPUS_VALUE_GET_INT(byteOffset) + (start << shift);
  LEPUS_FreeValue(ctx, byteOffset);
  ta_buffer = lepus_typed_array_get_buffer(ctx, this_val, 0);
  if (LEPUS_IsException(ta_buffer)) goto exception;
  args[0] = this_val;
  args[1] = ta_buffer;
  args[2] = LEPUS_NewInt32(ctx, offset);
  args[3] = LEPUS_NewInt32(ctx, count);
  arr = lepus_typed_array___speciesCreate(ctx, LEPUS_UNDEFINED, 4, args);
  LEPUS_FreeValue(ctx, ta_buffer);
  return arr;

exception:
  return LEPUS_EXCEPTION;
}

/* TypedArray.prototype.sort */

QJS_STATIC int lepus_cmp_doubles(double x, double y) {
  if (isnan(x)) return isnan(y) ? 0 : +1;
  if (isnan(y)) return -1;
  if (x < y) return -1;
  if (x > y) return 1;
  if (x != 0) return 0;
  if (signbit(x))
    return signbit(y) ? 0 : -1;
  else
    return signbit(y) ? -1 : 0;
}

QJS_STATIC int lepus_TA_cmp_int8(const void *a, const void *b, void *opaque) {
  return *(const int8_t *)a - *(const int8_t *)b;
}

QJS_STATIC int lepus_TA_cmp_uint8(const void *a, const void *b, void *opaque) {
  return *(const uint8_t *)a - *(const uint8_t *)b;
}

QJS_STATIC int lepus_TA_cmp_int16(const void *a, const void *b, void *opaque) {
  return *(const int16_t *)a - *(const int16_t *)b;
}

QJS_STATIC int lepus_TA_cmp_uint16(const void *a, const void *b, void *opaque) {
  return *(const uint16_t *)a - *(const uint16_t *)b;
}

QJS_STATIC int lepus_TA_cmp_int32(const void *a, const void *b, void *opaque) {
  int32_t x = *(const int32_t *)a;
  int32_t y = *(const int32_t *)b;
  return (y < x) - (y > x);
}

QJS_STATIC int lepus_TA_cmp_uint32(const void *a, const void *b, void *opaque) {
  uint32_t x = *(const uint32_t *)a;
  uint32_t y = *(const uint32_t *)b;
  return (y < x) - (y > x);
}

#ifdef CONFIG_BIGNUM
static int lepus_TA_cmp_int64(const void *a, const void *b, void *opaque) {
  int64_t x = *(const int64_t *)a;
  int64_t y = *(const int64_t *)b;
  return (y < x) - (y > x);
}

static int lepus_TA_cmp_uint64(const void *a, const void *b, void *opaque) {
  uint64_t x = *(const uint64_t *)a;
  uint64_t y = *(const uint64_t *)b;
  return (y < x) - (y > x);
}
#endif

QJS_STATIC int lepus_TA_cmp_float32(const void *a, const void *b,
                                    void *opaque) {
  return lepus_cmp_doubles(*(const float *)a, *(const float *)b);
}

QJS_STATIC int lepus_TA_cmp_float64(const void *a, const void *b,
                                    void *opaque) {
  return lepus_cmp_doubles(*(const double *)a, *(const double *)b);
}

QJS_STATIC LEPUSValue lepus_TA_get_int8(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const int8_t *)a);
}

QJS_STATIC LEPUSValue lepus_TA_get_uint8(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const uint8_t *)a);
}

QJS_STATIC LEPUSValue lepus_TA_get_int16(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const int16_t *)a);
}

QJS_STATIC LEPUSValue lepus_TA_get_uint16(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const uint16_t *)a);
}

QJS_STATIC LEPUSValue lepus_TA_get_int32(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewInt32(ctx, *(const int32_t *)a);
}

QJS_STATIC LEPUSValue lepus_TA_get_uint32(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewUint32(ctx, *(const uint32_t *)a);
}

#ifdef CONFIG_BIGNUM
static LEPUSValue lepus_TA_get_int64(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewBigInt64(ctx, *(int64_t *)a);
}

static LEPUSValue lepus_TA_get_uint64(LEPUSContext *ctx, const void *a) {
  return LEPUS_NewBigUint64(ctx, *(uint64_t *)a);
}
#endif

QJS_STATIC LEPUSValue lepus_TA_get_float32(LEPUSContext *ctx, const void *a) {
  return __JS_NewFloat64(ctx, *(const float *)a);
}

QJS_STATIC LEPUSValue lepus_TA_get_float64(LEPUSContext *ctx, const void *a) {
  return __JS_NewFloat64(ctx, *(const double *)a);
}

struct TA_sort_context {
  LEPUSContext *ctx;
  int exception;
  LEPUSValueConst arr;
  LEPUSValueConst cmp;
  LEPUSValue (*getfun)(LEPUSContext *ctx, const void *a);
  int (*cmpfun)(const void *a, const void *b, void *opaque);
  uint8_t *array_ptr;
  int elt_size;
};

QJS_STATIC int lepus_TA_cmp_generic(const void *a, const void *b,
                                    void *opaque) {
  struct TA_sort_context *psc = static_cast<struct TA_sort_context *>(opaque);
  LEPUSContext *ctx = psc->ctx;
  uint32_t a_idx, b_idx;
  LEPUSValueConst argv[2];
  LEPUSValue res;
  int cmp;

  cmp = 0;
  if (!psc->exception) {
    a_idx = *(uint32_t *)a;
    b_idx = *(uint32_t *)b;
    argv[0] = psc->getfun(ctx, psc->array_ptr + a_idx * (size_t)psc->elt_size);
    argv[1] =
        psc->getfun(ctx, psc->array_ptr + b_idx * (size_t)(psc->elt_size));
    res = LEPUS_Call(ctx, psc->cmp, LEPUS_UNDEFINED, 2, argv);
    if (LEPUS_IsException(res)) {
      psc->exception = 1;
      goto done;
    }
    if (LEPUS_VALUE_IS_INT(res)) {
      int val = LEPUS_VALUE_GET_INT(res);
      cmp = (val > 0) - (val < 0);
    } else {
      double val;
      if (LEPUS_ToFloat64Free(ctx, &val, res) < 0) {
        psc->exception = 1;
        goto done;
      } else {
        cmp = (val > 0) - (val < 0);
      }
    }
    if (cmp == 0) {
      /* make sort stable: compare array offsets */
      cmp = (a_idx > b_idx) - (a_idx < b_idx);
    }
    if (validate_typed_array(ctx, psc->arr) < 0) {
      psc->exception = 1;
    }
  done:
    LEPUS_FreeValue(ctx, (LEPUSValue)argv[0]);
    LEPUS_FreeValue(ctx, (LEPUSValue)argv[1]);
  }
  return cmp;
}

QJS_STATIC LEPUSValue lepus_typed_array_sort(LEPUSContext *ctx,
                                             LEPUSValueConst this_val, int argc,
                                             LEPUSValueConst *argv) {
  LEPUSObject *p;
  int len, elt_size;
  struct TA_sort_context tsc;
  void *array_ptr, *array_copy = NULL, *array_org;
  int (*cmpfun)(const void *a, const void *b, void *opaque);

  tsc.ctx = ctx;
  tsc.exception = 0;
  tsc.arr = this_val;
  tsc.cmp = argv[0];

  len = lepus_typed_array_get_length_internal(ctx, this_val);
  if (len < 0) return LEPUS_EXCEPTION;
  if (!LEPUS_IsUndefined(tsc.cmp) && check_function(ctx, tsc.cmp))
    return LEPUS_EXCEPTION;

  if (len > 1) {
    p = LEPUS_VALUE_GET_OBJ(this_val);
    switch (p->class_id) {
      case LEPUS_CLASS_INT8_ARRAY:
        tsc.getfun = lepus_TA_get_int8;
        tsc.cmpfun = lepus_TA_cmp_int8;
        break;
      case LEPUS_CLASS_UINT8C_ARRAY:
      case LEPUS_CLASS_UINT8_ARRAY:
        tsc.getfun = lepus_TA_get_uint8;
        tsc.cmpfun = lepus_TA_cmp_uint8;
        break;
      case LEPUS_CLASS_INT16_ARRAY:
        tsc.getfun = lepus_TA_get_int16;
        tsc.cmpfun = lepus_TA_cmp_int16;
        break;
      case LEPUS_CLASS_UINT16_ARRAY:
        tsc.getfun = lepus_TA_get_uint16;
        tsc.cmpfun = lepus_TA_cmp_uint16;
        break;
      case LEPUS_CLASS_INT32_ARRAY:
        tsc.getfun = lepus_TA_get_int32;
        tsc.cmpfun = lepus_TA_cmp_int32;
        break;
      case LEPUS_CLASS_UINT32_ARRAY:
        tsc.getfun = lepus_TA_get_uint32;
        tsc.cmpfun = lepus_TA_cmp_uint32;
        break;
#ifdef CONFIG_BIGNUM
      case LEPUS_CLASS_BIG_INT64_ARRAY:
        tsc.getfun = lepus_TA_get_int64;
        tsc.cmpfun = lepus_TA_cmp_int64;
        break;
      case LEPUS_CLASS_BIG_UINT64_ARRAY:
        tsc.getfun = lepus_TA_get_uint64;
        tsc.cmpfun = lepus_TA_cmp_uint64;
        break;
#endif
      case LEPUS_CLASS_FLOAT32_ARRAY:
        tsc.getfun = lepus_TA_get_float32;
        tsc.cmpfun = lepus_TA_cmp_float32;
        break;
      case LEPUS_CLASS_FLOAT64_ARRAY:
        tsc.getfun = lepus_TA_get_float64;
        tsc.cmpfun = lepus_TA_cmp_float64;
        break;
      default:
        abort();
    }
    array_ptr = array_org = p->u.array.u.ptr;
    elt_size = 1 << typed_array_size_log2(p->class_id);
    cmpfun = tsc.cmpfun;
    if (!LEPUS_IsUndefined(tsc.cmp)) {
      uint32_t *array_idx;
      void *array_tmp;
      size_t i, j;

      /* XXX: a stable sort would use less memory */
      array_idx = static_cast<uint32_t *>(
          lepus_malloc(ctx, len * sizeof(array_idx[0])));
      if (!array_idx) return LEPUS_EXCEPTION;
      for (i = 0; i < len; i++) array_idx[i] = i;
      tsc.array_ptr = static_cast<uint8_t *>(array_ptr);
      tsc.elt_size = elt_size;
      rqsort(array_idx, len, sizeof(array_idx[0]), lepus_TA_cmp_generic, &tsc);
      if (tsc.exception) goto fail;
      array_tmp = lepus_malloc(ctx, len * elt_size);
      if (!array_tmp) {
      fail:
        lepus_free(ctx, array_idx);
        return LEPUS_EXCEPTION;
      }
      memcpy(array_tmp, array_ptr, len * elt_size);
      switch (elt_size) {
        case 1:
          for (i = 0; i < len; i++) {
            j = array_idx[i];
            ((uint8_t *)array_ptr)[i] = ((uint8_t *)array_tmp)[j];
          }
          break;
        case 2:
          for (i = 0; i < len; i++) {
            j = array_idx[i];
            ((uint16_t *)array_ptr)[i] = ((uint16_t *)array_tmp)[j];
          }
          break;
        case 4:
          for (i = 0; i < len; i++) {
            j = array_idx[i];
            ((uint32_t *)array_ptr)[i] = ((uint32_t *)array_tmp)[j];
          }
          break;
        case 8:
          for (i = 0; i < len; i++) {
            j = array_idx[i];
            ((uint64_t *)array_ptr)[i] = ((uint64_t *)array_tmp)[j];
          }
          break;
        default:
          abort();
      }
      lepus_free(ctx, array_tmp);
      lepus_free(ctx, array_idx);
    } else {
      rqsort(array_ptr, len, elt_size, cmpfun, &tsc);
      if (tsc.exception) {
        return LEPUS_EXCEPTION;
      }
    }
  }
  return LEPUS_DupValue(ctx, this_val);
}

static const LEPUSCFunctionListEntry lepus_typed_array_base_funcs[] = {
    LEPUS_CFUNC_DEF("from", 1, lepus_typed_array_from),
    LEPUS_CFUNC_DEF("of", 0, lepus_typed_array_of),
    LEPUS_CGETSET_DEF("[Symbol.species]", lepus_get_this, NULL),
    // LEPUS_CFUNC_DEF("__getLength", 2, lepus_typed_array___getLength ),
    // LEPUS_CFUNC_DEF("__create", 2, lepus_typed_array___create ),
    // LEPUS_CFUNC_DEF("__speciesCreate", 2, lepus_typed_array___speciesCreate
    // ),
};

static const LEPUSCFunctionListEntry lepus_typed_array_base_proto_funcs[] = {
    LEPUS_CGETSET_DEF("length", lepus_typed_array_get_length, NULL),
    LEPUS_CGETSET_MAGIC_DEF("buffer", lepus_typed_array_get_buffer, NULL, 0),
    LEPUS_CGETSET_MAGIC_DEF("byteLength", lepus_typed_array_get_byteLength,
                            NULL, 0),
    LEPUS_CGETSET_MAGIC_DEF("byteOffset", lepus_typed_array_get_byteOffset,
                            NULL, 0),
    LEPUS_CFUNC_DEF("set", 1, lepus_typed_array_set),
    LEPUS_CFUNC_MAGIC_DEF("values", 0, lepus_create_typed_array_iterator,
                          LEPUS_ITERATOR_KIND_VALUE),
    LEPUS_ALIAS_DEF("[Symbol.iterator]", "values"),
    LEPUS_CFUNC_MAGIC_DEF("keys", 0, lepus_create_typed_array_iterator,
                          LEPUS_ITERATOR_KIND_KEY),
    LEPUS_CFUNC_MAGIC_DEF("entries", 0, lepus_create_typed_array_iterator,
                          LEPUS_ITERATOR_KIND_KEY_AND_VALUE),
    LEPUS_CGETSET_DEF("[Symbol.toStringTag]", lepus_typed_array_get_toStringTag,
                      NULL),
    LEPUS_CFUNC_DEF("copyWithin", 2, lepus_typed_array_copyWithin),
    LEPUS_CFUNC_MAGIC_DEF("every", 1, lepus_array_every,
                          special_every | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("some", 1, lepus_array_every,
                          special_some | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("forEach", 1, lepus_array_every,
                          special_forEach | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("map", 1, lepus_array_every,
                          special_map | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("filter", 1, lepus_array_every,
                          special_filter | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("reduce", 1, lepus_array_reduce,
                          special_reduce | special_TA),
    LEPUS_CFUNC_MAGIC_DEF("reduceRight", 1, lepus_array_reduce,
                          special_reduceRight | special_TA),
    LEPUS_CFUNC_DEF("fill", 1, lepus_typed_array_fill),
    LEPUS_CFUNC_MAGIC_DEF("find", 1, lepus_typed_array_find, 0),
    LEPUS_CFUNC_MAGIC_DEF("findIndex", 1, lepus_typed_array_find, 1),
    LEPUS_CFUNC_DEF("reverse", 0, lepus_typed_array_reverse),
    LEPUS_CFUNC_DEF("slice", 2, lepus_typed_array_slice),
    LEPUS_CFUNC_DEF("subarray", 2, lepus_typed_array_subarray),
    LEPUS_CFUNC_DEF("sort", 1, lepus_typed_array_sort),
    LEPUS_CFUNC_MAGIC_DEF("join", 1, lepus_typed_array_join, 0),
    LEPUS_CFUNC_MAGIC_DEF("toLocaleString", 0, lepus_typed_array_join, 1),
    LEPUS_CFUNC_MAGIC_DEF("indexOf", 1, lepus_typed_array_indexOf,
                          special_indexOf),
    LEPUS_CFUNC_MAGIC_DEF("lastIndexOf", 1, lepus_typed_array_indexOf,
                          special_lastIndexOf),
    LEPUS_CFUNC_MAGIC_DEF("includes", 1, lepus_typed_array_indexOf,
                          special_includes),
    // LEPUS_ALIAS_BASE_DEF("toString", "toString", 2 /* Array.prototype. */),
    // @@@
};

QJS_STATIC LEPUSValue
lepus_typed_array_base_constructor(LEPUSContext *ctx, LEPUSValueConst this_val,
                                   int argc, LEPUSValueConst *argv) {
  return LEPUS_ThrowTypeError(ctx, "cannot be called");
}

/* 'obj' must be an allocated typed array object */
QJS_STATIC int typed_array_init(LEPUSContext *ctx, LEPUSValueConst obj,
                                LEPUSValue buffer, uint64_t offset,
                                uint64_t len) {
  LEPUSTypedArray *ta;
  LEPUSObject *p, *pbuffer;
  LEPUSArrayBuffer *abuf;
  int size_log2;

  p = LEPUS_VALUE_GET_OBJ(obj);
  size_log2 = typed_array_size_log2(p->class_id);
  ta = static_cast<LEPUSTypedArray *>(lepus_malloc(ctx, sizeof(*ta)));
  if (!ta) {
    LEPUS_FreeValue(ctx, buffer);
    return -1;
  }
  pbuffer = LEPUS_VALUE_GET_OBJ(buffer);
  abuf = pbuffer->u.array_buffer;
  ta->obj = p;
  ta->buffer = pbuffer;
  ta->offset = offset;
  ta->length = len << size_log2;
  list_add_tail(&ta->link, &abuf->array_list);
  p->u.typed_array = ta;
  p->u.array.count = len;
  p->u.array.u.ptr = abuf->data + offset;
  return 0;
}

QJS_STATIC LEPUSValue lepus_array_from_iterator(LEPUSContext *ctx,
                                                uint32_t *plen,
                                                LEPUSValueConst obj,
                                                LEPUSValueConst method) {
  LEPUSValue arr, iter, next_method = LEPUS_UNDEFINED, val;
  BOOL done;
  uint32_t k;

  *plen = 0;
  arr = LEPUS_NewArray(ctx);
  if (LEPUS_IsException(arr)) return arr;
  iter = LEPUS_GetIterator2(ctx, obj, method);
  if (LEPUS_IsException(iter)) goto fail;
  next_method = LEPUS_GetProperty(ctx, iter, LEPUS_ATOM_next);
  if (LEPUS_IsException(next_method)) goto fail;
  k = 0;
  for (;;) {
    val = LEPUS_IteratorNext(ctx, iter, next_method, 0, NULL, &done);
    if (LEPUS_IsException(val)) goto fail;
    if (done) {
      LEPUS_FreeValue(ctx, val);
      break;
    }
    if (LEPUS_CreateDataPropertyUint32(ctx, arr, k, val, LEPUS_PROP_THROW) < 0)
      goto fail;
    k++;
  }
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  *plen = k;
  return arr;
fail:
  LEPUS_FreeValue(ctx, next_method);
  LEPUS_FreeValue(ctx, iter);
  LEPUS_FreeValue(ctx, arr);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue
lepus_typed_array_constructor_obj(LEPUSContext *ctx, LEPUSValueConst new_target,
                                  LEPUSValueConst obj, int classid) {
  LEPUSValue iter, ret, arr = LEPUS_UNDEFINED, val, buffer;
  uint32_t i;
  int size_log2;
  int64_t len;

  size_log2 = typed_array_size_log2(classid);
  ret = lepus_create_from_ctor(ctx, new_target, classid);
  if (LEPUS_IsException(ret)) return LEPUS_EXCEPTION;

  iter = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_Symbol_iterator);
  if (LEPUS_IsException(iter)) goto fail;
  if (!LEPUS_IsUndefined(iter) && !LEPUS_IsNull(iter)) {
    uint32_t len1;
    arr = lepus_array_from_iterator(ctx, &len1, obj, iter);
    LEPUS_FreeValue(ctx, iter);
    if (LEPUS_IsException(arr)) goto fail;
    len = len1;
  } else {
    if (lepus_get_length64(ctx, &len, obj)) goto fail;
    arr = LEPUS_DupValue(ctx, obj);
  }

  buffer =
      lepus_array_buffer_constructor1(ctx, LEPUS_UNDEFINED, len << size_log2);
  if (LEPUS_IsException(buffer)) goto fail;
  if (typed_array_init(ctx, ret, buffer, 0, len)) goto fail;

  for (i = 0; i < len; i++) {
    val = LEPUS_GetPropertyUint32(ctx, arr, i);
    if (LEPUS_IsException(val)) goto fail;
    if (LEPUS_SetPropertyUint32(ctx, ret, i, val) < 0) goto fail;
  }
  LEPUS_FreeValue(ctx, arr);
  return ret;
fail:
  LEPUS_FreeValue(ctx, arr);
  LEPUS_FreeValue(ctx, ret);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue
lepus_typed_array_constructor_ta(LEPUSContext *ctx, LEPUSValueConst new_target,
                                 LEPUSValueConst src_obj, int classid) {
  LEPUSObject *p, *src_buffer;
  LEPUSTypedArray *ta;
  LEPUSValue ctor, obj, buffer;
  uint32_t len, i;
  int size_log2;
  LEPUSArrayBuffer *src_abuf, *abuf;

  obj = lepus_create_from_ctor(ctx, new_target, classid);
  if (LEPUS_IsException(obj)) return obj;
  p = LEPUS_VALUE_GET_OBJ(src_obj);
  if (typed_array_is_detached(ctx, p)) {
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  ta = p->u.typed_array;
  len = p->u.array.count;
  src_buffer = ta->buffer;
  src_abuf = src_buffer->u.array_buffer;
  if (!src_abuf->shared) {
    ctor = LEPUS_SpeciesConstructor(
        ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, src_buffer), LEPUS_UNDEFINED);
    if (LEPUS_IsException(ctor)) goto fail;
  } else {
    /* force ArrayBuffer default constructor */
    ctor = LEPUS_UNDEFINED;
  }
  size_log2 = typed_array_size_log2(classid);
  buffer =
      lepus_array_buffer_constructor1(ctx, ctor, (uint64_t)len << size_log2);
  LEPUS_FreeValue(ctx, ctor);
  if (LEPUS_IsException(buffer)) goto fail;
  /* necessary because it could have been detached */
  if (typed_array_is_detached(ctx, p)) {
    LEPUS_FreeValue(ctx, buffer);
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  abuf = static_cast<LEPUSArrayBuffer *>(
      LEPUS_GetOpaque(buffer, LEPUS_CLASS_ARRAY_BUFFER));
  if (typed_array_init(ctx, obj, buffer, 0, len)) goto fail;
  if (p->class_id == classid) {
    /* same type: copy the content */
    memcpy(abuf->data, src_abuf->data + ta->offset, abuf->byte_length);
  } else {
    for (i = 0; i < len; i++) {
      LEPUSValue val;
      val = LEPUS_GetPropertyUint32(ctx, src_obj, i);
      if (LEPUS_IsException(val)) goto fail;
      if (LEPUS_SetPropertyUint32(ctx, obj, i, val) < 0) goto fail;
    }
  }
  return obj;
fail:
  LEPUS_FreeValue(ctx, obj);
  return LEPUS_EXCEPTION;
}

QJS_STATIC LEPUSValue lepus_typed_array_constructor(LEPUSContext *ctx,
                                                    LEPUSValueConst new_target,
                                                    int argc,
                                                    LEPUSValueConst *argv,
                                                    int classid) {
  LEPUSValue buffer, obj;
  LEPUSArrayBuffer *abuf;
  int size_log2;
  uint64_t len, offset;

  size_log2 = typed_array_size_log2(classid);
  if (LEPUS_VALUE_IS_NOT_OBJECT(argv[0])) {
    if (LEPUS_ToIndex(ctx, &len, argv[0])) return LEPUS_EXCEPTION;
    buffer =
        lepus_array_buffer_constructor1(ctx, LEPUS_UNDEFINED, len << size_log2);
    if (LEPUS_IsException(buffer)) return LEPUS_EXCEPTION;
    offset = 0;
  } else {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(argv[0]);
    if (p->class_id == LEPUS_CLASS_ARRAY_BUFFER ||
        p->class_id == LEPUS_CLASS_SHARED_ARRAY_BUFFER) {
      abuf = p->u.array_buffer;
      if (LEPUS_ToIndex(ctx, &offset, argv[1])) return LEPUS_EXCEPTION;
      if (abuf->detached) return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
      if ((offset & ((1 << size_log2) - 1)) != 0 || offset > abuf->byte_length)
        return LEPUS_ThrowRangeError(ctx, "invalid offset");
      if (LEPUS_IsUndefined(argv[2])) {
        if ((abuf->byte_length & ((1 << size_log2) - 1)) != 0)
          goto invalid_length;
        len = (abuf->byte_length - offset) >> size_log2;
      } else {
        if (LEPUS_ToIndex(ctx, &len, argv[2])) return LEPUS_EXCEPTION;
        if (abuf->detached) return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
        if ((offset + (len << size_log2)) > abuf->byte_length) {
        invalid_length:
          return LEPUS_ThrowRangeError(ctx, "invalid length");
        }
      }
      buffer = LEPUS_DupValue(ctx, argv[0]);
    } else {
      if (p->class_id >= LEPUS_CLASS_UINT8C_ARRAY &&
          p->class_id <= LEPUS_CLASS_FLOAT64_ARRAY) {
        return lepus_typed_array_constructor_ta(ctx, new_target, argv[0],
                                                classid);
      } else {
        return lepus_typed_array_constructor_obj(ctx, new_target, argv[0],
                                                 classid);
      }
    }
  }

  obj = lepus_create_from_ctor(ctx, new_target, classid);
  if (LEPUS_IsException(obj)) {
    LEPUS_FreeValue(ctx, buffer);
    return LEPUS_EXCEPTION;
  }
  if (typed_array_init(ctx, obj, buffer, offset, len)) {
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  return obj;
}

QJS_STATIC void lepus_typed_array_finalizer(LEPUSRuntime *rt, LEPUSValue val) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSTypedArray *ta = p->u.typed_array;
  if (ta) {
    /* during the GC the finalizers are called in an arbitrary
       order so the ArrayBuffer finalizer may have been called */
    if (LEPUS_IsLiveObject(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer))) {
      list_del(&ta->link);
    }
    LEPUS_FreeValueRT(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer));
    lepus_free_rt(rt, ta);
  }
}

QJS_STATIC void lepus_typed_array_mark(LEPUSRuntime *rt, LEPUSValueConst val,
                                       LEPUS_MarkFunc *mark_func) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  LEPUSTypedArray *ta = p->u.typed_array;
  if (ta) {
    LEPUS_MarkValue(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer), mark_func);
  }
}

QJS_STATIC LEPUSValue lepus_dataview_constructor(LEPUSContext *ctx,
                                                 LEPUSValueConst new_target,
                                                 int argc,
                                                 LEPUSValueConst *argv) {
  LEPUSArrayBuffer *abuf;
  uint64_t offset;
  uint32_t len;
  LEPUSValueConst buffer;
  LEPUSValue obj;
  LEPUSTypedArray *ta;
  LEPUSObject *p;

  buffer = argv[0];
  abuf = lepus_get_array_buffer(ctx, buffer);
  if (!abuf) return LEPUS_EXCEPTION;
  offset = 0;
  if (argc > 1) {
    if (LEPUS_ToIndex(ctx, &offset, argv[1])) return LEPUS_EXCEPTION;
  }
  if (abuf->detached) return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  if (offset > abuf->byte_length)
    return LEPUS_ThrowRangeError(ctx, "invalid byteOffset");
  len = abuf->byte_length - offset;
  if (argc > 2 && !LEPUS_IsUndefined(argv[2])) {
    uint64_t l;
    if (LEPUS_ToIndex(ctx, &l, argv[2])) return LEPUS_EXCEPTION;
    if (l > len) return LEPUS_ThrowRangeError(ctx, "invalid byteLength");
    len = l;
  }

  obj = lepus_create_from_ctor(ctx, new_target, LEPUS_CLASS_DATAVIEW);
  if (LEPUS_IsException(obj)) return LEPUS_EXCEPTION;
  if (abuf->detached) {
    /* could have been detached in lepus_create_from_ctor() */
    LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
    goto fail;
  }
  ta = static_cast<LEPUSTypedArray *>(lepus_malloc(ctx, sizeof(*ta)));
  if (!ta) {
  fail:
    LEPUS_FreeValue(ctx, obj);
    return LEPUS_EXCEPTION;
  }
  p = LEPUS_VALUE_GET_OBJ(obj);
  ta->obj = p;
  ta->buffer = LEPUS_VALUE_GET_OBJ(LEPUS_DupValue(ctx, buffer));
  ta->offset = offset;
  ta->length = len;
  list_add_tail(&ta->link, &abuf->array_list);
  p->u.typed_array = ta;
  return obj;
}

QJS_STATIC LEPUSValue lepus_dataview_getValue(LEPUSContext *ctx,
                                              LEPUSValueConst this_obj,
                                              int argc, LEPUSValueConst *argv,
                                              int class_id) {
  LEPUSTypedArray *ta;
  LEPUSArrayBuffer *abuf;
  int is_swap, size;
  uint8_t *ptr;
  uint32_t v;
  uint64_t pos;

  ta = static_cast<LEPUSTypedArray *>(
      LEPUS_GetOpaque2(ctx, this_obj, LEPUS_CLASS_DATAVIEW));
  if (!ta) return LEPUS_EXCEPTION;
  size = 1 << typed_array_size_log2(class_id);
  if (LEPUS_ToIndex(ctx, &pos, argv[0])) return LEPUS_EXCEPTION;
  is_swap = FALSE;
  if (argc > 1) is_swap = LEPUS_ToBool(ctx, argv[1]);
#ifndef WORDS_BIGENDIAN
  is_swap ^= 1;
#endif
  abuf = ta->buffer->u.array_buffer;
  if (abuf->detached) return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  if ((pos + size) > ta->length)
    return LEPUS_ThrowRangeError(ctx, "out of bound");
  ptr = abuf->data + ta->offset + pos;

  switch (class_id) {
    case LEPUS_CLASS_INT8_ARRAY:
      return LEPUS_NewInt32(ctx, *(int8_t *)ptr);
    case LEPUS_CLASS_UINT8_ARRAY:
      return LEPUS_NewInt32(ctx, *(uint8_t *)ptr);
    case LEPUS_CLASS_INT16_ARRAY:
      v = get_u16(ptr);
      if (is_swap) v = bswap16(v);
      return LEPUS_NewInt32(ctx, (int16_t)v);
    case LEPUS_CLASS_UINT16_ARRAY:
      v = get_u16(ptr);
      if (is_swap) v = bswap16(v);
      return LEPUS_NewInt32(ctx, v);
    case LEPUS_CLASS_INT32_ARRAY:
      v = get_u32(ptr);
      if (is_swap) v = bswap32(v);
      return LEPUS_NewInt32(ctx, v);
    case LEPUS_CLASS_UINT32_ARRAY:
      v = get_u32(ptr);
      if (is_swap) v = bswap32(v);
      return LEPUS_NewUint32(ctx, v);
#ifdef CONFIG_BIGNUM
    case LEPUS_CLASS_BIG_INT64_ARRAY: {
      uint64_t v;
      v = get_u64(ptr);
      if (is_swap) v = bswap64(v);
      return LEPUS_NewBigInt64(ctx, v);
    } break;
    case LEPUS_CLASS_BIG_UINT64_ARRAY: {
      uint64_t v;
      v = get_u64(ptr);
      if (is_swap) v = bswap64(v);
      return LEPUS_NewBigUint64(ctx, v);
    } break;
#endif
    case LEPUS_CLASS_FLOAT32_ARRAY: {
      union {
        float f;
        uint32_t i;
      } u;
      v = get_u32(ptr);
      if (is_swap) v = bswap32(v);
      u.i = v;
      return __JS_NewFloat64(ctx, u.f);
    }
    case LEPUS_CLASS_FLOAT64_ARRAY: {
      union {
        double f;
        uint64_t i;
      } u;
      u.i = get_u64(ptr);
      if (is_swap) u.i = bswap64(u.i);
      return __JS_NewFloat64(ctx, u.f);
    }
    default:
      abort();
  }
}

QJS_STATIC LEPUSValue lepus_dataview_setValue(LEPUSContext *ctx,
                                              LEPUSValueConst this_obj,
                                              int argc, LEPUSValueConst *argv,
                                              int class_id) {
  LEPUSTypedArray *ta;
  LEPUSArrayBuffer *abuf;
  int is_swap, size;
  uint8_t *ptr;
  uint64_t v64;
  uint32_t v;
  uint64_t pos;
  LEPUSValueConst val;

  ta = static_cast<LEPUSTypedArray *>(
      LEPUS_GetOpaque2(ctx, this_obj, LEPUS_CLASS_DATAVIEW));
  if (!ta) return LEPUS_EXCEPTION;
  size = 1 << typed_array_size_log2(class_id);
  if (LEPUS_ToIndex(ctx, &pos, argv[0])) return LEPUS_EXCEPTION;
  val = argv[1];
  v = 0;   /* avoid warning */
  v64 = 0; /* avoid warning */
  if (class_id <= LEPUS_CLASS_UINT32_ARRAY) {
    if (LEPUS_ToUint32(ctx, &v, val)) return LEPUS_EXCEPTION;
  } else
#ifdef CONFIG_BIGNUM
      if (class_id <= LEPUS_CLASS_BIG_UINT64_ARRAY) {
    if (LEPUS_ToBigInt64(ctx, (int64_t *)&v64, val)) return LEPUS_EXCEPTION;
  } else
#endif
  {
    double d;
    if (LEPUS_ToFloat64(ctx, &d, val)) return LEPUS_EXCEPTION;
    if (class_id == LEPUS_CLASS_FLOAT32_ARRAY) {
      union {
        float f;
        uint32_t i;
      } u;
      u.f = d;
      v = u.i;
    } else {
      LEPUSFloat64Union u;
      u.d = d;
      v64 = u.u64;
    }
  }
  is_swap = FALSE;
  if (argc > 2) is_swap = LEPUS_ToBool(ctx, argv[2]);
#ifndef WORDS_BIGENDIAN
  is_swap ^= 1;
#endif
  abuf = ta->buffer->u.array_buffer;
  if (abuf->detached) return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  if ((pos + size) > ta->length)
    return LEPUS_ThrowRangeError(ctx, "out of bound");
  ptr = abuf->data + ta->offset + pos;

  switch (class_id) {
    case LEPUS_CLASS_INT8_ARRAY:
    case LEPUS_CLASS_UINT8_ARRAY:
      *ptr = v;
      break;
    case LEPUS_CLASS_INT16_ARRAY:
    case LEPUS_CLASS_UINT16_ARRAY:
      if (is_swap) v = bswap16(v);
      put_u16(ptr, v);
      break;
    case LEPUS_CLASS_INT32_ARRAY:
    case LEPUS_CLASS_UINT32_ARRAY:
    case LEPUS_CLASS_FLOAT32_ARRAY:
      if (is_swap) v = bswap32(v);
      put_u32(ptr, v);
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_CLASS_BIG_INT64_ARRAY:
    case LEPUS_CLASS_BIG_UINT64_ARRAY:
#endif
    case LEPUS_CLASS_FLOAT64_ARRAY:
      if (is_swap) v64 = bswap64(v64);
      put_u64(ptr, v64);
      break;
    default:
      abort();
  }
  return LEPUS_UNDEFINED;
}

static const LEPUSCFunctionListEntry lepus_dataview_proto_funcs[] = {
    LEPUS_CGETSET_MAGIC_DEF("buffer", lepus_typed_array_get_buffer, NULL, 1),
    LEPUS_CGETSET_MAGIC_DEF("byteLength", lepus_typed_array_get_byteLength,
                            NULL, 1),
    LEPUS_CGETSET_MAGIC_DEF("byteOffset", lepus_typed_array_get_byteOffset,
                            NULL, 1),
    LEPUS_CFUNC_MAGIC_DEF("getInt8", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_INT8_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("getUint8", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_UINT8_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("getInt16", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_INT16_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("getUint16", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_UINT16_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("getInt32", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_INT32_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("getUint32", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_UINT32_ARRAY),
#ifdef CONFIG_BIGNUM
    LEPUS_CFUNC_MAGIC_DEF("getBigInt64", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_BIG_INT64_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("getBigUint64", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_BIG_UINT64_ARRAY),
#endif
    LEPUS_CFUNC_MAGIC_DEF("getFloat32", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_FLOAT32_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("getFloat64", 1, lepus_dataview_getValue,
                          LEPUS_CLASS_FLOAT64_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("setInt8", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_INT8_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("setUint8", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_UINT8_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("setInt16", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_INT16_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("setUint16", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_UINT16_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("setInt32", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_INT32_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("setUint32", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_UINT32_ARRAY),
#ifdef CONFIG_BIGNUM
    LEPUS_CFUNC_MAGIC_DEF("setBigInt64", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_BIG_INT64_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("setBigUint64", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_BIG_UINT64_ARRAY),
#endif
    LEPUS_CFUNC_MAGIC_DEF("setFloat32", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_FLOAT32_ARRAY),
    LEPUS_CFUNC_MAGIC_DEF("setFloat64", 2, lepus_dataview_setValue,
                          LEPUS_CLASS_FLOAT64_ARRAY),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "DataView",
                          LEPUS_PROP_CONFIGURABLE),
};

/* Atomics */
#ifdef CONFIG_ATOMICS

typedef enum AtomicsOpEnum {
  ATOMICS_OP_ADD,
  ATOMICS_OP_AND,
  ATOMICS_OP_OR,
  ATOMICS_OP_SUB,
  ATOMICS_OP_XOR,
  ATOMICS_OP_EXCHANGE,
  ATOMICS_OP_COMPARE_EXCHANGE,
  ATOMICS_OP_LOAD,
} AtomicsOpEnum;

static void *lepus_atomics_get_ptr(LEPUSContext *ctx, int *psize_log2,
                                   LEPUSClassID *pclass_id, LEPUSValueConst obj,
                                   LEPUSValueConst idx_val, BOOL is_waitable) {
  LEPUSObject *p;
  LEPUSTypedArray *ta;
  LEPUSArrayBuffer *abuf;
  void *ptr;
  uint64_t idx;
  BOOL err;
  int size_log2;

  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) goto fail;
  p = LEPUS_VALUE_GET_OBJ(obj);
#ifdef CONFIG_BIGNUM
  if (is_waitable)
    err = (p->class_id != LEPUS_CLASS_INT32_ARRAY &&
           p->class_id != LEPUS_CLASS_BIG_INT64_ARRAY);
  else
    err = !(p->class_id >= LEPUS_CLASS_INT8_ARRAY &&
            p->class_id <= LEPUS_CLASS_BIG_UINT64_ARRAY);
#else
  if (is_waitable)
    err = (p->class_id != LEPUS_CLASS_INT32_ARRAY);
  else
    err = !(p->class_id >= LEPUS_CLASS_INT8_ARRAY &&
            p->class_id <= LEPUS_CLASS_UINT32_ARRAY);
#endif
  if (err) {
  fail:
    LEPUS_ThrowTypeError(ctx, "integer TypedArray expected");
    return NULL;
  }
  ta = p->u.typed_array;
  abuf = ta->buffer->u.array_buffer;
  if (!abuf->shared) {
    LEPUS_ThrowTypeError(ctx, "not a SharedArrayBuffer TypedArray");
    return NULL;
  }
  if (LEPUS_ToIndex(ctx, &idx, idx_val)) {
    return NULL;
  }
  if (idx >= p->u.array.count) {
    LEPUS_ThrowRangeError(ctx, "out-of-bound access");
    return NULL;
  }
  size_log2 = typed_array_size_log2(p->class_id);
  ptr = p->u.array.u.uint8_ptr + ((uintptr_t)idx << size_log2);
  if (psize_log2) *psize_log2 = size_log2;
  if (pclass_id) *pclass_id = p->class_id;
  return ptr;
}

static LEPUSValue lepus_atomics_op(LEPUSContext *ctx, LEPUSValueConst this_obj,
                                   int argc, LEPUSValueConst *argv, int op) {
  int size_log2;
#ifdef CONFIG_BIGNUM
  uint64_t v, a, rep_val;
#else
  uint32_t v, a, rep_val;
#endif
  void *ptr;
  LEPUSValue ret;
  LEPUSClassID class_id;

  ptr = lepus_atomics_get_ptr(ctx, &size_log2, &class_id, argv[0], argv[1],
                              FALSE);
  if (!ptr) return LEPUS_EXCEPTION;
  rep_val = 0;
  if (op == ATOMICS_OP_LOAD) {
    v = 0;
  } else
#ifdef CONFIG_BIGNUM
      if (size_log2 == 3) {
    int64_t v64;
    if (LEPUS_ToBigInt64(ctx, &v64, argv[2])) return LEPUS_EXCEPTION;
    v = v64;
    if (op == ATOMICS_OP_COMPARE_EXCHANGE) {
      if (LEPUS_ToBigInt64(ctx, &v64, argv[3])) return LEPUS_EXCEPTION;
      rep_val = v64;
    }
  } else
#endif
  {
    uint32_t v32;
    if (LEPUS_ToUint32(ctx, &v32, argv[2])) return LEPUS_EXCEPTION;
    v = v32;
    if (op == ATOMICS_OP_COMPARE_EXCHANGE) {
      if (LEPUS_ToUint32(ctx, &v32, argv[3])) return LEPUS_EXCEPTION;
      rep_val = v32;
    }
  }
  switch (op | (size_log2 << 3)) {
#ifdef CONFIG_BIGNUM
#define OP(op_name, func_name)                  \
  case ATOMICS_OP_##op_name | (0 << 3):         \
    a = func_name((_Atomic(uint8_t) *)ptr, v);  \
    break;                                      \
  case ATOMICS_OP_##op_name | (1 << 3):         \
    a = func_name((_Atomic(uint16_t) *)ptr, v); \
    break;                                      \
  case ATOMICS_OP_##op_name | (2 << 3):         \
    a = func_name((_Atomic(uint32_t) *)ptr, v); \
    break;                                      \
  case ATOMICS_OP_##op_name | (3 << 3):         \
    a = func_name((_Atomic(uint64_t) *)ptr, v); \
    break;
#else
#define OP(op_name, func_name)                  \
  case ATOMICS_OP_##op_name | (0 << 3):         \
    a = func_name((_Atomic(uint8_t) *)ptr, v);  \
    break;                                      \
  case ATOMICS_OP_##op_name | (1 << 3):         \
    a = func_name((_Atomic(uint16_t) *)ptr, v); \
    break;                                      \
  case ATOMICS_OP_##op_name | (2 << 3):         \
    a = func_name((_Atomic(uint32_t) *)ptr, v); \
    break;
#endif
    OP(ADD, atomic_fetch_add)
    OP(AND, atomic_fetch_and)
    OP(OR, atomic_fetch_or)
    OP(SUB, atomic_fetch_sub)
    OP(XOR, atomic_fetch_xor)
    OP(EXCHANGE, atomic_exchange)
#undef OP

    case ATOMICS_OP_LOAD | (0 << 3):
      a = atomic_load((_Atomic(uint8_t) *)ptr);
      break;
    case ATOMICS_OP_LOAD | (1 << 3):
      a = atomic_load((_Atomic(uint16_t) *)ptr);
      break;
    case ATOMICS_OP_LOAD | (2 << 3):
      a = atomic_load((_Atomic(uint32_t) *)ptr);
      break;
#ifdef CONFIG_BIGNUM
    case ATOMICS_OP_LOAD | (3 << 3):
      a = atomic_load((_Atomic(uint64_t) *)ptr);
      break;
#endif

    case ATOMICS_OP_COMPARE_EXCHANGE | (0 << 3): {
      uint8_t v1 = v;
      atomic_compare_exchange_strong((_Atomic(uint8_t) *)ptr, &v1, rep_val);
      a = v1;
    } break;
    case ATOMICS_OP_COMPARE_EXCHANGE | (1 << 3): {
      uint16_t v1 = v;
      atomic_compare_exchange_strong((_Atomic(uint16_t) *)ptr, &v1, rep_val);
      a = v1;
    } break;
    case ATOMICS_OP_COMPARE_EXCHANGE | (2 << 3): {
      uint32_t v1 = v;
      atomic_compare_exchange_strong((_Atomic(uint32_t) *)ptr, &v1, rep_val);
      a = v1;
    } break;
#ifdef CONFIG_BIGNUM
    case ATOMICS_OP_COMPARE_EXCHANGE | (3 << 3): {
      uint64_t v1 = v;
      atomic_compare_exchange_strong((_Atomic(uint64_t) *)ptr, &v1, rep_val);
      a = v1;
    } break;
#endif
    default:
      abort();
  }

  switch (class_id) {
    case LEPUS_CLASS_INT8_ARRAY:
      a = (int8_t)a;
      goto done;
    case LEPUS_CLASS_UINT8_ARRAY:
      a = (uint8_t)a;
      goto done;
    case LEPUS_CLASS_INT16_ARRAY:
      a = (int16_t)a;
      goto done;
    case LEPUS_CLASS_UINT16_ARRAY:
      a = (uint16_t)a;
      goto done;
    case LEPUS_CLASS_INT32_ARRAY:
    done:
      ret = LEPUS_NewInt32(ctx, a);
      break;
    case LEPUS_CLASS_UINT32_ARRAY:
      ret = LEPUS_NewUint32(ctx, a);
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_CLASS_BIG_INT64_ARRAY:
      ret = LEPUS_NewBigInt64(ctx, a);
      break;
    case LEPUS_CLASS_BIG_UINT64_ARRAY:
      ret = LEPUS_NewBigUint64(ctx, a);
      break;
#endif
    default:
      abort();
  }
  return ret;
}

static LEPUSValue lepus_atomics_store(LEPUSContext *ctx,
                                      LEPUSValueConst this_obj, int argc,
                                      LEPUSValueConst *argv) {
  int size_log2;
  void *ptr;
  LEPUSValue ret;

  ptr = lepus_atomics_get_ptr(ctx, &size_log2, NULL, argv[0], argv[1], FALSE);
  if (!ptr) return LEPUS_EXCEPTION;
#ifdef CONFIG_BIGNUM
  if (size_log2 == 3) {
    int64_t v64;
    ret = LEPUS_ToBigIntValueFree(ctx, LEPUS_DupValue(ctx, argv[2]));
    if (LEPUS_IsException(ret)) return ret;
    if (LEPUS_ToBigInt64(ctx, &v64, ret)) {
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    }
    atomic_store((_Atomic(uint64_t) *)ptr, v64);
  } else
#endif
  {
    uint32_t v;
    /* XXX: spec, would be simpler to return the written value */
    ret = LEPUS_ToIntegerFree(ctx, LEPUS_DupValue(ctx, argv[2]));
    if (LEPUS_IsException(ret)) return ret;
    if (LEPUS_ToUint32(ctx, &v, ret)) {
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    }
    switch (size_log2) {
      case 0:
        atomic_store((_Atomic(uint8_t) *)ptr, v);
        break;
      case 1:
        atomic_store((_Atomic(uint16_t) *)ptr, v);
        break;
      case 2:
        atomic_store((_Atomic(uint32_t) *)ptr, v);
        break;
      default:
        abort();
    }
  }
  return ret;
}

static LEPUSValue lepus_atomics_isLockFree(LEPUSContext *ctx,
                                           LEPUSValueConst this_obj, int argc,
                                           LEPUSValueConst *argv) {
  int v, ret;
  if (LEPUS_ToInt32Sat(ctx, &v, argv[0])) return LEPUS_EXCEPTION;
  ret = (v == 1 || v == 2 || v == 4
#ifdef CONFIG_BIGNUM
         || v == 8
#endif
  );
  return LEPUS_NewBool(ctx, ret);
}

typedef struct LEPUSAtomicsWaiter {
  struct list_head link;
  BOOL linked;
  pthread_cond_t cond;
  int32_t *ptr;
} LEPUSAtomicsWaiter;

static pthread_mutex_t lepus_atomics_mutex = PTHREAD_MUTEX_INITIALIZER;
static struct list_head lepus_atomics_waiter_list =
    LIST_HEAD_INIT(lepus_atomics_waiter_list);

static LEPUSValue lepus_atomics_wait(LEPUSContext *ctx,
                                     LEPUSValueConst this_obj, int argc,
                                     LEPUSValueConst *argv) {
  int64_t v;
  int32_t v32;
  void *ptr;
  int64_t timeout;
  struct timespec ts;
  LEPUSAtomicsWaiter waiter_s, *waiter;
  int ret, size_log2, res;
  double d;

  ptr = lepus_atomics_get_ptr(ctx, &size_log2, NULL, argv[0], argv[1], TRUE);
  if (!ptr) return LEPUS_EXCEPTION;
#ifdef CONFIG_BIGNUM
  if (size_log2 == 3) {
    if (LEPUS_ToBigInt64(ctx, &v, argv[2])) return LEPUS_EXCEPTION;
  } else
#endif
  {
    if (LEPUS_ToInt32(ctx, &v32, argv[2])) return LEPUS_EXCEPTION;
    v = v32;
  }
  if (LEPUS_ToFloat64(ctx, &d, argv[3])) return LEPUS_EXCEPTION;
  if (isnan(d) || d > INT64_MAX)
    timeout = INT64_MAX;
  else if (d < 0)
    timeout = 0;
  else
    timeout = (int64_t)d;
  if (!ctx->rt->can_block)
    return LEPUS_ThrowTypeError(ctx, "cannot block in this thread");

  /* XXX: inefficient if large number of waiters, should hash on
     'ptr' value */
  /* XXX: use Linux futexes when available ? */
  pthread_mutex_lock(&lepus_atomics_mutex);
  if (size_log2 == 3) {
    res = *(int64_t *)ptr != v;
  } else {
    res = *(int32_t *)ptr != v;
  }
  if (res) {
    pthread_mutex_unlock(&lepus_atomics_mutex);
    return LEPUS_AtomToString(ctx, LEPUS_ATOM_not_equal);
  }

  waiter = &waiter_s;
  waiter->ptr = ptr;
  pthread_cond_init(&waiter->cond, NULL);
  waiter->linked = TRUE;
  list_add_tail(&waiter->link, &lepus_atomics_waiter_list);

  if (timeout == INT64_MAX) {
    pthread_cond_wait(&waiter->cond, &lepus_atomics_mutex);
    ret = 0;
  } else {
    /* XXX: use clock monotonic */
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_sec += timeout / 1000;
    ts.tv_nsec += (timeout % 1000) * 1000000;
    if (ts.tv_nsec >= 1000000000) {
      ts.tv_nsec -= 1000000000;
      ts.tv_sec++;
    }
    ret = pthread_cond_timedwait(&waiter->cond, &lepus_atomics_mutex, &ts);
  }
  if (waiter->linked) list_del(&waiter->link);
  pthread_mutex_unlock(&lepus_atomics_mutex);
  pthread_cond_destroy(&waiter->cond);
  if (ret == ETIMEDOUT) {
    return LEPUS_AtomToString(ctx, LEPUS_ATOM_timed_out);
  } else {
    return LEPUS_AtomToString(ctx, LEPUS_ATOM_ok);
  }
}

static LEPUSValue lepus_atomics_notify(LEPUSContext *ctx,
                                       LEPUSValueConst this_obj, int argc,
                                       LEPUSValueConst *argv) {
  struct list_head *el, *el1, waiter_list;
  int32_t count, n;
  void *ptr;
  LEPUSAtomicsWaiter *waiter;

  ptr = lepus_atomics_get_ptr(ctx, NULL, NULL, argv[0], argv[1], TRUE);
  if (!ptr) return LEPUS_EXCEPTION;

  if (LEPUS_IsUndefined(argv[2])) {
    count = INT32_MAX;
  } else {
    if (LEPUS_ToInt32Clamp(ctx, &count, argv[2], 0, INT32_MAX, 0))
      return LEPUS_EXCEPTION;
  }

  n = 0;
  if (count > 0) {
    pthread_mutex_lock(&lepus_atomics_mutex);
    init_list_head(&waiter_list);
    list_for_each_safe(el, el1, &lepus_atomics_waiter_list) {
      waiter = list_entry(el, LEPUSAtomicsWaiter, link);
      if (waiter->ptr == ptr) {
        list_del(&waiter->link);
        waiter->linked = FALSE;
        list_add_tail(&waiter->link, &waiter_list);
        n++;
        if (n >= count) break;
      }
    }
    list_for_each(el, &waiter_list) {
      waiter = list_entry(el, LEPUSAtomicsWaiter, link);
      pthread_cond_signal(&waiter->cond);
    }
    pthread_mutex_unlock(&lepus_atomics_mutex);
  }
  return LEPUS_NewInt32(ctx, n);
}

static const LEPUSCFunctionListEntry lepus_atomics_funcs[] = {
    LEPUS_CFUNC_MAGIC_DEF("add", 3, lepus_atomics_op, ATOMICS_OP_ADD),
    LEPUS_CFUNC_MAGIC_DEF("and", 3, lepus_atomics_op, ATOMICS_OP_AND),
    LEPUS_CFUNC_MAGIC_DEF("or", 3, lepus_atomics_op, ATOMICS_OP_OR),
    LEPUS_CFUNC_MAGIC_DEF("sub", 3, lepus_atomics_op, ATOMICS_OP_SUB),
    LEPUS_CFUNC_MAGIC_DEF("xor", 3, lepus_atomics_op, ATOMICS_OP_XOR),
    LEPUS_CFUNC_MAGIC_DEF("exchange", 3, lepus_atomics_op, ATOMICS_OP_EXCHANGE),
    LEPUS_CFUNC_MAGIC_DEF("compareExchange", 4, lepus_atomics_op,
                          ATOMICS_OP_COMPARE_EXCHANGE),
    LEPUS_CFUNC_MAGIC_DEF("load", 2, lepus_atomics_op, ATOMICS_OP_LOAD),
    LEPUS_CFUNC_DEF("store", 3, lepus_atomics_store),
    LEPUS_CFUNC_DEF("isLockFree", 1, lepus_atomics_isLockFree),
    LEPUS_CFUNC_DEF("wait", 4, lepus_atomics_wait),
    LEPUS_CFUNC_DEF("notify", 3, lepus_atomics_notify),
    LEPUS_PROP_STRING_DEF("[Symbol.toStringTag]", "Atomics",
                          LEPUS_PROP_CONFIGURABLE),
};

static const LEPUSCFunctionListEntry lepus_atomics_obj[] = {
    LEPUS_OBJECT_DEF("Atomics", lepus_atomics_funcs,
                     countof(lepus_atomics_funcs),
                     LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE),
};

void LEPUS_AddIntrinsicAtomics(LEPUSContext *ctx) {
  /* add Atomics as autoinit object */
  LEPUS_SetPropertyFunctionList(ctx, ctx->global_obj, lepus_atomics_obj,
                                countof(lepus_atomics_obj));
}

#endif /* CONFIG_ATOMICS */

void LEPUS_AddIntrinsicTypedArrays(LEPUSContext *ctx) {
  LEPUSValue typed_array_base_proto, typed_array_base_func;
  LEPUSValueConst array_buffer_func, shared_array_buffer_func;
  int i;

  ctx->class_proto[LEPUS_CLASS_ARRAY_BUFFER] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_ARRAY_BUFFER],
                                lepus_array_buffer_proto_funcs,
                                countof(lepus_array_buffer_proto_funcs));

  array_buffer_func = LEPUS_NewGlobalCConstructorOnly(
      ctx, "ArrayBuffer", lepus_array_buffer_constructor, 1,
      ctx->class_proto[LEPUS_CLASS_ARRAY_BUFFER]);
  LEPUS_SetPropertyFunctionList(ctx, array_buffer_func,
                                lepus_array_buffer_funcs,
                                countof(lepus_array_buffer_funcs));

  ctx->class_proto[LEPUS_CLASS_SHARED_ARRAY_BUFFER] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(
      ctx, ctx->class_proto[LEPUS_CLASS_SHARED_ARRAY_BUFFER],
      lepus_shared_array_buffer_proto_funcs,
      countof(lepus_shared_array_buffer_proto_funcs));

  shared_array_buffer_func = LEPUS_NewGlobalCConstructorOnly(
      ctx, "SharedArrayBuffer", lepus_shared_array_buffer_constructor, 1,
      ctx->class_proto[LEPUS_CLASS_SHARED_ARRAY_BUFFER]);
  LEPUS_SetPropertyFunctionList(ctx, shared_array_buffer_func,
                                lepus_shared_array_buffer_funcs,
                                countof(lepus_shared_array_buffer_funcs));

  typed_array_base_proto = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, typed_array_base_proto,
                                lepus_typed_array_base_proto_funcs,
                                countof(lepus_typed_array_base_proto_funcs));

  /* TypedArray.prototype.toString must be the same object as
   * Array.prototype.toString */
  LEPUSValue obj = LEPUS_GetProperty(ctx, ctx->class_proto[LEPUS_CLASS_ARRAY],
                                     LEPUS_ATOM_toString);
  /* XXX: should use alias method in LEPUSCFunctionListEntry */  //@@@
  LEPUS_DefinePropertyValue(ctx, typed_array_base_proto, LEPUS_ATOM_toString,
                            obj, LEPUS_PROP_WRITABLE | LEPUS_PROP_CONFIGURABLE);

  typed_array_base_func = LEPUS_NewCFunction(
      ctx, lepus_typed_array_base_constructor, "TypedArray", 0);
  LEPUS_SetPropertyFunctionList(ctx, typed_array_base_func,
                                lepus_typed_array_base_funcs,
                                countof(lepus_typed_array_base_funcs));
  LEPUS_SetConstructor(ctx, typed_array_base_func, typed_array_base_proto);

  for (i = LEPUS_CLASS_UINT8C_ARRAY;
       i < LEPUS_CLASS_UINT8C_ARRAY + LEPUS_TYPED_ARRAY_COUNT; i++) {
    LEPUSValue func_obj;
    char buf[ATOM_GET_STR_BUF_SIZE];
    const char *name;

    ctx->class_proto[i] = LEPUS_NewObjectProto(ctx, typed_array_base_proto);
    LEPUS_DefinePropertyValueStr(
        ctx, ctx->class_proto[i], "BYTES_PER_ELEMENT",
        LEPUS_NewInt32(ctx, 1 << typed_array_size_log2(i)), 0);
    name = LEPUS_AtomGetStr(
        ctx, buf, sizeof(buf),
        LEPUS_ATOM_Uint8ClampedArray + i - LEPUS_CLASS_UINT8C_ARRAY);
    func_obj = LEPUS_NewCFunction3(
        ctx, (LEPUSCFunction *)lepus_typed_array_constructor, name, 3,
        LEPUS_CFUNC_constructor_magic, i, typed_array_base_func);
    LEPUS_NewGlobalCConstructor2(ctx, func_obj, name, ctx->class_proto[i]);
    LEPUS_DefinePropertyValueStr(
        ctx, func_obj, "BYTES_PER_ELEMENT",
        LEPUS_NewInt32(ctx, 1 << typed_array_size_log2(i)), 0);
  }
  LEPUS_FreeValue(ctx, typed_array_base_proto);
  LEPUS_FreeValue(ctx, typed_array_base_func);

  /* DataView */
  ctx->class_proto[LEPUS_CLASS_DATAVIEW] = LEPUS_NewObject(ctx);
  LEPUS_SetPropertyFunctionList(ctx, ctx->class_proto[LEPUS_CLASS_DATAVIEW],
                                lepus_dataview_proto_funcs,
                                countof(lepus_dataview_proto_funcs));
  LEPUS_NewGlobalCConstructorOnly(ctx, "DataView", lepus_dataview_constructor,
                                  1, ctx->class_proto[LEPUS_CLASS_DATAVIEW]);
  /* Atomics */
#ifdef CONFIG_ATOMICS
  LEPUS_AddIntrinsicAtomics(ctx);
#endif
}

LEPUSValue LEPUS_ToJSON(LEPUSContext *ctx, LEPUSValueConst val, int indent) {
  LEPUSValue args[3];
  args[0] = val;
  args[1] = LEPUS_NULL;
  args[2] = LEPUS_MKVAL(LEPUS_TAG_INT, indent);

  return lepus_json_stringify(ctx, val, 3, args);
}

LEPUSValue LEPUS_NewWString(LEPUSContext *ctx, const uint16_t *buf,
                            size_t length) {
  return lepus_new_string16(ctx, buf, length);
}

LEPUSValue LEPUS_ToWString(LEPUSContext *ctx, LEPUSValueConst val1) {
  LEPUSValue val;
  LEPUSString *str, *str_new;
  int pos, len;
  uint8_t *src;
  uint16_t *q;

  if (!LEPUS_VALUE_IS_STRING(val1)) {
    val = LEPUS_ToString(ctx, val1);
    if (LEPUS_IsException(val)) return val;
  } else {
    val = LEPUS_DupValue(ctx, val1);
  }

  str = LEPUS_VALUE_GET_STRING(val);
  len = str->len;
  if (str->is_wide_char) {
    return val;
  }
  str_new = lepus_alloc_string(ctx, len, 1);
  if (!str_new) return LEPUS_EXCEPTION;
  src = str->u.str8;
  q = str_new->u.str16;
  pos = 0;
  while (pos < len) {
    *q++ = src[pos++];
  }

  LEPUS_FreeValue(ctx, val);
  return LEPUS_MKPTR(LEPUS_TAG_STRING, str_new);
}

uint32_t LEPUS_GetStringLength(LEPUSContext *ctx, LEPUSValueConst str) {
  if (!LEPUS_VALUE_IS_STRING(str)) return 0;
  LEPUSString *s = LEPUS_VALUE_GET_STRING(str);
  if (!s->is_wide_char) return 0;
  return s->len;
}

const uint16_t *LEPUS_GetStringChars(LEPUSContext *ctx, LEPUSValueConst str) {
  if (!LEPUS_VALUE_IS_STRING(str)) return 0;
  LEPUSString *s = LEPUS_VALUE_GET_STRING(str);
  if (!s->is_wide_char) return 0;
  return s->u.str16;
}

LEPUSClassID LEPUS_GetClassID(LEPUSContext *ctx, LEPUSValueConst obj) {
  if (LEPUS_VALUE_IS_NOT_OBJECT(obj)) return 0;

  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
  return p->class_id;
}

LEPUSValue LEPUS_NewArrayWithValue(LEPUSContext *ctx, uint32_t length,
                                   LEPUSValueConst *values) {
  return lepus_build_rest(ctx, 0, length, values);
}

LEPUSValue LEPUS_NewTypedArray(LEPUSContext *ctx, uint32_t length,
                               LEPUSClassID class_id) {
  LEPUSValue arg0 = LEPUS_NewInt32(ctx, length);
  return lepus_typed_array_constructor(ctx, LEPUS_UNDEFINED, 1, &arg0,
                                       class_id);
}

LEPUSValue LEPUS_NewTypedArrayWithBuffer(LEPUSContext *ctx,
                                         LEPUSValueConst buffer,
                                         uint32_t byteOffset, uint32_t length,
                                         LEPUSClassID class_id) {
  LEPUSValue args[3] = {buffer, LEPUS_NewInt32(ctx, byteOffset),
                        LEPUS_NewInt32(ctx, length)};
  return lepus_typed_array_constructor(ctx, LEPUS_UNDEFINED, 3, args, class_id);
}

LEPUSValue LEPUS_CallConstructorV(LEPUSContext *ctx, LEPUSValueConst func_obj,
                                  int argc, LEPUSValue *argv) {
  return LEPUS_CallConstructorInternal(ctx, func_obj, func_obj, argc, argv, 0);
}

LEPUSValue LEPUS_CallV(LEPUSContext *ctx, LEPUSValueConst func_obj,
                       LEPUSValueConst this_obj, int argc, LEPUSValue *argv) {
  return LEPUS_CallInternalTI(ctx, func_obj, this_obj, LEPUS_UNDEFINED, argc,
                              argv, 0);
}

LEPUS_BOOL LEPUS_IsPrimjsEnabled(LEPUSRuntime *rt) {
#ifdef ENABLE_PRIMJS_SNAPSHOT
  return rt && rt->use_primjs;
#else
  return false;
#endif
}

/* return LEPUS_ATOM_NULL in case of exception */
LEPUSAtom LEPUS_ValueToAtom(LEPUSContext *ctx, LEPUSValueConst val) {
  LEPUSAtom atom;
  if (LEPUS_VALUE_IS_INT(val) &&
      (uint32_t)LEPUS_VALUE_GET_INT(val) <= LEPUS_ATOM_MAX_INT) {
    /* fast path for integer values */
    atom = __JS_AtomFromUInt32(LEPUS_VALUE_GET_INT(val));
  } else if (LEPUS_VALUE_IS_SYMBOL(val)) {
    LEPUSAtomStruct *p =
        static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(val));
    atom = LEPUS_DupAtom(ctx, lepus_get_atom_index(ctx->rt, p));
  } else {
    LEPUSValue str;
    str = LEPUS_ToPropertyKey(ctx, val);
    if (LEPUS_IsException(str)) return LEPUS_ATOM_NULL;
    if (LEPUS_VALUE_IS_SYMBOL(str)) {
      atom = lepus_symbol_to_atom(ctx, str);
    } else {
      atom = LEPUS_NewAtomStr(ctx, LEPUS_VALUE_GET_STRING(str));
    }
  }
  return atom;
}

/* Return the buffer associated to the typed array or an exception if
   it is not a typed array or if the buffer is detached. pbyte_offset,
   pbyte_length or pbytes_per_element can be NULL. */
LEPUSValue LEPUS_GetTypedArrayBuffer(LEPUSContext *ctx, LEPUSValueConst obj,
                                     size_t *pbyte_offset, size_t *pbyte_length,
                                     size_t *pbytes_per_element) {
  LEPUSObject *p;
  LEPUSTypedArray *ta;
  p = get_typed_array(ctx, obj, FALSE);
  if (!p) return LEPUS_EXCEPTION;
  if (typed_array_is_detached(ctx, p))
    return LEPUS_ThrowTypeErrorDetachedArrayBuffer(ctx);
  ta = p->u.typed_array;
  if (pbyte_offset) *pbyte_offset = ta->offset;
  if (pbyte_length) *pbyte_length = ta->length;
  if (pbytes_per_element) {
    *pbytes_per_element = 1 << typed_array_size_log2(p->class_id);
  }
  return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, ta->buffer));
}

// <ByteDance begin>
LEPUSTypedArrayType LEPUS_GetTypedArrayType(LEPUSContext *ctx,
                                            LEPUSValueConst val) {
  if (!LEPUS_IsObject(val)) return LEPUS_TYPED_UNKNOW;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  switch (p->class_id) {
    case LEPUS_CLASS_UINT8C_ARRAY:
      return LEPUS_TYPED_UINT8C_ARRAY;
    case LEPUS_CLASS_UINT8_ARRAY:
      return LEPUS_TYPED_UINT8_ARRAY;
    case LEPUS_CLASS_INT8_ARRAY:
      return LEPUS_TYPED_INT8_ARRAY;
    case LEPUS_CLASS_INT16_ARRAY:
      return LEPUS_TYPED_INT16_ARRAY;
    case LEPUS_CLASS_UINT16_ARRAY:
      return LEPUS_TYPED_UINT16_ARRAY;
    case LEPUS_CLASS_INT32_ARRAY:
      return LEPUS_TYPED_INT32_ARRAY;
    case LEPUS_CLASS_UINT32_ARRAY:
      return LEPUS_TYPED_UINT32_ARRAY;
    case LEPUS_CLASS_FLOAT32_ARRAY:
      return LEPUS_TYPED_FLOAT32_ARRAY;
    case LEPUS_CLASS_FLOAT64_ARRAY:
      return LEPUS_TYPED_FLOAT64_ARRAY;
    default:
      return LEPUS_TYPED_UNKNOW;
  }
  return LEPUS_TYPED_UNKNOW;
}

LEPUS_BOOL LEPUS_IsDataView(LEPUSContext *ctx, LEPUSValueConst val) {
  if (!LEPUS_IsObject(val)) return FALSE;
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
  return p->class_id == LEPUS_CLASS_DATAVIEW;
}

LEPUSClassID LEPUS_GetTypedArrayClassID(LEPUSTypedArrayType type) {
  if (type == LEPUS_TYPED_UNKNOW) return -1;
  return (type - LEPUS_TYPED_UINT8C_ARRAY) + LEPUS_CLASS_UINT8C_ARRAY;
}

class ObjectCloneState {
 public:
  using key_t = LEPUSObject *;
  using val_t = LEPUSObject *;

  ObjectCloneState(LEPUSContext *ctx) : ctx_(ctx) {
    handled_obj_ = LEPUS_NewObject(ctx_);
  }

  ~ObjectCloneState() { LEPUS_FreeValue(ctx_, handled_obj_); }

  val_t GetVal(const key_t &key) const {
    auto ret = LEPUS_GetPropertyInt64(ctx_, handled_obj_, (int64_t)key);
    if (LEPUS_IsUndefined(ret)) {
      return nullptr;
    }
    int64_t val = 0;
    if (LEPUS_ToInt64(ctx_, &val, ret)) {
      return nullptr;
    }
    return (val_t)val;
  }

  void SetValue(const key_t &key, const val_t &val) {
    LEPUS_SetPropertyInt64(ctx_, handled_obj_, (int64_t)key,
                           LEPUS_NewInt64(ctx_, (int64_t)val));
  }

  void EraseKey(const key_t &key) {
    LEPUS_DeletePropertyInt64(ctx_, handled_obj_, (int64_t)key, 0);
  }

 private:
  LEPUSContext *ctx_ = nullptr;
  LEPUSValue handled_obj_ = LEPUS_UNDEFINED;
  ObjectCloneState(const ObjectCloneState &) {}
  ObjectCloneState(ObjectCloneState &&) {}
};

LEPUSValue LEPUS_StructuredClone(LEPUSContext *ctx, LEPUSValue src,
                                 ObjectCloneState &state) {
  auto tag = LEPUS_VALUE_GET_NORM_TAG(src);

  switch (tag) {
    case LEPUS_TAG_NULL:
    case LEPUS_TAG_UNDEFINED:
    case LEPUS_TAG_BOOL:
    case LEPUS_TAG_INT:
    case LEPUS_TAG_FLOAT64: {
      return src;
    }
    case LEPUS_TAG_STRING: {
      return LEPUS_DupValue(ctx, src);
    }

#ifdef ENABLE_LEPUSNG
    case LEPUS_TAG_LEPUS_REF: {
      LEPUSLepusRef *pref =
          reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(src));

      if (auto *p = state.GetVal((LEPUSObject *)(pref->p))) {
        return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
      }
      LEPUSValue ret = LEPUS_UNDEFINED;
      if (LEPUS_IsUndefined(pref->lepus_val)) {
        ret = LEPUSRef2Value(ctx, src);
        pref->lepus_val = LEPUS_UNDEFINED;
      } else {
        ret = LEPUS_StructuredClone(ctx, pref->lepus_val, state);
      }

      if (!LEPUS_IsException(ret)) {
        state.SetValue((LEPUSObject *)(pref->p), LEPUS_VALUE_GET_OBJ(ret));
      }
      return ret;
    }
#endif

    case LEPUS_TAG_OBJECT: {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(src);
      if (auto *result = state.GetVal(p)) {
        // find
        return LEPUS_DupValue(ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, result));
      }
      LEPUSShape *sh = p->shape;
      LEPUSValue ret = LEPUS_NewObjectClass(ctx, p->class_id);
      LEPUSObject *ret_p = LEPUS_VALUE_GET_OBJ(ret);
      state.SetValue(p, ret_p);
      if (sh && p->prop) {
        // clone property
        LEPUSShapeProperty *prs = sh->prop;
        for (uint32_t i = 0; i < sh->prop_count; ++i, ++prs) {
          int32_t flags = prs->flags;
          if (prs->atom != LEPUS_ATOM_NULL && (flags & LEPUS_PROP_TMASK) == 0) {
            LEPUSValue cloned_prop =
                LEPUS_StructuredClone(ctx, p->prop[i].u.value, state);
            if (LEPUS_IsException(cloned_prop) ||
                (LEPUS_DefinePropertyValue(ctx, ret, prs->atom, cloned_prop,
                                           flags & LEPUS_PROP_C_W_E) < 0)) {
              goto fail;
            }
          }
        }
      }

      switch (p->class_id) {
        case LEPUS_CLASS_OBJECT: {
          break;
        }
        case LEPUS_CLASS_ARRAY: {
          if (p->fast_array) {
            for (uint32_t i = 0; i < p->u.array.count; ++i) {
              LEPUSValue cloned_element =
                  LEPUS_StructuredClone(ctx, p->u.array.u.values[i], state);
              if (LEPUS_IsException(cloned_element) ||
                  (LEPUS_DefinePropertyValueUint32(ctx, ret, i, cloned_element,
                                                   LEPUS_PROP_C_W_E) < 0)) {
                goto fail;
              }
            }
          }
        } break;
        case LEPUS_CLASS_NUMBER:
        case LEPUS_CLASS_STRING:
        case LEPUS_CLASS_BOOLEAN:
        case LEPUS_CLASS_DATE: {
          LEPUSValue object_data =
              LEPUS_StructuredClone(ctx, p->u.object_data, state);
          LEPUS_SetObjectData(ctx, ret, object_data);
        } break;
        case LEPUS_CLASS_ARRAY_BUFFER: {
          auto *array_buffer = p->u.array_buffer;
          if (array_buffer && !array_buffer->detached) {
            auto *abuf = reinterpret_cast<LEPUSArrayBuffer *>(
                lepus_mallocz(ctx, sizeof(LEPUSArrayBuffer)));
            if (!abuf) goto fail;
            abuf->byte_length = array_buffer->byte_length;
            abuf->data = reinterpret_cast<uint8_t *>(
                lepus_malloc(ctx, abuf->byte_length));
            if (!abuf->data) {
              lepus_free(ctx, abuf);
              goto fail;
            }
            abuf->free_func = lepus_array_buffer_free;
            abuf->opaque = array_buffer->opaque;
            init_list_head(&abuf->array_list);
            memcpy(abuf->data, array_buffer->data, abuf->byte_length);
            LEPUS_SetOpaque(ret, abuf);
          }
        } break;
        case LEPUS_CLASS_UINT8C_ARRAY ... LEPUS_CLASS_DATAVIEW: {
          auto *typearray = p->u.typed_array;
          auto *arraybuffer =
              typearray ? typearray->buffer->u.array_buffer : nullptr;
          if (arraybuffer && !arraybuffer->detached) {
            auto *ta = reinterpret_cast<LEPUSTypedArray *>(
                lepus_mallocz(ctx, sizeof(LEPUSTypedArray)));
            if (!ta) goto fail;
            ta->obj = ret_p;
            ta->offset = typearray->offset;
            ta->length = typearray->length;
            LEPUSValue new_buffer = LEPUS_StructuredClone(
                ctx, LEPUS_MKPTR(LEPUS_TAG_OBJECT, typearray->buffer), state);

            if (LEPUS_IsException(new_buffer)) {
              lepus_free(ctx, ta);
              goto fail;
            }
            auto *pbuffer = LEPUS_VALUE_GET_OBJ(new_buffer);
            ta->buffer = pbuffer;
            auto *abuf = pbuffer->u.array_buffer;
            list_add_tail(&ta->link, &(abuf->array_list));

            ret_p->u.typed_array = ta;
            if (p->class_id != LEPUS_CLASS_DATAVIEW) {
              ret_p->u.array.count = p->u.array.count;
              ret_p->u.array.u.ptr = abuf->data + ta->offset;
            }
          }
        } break;
        default: {
          LEPUS_ThrowTypeError(
              ctx, "object classid: %d is not supported in StructuredClone",
              p->class_id);
          goto fail;
        }
      }
      return ret;
    fail:
      state.EraseKey(p);
      LEPUS_FreeValue(ctx, ret);
      return LEPUS_EXCEPTION;
    } break;
    default: {
      goto use_snapshot;
    }

    use_snapshot:
#ifndef NO_QUICKJS_COMPILER
      size_t psize = 0;
      uint8_t *buf = LEPUS_WriteObject(ctx, &psize, src, 0);

      if (buf) {
        LEPUSValue val = LEPUS_ReadObject(ctx, buf, psize, 0);
        lepus_free(ctx, buf);
        return val;
      } else {
        return LEPUS_UNDEFINED;
      }
#else
      return LEPUS_UNDEFINED;
#endif
  }
}

LEPUSValue LEPUS_DeepCopy(LEPUSContext *ctx, LEPUSValueConst obj) {
  ObjectCloneState state(ctx);
  return LEPUS_StructuredClone(ctx, obj, state);
}

int64_t LEPUS_GetNapiEnv(LEPUSContext *ctx) { return ctx->napi_env; }

void LEPUS_SetNapiEnv(LEPUSContext *ctx, int64_t env) { ctx->napi_env = env; }

void LEPUS_ResetNapiEnv(LEPUSContext *ctx) { ctx->napi_env = 0; }

void RegisterQJSDebuggerCallbacks(LEPUSRuntime *rt, void **funcs,
                                  int32_t callback_size) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (!rt || !funcs) {
    return;
  }
  int32_t num = 0;
#define Name(name)                                                \
  if (num < callback_size) {                                      \
    rt->debugger_callbacks_.name =                                \
        reinterpret_cast<decltype(rt->debugger_callbacks_.name)>( \
            funcs[num++]);                                        \
  } else {                                                        \
    rt->debugger_callbacks_.name = NULL;                          \
  }
  QJSCallBackName(Name)
#undef Name
#endif
}

struct LEPUSDebuggerInfo *GetDebuggerInfo(LEPUSContext *ctx) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  return ctx->debugger_info;
#else
  return NULL;
#endif
}

struct queue *GetDebuggerMessageQueue(LEPUSDebuggerInfo *info) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  return (info ? info->message_queue : NULL);
#else
  return NULL;
#endif
}

void SetDebuggerSourceCode(LEPUSContext *ctx, char *source_code) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  if (ctx->debugger_info) {
    ctx->debugger_info->source_code = lepus_strndup(
        ctx, (const char *)source_code, strlen((char *)source_code) + 1);
    strcpy(ctx->debugger_info->source_code, source_code);
  }
#else
  return;
#endif
}

#ifdef ENABLE_LEPUSNG
void SetLynxTargetSdkVersion(LEPUSContext *ctx, const char *version) {
  ctx->lynx_target_sdk_version = version;
  if (IsHigherOrEqual(version, FEATURE_LEPUSNG_DEBUGINFO_OUTSIDE)) {
    ctx->debuginfo_outside = 1;
  } else {
    ctx->debuginfo_outside = 0;
  }
}
#endif

// get all the functionbytecode for lepusng debugger encode
LEPUSFunctionBytecode **GetDebuggerAllFunction(LEPUSContext *ctx,
                                               LEPUSValue top_level_function,
                                               uint32_t *use_size) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  *use_size = 0;
  uint32_t total_size = 50;
  LEPUSFunctionBytecode **all_functions = static_cast<LEPUSFunctionBytecode **>(
      lepus_mallocz(ctx, sizeof(LEPUSFunctionBytecode *) * total_size));
  if (all_functions) {
    AddFunctionBytecode(ctx, top_level_function, all_functions, use_size,
                        total_size);
  }
  return all_functions;
#else
  return NULL;
#endif
}

void SetFunctionDebugFileName(LEPUSContext *ctx, LEPUSFunctionBytecode *b,
                              const char *filename, int len) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  assert(b->has_debug);
  if (filename) {
    b->debug.filename = LEPUS_NewAtom(ctx, filename);
  } else {
    b->debug.filename = LEPUS_ATOM_NULL;
  }
#endif
}

void SetFunctionDebugLineNum(LEPUSFunctionBytecode *b, int line_number) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  assert(b->has_debug);
  b->debug.line_num = line_number;
#endif
}

void SetFunctionDebugColumnNum(LEPUSFunctionBytecode *b,
                               int64_t column_number) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  assert(b->has_debug);
  b->debug.column_num = column_number;
#endif
}

void SetFunctionDebugPC2LineBufLen(LEPUSContext *ctx, LEPUSFunctionBytecode *b,
                                   uint8_t *buf, int buf_len) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  assert(b->has_debug);
  if (buf) {
    b->debug.pc2line_buf = static_cast<uint8_t *>(lepus_mallocz(ctx, buf_len));
    if (!b->debug.pc2line_buf) {
      b->debug.pc2line_len = 0;
      return;
    }
    memcpy(b->debug.pc2line_buf, buf, buf_len);
    b->debug.pc2line_len = buf_len;
  } else {
    b->debug.pc2line_buf = NULL;
    b->debug.pc2line_len = 0;
  }
#endif
}

uint32_t GetFunctionDebugId(LEPUSFunctionBytecode *b) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  return b->function_id;
#else
  return 0;
#endif
}

void SetFunctionDebugSource(LEPUSContext *ctx, LEPUSFunctionBytecode *b,
                            const char *source, int32_t source_len) {
#ifdef ENABLE_QUICKJS_DEBUGGER
  assert(b->has_debug);
  b->debug.source_len = source_len;
  b->debug.source = lepus_strndup(ctx, (const char *)source, source_len);
#endif
}

// napi_release_deferred use to execute promise resolve/reject function
LEPUSStackFrame *GetStackFrame(LEPUSContext *ctx) {
  return ctx->rt->current_stack_frame;
}

#ifndef ENABLE_QUICKJS_DEBUGGER
void PrepareQJSDebuggerForSharedContext(LEPUSContext *ctx, void **funcs,
                                        int32_t callback_size,
                                        bool devtool_connect) {}
void PauseOnDebuggerKeyword(LEPUSDebuggerInfo *info, const uint8_t *cur_pc) {}
#endif

#ifdef ENABLE_QUICKJS_DEBUGGER
QJS_HIDE const uint8_t *GetInspectorCurrentPC(LEPUSContext *ctx) {
  return ctx->debugger_current_pc;
}

QJS_HIDE LEPUSStackFrame *GetPreFrame(LEPUSStackFrame *frame) {
  return frame->prev_frame;
}

int32_t GetFunctionDebugSourceLen(LEPUSContext *ctx, LEPUSFunctionBytecode *b) {
  if (b && b->has_debug) {
    return b->debug.source_len;
  } else {
    return -1;
  }
}

QJS_HIDE LEPUSVarDef *GetFunctionVarDefs(LEPUSObject *obj) {
  return obj->u.func.function_bytecode->vardefs;
}

QJS_HIDE LEPUSValueConst GetThisObj(struct LEPUSStackFrame *sf,
                                    LEPUSObject *p) {
  struct LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
  return sf->var_buf[b->var_count];
}

QJS_HIDE LEPUSValue GetAtomGetValue(LEPUSContext *ctx) {
  return LEPUS_AtomToValue(ctx, LEPUS_ATOM_get);
}

QJS_HIDE LEPUSValue GetAtomSetValue(LEPUSContext *ctx) {
  return LEPUS_AtomToValue(ctx, LEPUS_ATOM_set);
}

// get protocol messages when vm is running
QJS_HIDE void GetProtocolMessages(LEPUSContext *ctx) {
  auto get_messages_callback = ctx->rt->debugger_callbacks_.get_messages;
  if (get_messages_callback) {
    get_messages_callback(ctx);
  }
}

// for shared context qjs debugger: set session enable state
QJS_HIDE void SetSessionEnableState(LEPUSContext *ctx, int32_t view_id,
                                    int32_t protocol_type) {
  auto cb = ctx->rt->debugger_callbacks_.set_session_enable_state;
  if (cb) {
    cb(ctx, view_id, protocol_type);
  }
}

// get session enable state given view id: Debugger, Runtime, etc.
QJS_HIDE void GetSessionEnableState(LEPUSContext *ctx, int32_t view_id,
                                    int32_t protocol_type, bool *ret) {
  auto cb = ctx->rt->debugger_callbacks_.get_session_enable_state;
  if (cb) {
    cb(ctx, view_id, protocol_type, ret);
  } else {
    *ret = true;
  }
}

// for shared context qjs debugger: get session state: enable and paused
QJS_HIDE void GetSessionState(LEPUSContext *ctx, int32_t view_id,
                              bool *is_already_enabled, bool *is_paused) {
  auto cb = ctx->rt->debugger_callbacks_.get_session_state;
  if (cb) {
    cb(ctx, view_id, is_already_enabled, is_paused);
  }
}

// for shared context qjs debugger: send protocol responses with view id
QJS_HIDE void SendProtocolResponseWithViewID(LEPUSContext *ctx,
                                             int32_t message_id,
                                             const char *response_message,
                                             int32_t view_id) {
  auto cb = ctx->rt->debugger_callbacks_.send_response_with_view_id;
  if (cb) {
    cb(ctx, message_id, response_message, view_id);
  }
}

// for shared context qjs debugger: send protocol notifications with view id
QJS_HIDE void SendProtocolNotificationWithViewID(LEPUSContext *ctx,
                                                 const char *response_message,
                                                 int32_t view_id) {
  auto cb = ctx->rt->debugger_callbacks_.send_ntfy_with_view_id;
  if (cb) {
    cb(ctx, response_message, view_id);
  }
}

// send protocol responses
QJS_HIDE void SendProtocolResponse(LEPUSContext *ctx, int32_t message_id,
                                   const char *response_message) {
  auto send_response_callback = ctx->rt->debugger_callbacks_.send_response;
  if (send_response_callback) {
    send_response_callback(ctx, message_id, response_message);
  }
}

// send protocol notifications
QJS_HIDE void SendProtocolNotification(LEPUSContext *ctx,
                                       const char *response_message) {
  auto send_notification_callback =
      ctx->rt->debugger_callbacks_.send_notification;
  if (send_notification_callback) {
    send_notification_callback(ctx, response_message);
  }
}

// pause the vm
QJS_HIDE void RunMessageLoopOnPause(LEPUSContext *ctx) {
  auto pause_callback = ctx->rt->debugger_callbacks_.run_message_loop_on_pause;
  if (pause_callback) {
    pause_callback(ctx);
  }
}

// quit pause
QJS_HIDE void QuitMessageLoopOnPause(LEPUSContext *ctx) {
  auto quit_pause_callback =
      ctx->rt->debugger_callbacks_.quit_message_loop_on_pause;
  if (quit_pause_callback) {
    quit_pause_callback(ctx);
  }
}

// get local variables given the stack frame
QJS_HIDE LEPUSValue GetLocalVariables(LEPUSContext *ctx, int32_t stack_index) {
  LEPUSValue ret = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(ret)) {
    goto done;
  }
  struct LEPUSStackFrame *sf;
  int32_t cur_index;
  cur_index = 0;

  for (sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
    if (cur_index < stack_index) {
      cur_index++;
      continue;
    }

    LEPUSObject *f = LEPUS_VALUE_GET_OBJ(sf->cur_func);
    if (!f || !lepus_class_has_bytecode(f->class_id)) goto done;
    struct LEPUSFunctionBytecode *b = f->u.func.function_bytecode;

    for (uint32_t i = 0; i < b->arg_count + b->var_count; i++) {
      LEPUSValue var_val;
      if (i < b->arg_count)
        var_val = sf->arg_buf[i];
      else
        var_val = sf->var_buf[i - b->arg_count];

      struct LEPUSVarDef *vd = b->vardefs + i;
      LEPUS_SetProperty(ctx, ret, vd->var_name, LEPUS_DupValue(ctx, var_val));
    }
    break;
  }
done:
  return ret;
}

#define QJSDebuggerRegisterConsole(V) \
  V("log", LOG)                       \
  V("info", INFO)                     \
  V("debug", DEBUG)                   \
  V("error", ERROR)                   \
  V("warn", WARN)                     \
  V("alog", ALOG)                     \
  V("profile", PROFILE)               \
  V("profileEnd", PROFILEEND)         \
  V("report", REPORT)                 \
  V("time", TIME)                     \
  V("timeEnd", TIMEEND)

#define QJSDebuggerClassId(V)                                     \
  V(Map, LEPUS_CLASS_MAP)                                         \
  V(Set, LEPUS_CLASS_SET)                                         \
  V(WeakMap, LEPUS_CLASS_WEAKMAP)                                 \
  V(WeakSet, LEPUS_CLASS_WEAKSET)                                 \
  V(Proxy, LEPUS_CLASS_PROXY)                                     \
  V(Generator, LEPUS_CLASS_GENERATOR)                             \
  V(GeneratorFunction, LEPUS_CLASS_GENERATOR_FUNCTION)            \
  V(Promise, LEPUS_CLASS_PROMISE)                                 \
  V(WeakRef, LEPUS_CLASS_WeakRef)                                 \
  V(FinalizationRegistry, LEPUS_CLASS_FinalizationRegistry)       \
  V(ArrayIterator, LEPUS_CLASS_ARRAY_ITERATOR)                    \
  V(StringIterator, LEPUS_CLASS_STRING_ITERATOR)                  \
  V(SetIterator, LEPUS_CLASS_SET_ITERATOR)                        \
  V(MapIterator, LEPUS_CLASS_MAP_ITERATOR)                        \
  V(RegExpStringIterator, LEPUS_CLASS_REGEXP_STRING_ITERATOR)     \
  V(AsyncFunction, LEPUS_CLASS_ASYNC_FUNCTION)                    \
  V(AsyncGenerator, LEPUS_CLASS_ASYNC_GENERATOR)                  \
  V(AsyncGeneratorFunction, LEPUS_CLASS_ASYNC_GENERATOR_FUNCTION) \
  V(AsyncFunctionResolve, LEPUS_CLASS_ASYNC_FUNCTION_RESOLVE)     \
  V(AsyncFunctionReject, LEPUS_CLASS_ASYNC_FUNCTION_REJECT)       \
  V(AsyncFromSyncIterator, LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR)  \
  V(PromiseResolveFunction, LEPUS_CLASS_PROMISE_RESOLVE_FUNCTION) \
  V(PromiseRejectFunction, LEPUS_CLASS_PROMISE_REJECT_FUNCTION)

void ComputeLineCol(int64_t line_col_num, int32_t *line, int64_t *column) {
  // for line and column compatibility
  // if the highest bit is 1, use 24 bits for line number, 38 bits for column
  // number if the highest bit is 0, use 12 bits for line number, 20 bits for
  // column number
  int32_t type = line_col_num >> LINE_COLUMN_TYPE_SHIFT;
  if (type == 1) {
    *line = line_col_num & (((uint64_t)1 << LINE_NUMBER_BITS_COUNT) - 1);
    *column =
        (int64_t)((line_col_num ^ ((uint64_t)1 << LINE_COLUMN_TYPE_SHIFT)) >>
                  LINE_NUMBER_BITS_COUNT);
  } else if (type == 0) {
    *line = line_col_num & (((uint64_t)1 << OLD_LINE_NUMBER_BITS_COUNT) - 1);
    *column = (int64_t)(line_col_num >> OLD_LINE_NUMBER_BITS_COUNT);
  }
  // line and column start from 0
  *line = *line - 1;
  *column = *column - 1;
  if (*line < 0 || *column < 0) {
    *line = 0;
    *column = 0;
  }
}

// given pc, return where this pc is
QJS_STATIC void GetPCLineColumn(LEPUSContext *ctx, const uint8_t *&p, int &pc,
                                const uint8_t *p_end,
                                struct LEPUSFunctionBytecode *b, int32_t &line,
                                int64_t &column) {
  int pc_prev = pc;
  if (p < p_end) {
    int64_t v;
    int ret;
    unsigned int op;
    op = *(p)++;
    if (op == 0) {
      uint64_t val;
      ret = get_leb128_u64(&val, p, p_end);
      if (ret < 0) goto fail;
      pc += val;
      p += ret;
      ret = get_sleb128_u64(&v, p, p_end);
      if (ret < 0) {
      fail:
        return;
      }
      p += ret;
    } else {
      op -= PC2LINE_OP_FIRST;
      pc += (op / PC2LINE_RANGE);
    }
  }
  int64_t line_column_num = find_line_num(ctx, b, pc_prev);
  ComputeLineCol(line_column_num, &line, &column);
}

// given the line and column range, return if the current line and column is in
// this range
QJS_STATIC BOOL InRange(int32_t line, int64_t column, int64_t start_line,
                        int64_t start_col, int64_t end_line, int64_t end_col) {
  if (line == start_line && line != end_line) {
    return column >= start_col;
  }
  if (line == end_line && line != start_line) {
    return (end_col != 0 && column <= end_col);
  }

  if (line == start_line && line == end_line) {
    return column >= start_col && column <= end_col;
  }

  return line > start_line && line < end_line;
}

QJS_STATIC bool LineColExist(LEPUSContext *ctx, LEPUSValue locations,
                             int32_t line, int64_t column) {
  int len = LEPUS_GetLength(ctx, locations);
  for (int i = 0; i < len; i++) {
    LEPUSValue location = LEPUS_GetPropertyUint32(ctx, locations, i);
    int32_t each_line = -1;
    int64_t each_column = -1;
    LEPUSValue line_number = LEPUS_GetPropertyStr(ctx, location, "lineNumber");
    LEPUSValue column_number =
        LEPUS_GetPropertyStr(ctx, location, "columnNumber");
    LEPUS_ToInt32(ctx, &each_line, line_number);
    LEPUS_ToInt64(ctx, &each_column, column_number);
    LEPUS_FreeValue(ctx, location);
    if (line == each_line && column == each_column) {
      return true;
    }
  }
  return false;
}

QJS_HIDE LEPUSScriptSource *GetScriptByScriptURL(LEPUSContext *ctx,
                                                 const char *filename) {
  struct list_head *el;
  list_for_each(el, &ctx->script_list) {
    LEPUSScriptSource *script = list_entry(el, LEPUSScriptSource, link);
    if (script && script->url && filename &&
        strcmp(script->url, filename) == 0) {
      return script;
    }
  }
  return NULL;
}

// for shared context qjs debugger: delete qjs debugger script by URL
void DeleteScriptByURL(LEPUSContext *ctx, const char *filename) {
  struct list_head *el, *el1;
  struct list_head node = ctx->script_list;
  if (node.prev && node.next) {
    list_for_each_safe(el, el1, &ctx->script_list) {
      auto script = list_entry(el, LEPUSScriptSource, link);
      if (script && script->url && filename &&
          strcmp(script->url, filename) == 0) {
        DebuggerFreeScript(ctx, script);
      }
    }
  }
}

QJS_HIDE LEPUSScriptSource *GetScriptByHash(LEPUSContext *ctx,
                                            const char *hash) {
  struct list_head *el;
  list_for_each(el, &ctx->script_list) {
    LEPUSScriptSource *script = list_entry(el, LEPUSScriptSource, link);
    if (script && script->hash && hash && strcmp(script->hash, hash) == 0) {
      return script;
    }
  }
  return NULL;
}

QJS_STATIC bool AdjustSatisfy(int32_t line, int64_t column, int32_t bp_line,
                              int64_t bp_column, int32_t closed_line,
                              int64_t closed_column) {
  if (closed_line == -1) return true;
  bool condition1 = (line != bp_line && line - bp_line < closed_line - bp_line);
  if (condition1) return true;

  bool condition2 = (line == bp_line && line == closed_line &&
                     column - bp_column < closed_column - bp_column);
  if (condition2) return true;

  bool condition3 = (line == bp_line && bp_line != closed_line);
  return condition3;
}

/**
 * @brief adjust breakpoint location to the nearest bytecode
 */
QJS_HIDE void AdjustBreakpoint(LEPUSDebuggerInfo *info, const char *url,
                               const char *hash, LEPUSBreakpoint *bp) {
  LEPUSContext *ctx = info->ctx;
  LEPUSScriptSource *bsrc = NULL;
  if (url && url[0] != '\0') {
    bsrc = GetScriptByScriptURL(ctx, url);
  } else if (hash && hash[0] != '\0') {
    bsrc = GetScriptByHash(ctx, hash);
  }
  if (!bsrc) {
    return;
  }
  int64_t closed_column = -1;
  int32_t closed_line = -1;
  struct list_head *el;
  int32_t bp_line = bp->line;
  int32_t bp_column = bp->column;
  list_for_each(el, &ctx->bytecode_list) {
    LEPUSFunctionBytecode *b = list_entry(el, LEPUSFunctionBytecode, link);
    if (!b || !b->has_debug) continue;
    if (b->script && b->script != bsrc) continue;
    if (!b->script && url && strcmp(url, "lepus.js") != 0) continue;

    const uint8_t *p_end, *p, *p_prev;
    int pc;

    p_prev = p = b->debug.pc2line_buf;
    p_end = p + b->debug.pc2line_len;
    pc = 0;
    while (p_prev < p_end) {
      int32_t line = -1;
      int64_t column = -1;
      p_prev = p;
      GetPCLineColumn(ctx, p, pc, p_end, b, line, column);
      if (line < bp_line || line < b->debug.line_num - 1 ||
          (closed_line != -1 && line > closed_line) ||
          (line == bp_line && column < bp_column)) {
        continue;
      }

      if (AdjustSatisfy(line, column, bp_line, bp_column, closed_line,
                        closed_column)) {
        closed_line = line;
        closed_column = column;
      }
    }
  }
  if (closed_column >= 0 && closed_line >= 0) {
    bp->column = closed_column;
    bp->line = closed_line;
    bp->is_adjust = true;
  }

  bp->script_id = bp->script_id == -1 ? -1 : bsrc->id;
}

QJS_STATIC void GetFunctionScriptId(LEPUSContext *ctx, LEPUSFunctionBytecode *b,
                                    int32_t &script_id, bool &is_lepus) {
  script_id = -1;
  if (!b->script) {
    auto *el = (ctx->script_list).next;
    if (el) {
      auto *script = list_entry(el, LEPUSScriptSource, link);
      if (script && script->url && (strcmp(script->url, "lepus.js") == 0)) {
        script_id = script->id;
        is_lepus = true;
      }
    }
  } else {
    script_id = b->script->is_debug_file ? b->script->id : -1;
    is_lepus = false;
  }
}

QJS_HIDE void GetCurrentLocation(LEPUSContext *ctx,
                                 struct LEPUSStackFrame *frame,
                                 const uint8_t *cur_pc, int32_t &line,
                                 int64_t &column, int32_t &script_id) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(frame->cur_func);
  if (p && lepus_class_has_bytecode(p->class_id)) {
    struct LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
    if (!b || !b->has_debug) return;

    bool is_lepus = false;
    GetFunctionScriptId(ctx, b, script_id, is_lepus);

    const uint8_t *pc =
        frame != GetStackFrame(ctx) || !cur_pc ? frame->cur_pc : cur_pc;

    int64_t line_num1 =
        find_line_num(ctx, b, (uint32_t)(pc - b->byte_code_buf - 1));
    ComputeLineCol(line_num1, &line, &column);
  }
}

// traverse all the funciton and traverse all the pc. find all the pc in the
// given range
QJS_HIDE void GetPossibleBreakpointsByScriptId(
    LEPUSContext *ctx, int32_t script_id, int64_t start_line, int64_t start_col,
    int64_t end_line, int64_t end_col, LEPUSValue locations) {
  LEPUSDebuggerInfo *info = ctx->debugger_info;
  if (!info) return;
  int32_t id = 0;
  struct list_head *el;
  list_for_each(el, &ctx->bytecode_list) {
    LEPUSFunctionBytecode *b = list_entry(el, LEPUSFunctionBytecode, link);
    if (!b || !b->has_debug) continue;
    if ((b->script && b->script->id != script_id) ||
        (b->debug.line_num - 1 > end_line)) {
      continue;
    }
    const uint8_t *p_end, *p, *p_prev;
    int pc;
    p_prev = p = b->debug.pc2line_buf;
    p_end = p + b->debug.pc2line_len;
    pc = 0;
    while (p_prev < p_end) {
      int32_t line = -1;
      int64_t column = -1;
      p_prev = p;
      GetPCLineColumn(ctx, p, pc, p_end, b, line, column);
      if (line == -1 && column == -1) {
        continue;
      }
      if (InRange(line, column, start_line, start_col, end_line, end_col) &&
          !LineColExist(ctx, locations, line, column)) {
        char str_script_id[40];
        snprintf(str_script_id,
                 (sizeof(str_script_id) / sizeof(str_script_id[0])), "%d",
                 script_id);
        auto *info = GetDebuggerInfo(ctx);
        LEPUSObject *p =
            DebuggerCreateObjFromShape(info, info->debugger_obj->bp_location);
        uint32_t idx = 0;
        SetFixedShapeObjValue(ctx, p, idx++,
                              LEPUS_NewString(ctx, str_script_id));
        SetFixedShapeObjValue(ctx, p, idx++, LEPUS_NewInt32(ctx, line));
        SetFixedShapeObjValue(ctx, p, idx++, LEPUS_NewInt64(ctx, column));
        LEPUS_SetPropertyUint32(ctx, locations, id++,
                                LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
      }
    }
  }
}

/**
 * @brief get script by index
 */
QJS_HIDE LEPUSScriptSource *GetScriptByIndex(LEPUSContext *ctx,
                                             int32_t script_index) {
  struct list_head *el;
  int32_t idx = 0;
  list_for_each(el, &ctx->script_list) {
    LEPUSScriptSource *script = list_entry(el, LEPUSScriptSource, link);
    if (idx == script_index) {
      return script;
    } else {
      idx++;
    }
  }
  return NULL;
}

void SetDebuggerInfoOpaque(LEPUSDebuggerInfo *info, void *opaque) {
  if (info) {
    info->opaque = opaque;
  }
}

void *GetDebuggerInfoOpaque(LEPUSDebuggerInfo *info) {
  return info ? info->opaque : NULL;
}

QJS_HIDE LEPUSScriptSource *GetBytecodeScript(LEPUSFunctionBytecode *b) {
  return b->script;
}

QJS_HIDE LEPUSValue *GetFrameThisObj(LEPUSStackFrame *frame) {
  return &(frame->pthis);
}

enum {
#define ConsoleEnum(name, type) LEPUS_CONSOLE_##type,
  QJSDebuggerRegisterConsole(ConsoleEnum)
#undef ConsoleEnum
};

QJS_STATIC void GetConsoleMessageRIDOrGroupID(LEPUSContext *ctx, LEPUSValue val,
                                              int32_t &rid, char *&gid,
                                              int32_t &lepus_id) {
  const char *first_arg = LEPUS_ToCString(ctx, val);
  const char *console_tag[] = {"runtimeId:", "groupId:", "lepusRuntimeId:"};
  if (first_arg) {
    const char *rid_head = console_tag[0];
    size_t rid_head_len = strlen(rid_head);
    if (strncmp(first_arg, rid_head, rid_head_len) == 0) {
      const char *view_id_str = first_arg + rid_head_len;
      if (view_id_str) {
        rid = atoi(view_id_str);
      }
    } else {
      const char *gid_head = console_tag[1];
      size_t gid_head_len = strlen(gid_head);
      if (strncmp(first_arg, gid_head, gid_head_len) == 0) {
        gid = static_cast<char *>(lepus_malloc(
            ctx, strlen(first_arg) - gid_head_len + 1));  // need to be freed
        strcpy(gid, first_arg + gid_head_len);
      } else {
        const char *lepus_head = console_tag[2];
        size_t lepus_head_len = strlen(lepus_head);
        if (strncmp(first_arg, lepus_head, lepus_head_len) == 0) {
          const char *lepus_id_str = first_arg + lepus_head_len;
          if (lepus_id_str) {
            lepus_id = atoi(lepus_id_str);
          }
        }
      }
    }
  }
  LEPUS_FreeCString(ctx, first_arg);
}

QJS_STATIC int64_t date_now(void);
QJS_STATIC void CommonLog(LEPUSContext *ctx, LEPUSValueConst this_val, int argc,
                          LEPUSValueConst *argv, int magic,
                          bool is_lynx_console = false) {
  auto *debugger_info = ctx->debugger_info;
  if (LEPUS_IsNull(debugger_info->console.messages)) return;
  const char *tag_table[] = {"log", "info", "debug", "error", "warning", "log",
                             "",    "",     "log",   "",      "timeEnd"};
  const char *tag = tag_table[magic];
  if (*tag == '\0') return;
  LEPUSValue console_msg = LEPUS_NewArray(ctx);
  int32_t rid = -1;
  char *gid = nullptr;
  int32_t lepus_id = -1;
  int argc_idx;
  int real_param = 0;
  for (argc_idx = 0; argc_idx < argc; argc_idx++) {
    if (argc_idx == 0 && is_lynx_console) {
      GetConsoleMessageRIDOrGroupID(ctx, argv[0], rid, gid,
                                    lepus_id);  // gid need to be freed
      if (rid == -1 && !gid && lepus_id == -1) {
        LEPUS_SetPropertyUint32(ctx, console_msg, real_param++,
                                LEPUS_DupValue(ctx, argv[argc_idx]));
      }

    } else {
      LEPUS_SetPropertyUint32(ctx, console_msg, real_param++,
                              LEPUS_DupValue(ctx, argv[argc_idx]));
    }
  }

  LEPUS_SetPropertyStr(ctx, console_msg, "tag", LEPUS_NewString(ctx, tag));
  LEPUS_SetPropertyStr(ctx, console_msg, "timestamp",
                       LEPUS_NewInt64(ctx, date_now()));
  if (ctx->rt->debugger_callbacks_.get_console_stack_trace) {
    LEPUSValue ret = LEPUS_NewObject(ctx);
    ctx->rt->debugger_callbacks_.get_console_stack_trace(ctx, &ret);
    LEPUS_SetPropertyStr(ctx, console_msg, "stackTrace", ret);
  }
  if (is_lynx_console) {
    if (rid != -1) {
      LEPUS_SetPropertyStr(ctx, console_msg, "rid", LEPUS_NewInt32(ctx, rid));
    }
    if (gid) {
      LEPUS_SetPropertyStr(ctx, console_msg, "gid", LEPUS_NewString(ctx, gid));
      lepus_free(ctx, gid);
    }
    if (lepus_id != -1) {
      LEPUS_SetPropertyStr(ctx, console_msg, "rid",
                           LEPUS_NewInt32(ctx, lepus_id));
      LEPUS_SetPropertyStr(ctx, console_msg, "lepusConsole",
                           LEPUS_NewBool(ctx, 1));
    }
  }

  int idx = debugger_info->console.length++;
  LEPUS_SetPropertyUint32(ctx, debugger_info->console.messages, idx,
                          LEPUS_DupValue(ctx, console_msg));

  LEPUSRuntime *rt = ctx->rt;
  if (ctx->debugger_info->is_debugger_enabled) {
    auto cb = is_lynx_console
                  ? rt->debugger_callbacks_.console_api_called_ntfy_with_rid
                  : rt->debugger_callbacks_.console_api_called_ntfy;
    if (cb) {
      cb(ctx, &console_msg);
    }
  }
  auto console_message_cb = rt->debugger_callbacks_.console_message;
  if (console_message_cb) {
    console_message_cb(ctx, magic, argv, argc);
  }
  LEPUS_FreeValue(ctx, console_msg);
}

QJS_STATIC LEPUSValue DebuggerLog(LEPUSContext *ctx, LEPUSValueConst this_val,
                                  int argc, LEPUSValueConst *argv, int magic) {
  CommonLog(ctx, this_val, argc, argv, magic);
  return LEPUS_UNDEFINED;
}

QJS_STATIC LEPUSValue LynxDebuggerLog(LEPUSContext *ctx,
                                      LEPUSValueConst this_val, int argc,
                                      LEPUSValueConst *argv, int magic) {
  CommonLog(ctx, this_val, argc, argv, magic, true);
  return LEPUS_UNDEFINED;
}

QJS_STATIC void LEPUS_AddIntrinsicConsole(LEPUSContext *ctx,
                                          bool is_lynx_console) {
  LEPUSValue global = ctx->global_obj;  // dup
  LEPUSValue console = LEPUS_NewObject(ctx);
  auto log_func = is_lynx_console ? LynxDebuggerLog : DebuggerLog;
  if (is_lynx_console) {
    DebuggerSetPropertyStr(ctx, global, "lynxConsole", console);
  } else {
    DebuggerSetPropertyStr(ctx, global, "console", console);
  }
#define RegisterConsole(name, type)                                         \
  DebuggerSetPropertyStr(ctx, console, name,                                \
                         LEPUS_NewCFunctionMagic(ctx, log_func, name, 1,    \
                                                 LEPUS_CFUNC_generic_magic, \
                                                 LEPUS_CONSOLE_##type));
  QJSDebuggerRegisterConsole(RegisterConsole)
#undef RegisterConsole
      if (ctx->debugger_info &&
          LEPUS_IsNull(ctx->debugger_info->console.messages)) {
    ctx->debugger_info->console.messages = LEPUS_NewArray(ctx);
    ctx->debugger_info->console.length = 0;
  }
}

// add lepus.js script info into rt->script_list
void AddDebuggerScript(LEPUSContext *ctx, char *script_source,
                       int32_t source_len, int32_t end_line_num) {
  LEPUSScriptSource *script = static_cast<LEPUSScriptSource *>(
      lepus_mallocz(ctx, sizeof(LEPUSScriptSource)));
  if (script) {
    script->id = ++(ctx->rt->next_script_id);
    script->is_debug_file = true;
    script->end_line = end_line_num;
    script->length = source_len;
    script->url = static_cast<char *>(lepus_strdup(ctx, "lepus.js"));
    script->source = static_cast<char *>(lepus_malloc(ctx, source_len + 1));
    if (script->source) {
      memcpy(script->source, script_source, source_len + 1);
    }
    script->source_map_url = NULL;
    ctx->debugger_info->script_num++;
    list_add_tail(&script->link, &ctx->script_list);
  }
}

QJS_HIDE const char *GetScriptSourceByScriptId(LEPUSContext *ctx,
                                               int32_t script_id) {
  struct list_head *el;
  list_for_each(el, &ctx->script_list) {
    LEPUSScriptSource *script = list_entry(el, LEPUSScriptSource, link);
    if (script->id == script_id) {
      return script->source;
    }
  }
  return "";
}

QJS_HIDE const char *GetScriptURLByScriptId(LEPUSContext *ctx,
                                            int32_t script_id) {
  struct list_head *el, *el1;
  list_for_each_safe(el, el1, &ctx->script_list) {
    LEPUSScriptSource *script = list_entry(el, LEPUSScriptSource, link);
    if (script->id == script_id) {
      return script->url;
    }
  }
  return NULL;
}

QJS_HIDE LEPUSString *GetRegExpPattern(LEPUSRegExp *re) { return re->pattern; }

#define IsType(name, type)                                \
  uint8_t Is##name(LEPUSContext *ctx, LEPUSValue value) { \
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(value);          \
    return p && p->class_id == type;                      \
  }
QJSDebuggerClassId(IsType)
#undef IsType

    uint8_t IsDate(LEPUSContext *ctx, LEPUSValue value) {
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(value);
  return p && p->class_id == LEPUS_CLASS_DATE &&
         LEPUS_IsNumber(p->u.object_data);
}

QJS_HIDE LEPUSValue GetMapRecordKey(LEPUSMapRecord *record) {
  return record->key;
}

QJS_HIDE LEPUSValue GetMapRecordValue(LEPUSMapRecord *record) {
  return record->value;
}

QJS_HIDE int32_t GetScriptIdByFunctionBytecode(
    LEPUSContext *ctx, struct LEPUSFunctionBytecode *b) {
  struct list_head *el, *el1;
  struct LEPUSFunctionBytecode *bytecode;
  list_for_each_safe(el, el1, &ctx->bytecode_list) {
    bytecode = list_entry(el, LEPUSFunctionBytecode, link);
    if (bytecode == b && bytecode->script) {
      return bytecode->script->id;
    }
  }
  return -1;
}

QJS_HIDE LEPUSFunctionBytecode *GetFunctionBytecodeByScriptId(
    LEPUSContext *ctx, int32_t script_id) {
  struct list_head *el, *el1;
  list_for_each_safe(el, el1, &ctx->bytecode_list) {
    LEPUSFunctionBytecode *b = list_entry(el, LEPUSFunctionBytecode, link);
    // return top level bytecode
    if (b->script && b->func_level_state == DEBUGGER_TOP_LEVEL_FUNCTION &&
        b->script->id == script_id) {
      return b;
    }
  }
  return NULL;
}

QJS_HIDE LEPUSValue GetGeneratorFunction(LEPUSContext *ctx, LEPUSValue obj) {
  auto *s = static_cast<LEPUSGeneratorData *>(
      LEPUS_GetOpaque(obj, LEPUS_CLASS_GENERATOR));
  if (!s) return LEPUS_UNDEFINED;
  LEPUSStackFrame *sf = &(s->func_state.frame);
  return LEPUS_DupValue(ctx, sf->cur_func);
}

QJS_HIDE LEPUSValue GetGeneratorState(LEPUSContext *ctx, LEPUSValue obj) {
  auto *s = static_cast<LEPUSGeneratorData *>(
      LEPUS_GetOpaque(obj, LEPUS_CLASS_GENERATOR));
  if (!s) return LEPUS_UNDEFINED;
  LEPUSGeneratorStateEnum state = s->state;
  if (state == LEPUS_GENERATOR_STATE_SUSPENDED_START ||
      state == LEPUS_GENERATOR_STATE_SUSPENDED_YIELD ||
      state == LEPUS_GENERATOR_STATE_SUSPENDED_YIELD_STAR) {
    return LEPUS_NewString(ctx, "suspended");
  } else if (state == LEPUS_GENERATOR_STATE_EXECUTING) {
    return LEPUS_NewString(ctx, "executing");
  } else if (state == LEPUS_GENERATOR_STATE_COMPLETED) {
    return LEPUS_NewString(ctx, "completed");
  }
  return LEPUS_NewString(ctx, "");
}

QJS_HIDE LEPUSValue GetGeneratorFuncName(LEPUSContext *ctx, LEPUSValue obj) {
  auto *s = static_cast<LEPUSGeneratorData *>(
      LEPUS_GetOpaque(obj, LEPUS_CLASS_GENERATOR));
  LEPUSStackFrame *sf = &s->func_state.frame;
  const char *frame_name = get_func_name(ctx, sf->cur_func);
  if (frame_name) {
    LEPUSValue ret = LEPUS_NewString(ctx, frame_name);
    LEPUS_FreeCString(ctx, frame_name);
    return ret;
  } else {
    return LEPUS_NewString(ctx, "");
  }
}

QJS_HIDE LEPUSValue LEPUS_EvalFunctionWithThisObj(LEPUSContext *ctx,
                                                  LEPUSValue func_obj,
                                                  LEPUSValueConst this_obj,
                                                  int argc, LEPUSValue *argv) {
  LEPUSValue res = LEPUS_UNDEFINED;
  LEPUSValue func_obj_save = func_obj;
  if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(func_obj)) {
    LEPUSFunctionBytecode *b =
        static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(func_obj));
    for (int32_t i = 0; i < b->cpool_count; i++) {
      LEPUSValue child = b->cpool[i];
      if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(child)) {
        func_obj = child;
        b->cpool[i] = LEPUS_UNDEFINED;
        break;
      }
    }

    func_obj = lepus_closure(ctx, func_obj, NULL, NULL);
    res = LEPUS_CallInternalTI(ctx, func_obj, this_obj, LEPUS_UNDEFINED, argc,
                               argv, 0);
    LEPUS_FreeValue(ctx, func_obj_save);
    LEPUS_FreeValue(ctx, func_obj);
  }
  return res;
}

QJS_HIDE LEPUSMapRecord *DebuggerMapFindIndex(LEPUSContext *ctx,
                                              LEPUSValue this_val,
                                              int32_t index, int32_t magic) {
  auto *s = static_cast<LEPUSMapState *>(
      LEPUS_GetOpaque2(ctx, this_val, LEPUS_CLASS_MAP + magic));
  struct list_head *el;
  LEPUSMapRecord *mr;
  int32_t num = 0;
  list_for_each(el, s->hash_table) {
    if (num == index) {
      mr = list_entry(el, LEPUSMapRecord, hash_link);
      return mr;
    } else {
      num++;
    }
  }
  return NULL;
}

QJS_HIDE void SetInspectorCurrentPC(LEPUSContext *ctx, const uint8_t *pc) {
  ctx->debugger_current_pc = pc;
}

QJS_HIDE LEPUSValue GetFrameFunction(LEPUSStackFrame *frame) {
  return frame->cur_func;
}

int64_t GetFunctionDebugColumnNum(LEPUSContext *ctx, LEPUSFunctionBytecode *b) {
  if (b && b->has_debug) {
    return b->debug.column_num;
  }
  return -1;
}

QJS_HIDE int32_t GetClosureSize(LEPUSContext *ctx, int32_t stack_index) {
  int32_t size = 0;
  struct LEPUSStackFrame *sf;
  int32_t cur_index = 0;
  for (sf = ctx->rt->current_stack_frame; sf != NULL; sf = sf->prev_frame) {
    if (cur_index < stack_index) {
      cur_index++;
      continue;
    }

    LEPUSObject *f = LEPUS_VALUE_GET_OBJ(sf->cur_func);
    if (!f || !lepus_class_has_bytecode(f->class_id)) return size;
    struct LEPUSFunctionBytecode *b = f->u.func.function_bytecode;
    if (b->closure_var_count > 0) {
      size++;
    } else {
      break;
    }
  }
  return size;
}

// given LEPUSClosureVar, return the closure lepusvalue
QJS_STATIC LEPUSValue FindClosureVar(struct LEPUSStackFrame *sf,
                                     struct LEPUSClosureVar *cvar) {
  while (sf && sf->prev_frame) {
    sf = sf->prev_frame;
    LEPUSObject *f = LEPUS_VALUE_GET_OBJ(sf->cur_func);
    if (!f || !lepus_class_has_bytecode(f->class_id)) return LEPUS_UNDEFINED;
    struct LEPUSFunctionBytecode *b = f->u.func.function_bytecode;

    if (cvar->is_local) {
      if (cvar->is_arg) {
        if (!sf->arg_buf) return LEPUS_UNDEFINED;
        return sf->arg_buf[cvar->var_idx];
      } else {
        return sf->var_buf[cvar->var_idx];
      }
    }

    if (!b->closure_var) break;
    cvar = b->closure_var + cvar->var_idx;
  }

  return LEPUS_UNDEFINED;
}

// get closure variables given the stack frame
QJS_HIDE LEPUSValue GetFrameClosureVariables(LEPUSContext *ctx,
                                             int32_t stack_index,
                                             int32_t closure_level) {
  LEPUSValue ret = LEPUS_NewObject(ctx);
  if (LEPUS_IsException(ret)) {
    goto done;
  }
  struct LEPUSStackFrame *sf;
  int32_t cur_index;
  cur_index = 0;
  for (sf = ctx->rt->current_stack_frame; sf != NULL;
       sf = sf->prev_frame, cur_index++) {
    if (cur_index < stack_index + closure_level) {
      continue;
    }

    LEPUSObject *f = LEPUS_VALUE_GET_OBJ(sf->cur_func);
    if (!f || !lepus_class_has_bytecode(f->class_id)) goto done;

    struct LEPUSFunctionBytecode *b = f->u.func.function_bytecode;

    for (uint32_t i = 0; i < b->closure_var_count; i++) {
      struct LEPUSClosureVar *cvar = b->closure_var + i;
      LEPUSValue val = FindClosureVar(sf, cvar);
      LEPUSValue ret_val = LEPUS_UNDEFINED;
      if (LEPUS_IsUndefined(val)) {
        LEPUSVarRef **var_refs = f->u.func.var_refs;
        if (var_refs) {
          LEPUSVarRef *var_ref = var_refs[i];
          if (var_ref) {
            ret_val = LEPUS_DupValue(ctx, var_ref->value);
          }
        }
      } else {
        ret_val = LEPUS_DupValue(ctx, val);
      }

      LEPUS_SetProperty(ctx, ret, cvar->var_name, ret_val);
    }
    break;
  }
done:
  return ret;
}

QJS_STATIC void DebuggerSetFunctionBytecodeScript(LEPUSContext *ctx,
                                                  LEPUSFunctionDef *fd,
                                                  LEPUSFunctionBytecode *b) {
  b->func_level_state = DEBUGGER_LOW_LEVEL_FUNCTION;
  b->script = fd->script;
  if (b->script != NULL) {
    b->func_level_state = DEBUGGER_TOP_LEVEL_FUNCTION;
  } else if (fd->parent != NULL) {
    // set function bytecode script: top level function script
    LEPUSFunctionDef *p = fd->parent;
    while (p->script == NULL && p->parent != NULL) {
      p = p->parent;
    }
    b->script = p->script;
  }
  // add bytecode to bytecode_list
  list_add_tail(&b->link, &ctx->bytecode_list);
}

QJS_STATIC void InitializeDebuggerInfo(LEPUSDebuggerInfo *info) {
  info->step_location = NULL;
  info->step_statement = false;
  info->next_statement_count = 0;
  info->source_code = NULL;
  info->message_queue = NULL;
  info->end_line_num = -1;
  info->is_debugger_enabled = FALSE;
  info->is_runtime_enabled = FALSE;
  info->script_num = 0;
  info->console.messages = LEPUS_NULL;
  info->console.length = 0;
}

QJS_STATIC void DebuggerInitialize(LEPUSContext *ctx) {
  LEPUSDebuggerInfo *info = static_cast<LEPUSDebuggerInfo *>(
      lepus_mallocz_rt(ctx->rt, sizeof(LEPUSDebuggerInfo)));
  if (info) {
    InitializeDebuggerInfo(info);
  }
  ctx->debugger_info = info;
}

void DebuggerFree(LEPUSContext *ctx) {
  assert(ctx->debugger_info->script_num == 0);
  ctx->debugger_info->cpu_profiling_started = false;
  if (ctx->debugger_info) {
    lepus_free(ctx, ctx->debugger_info->source_code);
  }
  lepus_free_rt(ctx->rt, ctx->debugger_info);
}

QJS_STATIC char *DebuggerSetScriptHash(LEPUSContext *ctx, const char *src,
                                       int32_t id) {
  const int32_t buf_len = 64;
  char *buf = static_cast<char *>(lepus_malloc(ctx, (sizeof(char) * buf_len)));
  if (buf) {
    uint64_t h = 0;
    while (*src) {
      h = h * 31 + *src++;
    }
    h = h * 31 + id;
    snprintf(buf, buf_len, "%llu", (unsigned long long)h);
  }
  return buf;
}

char *FindDebuggerMagicContent(LEPUSContext *ctx, char *content1, char *name1,
                               uint8_t multi_line);
QJS_STATIC void SetScriptSourceMappingUrl(LEPUSContext *ctx,
                                          LEPUSScriptSource *script) {
  char *source_map_url = FindDebuggerMagicContent(
      ctx, script->source, (char *)"sourceMappingURL", 0);
  script->source_map_url = source_map_url;
}

QJS_STATIC void SetScriptUrl(LEPUSContext *ctx, const char *filename,
                             LEPUSScriptSource *script, char *source_url) {
  script->url = NULL;
  if (*filename) {
    script->url = lepus_strdup(ctx, filename);
  } else if (script->source) {
    script->url = source_url;
  }

  if (!script->url) {
    script->url = lepus_strdup(ctx, "");
  }
}

QJS_STATIC void SetScriptHash(LEPUSContext *ctx, LEPUSScriptSource *script) {
  script->hash = NULL;
  if (script->source) {
    char *hash = DebuggerSetScriptHash(ctx, script->source, script->id);
    script->hash = hash;
  }
}

QJS_STATIC void SendParseScriptNotification(LEPUSContext *ctx,
                                            LEPUSScriptSource *script,
                                            int32_t err, int32_t view_id) {
  if (ctx->debugger_info->is_debugger_enabled) {
    if (!err) {
      if (view_id == -1) {
        auto cb = ctx->rt->debugger_callbacks_.script_parsed_ntfy;
        if (cb) {
          cb(ctx, script);
        }
      } else {
        auto cb = ctx->rt->debugger_callbacks_.script_parsed_ntfy_with_view_id;
        if (cb) {
          cb(ctx, script, view_id);
        }
      }
    } else {
      if (view_id == -1) {
        auto cb = ctx->rt->debugger_callbacks_.script_fail_parse_ntfy;
        if (cb) {
          cb(ctx, script);
        }
      } else {
        auto cb =
            ctx->rt->debugger_callbacks_.script_fail_parse_ntfy_with_view_id;
        if (cb) {
          cb(ctx, script, view_id);
        }
      }
    }
  }
}

QJS_STATIC bool IsDebuggerFile(const char *filename) {
  return filename && strcmp(filename, "quickjsTriggerTimer.js") != 0;
}

QJS_STATIC LEPUSScriptSource *FindDebuggerScript(LEPUSContext *ctx,
                                                 char *source_url) {
  struct list_head *el, *el1;
  list_for_each_safe(el, el1, &ctx->script_list) {
    LEPUSScriptSource *script = list_entry(el, LEPUSScriptSource, link);
    if (script && script->url && source_url &&
        strcmp(script->url, source_url) == 0) {
      return script;
    }
  }
  return NULL;
}

// get view id from filename
// filename format: file://viewx/app-service.js
QJS_STATIC int32_t GetViewID(const char *filename) {
  int32_t view_id = -1;
  const char *file_head = "file://view";
  size_t file_head_len = strlen(file_head);
  size_t file_name_len = strlen(filename);
  if (filename && strncmp(filename, file_head, file_head_len) == 0) {
    view_id = 0;
    for (size_t i = file_head_len; i < file_name_len && filename[i] != '/';
         i++) {
      if (filename[i] >= '0' && filename[i] <= '9') {
        view_id = view_id * 10 + (filename[i] - '0');
      }
    }
  }
  return view_id;
}

QJS_STATIC void DebuggerParseScript(LEPUSContext *ctx, const char *input,
                                    size_t input_len, LEPUSFunctionDef *fd,
                                    const char *filename, int32_t end_line_num,
                                    int32_t err) {
  auto *debug_info = GetDebuggerInfo(ctx);
  if (!debug_info) return;
  char *source_url = NULL;
  LEPUSScriptSource *script = NULL;
  if (input) {
    source_url =
        FindDebuggerMagicContent(ctx, (char *)input, (char *)"sourceURL", 0);
    if (source_url) {
      // if the script is already in script list, do not need to create new
      // script
      script = FindDebuggerScript(ctx, source_url);
    }
  }

  if (!script && IsDebuggerFile(filename)) {
    script = static_cast<LEPUSScriptSource *>(
        lepus_mallocz(ctx, sizeof(LEPUSScriptSource)));
    if (script) {
      script->id = ++ctx->rt->next_script_id;
      script->is_debug_file = (strcmp(filename, "<input>") != 0);
      script->length = input_len;
      script->source = static_cast<char *>(lepus_malloc(ctx, input_len + 1));
      if (script->source) {
        memcpy(script->source, input, input_len + 1);
      }
      script->end_line = end_line_num;
      SetScriptUrl(ctx, filename, script, source_url);
      SetScriptSourceMappingUrl(ctx, script);
      SetScriptHash(ctx, script);
      debug_info->script_num++;
      list_add_tail(&script->link, &ctx->script_list);
    }
  }

  if (script) {
    fd->source_len = input_len;
    if (err) {
      fd->source = lepus_strdup(
          ctx, script->source);  // fd->source free in lepus_free_function_def
    } else {
      fd->source = script->source;
    }
    fd->script = script;
    int32_t view_id = GetViewID(filename);
    const char *script_url = script ? script->url : nullptr;
    if (!(script_url && strcmp(script_url, "<input>") == 0)) {
      SendParseScriptNotification(ctx, script, err, view_id);
    }
  }
}

QJS_STATIC uint8_t DebuggerIsDevtoolOn(LEPUSRuntime *rt) {
  if (rt->debugger_callbacks_.is_devtool_on) {
    return rt->debugger_callbacks_.is_devtool_on(rt);
  }
  return 0;
}

int32_t GetExecutionContextId(LEPUSContext *ctx) {
  struct list_head *el, *el1;
  LEPUSRuntime *rt = ctx->rt;
  int32_t index = 0;
  list_for_each_safe(el, el1, &rt->context_list) {
    LEPUSContext *ctx1 = list_entry(el, LEPUSContext, link);
    if (ctx1 == ctx) {
      return index;
    } else {
      index++;
    }
  }
  // not found
  return -1;
}

QJS_HIDE LEPUSContext *GetContextByContextId(LEPUSRuntime *rt, int32_t id) {
  struct list_head *el, *el1;
  int32_t index = 0;
  list_for_each_safe(el, el1, &rt->context_list) {
    if (index == id) {
      LEPUSContext *ctx1 = list_entry(el, LEPUSContext, link);
      return ctx1;
    }
  }
  return NULL;
}

QJS_HIDE void DebuggerFreeScript(LEPUSContext *ctx, LEPUSScriptSource *script) {
  ctx->debugger_info->script_num--;
  LEPUSRuntime *rt = ctx->rt;
  list_del(&script->link);
  lepus_free_rt(rt, script->url);
  lepus_free_rt(rt, script->source);
  lepus_free_rt(rt, script->hash);
  if (script->source_map_url) {
    lepus_free_rt(rt, script->source_map_url);
  }
  lepus_free_rt(rt, script);
}

QJS_STATIC void FreeDebuggerScriptAndBytecodeList(LEPUSContext *ctx) {
  struct list_head *el, *el1;
  struct list_head node = ctx->script_list;
  if (node.prev && node.next) {
    list_for_each_safe(el, el1, &ctx->script_list) {
      LEPUSScriptSource *script = list_entry(el, LEPUSScriptSource, link);
      if (script) {
        DebuggerFreeScript(ctx, script);
      }
    }
  }
  node = ctx->bytecode_list;
  if (node.prev && node.next) {
    list_for_each_safe(el, el1, &ctx->bytecode_list) {
      LEPUSFunctionBytecode *b = list_entry(el, LEPUSFunctionBytecode, link);
      if (b) {
        b->link.prev = NULL;
        b->link.next = NULL;
      }
    }
  }
}

void DebuggerPause(LEPUSContext *ctx, LEPUSValue val, const uint8_t *pc) {
  auto *info = ctx->debugger_info;
  if (!info) return;
  const char *name = LEPUS_ToCString(ctx, val);
  // only pause when breakpoint is active
  if (info->breakpoints_is_active && name && strcmp(name, "debugger") == 0) {
    auto paused_callback = ctx->rt->debugger_callbacks_.debugger_paused;
    if (paused_callback) {
      paused_callback(ctx, pc);
    }
  }
  LEPUS_FreeCString(ctx, name);
}

uint8_t *GetFunctionDebugPC2LineBuf(LEPUSContext *ctx,
                                    LEPUSFunctionBytecode *b) {
  if (b && b->has_debug) {
    return b->debug.pc2line_buf;
  }
  return NULL;
}

int GetFunctionDebugPC2LineLen(LEPUSContext *ctx, LEPUSFunctionBytecode *b) {
  if (b && b->has_debug) {
    return b->debug.pc2line_len;
  }
  return 0;
}

uint32_t DebuggerGetFuncSize(LEPUSContext *ctx) {
  return ctx->next_function_id - 1;  // next_function_id start from 1
}

const char *GetFunctionDebugFileName(LEPUSContext *ctx,
                                     LEPUSFunctionBytecode *b) {
  if (b && b->has_debug) {
    LEPUS_AtomToCString(ctx, b->debug.filename);
  }
  return NULL;
}

const char *GetFunctionName(LEPUSContext *ctx, LEPUSFunctionBytecode *b) {
  if (b) {
    if (b->func_name == LEPUS_ATOM_NULL) return NULL;
    return LEPUS_AtomToCString(ctx, b->func_name);
  }
  return NULL;
}

int32_t GetFunctionDebugLineNum(LEPUSContext *ctx, LEPUSFunctionBytecode *b) {
  if (b && b->has_debug) {
    return b->debug.line_num - 1;
  } else {
    return -1;
  }
}

QJS_STATIC uint8_t AddToFunctionBytecodeList(LEPUSContext *ctx,
                                             LEPUSFunctionBytecode *b,
                                             LEPUSFunctionBytecode **&list,
                                             uint32_t *use_size,
                                             uint32_t &total_size) {
  const uint32_t size = 50;
  if (*use_size >= total_size) {
    list = static_cast<LEPUSFunctionBytecode **>(lepus_realloc(
        ctx, list, sizeof(LEPUSFunctionBytecode *) * (total_size + size)));
    if (list) {
      total_size += size;
    } else {
      *use_size = 0;
      return 0;
    }
  }
  list[*use_size] = b;
  *use_size += 1;
  return 1;
}

QJS_STATIC void AddFunctionBytecode(LEPUSContext *ctx, LEPUSValue obj,
                                    LEPUSFunctionBytecode **&list,
                                    uint32_t *use_size, uint32_t &total_size) {
  int64_t tag = LEPUS_VALUE_GET_NORM_TAG(obj);
  switch (tag) {
    case LEPUS_TAG_FUNCTION_BYTECODE: {
      LEPUSFunctionBytecode *b =
          static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(obj));
      if (!AddToFunctionBytecodeList(ctx, b, list, use_size, total_size)) {
        lepus_free(ctx, list);
        list = NULL;
        return;
      }
      for (int i = 0; i < b->cpool_count; i++) {
        AddFunctionBytecode(ctx, b->cpool[i], list, use_size, total_size);
      }
      break;
    }
    case LEPUS_TAG_MODULE: {
      LEPUSModuleDef *m =
          static_cast<LEPUSModuleDef *>(LEPUS_VALUE_GET_PTR(obj));
      AddFunctionBytecode(ctx, m->func_obj, list, use_size, total_size);
      break;
    }
    case LEPUS_TAG_OBJECT: {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(obj);
      uint32_t i, prop_count, len;
      LEPUSShape *sh;
      LEPUSShapeProperty *pr;
      LEPUSValue val;
      int ret, pass;
      BOOL is_template;
      LEPUSAtom atom;

      if (p->class_id == LEPUS_CLASS_ARRAY) {
        if (!p->extensible) {
          is_template = TRUE;
        } else {
          is_template = FALSE;
        }
        if (lepus_get_length32(ctx, &len, obj)) {
          break;
        };
        for (i = 0; i < len; i++) {
          val = LEPUS_GetPropertyUint32(ctx, obj, i);
          if (LEPUS_IsException(val)) break;
          AddFunctionBytecode(ctx, val, list, use_size, total_size);
          LEPUS_FreeValue(ctx, val);
        }
        if (is_template) {
          val = LEPUS_GetProperty(ctx, obj, LEPUS_ATOM_raw);
          if (LEPUS_IsException(val)) break;
          AddFunctionBytecode(ctx, val, list, use_size, total_size);
          LEPUS_FreeValue(ctx, val);
        }
      } else {
        sh = p->shape;
        for (pass = 0; pass < 2; pass++) {
          for (i = 0, pr = get_shape_prop(sh); i < sh->prop_count; i++, pr++) {
            atom = pr->atom;
            if (atom != LEPUS_ATOM_NULL && LEPUS_AtomIsString(ctx, atom) &&
                (pr->flags & LEPUS_PROP_ENUMERABLE)) {
              if (pr->flags & LEPUS_PROP_TMASK) {
                LEPUS_ThrowTypeError(ctx,
                                     "only value properties are supported");
                break;
              }
              if (pass != 0) {
                AddFunctionBytecode(ctx, p->prop[i].u.value, list, use_size,
                                    total_size);
              }
            }
          }
        }
      }
      break;
    }
    default: {
      break;
    }
  }
}

void SetDebuggerEndLineNum(LEPUSContext *ctx, int32_t end_line_num) {
  if (ctx->debugger_info) {
    ctx->debugger_info->end_line_num = end_line_num;
  }
}

int GetFunctionBytecodeLen(LEPUSFunctionBytecode *b) {
  if (b) {
    return b->byte_code_len;
  } else {
    return -1;
  }
}

const char *GetFunctionDebugSource(LEPUSContext *ctx,
                                   LEPUSFunctionBytecode *b) {
  if (b && b->has_debug) {
    return b->debug.source;
  } else {
    return NULL;
  }
}

void InitQJSDebugger(LEPUSContext *ctx) {
  LEPUSRuntime *rt = ctx->rt;
#ifdef ENABLE_MONITOR
  const char *biz_name = DEFAULT_BIZ_NAME;
  if (rt->rt_info) {
    biz_name = rt->rt_info;
  }
#ifdef ENABLE_PRIMJS_SNAPSHOT
  const char *module_name = rt->use_primjs ? MODULE_PRIMJS : MODULE_QUICK;
  MonitorEvent(module_name, biz_name, "QuickjsDebug", "true");
#else
  MonitorEvent(MODULE_QUICK, biz_name, "QuickjsDebug", "true");
#endif
#endif
  if (!ctx->debugger_info) {
    DebuggerInitialize(ctx);
    init_list_head(&ctx->script_list);
    init_list_head(&ctx->bytecode_list);
  }
}

QJS_HIDE void RegisterLynxConsole(LEPUSContext *ctx) {
  // register lynx console
  LEPUSValue global = LEPUS_GetGlobalObject(ctx);  // dup
  LEPUSValue lynx_console = LEPUS_GetPropertyStr(ctx, global, "lynxConsole");
  if (LEPUS_IsUndefined(lynx_console)) {
    // for lynxconsole.xxx
    LEPUS_AddIntrinsicConsole(ctx, true);
  }
  LEPUS_FreeValue(ctx, global);
  LEPUS_FreeValue(ctx, lynx_console);
}

void PrepareQJSDebuggerDefer(LEPUSContext *ctx, void **funcs,
                             int32_t callback_size) {
  LEPUSRuntime *rt = ctx->rt;
  if (!rt->debugger_callbacks_.run_message_loop_on_pause) {
    RegisterQJSDebuggerCallbacks(rt, funcs, callback_size);
  }
  InitQJSDebugger(ctx);
  ctx->debugger_mode = 1;
  LEPUS_AddIntrinsicConsole(ctx);
}

void PrepareQJSDebuggerForSharedContext(LEPUSContext *ctx, void **funcs,
                                        int32_t callback_size,
                                        bool devtool_connect) {
  LEPUSRuntime *rt = ctx->rt;
  if (!rt->debugger_callbacks_.run_message_loop_on_pause) {
    RegisterQJSDebuggerCallbacks(rt, funcs, callback_size);
  }

  InitQJSDebugger(ctx);
  if (devtool_connect) {
    ctx->debugger_mode = 1;
  } else {
    ctx->debugger_parse_script = 1;
    ctx->debugger_mode = 0;
  }
  RegisterLynxConsole(ctx);
}

// get promise object properties
LEPUSValue DebuggerGetPromiseProperties(LEPUSContext *ctx, LEPUSValue val) {
  LEPUSPromiseData *s = static_cast<LEPUSPromiseData *>(
      LEPUS_GetOpaque(val, LEPUS_CLASS_PROMISE));
  const char *promise_state[] = {"pending", "fulfilled", "rejected"};
  LEPUSValue debugger_promise = LEPUS_NewObject(ctx);
  DebuggerSetPropertyStr(ctx, debugger_promise, "PromiseResult",
                         LEPUS_DupValue(ctx, s->promise_result));
  DebuggerSetPropertyStr(ctx, debugger_promise, "PromiseState",
                         LEPUS_NewString(ctx, promise_state[s->promise_state]));
  return debugger_promise;
}

// get proxy object properties
LEPUSValue DebuggerGetProxyProperties(LEPUSContext *ctx, LEPUSValue val) {
  LEPUSProxyData *s =
      static_cast<LEPUSProxyData *>(LEPUS_GetOpaque(val, LEPUS_CLASS_PROXY));
  LEPUSValue debugger_proxy = LEPUS_NewObject(ctx);
  DebuggerSetPropertyStr(ctx, debugger_proxy, "IsRevoked",
                         LEPUS_NewBool(ctx, s->is_revoked));
  DebuggerSetPropertyStr(ctx, debugger_proxy, "Target",
                         LEPUS_DupValue(ctx, s->target));
  DebuggerSetPropertyStr(ctx, debugger_proxy, "Handler",
                         LEPUS_DupValue(ctx, s->handler));
  return debugger_proxy;
}

#ifdef QJS_UNITTEST
LEPUSValue GetAnonFunc(LEPUSFunctionBytecode *b) {
  LEPUSValue func_obj = LEPUS_UNDEFINED;
  for (int32_t i = 0; i < b->cpool_count; i++) {
    LEPUSValue child = b->cpool[i];
    if (LEPUS_VALUE_IS_FUNCTION_BYTECODE(child)) {
      func_obj = child;
      break;
    }
  }
  return func_obj;
}
#endif

void DebuggerSetPropertyStr(LEPUSContext *ctx, LEPUSValueConst this_obj,
                            const char *prop, LEPUSValue val) {
  LEPUSAtom atom;
  LEPUSProperty *pr;
  atom = LEPUS_NewAtom(ctx, prop);
  LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_obj);
  pr = add_property(ctx, p, atom, LEPUS_PROP_C_W_E);
  if (unlikely(!pr)) {
    LEPUS_FreeValue(ctx, val);
    return;
  }
  pr->u.value = val;
  LEPUS_FreeAtom(ctx, atom);
}

void SetDebuggerMode(LEPUSContext *ctx) { ctx->debugger_mode = 0; }

void SetFixedShapeObjValue(LEPUSContext *ctx, LEPUSObject *p, uint32_t idx,
                           LEPUSValue val) {
  p->prop[idx].u.value = val;
}

LEPUSObject *DebuggerCreateObjFromShape(LEPUSDebuggerInfo *info,
                                        LEPUSValue obj) {
  LEPUSShape *result_sh = LEPUS_VALUE_GET_OBJ(obj)->shape;
  LEPUSValue result =
      LEPUS_NewObjectFromShape(info->ctx, lepus_dup_shape(result_sh), 1);
  return LEPUS_VALUE_GET_OBJ(result);
}

LEPUSValue DebuggerDupException(LEPUSContext *ctx) {
  LEPUSValue val = ctx->rt->current_exception;
  LEPUS_DupValue(ctx, val);
  return val;
}

void SetDebuggerStepStatement(LEPUSDebuggerInfo *info, LEPUSContext *ctx,
                              const uint8_t *cur_pc) {
  if (!info) return;
#ifdef ENABLE_QUICKJS_STEP_STATEMENT
  LEPUSValue val = LEPUS_UNDEFINED;
  LEPUSValue function = ctx->rt->current_stack_frame->cur_func;
  struct LEPUSFunctionBytecode *b = LEPUS_GetFunctionBytecode(function);
  int op_code = *(cur_pc - 1);
  switch ((op_code)) {
    case OP_push_const:
      val = b->cpool[get_u32(cur_pc)];
      break;
    case OP_push_const8:
      val = b->cpool[*cur_pc];
      break;
    default:
      break;
  }
  const char *name = LEPUS_ToCString(ctx, val);
  if (name && strcmp(name, "statement") == 0) {
    // statement here
    info->step_statement = true;
  }
  LEPUS_FreeCString(ctx, name);
#else
  info->step_statement = false;
#endif
}
#endif  // end of quickjs debugger

#ifdef ENABLE_QUICKJS_CPU_PROFILER
QJS_HIDE uint8_t FunctionBytecodeHasDebug(LEPUSFunctionBytecode *b) {
  return b->has_debug;
}

QJS_HIDE const uint8_t *GetFrameCurPC(LEPUSStackFrame *sf) {
  return sf->cur_pc;
}

QJS_HIDE uint8_t *GetFunctionBytecodeBuf(LEPUSFunctionBytecode *b) {
  return b->byte_code_buf;
}

QJS_HIDE LEPUSValue DeepCloneFuncFrameForProfiler(LEPUSContext *ctx,
                                                  LEPUSContext *profiler_ctx,
                                                  LEPUSValue frame_func) {
  if (!ctx->rt->use_dlmalloc) return LEPUS_UNDEFINED;
  auto *b = LEPUS_GetFunctionBytecode(frame_func);
  if (b) {
    LEPUSFunctionBytecode *b_clone;
    int function_size = sizeof(*b_clone);
    int byte_code_offset = function_size;
    function_size += b->byte_code_len;
    b_clone = static_cast<LEPUSFunctionBytecode *>(
        lepus_mallocz(profiler_ctx, function_size));
    if (!b_clone) return LEPUS_UNDEFINED;
    b_clone->header.ref_count = 1;
    b_clone->byte_code_buf = (uint8_t *)b_clone + byte_code_offset;
    b_clone->byte_code_len = b->byte_code_len;
    b_clone->stack_size = b->stack_size;
    b_clone->has_debug = b->has_debug;
    if (b_clone->has_debug) {
      b_clone->debug.line_num = b->debug.line_num;
      b_clone->debug.column_num = b->debug.column_num;
      b_clone->debug.pc2line_buf = static_cast<uint8_t *>(
          lepus_mallocz(profiler_ctx, b->debug.pc2line_len));
      if (b_clone->debug.pc2line_buf) {
        memcpy(b_clone->debug.pc2line_buf, b->debug.pc2line_buf,
               b->debug.pc2line_len);
        b_clone->debug.pc2line_len = b->debug.pc2line_len;
      }
    }
    if (b->script) {
      if (b->script->url) {
        struct list_head *el, *el1;
        list_for_each_safe(el, el1, &profiler_ctx->script_list) {
          LEPUSScriptSource *script = list_entry(el, LEPUSScriptSource, link);
          if (script && script->url &&
              strcmp(script->url, b->script->url) == 0) {
            b_clone->script = b->script;
            goto done;
          }
        }
      }
      b_clone->script = static_cast<LEPUSScriptSource *>(
          lepus_mallocz(profiler_ctx, sizeof(LEPUSScriptSource)));
      if (b_clone->script) {
        b_clone->script->url = lepus_strdup(profiler_ctx, b->script->url);
      }
      LEPUSDebuggerInfo *info = GetDebuggerInfo(profiler_ctx);
      if (info) {
        info->script_num++;
        list_add_tail(&b_clone->script->link, &profiler_ctx->script_list);
      }
    }

  done:
    LEPUSValue func_obj_clone =
        LEPUS_NewObjectProtoClass(profiler_ctx, profiler_ctx->function_proto,
                                  LEPUS_CLASS_BYTECODE_FUNCTION);

    LEPUSObject *p_clone = LEPUS_VALUE_GET_OBJ(func_obj_clone);
    p_clone->u.func.function_bytecode = b_clone;
    p_clone->u.func.home_object = NULL;
    p_clone->u.func.var_refs = NULL;

    const char *func_name = get_func_name(ctx, frame_func);
    LEPUS_DefinePropertyValue(profiler_ctx, func_obj_clone, LEPUS_ATOM_name,
                              LEPUS_NewString(profiler_ctx, func_name),
                              LEPUS_PROP_CONFIGURABLE);
    LEPUS_FreeCString(ctx, func_name);
    return func_obj_clone;
  }
  return LEPUS_UNDEFINED;
}

void SetIsProfilerCtx(LEPUSContext *ctx, uint8_t val) {
  ctx->is_profiler_ctx = val;
}
#endif  // end of quickjs cpu profiler

#if defined(ENABLE_QUICKJS_DEBUGGER) || defined(ENABLE_HEAPPROFILER)
QJS_HIDE LEPUSValue GetGlobalVarObj(LEPUSContext *ctx) {
  return LEPUS_DupValue(ctx, ctx->global_var_obj);
}
#endif
// <ByteDance end>

// <primjs begin>
#ifdef ENABLE_PRIMJS_SNAPSHOT

no_inline void prim_js_print(const char *msg) { printf("msg: %s\n", msg); }

no_inline void prim_js_print_register(uint64_t reg_val) {
  printf("Register: %p\n", (void *)reg_val);
}

static int trace_id = 0;

void prim_js_print_trace(int bytecode, int tos) {
  const char *name = short_opcode_info((OPCodeEnum)bytecode).name;
  PRIM_LOG("TRACE: id: %d, opcode %d, %s tos %d\n", trace_id++, bytecode, name,
           tos);
}

no_inline void prim_js_print_func(LEPUSContext *ctx, LEPUSValue func_obj) {
  if (LEPUS_VALUE_IS_OBJECT(func_obj)) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(func_obj);
    LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
    if (p->class_id == LEPUS_CLASS_BYTECODE_FUNCTION) {
      const char *func_name = get_func_name(ctx, func_obj);
      if (!func_name || func_name[0] == '\0') {
        PRIM_LOG("primjs call bytecode function: \n");
      } else {
        PRIM_LOG("primjs call bytecode function: %s\n", func_name);
      }
    }
  }
}

LEPUSValue prim_js_op_eval(LEPUSContext *ctx, int scope_idx, LEPUSValue op1) {
  LEPUSValue ret_val;

  ret_val = LEPUS_EvalObject(ctx, LEPUS_UNDEFINED, op1, LEPUS_EVAL_TYPE_DIRECT,
                             scope_idx);
  LEPUS_FreeValue(ctx, op1);
  return ret_val;
}

void prim_close_var_refs(LEPUSContext *ctx, LEPUSStackFrame *sf) {
  struct list_head *el, *el1;
  LEPUSVarRef *var_ref;
  int var_idx;
  LEPUSRuntime *rt = ctx->rt;

  list_for_each_safe(el, el1, &sf->var_ref_list) {
    var_ref = list_entry(el, LEPUSVarRef, link);
    var_idx = var_ref->var_idx;
    if (var_ref->is_arg)
      var_ref->value = LEPUS_DupValueRT(rt, sf->arg_buf[var_idx]);
    else
      var_ref->value = LEPUS_DupValueRT(rt, sf->var_buf[var_idx]);
    var_ref->pvalue = &var_ref->value;
    var_ref->link.prev = NULL; /* the reference is no longer to a
                                  local variable */
  }
}

/* called with the ref_count of 'v' reaches zero. */
void LEPUS_FreeValueRef(LEPUSContext *ctx, LEPUSValue v) {
  LEPUSRuntime *rt = ctx->rt;
  int64_t tag = LEPUS_VALUE_GET_TAG(v);

#ifdef DUMP_FREE
  {
    printf("Freeing ");
    if (tag == LEPUS_TAG_OBJECT) {
      LEPUS_DumpObject(rt, LEPUS_VALUE_GET_OBJ(v));
    } else {
      LEPUS_DumpValueShort(rt, v);
      printf("\n");
    }
  }
#endif

  switch (tag) {
    case LEPUS_TAG_STRING: {
      LEPUSString *p = LEPUS_VALUE_GET_STRING(v);
      if (p->atom_type) {
        LEPUS_FreeAtomStruct(rt, p);
      } else {
#ifdef DUMP_LEAKS
        list_del(&p->link);
#endif

#ifdef ENABLE_LEPUSNG
        // <ByteDance begin>
        LEPUS_FreeStringCache(rt, p);
        // <ByteDance end>
#endif
        lepus_free_rt(rt, p);
      }
    } break;
    case LEPUS_TAG_OBJECT:
      free_object(rt, LEPUS_VALUE_GET_OBJ(v));
      break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      free_function_bytecode(
          rt, static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(v)));
      break;
    case LEPUS_TAG_SHAPE:
    case LEPUS_TAG_ASYNC_FUNCTION:
    case LEPUS_TAG_VAR_REF:
    case LEPUS_TAG_MODULE:
      abort(); /* never freed here */
      break;
#ifdef CONFIG_BIGNUM
    case LEPUS_TAG_BIG_INT:
    case LEPUS_TAG_BIG_FLOAT: {
      LEPUSBigFloat *bf =
          reinterpret_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(v));
      bf_delete(&bf->num);
      lepus_free_rt(rt, bf);
    } break;
#else
#ifdef ENABLE_LEPUSNG
    // <ByteDance begin>
    case LEPUS_TAG_BIG_FLOAT:
    case LEPUS_TAG_BIG_INT: {
      LEPUSBigFloat *bf = static_cast<LEPUSBigFloat *>(LEPUS_VALUE_GET_PTR(v));
      lepus_free_rt(rt, bf);
      break;
    }
    case LEPUS_TAG_LEPUS_REF: {
      if (rt->lepus_callbacks_.free_value) {
        rt->lepus_callbacks_.free_value(rt, v);
      }
      break;
    }
    // <ByteDance end>
#endif
#endif
    case LEPUS_TAG_SYMBOL: {
      LEPUSAtomStruct *p =
          static_cast<LEPUSAtomStruct *>(LEPUS_VALUE_GET_PTR(v));
      LEPUS_FreeAtomStruct(rt, p);
    } break;
    default:
      printf("__JS_FreeValue: unknown tag=%p\n", (void *)tag);
      abort();
  }
}

int prim_js_copy_data_properties(LEPUSContext *ctx, LEPUSValue *sp, int mask) {
  if (LEPUS_CopyDataProperties(ctx, sp[-1 - (mask & 3)],
                               sp[-1 - ((mask >> 2) & 7)],
                               sp[-1 - ((mask >> 5) & 7)], 0)) {
    return -1;
  }
  return 0;
}

int prim_js_with_op(LEPUSContext *ctx, LEPUSValue *sp, LEPUSAtom atom,
                    int is_with, int opcode) {
  LEPUSValue obj, val;
  obj = sp[-1];
  int ret = LEPUS_HasProperty(ctx, obj, atom);
  if (unlikely(ret < 0)) goto exception;
  if (ret) {
    if (is_with) {
      ret = lepus_has_unscopable(ctx, obj, atom);
      if (unlikely(ret < 0)) goto exception;
      if (ret) goto no_with;
    }
    switch (opcode) {
      case OP_with_get_var:
        val = LEPUS_GetProperty(ctx, obj, atom);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        set_value(ctx, &sp[-1], val);
        break;
      case OP_with_put_var:
        ret = LEPUS_SetPropertyInternal(ctx, obj, atom, sp[-2],
                                        LEPUS_PROP_THROW_STRICT);
        LEPUS_FreeValue(ctx, sp[-1]);
        if (unlikely(ret < 0)) goto exception;
        break;
      case OP_with_delete_var:
        ret = LEPUS_DeleteProperty(ctx, obj, atom, 0);
        if (unlikely(ret < 0)) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = LEPUS_NewBool(ctx, ret);
        break;
      case OP_with_make_ref:
        /* produce a pair object/propname on the stack */
        *sp++ = LEPUS_AtomToValue(ctx, atom);
        break;
      case OP_with_get_ref:
        /* produce a pair object/method on the stack */
        val = LEPUS_GetProperty(ctx, obj, atom);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        *sp++ = val;
        break;
      case OP_with_get_ref_undef:
        /* produce a pair undefined/function on the stack */
        val = LEPUS_GetProperty(ctx, obj, atom);
        if (unlikely(LEPUS_IsException(val))) goto exception;
        LEPUS_FreeValue(ctx, sp[-1]);
        sp[-1] = LEPUS_UNDEFINED;
        *sp++ = val;
        break;
    }
    return 1;
  } else {
  no_with:
    /* if not jumping, drop the object argument */
    LEPUS_FreeValue(ctx, sp[-1]);
    return 0;
  }
exception:
  return -1;
}

LEPUSValue prim_js_for_in_start(LEPUSContext *ctx, LEPUSValue op) {
  LEPUSValue res = build_for_in_iterator(ctx, op);
  return res;
}

LEPUSValue *prim_js_iterator_close_return(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue ret_val;
  /* iter_obj next catch_offset ... ret_val ->
      ret_eval iter_obj next catch_offset */
  ret_val = *--sp;
  while (!LEPUS_VALUE_IS_CATCH_OFFSET(sp[-1])) {
    LEPUS_FreeValue(ctx, *--sp);
  }
  // TODO(wangao): Add the sp check.
  // if (unlikely(sp < stack_buf + 3)) {
  //   LEPUS_ThrowInternalError(ctx, "iterator_close_return");
  //   LEPUS_FreeValue(ctx, ret_val);
  //   goto exception;
  // }
  sp[0] = sp[-1];
  sp[-1] = sp[-2];
  sp[-2] = sp[-3];
  sp[-3] = ret_val;
  sp++;
  return sp;
}

int prim_js_async_iterator_close(LEPUSContext *ctx, LEPUSValue *sp) {
  LEPUSValue ret, method;
  int ret_flag;
  method = LEPUS_GetProperty(ctx, sp[-3], LEPUS_ATOM_return);
  if (LEPUS_IsException(method)) goto exception;
  if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
    ret = LEPUS_UNDEFINED;
    ret_flag = TRUE;
  } else {
    ret = LEPUS_CallFree(ctx, method, sp[-3], 0, NULL);
    if (LEPUS_IsException(ret)) goto exception;
    ret_flag = FALSE;
  }
  LEPUS_FreeValue(ctx, sp[-3]);
  LEPUS_FreeValue(ctx, sp[-2]);
  LEPUS_FreeValue(ctx, sp[-1]);
  sp[-3] = ret;
  sp[-2] = LEPUS_NewBool(ctx, ret_flag);
  return 0;
exception:
  return -1;
}

int prim_js_async_iterator_get(LEPUSContext *ctx, LEPUSValue *sp, int flags) {
  LEPUSValue method, ret;
  BOOL ret_flag;
  if (flags == 2) {
    LEPUS_ThrowTypeError(ctx, "iterator does not have a throw method");
    goto exception;
  }
  method = LEPUS_GetProperty(ctx, sp[-4],
                             flags ? LEPUS_ATOM_throw : LEPUS_ATOM_return);
  if (LEPUS_IsException(method)) goto exception;
  if (LEPUS_IsUndefined(method) || LEPUS_IsNull(method)) {
    ret_flag = TRUE;
  } else {
    ret = LEPUS_CallFree(ctx, method, sp[-4], 1, (LEPUSValueConst *)(sp - 1));
    if (LEPUS_IsException(ret)) goto exception;
    LEPUS_FreeValue(ctx, sp[-1]);
    sp[-1] = ret;
    ret_flag = FALSE;
  }
  sp[0] = LEPUS_NewBool(ctx, ret_flag);
  // sp += 1;
  return 0;
exception:
  return -1;
}

LEPUSValue primjs_get_super_ctor(LEPUSContext *ctx, LEPUSValue op) {
  LEPUSValue proto;
  proto = LEPUS_DupValue(ctx, LEPUS_GetPrototype(ctx, op));
  if (LEPUS_IsException(proto)) {
    LEPUS_FreeValue(ctx, op);
    return LEPUS_EXCEPTION;
  }
  if (!LEPUS_IsConstructor(ctx, proto)) {
    LEPUS_FreeValue(ctx, proto);
    LEPUS_FreeValue(ctx, op);
    LEPUS_ThrowTypeError(ctx, "not a constructor");
    return LEPUS_EXCEPTION;
  }
  LEPUS_FreeValue(ctx, op);
  return proto;
}

LEPUSValue prim_js_unary_arith_slow(LEPUSContext *ctx, LEPUSValue op1,
                                    OPCodeEnum op) {
  double d;

  if (unlikely(LEPUS_ToFloat64Free(ctx, &d, op1))) {
    return LEPUS_EXCEPTION;
  }
  switch (op) {
    case OP_inc:
    case OP_inc_loc:
      d++;
      break;
    case OP_dec:
    case OP_dec_loc:
      d--;
      break;
    case OP_plus:
      break;
    case OP_neg:
      d = -d;
      break;
    default: {
      abort();
    }
  }
  return LEPUS_NewFloat64(ctx, d);
}

LEPUSValue prim_js_add_slow(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2) {
  LEPUSValue ret_val;
  if ((LEPUS_VALUE_IS_INT(op1) || LEPUS_VALUE_IS_FLOAT64(op1)) &&
      (LEPUS_VALUE_IS_INT(op2) || LEPUS_VALUE_IS_FLOAT64(op2))) {
    goto add_numbers;
  } else {
    op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    op2 = LEPUS_ToPrimitiveFree(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    if (LEPUS_VALUE_IS_STRING(op1) || LEPUS_VALUE_IS_STRING(op2)) {
      ret_val = LEPUS_ConcatString(ctx, op1, op2);
      if (LEPUS_IsException(ret_val)) goto exception;
    } else {
      double d1, d2;
    add_numbers:
      if (LEPUS_ToFloat64Free(ctx, &d1, op1)) {
        LEPUS_FreeValue(ctx, op2);
        goto exception;
      }
      if (LEPUS_ToFloat64Free(ctx, &d2, op2)) goto exception;
      ret_val = LEPUS_NewFloat64(ctx, d1 + d2);
    }
  }
  return ret_val;
exception:
  return LEPUS_EXCEPTION;
}

no_inline LEPUSValue prim_js_not_slow(LEPUSContext *ctx, LEPUSValue op) {
  int32_t v1;

  if (unlikely(LEPUS_ToInt32Free(ctx, &v1, op))) {
    return LEPUS_EXCEPTION;
  }
  return LEPUS_NewInt32(ctx, ~v1);
}

LEPUSValue prim_js_binary_arith_slow(LEPUSContext *ctx, LEPUSValue op1,
                                     LEPUSValue op2, OPCodeEnum op) {
  double d1, d2, r;
  if (unlikely(LEPUS_ToFloat64Free(ctx, &d1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    return LEPUS_EXCEPTION;
  }
  if (unlikely(LEPUS_ToFloat64Free(ctx, &d2, op2))) {
    return LEPUS_EXCEPTION;
  }
  switch (op) {
    case OP_sub:
      r = d1 - d2;
      break;
    case OP_mul:
      r = d1 * d2;
      break;
    case OP_div:
      r = d1 / d2;
      break;
    case OP_mod:
      r = fmod(d1, d2);
      break;
    case OP_pow:
      r = lepus_pow(d1, d2);
      break;
    default: {
      prim_abort();
    }
  }
  return LEPUS_NewFloat64(ctx, r);
}

double prim_js_fmod_double(double a, double b) {
  double c = fmod(a, b);
  return c;
}

LEPUSValue prim_js_binary_logic_slow(LEPUSContext *ctx, LEPUSValue op1,
                                     LEPUSValue op2, OPCodeEnum op) {
  uint32_t v1, v2, r;
  if (unlikely(LEPUS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(LEPUS_ToInt32Free(ctx, (int32_t *)&v2, op2))) goto exception;
  switch (op) {
    case OP_shl:
      r = v1 << (v2 & 0x1f);
      break;
    case OP_sar:
      r = (int)v1 >> (v2 & 0x1f);
      break;
    case OP_and:
      r = v1 & v2;
      break;
    case OP_or:
      r = v1 | v2;
      break;
    case OP_xor:
      r = v1 ^ v2;
      break;
    default:
      prim_abort();
  }
  return LEPUS_NewInt32(ctx, r);
exception:
  return LEPUS_EXCEPTION;
}

LEPUSValue prim_js_shr_slow(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2) {
  uint32_t v1, v2, r;
  if (unlikely(LEPUS_ToUint32Free(ctx, &v1, op1))) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  if (unlikely(LEPUS_ToUint32Free(ctx, &v2, op2))) goto exception;
  r = v1 >> (v2 & 0x1f);
  return LEPUS_NewUint32(ctx, r);
exception:
  return LEPUS_EXCEPTION;
}

LEPUSValue prim_js_relation_slow(LEPUSContext *ctx, LEPUSValue op1,
                                 LEPUSValue op2, OPCodeEnum op) {
  int res;
  op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NUMBER);
  if (LEPUS_IsException(op1)) {
    LEPUS_FreeValue(ctx, op2);
    goto exception;
  }
  op2 = LEPUS_ToPrimitiveFree(ctx, op2, HINT_NUMBER);
  if (LEPUS_IsException(op2)) {
    LEPUS_FreeValue(ctx, op1);
    goto exception;
  }
  if (LEPUS_VALUE_IS_STRING(op1) && LEPUS_VALUE_IS_STRING(op2)) {
    LEPUSString *p1, *p2;
    p1 = LEPUS_VALUE_GET_STRING(op1);
    p2 = LEPUS_VALUE_GET_STRING(op2);
    res = lepus_string_compare(ctx, p1, p2);
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    switch (op) {
      case OP_lt:
        res = (res < 0);
        break;
      case OP_lte:
        res = (res <= 0);
        break;
      case OP_gt:
        res = (res > 0);
        break;
      default:
      case OP_gte:
        res = (res >= 0);
        break;
    }
  } else {
    double d1, d2;
    if (LEPUS_ToFloat64Free(ctx, &d1, op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    if (LEPUS_ToFloat64Free(ctx, &d2, op2)) goto exception;
    switch (op) {
      case OP_lt:
        res = (d1 < d2); /* if NaN return false */
        break;
      case OP_lte:
        res = (d1 <= d2); /* if NaN return false */
        break;
      case OP_gt:
        res = (d1 > d2); /* if NaN return false */
        break;
      default:
      case OP_gte:
        res = (d1 >= d2); /* if NaN return false */
        break;
    }
  }
  return LEPUS_NewBool(ctx, res);
exception:
  return LEPUS_EXCEPTION;
}

LEPUSValue prim_js_eq_slow(LEPUSContext *ctx, LEPUSValue op1, LEPUSValue op2,
                           int is_neq) {
  uint64_t tag1, tag2;
  BOOL res;
redo:
  tag1 = LEPUS_VALUE_GET_NORM_TAG(op1);
  tag2 = LEPUS_VALUE_GET_NORM_TAG(op2);
  if (tag1 == tag2 || (tag1 == LEPUS_TAG_INT && tag2 == LEPUS_TAG_FLOAT64) ||
      (tag2 == LEPUS_TAG_INT && tag1 == LEPUS_TAG_FLOAT64)) {
    res = lepus_strict_eq(ctx, op1, op2);
  } else if ((tag1 == LEPUS_TAG_NULL && tag2 == LEPUS_TAG_UNDEFINED) ||
             (tag2 == LEPUS_TAG_NULL && tag1 == LEPUS_TAG_UNDEFINED)) {
    res = TRUE;
  } else if ((tag1 == LEPUS_TAG_STRING &&
              (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64)) ||
             (tag2 == LEPUS_TAG_STRING &&
              (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64))) {
    double d1;
    double d2;
    if (LEPUS_ToFloat64Free(ctx, &d1, op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    if (LEPUS_ToFloat64Free(ctx, &d2, op2)) goto exception;
    res = (d1 == d2);
  } else if (tag1 == LEPUS_TAG_BOOL) {
    op1 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(op1));
    goto redo;
  } else if (tag2 == LEPUS_TAG_BOOL) {
    op2 = LEPUS_NewInt32(ctx, LEPUS_VALUE_GET_BOOL(op2));
    goto redo;
  } else if (tag1 == LEPUS_TAG_OBJECT &&
             (tag2 == LEPUS_TAG_INT || tag2 == LEPUS_TAG_FLOAT64 ||
              tag2 == LEPUS_TAG_STRING || tag2 == LEPUS_TAG_SYMBOL)) {
    op1 = LEPUS_ToPrimitiveFree(ctx, op1, HINT_NONE);
    if (LEPUS_IsException(op1)) {
      LEPUS_FreeValue(ctx, op2);
      goto exception;
    }
    goto redo;
  } else if (tag2 == LEPUS_TAG_OBJECT &&
             (tag1 == LEPUS_TAG_INT || tag1 == LEPUS_TAG_FLOAT64 ||
              tag1 == LEPUS_TAG_STRING || tag1 == LEPUS_TAG_SYMBOL)) {
    op2 = LEPUS_ToPrimitiveFree(ctx, op2, HINT_NONE);
    if (LEPUS_IsException(op2)) {
      LEPUS_FreeValue(ctx, op1);
      goto exception;
    }
    goto redo;
  } else {
    res = FALSE;
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
  }
  return LEPUS_NewBool(ctx, res ^ is_neq);
exception:
  return LEPUS_EXCEPTION;
}

LEPUSValue prim_js_strict_eq_slow(LEPUSContext *ctx, LEPUSValue op1,
                                  LEPUSValue op2, BOOL is_neq) {
  BOOL res;
  res = lepus_strict_eq(ctx, op1, op2);
  return LEPUS_NewBool(ctx, res ^ is_neq);
}

LEPUSValue prim_js_operator_instanceof(LEPUSContext *ctx, LEPUSValue op1,
                                       LEPUSValue op2) {
  BOOL ret;
  ret = LEPUS_IsInstanceOf(ctx, op1, op2);
  if (ret < 0) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    return LEPUS_EXCEPTION;
  }
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return LEPUS_NewBool(ctx, ret);
}

LEPUSValue prim_js_operator_in(LEPUSContext *ctx, LEPUSValue op1,
                               LEPUSValue op2) {
  LEPUSAtom atom;
  int ret;

  if (LEPUS_VALUE_IS_NOT_OBJECT(op2)) {
    atom = lepus_value_to_atom(ctx, op1);
    if (unlikely(atom == LEPUS_ATOM_NULL)) {
      LEPUS_ThrowTypeError(ctx, "invalid 'in' operand search for null");
      return LEPUS_EXCEPTION;
    }
    const char *msg = LEPUS_AtomToCString(ctx, atom);
    char buffer[200];
    if (msg) {
      snprintf(buffer, 199, "invalid 'in' operand search for '%s'", msg);
      LEPUS_FreeCString(ctx, msg);
    } else {
      snprintf(buffer, 199, "invalid 'in' operand search for null");
    }
    LEPUS_ThrowTypeError(ctx, "%s", buffer);
    LEPUS_FreeAtom(ctx, atom);
    return LEPUS_EXCEPTION;
  }
  atom = LEPUS_ValueToAtom(ctx, op1);
  if (unlikely(atom == LEPUS_ATOM_NULL)) {
    return LEPUS_EXCEPTION;
  }
  ret = LEPUS_HasProperty(ctx, op2, atom);
  LEPUS_FreeAtom(ctx, atom);
  if (ret < 0) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    return LEPUS_EXCEPTION;
  };
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return LEPUS_NewBool(ctx, ret);
}

LEPUSValue prim_js_operator_delete(LEPUSContext *ctx, LEPUSValue op1,
                                   LEPUSValue op2) {
  LEPUSAtom atom = LEPUS_ValueToAtom(ctx, op2);
  if (unlikely(atom == LEPUS_ATOM_NULL)) {
    return LEPUS_EXCEPTION;
  };
  int ret = LEPUS_DeleteProperty(ctx, op1, atom, LEPUS_PROP_THROW_STRICT);
  LEPUS_FreeAtom(ctx, atom);
  if (unlikely(ret < 0)) {
    LEPUS_FreeValue(ctx, op1);
    LEPUS_FreeValue(ctx, op2);
    return LEPUS_EXCEPTION;
  }
  LEPUS_FreeValue(ctx, op1);
  LEPUS_FreeValue(ctx, op2);
  return LEPUS_NewBool(ctx, ret);
}

#ifdef ENABLE_PRIMJS_IC
int LEPUS_SetPropertyWithIC(LEPUSContext *ctx, LEPUSValueConst this_obj,
                            LEPUSAtom prop, LEPUSValue val, int flags,
                            TypeSetFeedBack *feedback_vec) {
  // 1. directly set with no shape change
  // 2. set with shape change
  PRIM_LOG("primjs put_field %s, this_obj: %p, val: %p\n",
           LEPUS_AtomToCString(ctx, prop), this_obj.ptr, val.ptr);

  TypeSetFeedBack *feedback = NULL;
  if (likely(LEPUS_VALUE_IS_OBJECT(this_obj))) {
    LEPUSObject *p = LEPUS_VALUE_GET_OBJ(this_obj);
    for (int i = 0; i < DEFAULT_FEEDBACK_SIZE; i++) {
      feedback = &feedback_vec[i];
      // if this feedback is empty just return to patch it
      if (!feedback->old_shape) {
        break;
      }
      if (feedback->old_shape == p->shape) {
        // printf("Set Hit\n");
        // set length IC
        // length prop must be prop[0]
        if (unlikely(feedback->length)) {
          set_array_length(ctx, p, &p->prop[0], val, flags);
          return TRUE;
        }
        // if alloc is true, we need to realloc prop first
        if (unlikely(feedback->new_shape->prop_size !=
                     feedback->old_shape->prop_size)) {
          LEPUSProperty *new_prop;
          int new_size = feedback->new_shape->prop_size;
          new_prop = (LEPUSProperty *)lepus_realloc(
              ctx, p->prop, sizeof(new_prop[0]) * new_size);
          if (unlikely(!new_prop)) return -1;
          p->prop = new_prop;
        }
        LEPUSProperty *pr = &p->prop[feedback->offset];
        // if new_shape != old_shape, must be add_prop
        if (feedback->new_shape != feedback->old_shape) {
          pr->u.value = val;
          lepus_free_shape(ctx->rt, p->shape);
          p->shape = lepus_dup_shape(feedback->new_shape);
        } else {
          // new_shape == old_shape, must be directly set
          set_value(ctx, &pr->u.value, val);
        }
        return TRUE;
      }
    }
  }
  // memset(feedback, 0, sizeof(TypeSetFeedBack));
  return LEPUS_SetPropertyInternalImpl(ctx, this_obj, prop, val, flags,
                                       feedback);
}
#endif
#endif

#ifdef ENABLE_PRIMJS_PROFILER
extern void isolate_init(LEPUSContext *ctx);
extern void isolate_log_code(LEPUSFunctionBytecode *b,
                             const char *class_name = nullptr);
#endif

#if defined(ENABLE_PRIMJS_PROFILER) && !defined(ENABLE_PRIMJS_SNAPSHOT)
void PrimInit(LEPUSContext *ctx) { isolate_init(ctx); }
#endif

#ifdef ENABLE_PRIMJS_RUNTIME
extern void QuickJsStubRoutines_init1(FILE *fp = nullptr);
extern void QuickJsStubRoutines_init2(FILE *fp = nullptr);
void QuickJsInterpreter_init_stub();
void QuickJsInterpreter_init_code(FILE *fp = nullptr);
void codeCache_init();
void os_init();
void ostream_init();
extern void QuickJsRegExpJit_init();
#endif

#ifdef ENABLE_PRIMJS_SNAPSHOT
extern "C" void _call_stub_entry();

extern "C" void _dispatch_table();

extern "C" void _dispatch_table_offset();

typedef unsigned char u_char;
typedef u_char *address;

address _table[NUM_OF_TOS_STATES][OP_COUNT];

#define CAST_TO_FN_PTR(func_type, value) (reinterpret_cast<func_type>(value))

QuickJsCallStub entry;
uint8_t *prim_normal_entry;

#ifndef ENABLE_PRIMJS_RUNTIME
static void initialize_dispatchTable(LEPUSContext *ctx) {
  for (int i = 0; i < NUM_OF_TOS_STATES; i++) {
    for (int j = 1; j < OP_COUNT; j++) {
      int offset = i * (OP_COUNT - 1) + j - 1;
      int *table_entry = (int *)&_dispatch_table_offset + offset;
      int table_offset = *table_entry;
      _table[i][j] = (address)&_dispatch_table + table_offset;
    }
  }
  ctx->dispatch_table = _table;
}

static QuickJsCallStub call_stub() {
  return CAST_TO_FN_PTR(QuickJsCallStub, &_call_stub_entry);
}
#endif

#ifdef ENABLE_PRIMJS_RUNTIME
#include "src/BaselineJit.hpp"
#endif

void PrimInit(LEPUSContext *ctx) {
#ifdef ENABLE_PRIMJS_PROFILER
  isolate_init(ctx);
#endif
#ifdef ENABLE_PRIMJS_RUNTIME
  PRIM_LOG("Use baselinejit!\n");
  ostream_init();
  os_init();
  codeCache_init();
  QuickJsStubRoutines_init1();
  QuickJsInterpreter_init_stub();
  QuickJsInterpreter_init_code();
  QuickJsStubRoutines_init2();

#ifdef ENABLE_PRIMJS_BASELINEJIT
  QuickJsBaselineJit_init();
#endif
#else
  initialize_dispatchTable(ctx);
#endif

#ifdef ENABLE_PRIMJS_SNAPSHOT
#ifndef ENABLE_PRIMJS_RUNTIME
  entry = call_stub();
#else
  entry = QuickJsStubRoutines::call_stub();
  prim_normal_entry = QuickJsStubRoutines::normal_entry();
#endif
#endif
}

#endif

// <primjs end>

#pragma clang diagnostic pop

#ifdef ENABLE_HEAPPROFILER
#undef malloc
#undef free
#undef realloc

#include "quickjs/heapprofiler/include/quickjs-ext.h"
using namespace quickjs::heapprofiler;

typedef void LEPUS_HeapProfilerMarkFunc(LEPUSRuntime *, LEPUSValueConst,
                                        LEPUSObject *input);

static void LEPUS_HeapProfiler_markvalue(LEPUSRuntime *rt, LEPUSValueConst val,
                                         LEPUS_HeapProfilerMarkFunc *mark_func,
                                         LEPUSObject *input) {
  if (LEPUS_VALUE_HAS_REF_COUNT(val) && has_children(val)) {
    mark_func(rt, val, input);
  }
}

static void LEPUS_HeapProfiler_mark_children(
    LEPUSRuntime *rt, LEPUSValueConst val,
    LEPUS_HeapProfilerMarkFunc *mark_func, LEPUSObject *input) {
  switch (LEPUS_VALUE_GET_TAG(val)) {
    case LEPUS_TAG_OBJECT: {
      LEPUSObject *p = LEPUS_VALUE_GET_OBJ(val);
      LEPUSShapeProperty *prs;
      LEPUSShape *sh;
      int i;
      sh = p->shape;
      mark_func(rt, LEPUS_MKPTR(LEPUS_TAG_SHAPE, sh), input);
      /* mark all the fields */
      prs = get_shape_prop(sh);
      for (i = 0; i < sh->prop_count; i++) {
        LEPUSProperty *pr = &p->prop[i];
        if (prs->atom != LEPUS_ATOM_NULL) {
          if (prs->flags & LEPUS_PROP_TMASK) {
            if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
              if (pr->u.getset.getter)
                mark_func(rt,
                          LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter),
                          input);
              if (pr->u.getset.setter)
                mark_func(rt,
                          LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter),
                          input);
            } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
              LEPUS_HeapProfiler_markvalue(
                  rt, LEPUS_MKPTR(LEPUS_TAG_VAR_REF, pr->u.var_ref), mark_func,
                  input);
            } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
              /* nothing to do */
            }
          } else {
            LEPUS_HeapProfiler_markvalue(rt, pr->u.value, mark_func, input);
          }
        }
        prs++;
      }

      switch (p->class_id) {
        case LEPUS_CLASS_ARRAY:
        case LEPUS_CLASS_ARGUMENTS: {
          for (uint32_t i = 0; i < p->u.array.count; ++i) {
            LEPUS_HeapProfiler_markvalue(rt, p->u.array.u.values[i], mark_func,
                                         input);
          }
        } break;
        case LEPUS_CLASS_NUMBER:
        case LEPUS_CLASS_STRING:
        case LEPUS_CLASS_BOOLEAN:
        case LEPUS_CLASS_SYMBOL:
        case LEPUS_CLASS_DATE: {
          LEPUS_HeapProfiler_markvalue(rt, p->u.object_data, mark_func, input);
        } break;
        case LEPUS_CLASS_BYTECODE_FUNCTION:
        case LEPUS_CLASS_GENERATOR_FUNCTION: {
          LEPUSVarRef **varrefs = p->u.func.var_refs;
          LEPUSFunctionBytecode *b = p->u.func.function_bytecode;

          if (p->u.func.home_object) {
            LEPUS_HeapProfiler_markvalue(
                rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p->u.func.home_object),
                mark_func, input);
          }

          if (b) {
            if (varrefs) {
              for (uint32_t i = 0; i < b->closure_var_count; ++i) {
                LEPUSVarRef *varref = varrefs[i];
                if (varref) {
                  LEPUS_HeapProfiler_markvalue(
                      rt, LEPUS_MKPTR(LEPUS_TAG_VAR_REF, varref), mark_func,
                      input);
                }
              }
            }
            LEPUS_HeapProfiler_markvalue(
                rt, LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b), mark_func,
                input);
          }
        } break;
        case LEPUS_CLASS_BOUND_FUNCTION: {
          LEPUSBoundFunction *bf = p->u.bound_function;
          LEPUS_HeapProfiler_markvalue(rt, bf->func_obj, mark_func, input);
          LEPUS_HeapProfiler_markvalue(rt, bf->this_val, mark_func, input);

          for (uint32_t i = 0; i < bf->argc; ++i) {
            LEPUS_HeapProfiler_markvalue(rt, bf->argv[i], mark_func, input);
          }
        } break;
        case LEPUS_CLASS_C_FUNCTION_DATA: {
          LEPUSCFunctionDataRecord *s = static_cast<LEPUSCFunctionDataRecord *>(
              LEPUS_GetOpaque(val, LEPUS_CLASS_C_FUNCTION_DATA));
          if (s) {
            for (uint32_t i = 0; i < s->data_len; i++) {
              LEPUS_HeapProfiler_markvalue(rt, s->data[i], mark_func, input);
            }
          }
        } break;
        case LEPUS_CLASS_FOR_IN_ITERATOR: {
          LEPUSForInIterator *it = p->u.for_in_iterator;
          LEPUS_HeapProfiler_markvalue(rt, it->obj, mark_func, input);
        } break;
        case LEPUS_CLASS_GENERATOR:    /* u.generator_data */
        case LEPUS_CLASS_UINT8C_ARRAY: /* u.typed_array / u.array */
        case LEPUS_CLASS_INT8_ARRAY:   /* u.typed_array / u.array */
        case LEPUS_CLASS_UINT8_ARRAY:  /* u.typed_array / u.array */
        case LEPUS_CLASS_INT16_ARRAY:  /* u.typed_array / u.array */
        case LEPUS_CLASS_UINT16_ARRAY: /* u.typed_array / u.array */
        case LEPUS_CLASS_INT32_ARRAY:  /* u.typed_array / u.array */
        case LEPUS_CLASS_UINT32_ARRAY: /* u.typed_array / u.array */
#ifdef CONFIG_BIGNUM
        case LEPUS_CLASS_BIG_INT64_ARRAY:  /* u.typed_array / u.array */
        case LEPUS_CLASS_BIG_UINT64_ARRAY: /* u.typed_array / u.array */
#endif
        case LEPUS_CLASS_FLOAT32_ARRAY: /* u.typed_array / u.array */
        case LEPUS_CLASS_FLOAT64_ARRAY: /* u.typed_array / u.array */
        case LEPUS_CLASS_DATAVIEW:      /* u.typed_array */
#ifdef CONFIG_BIGNUM
        case LEPUS_CLASS_FLOAT_ENV: /* u.float_env */
#endif
        case LEPUS_CLASS_MAP:                      /* u.map_state */
        case LEPUS_CLASS_SET:                      /* u.map_state */
        case LEPUS_CLASS_WEAKMAP:                  /* u.map_state */
        case LEPUS_CLASS_WEAKSET:                  /* u.map_state */
        case LEPUS_CLASS_MAP_ITERATOR:             /* u.map_iterator_data */
        case LEPUS_CLASS_SET_ITERATOR:             /* u.map_iterator_data */
        case LEPUS_CLASS_ARRAY_ITERATOR:           /* u.array_iterator_data */
        case LEPUS_CLASS_STRING_ITERATOR:          /* u.array_iterator_data */
        case LEPUS_CLASS_PROXY:                    /* u.proxy_data */
        case LEPUS_CLASS_PROMISE:                  /* u.promise_data */
        case LEPUS_CLASS_PROMISE_RESOLVE_FUNCTION: /* u.promise_function_data */
        case LEPUS_CLASS_PROMISE_REJECT_FUNCTION:  /* u.promise_function_data */
        case LEPUS_CLASS_ASYNC_FUNCTION_RESOLVE:   /* u.async_function_data */
        case LEPUS_CLASS_ASYNC_FUNCTION_REJECT:    /* u.async_function_data */
        case LEPUS_CLASS_ASYNC_FROM_SYNC_ITERATOR: /* u.async_from_sync_iterator_data
                                                    */
        case LEPUS_CLASS_ASYNC_GENERATOR:          /* u.async_generator_data */
                                                   /* TODO */
        default: {
          // TOOD: mark these object's children
        }
      }
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE:
      /* the template objects can be part of a cycle */
      {
        LEPUSFunctionBytecode *b =
            static_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(val));
        for (int32_t i = 0; i < b->cpool_count; ++i) {
          LEPUS_HeapProfiler_markvalue(rt, b->cpool[i], mark_func, input);
        }
      }
      break;
    case LEPUS_TAG_VAR_REF: {
      LEPUSVarRef *var_ref =
          static_cast<LEPUSVarRef *>(LEPUS_VALUE_GET_PTR(val));
      /* the refcount of stack values is not incremented, hence
         the test */
      if (var_ref->link.prev == nullptr) {
        LEPUS_HeapProfiler_markvalue(rt, *var_ref->pvalue, mark_func, input);
      }
    } break;
    case LEPUS_TAG_ASYNC_FUNCTION: {
    } break;
    case LEPUS_TAG_SHAPE: {
      LEPUSShape *sh = static_cast<LEPUSShape *>(LEPUS_VALUE_GET_PTR(val));
      if (sh->proto != nullptr) {
        mark_func(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, sh->proto), input);
      }
    } break;
    default:
      /* no children */
      break;
  }
}

static void find_obj_children(LEPUSRuntime *, LEPUSValue, LEPUSObject *);
static void set_child_flag(LEPUSRuntime *rt, LEPUSValueConst obj,
                           LEPUSObject *input) {
  if (LEPUS_IsLepusRef(obj)) {
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (LEPUS_IsUndefined(lepus_val)) return;
    obj = lepus_val;
  }

  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (p == input) {
    // has circle
    p->gc_header.mark = 6;
  } else {
    if (p->gc_header.mark == 5) return;
    p->gc_header.mark = 5;
    find_obj_children(rt, obj, input);
  }
}

static void find_obj_children(LEPUSRuntime *rt, LEPUSValue obj,
                              LEPUSObject *input) {
  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  LEPUS_HeapProfiler_mark_children(rt, obj, set_child_flag, input);
}

static void set_flag_zero(LEPUSRuntime *rt, LEPUSValue obj);
static void set_childflag_zero(LEPUSRuntime *rt, LEPUSValue obj) {
  if (LEPUS_IsLepusRef(obj)) {
    LEPUSValue lepus_val =
        reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(obj))->lepus_val;
    if (LEPUS_IsUndefined(lepus_val)) return;
    obj = lepus_val;
  }

  LEPUSObject *p = reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(obj));
  if (p->gc_header.mark == 0) return;
  p->gc_header.mark = 0;
  set_flag_zero(rt, obj);
}

static void set_flag_zero(LEPUSRuntime *rt, LEPUSValue obj) {
  mark_children(rt, obj, set_childflag_zero);
}

QJS_STATIC void LEPUS_FindRootObject(
    LEPUSRuntime *rt, std::vector<LEPUSObject *> &virtual_roots) {
  struct list_head *el = nullptr, *el1 = nullptr;

  list_for_each_safe(el, el1, &rt->obj_list) {
    LEPUSObject *p = list_entry(el, LEPUSObject, link);
    if (!p->gc_header.mark) {
      p->gc_header.mark = 4;
      find_obj_children(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p), p);
    }
  }

  list_for_each_safe(el, el1, &rt->obj_list) {
    LEPUSObject *p = list_entry(el, LEPUSObject, link);
    if (p->gc_header.mark == 6 || p->gc_header.mark == 4) {
      virtual_roots.push_back(p);
    }
  }

  list_for_each_safe(el, el1, &rt->obj_list) {
    LEPUSObject *p = list_entry(el, LEPUSObject, link);
    p->gc_header.mark = 0;
    set_flag_zero(rt, LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  }
  return;
}

EntryInfo GetNameAndComputeSize(LEPUSContext *ctx, const LEPUSValue &value) {
  LEPUSRuntime *rt = ctx->rt;
  EntryInfo result;
  switch (LEPUS_VALUE_GET_NORM_TAG(value)) {
    case LEPUS_TAG_LEPUS_REF: {
      result.size_ = sizeof(LEPUSLepusRef);
      result.name_ = "lepusref";
      if (LEPUS_LepusRefIsArray(ctx->rt, value)) {
        result.type_ = HeapEntry::kArray;
      } else {
        result.type_ = HeapEntry::kObject;
      }
    } break;
    case LEPUS_TAG_STRING:
    case LEPUS_TAG_SYMBOL: {
      result.type_ = (LEPUS_VALUE_IS_STRING(value)) ? HeapEntry::kString
                                                    : HeapEntry::kSymbol;
      LEPUSString *p =
          reinterpret_cast<LEPUSString *>(LEPUS_VALUE_GET_PTR(value));
      result.size_ =
          p ? (sizeof(*p) + (p->len << p->is_wide_char) + 1 - p->is_wide_char)
            : 0;

      if (p->len == 0) {
        result.name_ = "";
        break;
      }
      const char *namestr = LEPUS_ToCString(ctx, value);
      result.name_ = namestr;
      LEPUS_FreeCString(ctx, namestr);
    } break;
    case LEPUS_TAG_SHAPE: {
      result.name_ = "Shape";
      result.type_ = HeapEntry::kObjectShape;
      LEPUSShape *shape =
          reinterpret_cast<LEPUSShape *>(LEPUS_VALUE_GET_PTR(value));
      result.size_ =
          shape ? get_shape_size((shape->prop_hash_mask + 1), shape->prop_size)
                : 0;
    } break;
    case LEPUS_TAG_VAR_REF: {
      result.name_ = "VarVef";
      result.type_ = HeapEntry::Type::kVarRef;
      LEPUSVarRef *varref =
          reinterpret_cast<LEPUSVarRef *>(LEPUS_VALUE_GET_PTR(value));
      result.size_ = varref ? (sizeof(*varref)) : 0;
      if (!LEPUS_IsUndefined(varref->value)) {
        result.size_ += sizeof(*varref->pvalue);
      }
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE: {
      result.name_ = "FunctionBytecode";
      result.type_ = HeapEntry::Type::kFunctionByteCode;
      LEPUSFunctionBytecode *b =
          reinterpret_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(value));
      if (!b) {
        result.size_ = 0;
        break;
      }
      size_t func_size = sizeof(*b);
      if (b->vardefs) {
        func_size += (b->arg_count + b->var_count) * sizeof(*b->vardefs);
      }

      if (b->closure_var) {
        func_size += b->closure_var_count * sizeof(*b->closure_var);
      }
      if (!b->read_only_bytecode && b->byte_code_buf) {
        func_size += b->byte_code_len;
      }

      if (b->cpool) {
        func_size += (sizeof(*b->cpool) * b->cpool_count);
      }

      if (b->has_debug) {
        if (b->debug.source) {
          func_size += b->debug.source_len + 1;
        }
        if (b->debug.pc2line_buf) {
          func_size += b->debug.pc2line_len;
        }
      }
      result.size_ = func_size;
    } break;
    case LEPUS_TAG_OBJECT: {
      if (LEPUS_IsArray(ctx, value)) {
        result.type_ = HeapEntry::Type::kArray;
      } else {
        result.type_ = HeapEntry::Type::kObject;
      }
      LEPUSObject *p =
          reinterpret_cast<LEPUSObject *>(LEPUS_VALUE_GET_PTR(value));
      if (!p) {
        result.name_ = "<null>";
        result.size_ = 0;
        break;
      }

      size_t object_size = sizeof(*p);
      object_size += sizeof(*p->prop) * p->shape->prop_count;

      if (p->class_id == LEPUS_CLASS_ARRAY ||
          p->class_id == LEPUS_CLASS_ARGUMENTS) {
        object_size += p->u.array.count * sizeof(*p->u.array.u.values);
      }
      result.size_ = object_size;

      LEPUSValue constructor =
          LEPUS_GetProperty(ctx, value, LEPUS_ATOM_constructor);
      if (!(LEPUS_IsUndefined(constructor) || LEPUS_IsNull(constructor) ||
            LEPUS_IsException(constructor))) {
        LEPUSValue constructor_name =
            LEPUS_GetProperty(ctx, constructor, LEPUS_ATOM_name);
        if (!(LEPUS_IsUndefined(constructor_name) ||
              LEPUS_IsNull(constructor_name) ||
              LEPUS_IsException(constructor_name))) {
          const char *namestr = LEPUS_ToCString(ctx, constructor_name);
          if (namestr) {
            result.name_ = namestr;
            LEPUS_FreeCString(ctx, namestr);
          }
          LEPUS_FreeValue(ctx, constructor_name);
        }
        LEPUS_FreeValue(ctx, constructor);
        break;
      }
      LEPUSValue class_name = lepus_object___getClass(
          ctx, LEPUS_UNDEFINED, 1, const_cast<LEPUSValue *>(&value));
      const char *class_namestr = LEPUS_ToCString(ctx, class_name);
      if (class_namestr) {
        result.name_ = class_namestr;
        LEPUS_FreeCString(ctx, class_namestr);
      } else {
        result.name_ = "Object";
      }
      LEPUS_FreeValue(ctx, class_name);
    } break;
    case LEPUS_TAG_LEPUS_CPOINTER: {
      result.name_ = "Cpointer";
      result.type_ = HeapEntry::Type::kCpointer;
      result.size_ = 0;
    } break;
    default: {
      if (LEPUS_IsNumber(value)) {
        result.name_ = "HeapNumber";
        result.type_ = HeapEntry::Type::kHeapNumber;
      } else {
        result.name_ = "";
        result.type_ = HeapEntry::kHidden;
      }
      result.size_ = 0;  // or 1
    }
  }
  return result;
}

void QjsHeapExplorer::ExtractLepusValueReference(const LEPUSValue &value) {
  if (!NeedExtracted(value)) return;
  HeapEntry *entry = GetEntry(value);
  if (entry == nullptr) return;
  InsertExtractedObj(value);

  switch (LEPUS_VALUE_GET_NORM_TAG(value)) {
    case LEPUS_TAG_LEPUS_REF: {
      LEPUSValue lepus_val =
          reinterpret_cast<LEPUSLepusRef *>(LEPUS_VALUE_GET_PTR(value))
              ->lepus_val;
      if (LEPUS_IsUndefined(lepus_val)) break;
      SetInternalReference(entry, "[lepus_value]", lepus_val);
      ExtractLepusValueReference(lepus_val);
    } break;
    case LEPUS_TAG_SHAPE: {
      LEPUSShape *shape =
          reinterpret_cast<LEPUSShape *>(LEPUS_VALUE_GET_PTR(value));
      if (!shape->proto) return;
      SetInternalReference(entry, "[proto]",
                           LEPUS_MKPTR(LEPUS_TAG_OBJECT, shape->proto));
    } break;
    case LEPUS_TAG_VAR_REF: {
      LEPUSVarRef *varref =
          reinterpret_cast<LEPUSVarRef *>(LEPUS_VALUE_GET_PTR(value));
      if (varref == nullptr || LEPUS_IsUndefined(varref->value)) break;
      LEPUSValue ref_value = varref->value;
      SetInternalReference(entry, "[VarRef->value]", ref_value);
      ExtractLepusValueReference(ref_value);
    } break;
    case LEPUS_TAG_FUNCTION_BYTECODE: {
      LEPUSFunctionBytecode *b =
          reinterpret_cast<LEPUSFunctionBytecode *>(LEPUS_VALUE_GET_PTR(value));
      if (b) {
        for (uint32_t i = 0; i < b->cpool_count; ++i) {
          LEPUSValue poolvalue = b->cpool[i];
          if (LEPUS_IsUndefined(poolvalue)) continue;
          SetInternalReference(entry, "[pool [" + std::to_string(i) + "] ]",
                               poolvalue);
          ExtractLepusValueReference(poolvalue);
        }
      }
    } break;
    default: {
      break;
    }
  }
  return;
}

void QjsHeapExplorer::SetAtomStringRootReference() {
  assert(context_ && context_->rt);
  LEPUSRuntime *rt = context_->rt;

  for (uint32_t i = 1; i < rt->atom_size; ++i) {
    LEPUSAtomStruct *p = rt->atom_array[i];
    if (!atom_is_free(p)) {
      SetSubRootReference(Root::kLepusString, LEPUS_MKPTR(LEPUS_TAG_STRING, p));
    }
  }
}

void QjsHeapExplorer::SetObjectRootReference() {
  std::vector<LEPUSObject *> virtual_root_obj_;
  LEPUS_FindRootObject(context_->rt, virtual_root_obj_);
  for (auto &itr : virtual_root_obj_) {
    SetSubRootReference(Root::kLepusObject, LEPUS_MKPTR(LEPUS_TAG_OBJECT, itr));
  }
}

void QjsHeapExplorer::ExtractObjectReference(LEPUSObject *p) {
  HeapEntry *entry = GetEntry(LEPUS_MKPTR(LEPUS_TAG_OBJECT, p));
  if (entry == nullptr) return;

  // set shape and shape->proto
  if (p->shape) {
    SetInternalReference(entry, "[shape]",
                         LEPUS_MKPTR(LEPUS_TAG_SHAPE, p->shape));
    ExtractLepusValueReference(LEPUS_MKPTR(LEPUS_TAG_SHAPE, p->shape));
  }

  // set properties references
  LEPUSShapeProperty *prs = p->shape->prop;
  for (uint32_t i = 0; i < p->shape->prop_count; ++i, ++prs) {
    LEPUSProperty *pr = p->prop + i;
    if (prs->atom != LEPUS_ATOM_NULL) {
      if (prs->flags & LEPUS_PROP_TMASK) {
        if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_GETSET) {
          if (pr->u.getset.getter) {
            SetPropertyReference(
                entry, prs->atom,
                LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.getter));
          }
          if (pr->u.getset.setter) {
            SetPropertyReference(
                entry, prs->atom,
                LEPUS_MKPTR(LEPUS_TAG_OBJECT, pr->u.getset.setter));
          }
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_VARREF) {
          SetPropertyReference(entry, prs->atom,
                               LEPUS_MKPTR(LEPUS_TAG_VAR_REF, pr->u.var_ref));
          ExtractLepusValueReference(
              LEPUS_MKPTR(LEPUS_TAG_VAR_REF, pr->u.var_ref));
        } else if ((prs->flags & LEPUS_PROP_TMASK) == LEPUS_PROP_AUTOINIT) {
          // no object need to be extract
          LEPUSValue init_value =
              LEPUS_MKPTR(LEPUS_TAG_LEPUS_CPOINTER,
                          reinterpret_cast<void *>(
                              pr->u.init.opaque));  // just for visualization
          SetPropertyReference(entry, prs->atom, init_value);
        }
      } else {
        SetPropertyReference(entry, prs->atom, pr->u.value);
        ExtractLepusValueReference(pr->u.value);
      }
    }
  }

  switch (p->class_id) {
    case LEPUS_CLASS_ARRAY:
    case LEPUS_CLASS_ARGUMENTS: {
      for (uint32_t i = 0; i < p->u.array.count; ++i) {
        SetElementReference(entry, i, p->u.array.u.values[i]);
        ExtractLepusValueReference(p->u.array.u.values[i]);
      }
    } break;
    case LEPUS_CLASS_NUMBER:
    case LEPUS_CLASS_STRING:
    case LEPUS_CLASS_BOOLEAN:
    case LEPUS_CLASS_SYMBOL:
    case LEPUS_CLASS_DATE: {
      SetPropertyReference(entry, "[value]", p->u.object_data);
      ExtractLepusValueReference(p->u.object_data);
    } break;
    case LEPUS_CLASS_BYTECODE_FUNCTION:
    case LEPUS_CLASS_GENERATOR_FUNCTION: {
      if (p->u.func.home_object) {
        SetInternalReference(
            entry, "[home object]",
            LEPUS_MKPTR(LEPUS_TAG_OBJECT, p->u.func.home_object));
      }
      LEPUSFunctionBytecode *b = p->u.func.function_bytecode;
      LEPUSVarRef **varrefs = p->u.func.var_refs;

      if (b) {
        if (varrefs) {
          for (uint32_t i = 0; i < b->closure_var_count; ++i) {
            LEPUSVarRef *varref = varrefs[i];
            if (varref) {
              SetInternalReference(entry, "varref [" + std::to_string(i) + "]",
                                   LEPUS_MKPTR(LEPUS_TAG_VAR_REF, varref));
              ExtractLepusValueReference(
                  LEPUS_MKPTR(LEPUS_TAG_VAR_REF, varref));
            }
          }
        }
        SetInternalReference(entry, "[function_bytecode]",
                             LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b));
        ExtractLepusValueReference(LEPUS_MKPTR(LEPUS_TAG_FUNCTION_BYTECODE, b));
      }
    } break;
    default: {
      // todo
    }
  }
  return;
}

void QjsHeapExplorer::IterateAndExtractReference(
    HeapSnapshotGenerator *generator) {
  generator_ = generator;
  assert(context_ && context_->rt);
  // Create Reference to the synthetic roots

  LEPUS_RunGC(context_->rt);
  SetRootToSubRootsReference();

  // LEPUSString
  SetAtomStringRootReference();

  // root LEPUSObject
  SetObjectRootReference();

  // GlobalObject Root Reference to global object
  SetGlobalRootReference();

  struct list_head *el, *el1;
  LEPUSRuntime *rt = context_->rt;

  list_for_each_safe(el, el1, &rt->obj_list) {
    LEPUSObject *p = list_entry(el, LEPUSObject, link);
    ExtractObjectReference(p);
  }
}

#endif
