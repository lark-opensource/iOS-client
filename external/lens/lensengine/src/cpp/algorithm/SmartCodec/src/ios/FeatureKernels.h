
#import <Foundation/Foundation.h>
NSString  *vf_metal_src =@
"#include <metal_stdlib>\r"
"#include <metal_atomic>\r"
"#include <metal_simdgroup>\r"
"using namespace metal;\r"
"#define N 1\r"
"#define TONEROW 256\r"
"#define TONECOL 256\r"
"#define MAX_SIMDGROUP_NUM_PER_THREADGROUP 64\r"
"#define GROUP_OVERFLOW (INT_MAX>>14)\r"
"#define GROUP_OVERFLOW_TI  (1<<8)\r"
"#define BLOCKSIZE 16\r"
"#define SKIP_STEPX 4\r"
"#define SKIP_STEPY 4\r"
"#define SKIP_STEPX_SI 2\r"
"#define SKIP_STEPY_SI 2\r"
"#define NOT_SKIP(x,y) ((x%SKIP_STEPX) == 0 && (y%SKIP_STEPY) == 0)\r"
"// #define NOT_SKIP_SI(x,y) ((x%SKIP_STEPX_SI) == 0 && (y%SKIP_STEPY_SI) == 0)\r"
"#define NOT_SKIP_SI(x,y) ((((214013*(x+y)+2531011) >>16)&0x000F) == 0 )\r"
"constexpr sampler spl(coord::pixel,\r"
"address::clamp_to_zero,\r"
"filter::nearest);\r"
"kernel void GLCM_MATRIX(texture2d<float, access::read> image [[texture(0)]],\r"
"constant int *mstep_x [[buffer(0)]],\r"
"constant int *mstep_y [[buffer(1)]],\r"
"device atomic_uint *tonematrix [[buffer(2)]],\r"
"uint2 gid [[thread_position_in_grid]],\r"
"ushort lid [[thread_index_in_threadgroup]])\r"
"{\r"
"int x = gid.x;\r"
"int y = gid.y;\r"
"if(NOT_SKIP(x,y))\r"
"{\r"
"int this_y = image.read(gid).r*255;\r"
"for (int g=0;g<N;g++)\r"
"{\r"
"uint p_x = gid.x + mstep_x[g];\r"
"uint p_y = gid.y + mstep_y[g];\r"
"if (p_x < 0 || p_x >= image.get_width() || p_y < 0 || p_y >= image.get_height()) continue;\r"
"uint2 idx(p_x,p_y);\r"
"int pair_y = image.read(idx).r*255;\r"
"int t_min = min(this_y,pair_y);\r"
"int t_max = max(this_y,pair_y);\r"
"atomic_fetch_add_explicit(tonematrix + g*TONEROW*TONECOL + t_min*256 + t_max, 2 - !!(this_y - pair_y), memory_order_relaxed);\r"
"}\r"
"}\r"
"}\r"
"#define GLCM_GROUP 20\r"
"#define MAX_SIMD_NUM 64\r"
"kernel void SceneCut(texture2d<float, access::read> image [[texture(0)]],\r"
"constant int *mstep_x [[buffer(0)]],\r"
"constant int *mstep_y [[buffer(1)]],\r"
"device atomic_uint *tonematrix [[buffer(2)]],\r"
"uint2 gid [[thread_position_in_grid]],\r"
"ushort lid [[thread_index_in_threadgroup]])\r"
"{}\r"
"#define EQUAL(x,y) (int)!!((x)-(y))\r"
"#define FETCH(x,y) (int)(image.read(uint2(x,y)).r*255)\r"
"kernel void TransForm(texture2d<float, access::sample> srcimage [[texture(0)]],\r"
"texture2d<float, access::write> dstimage [[texture(1)]],\r"
"constant int &need_rgb_to_yuv [[buffer(0)]],\r"
"constant int &need_change_range [[buffer(1)]],\r"
"device float *resdata [[buffer(2)]],\r"
"uint2 gid [[thread_position_in_grid]],\r"
"ushort lid [[thread_index_in_threadgroup]],\r"
"uint2 threads_per_threadgroup  [[threads_per_threadgroup]])\r"
"{\r"
"float width_frac  = (float)(srcimage.get_width()  -1)/ (dstimage.get_width() - 1);\r"
"float height_frac = (float)(srcimage.get_height() -1)/ (dstimage.get_height() -1);\r"
"float sample_x = width_frac * gid.x;\r"
"float sample_y = height_frac* gid.y;\r"
"float2 idx(sample_x,sample_y);\r"
"float dst_y_value;\r"
"if (need_rgb_to_yuv){\r"
"float3 rgb2y   = float3(0.2126f, 0.7152f, 0.0722f);\r"
"float4 inColor = srcimage.sample(spl,idx);\r"
"dst_y_value    = dot(inColor.rgb, rgb2y);\r"
"dst_y_value    = dst_y_value*219.0/255.0 + 16.0 / 255.0;\r"
"}\r"
"else{\r"
"dst_y_value = srcimage.sample(spl,idx).r;\r"
"}\r"
"float dst_y_value_final;\r"
"if (need_change_range)\r"
"dst_y_value_final = (dst_y_value - 16.0 / 255.0)*255.0/219.0;\r"
"else\r"
"dst_y_value_final = dst_y_value;\r"
"float4 yuv(dst_y_value_final, 1.0f, 1.0f, 1.0f);\r"
"dstimage.write(yuv, gid);\r"
"}\r"
"kernel void GLCM_FEATURE_atom(texture2d<uint, access::read> image [[texture(0)]],\r"
"device atomic_uint *feat_group [[buffer(0)]],\r"
"uint2 gid [[thread_position_in_grid]],\r"
"ushort lid [[thread_index_in_threadgroup]],\r"
"uint2 threads_per_threadgroup  [[threads_per_threadgroup]],\r"
"uint simd_size [[threads_per_simdgroup]],\r"
"uint simd_lane_id [[thread_index_in_simdgroup]],\r"
"uint simd_group_id [[simdgroup_index_in_threadgroup]])\r"
"{\r"
"int ind_x  = gid.x;\r"
"int ind_y  = gid.y %256;\r"
"uint group = gid.y / TONECOL;\r"
"uint toneCount = image.read(gid).r;\r"
"int sq = abs(ind_x - ind_y);\r"
"int left_shift = !!(ind_x - ind_y);\r"
"threadgroup atomic_int  val[16];\r"
"if (lid == 0){\r"
"for (uint i=0;i<16;i++)\r"
"atomic_store_explicit(val + i, 0, memory_order_relaxed);\r"
"}\r"
"threadgroup_barrier(mem_flags::mem_threadgroup);\r"
"\r"
"if (ind_y > ind_x)\r"
"{\r"
"}\r"
"else\r"
"{\r"
"int energy = ((toneCount>>4) * (toneCount>>4) )<< left_shift;\r"
"int contrast = (sq * sq * (toneCount))<< left_shift;\r"
"uint tmp  = (toneCount<<6) / (1.0 + sq*sq);\r"
"int homogeneity = (tmp)<< left_shift;\r"
"int disimilarity = (sq * toneCount )<< left_shift;\r"
"atomic_fetch_add_explicit(val + 0 , energy % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 1 , energy / GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 2 , contrast % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 3 , contrast / GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 4 , homogeneity % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 5 , homogeneity / GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 6 , disimilarity % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 7 , disimilarity / GROUP_OVERFLOW, memory_order_relaxed);\r"
"}\r"
"\r"
"toneCount = max(image.read(gid).r,image.read(uint2(ind_y,ind_x+group*256)).r);\r"
"atomic_fetch_add_explicit(val + 8 ,(toneCount*ind_x) % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 9 ,(toneCount*ind_x) / GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 10 ,(toneCount*ind_x*ind_x) % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 11 ,(toneCount*ind_x*ind_x) / GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 12 ,(toneCount*ind_x*ind_y) % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 13 ,(toneCount*ind_x*ind_y) / GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 14 ,(toneCount*(ind_x+ind_y)) % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(val + 15 ,(toneCount*(ind_x+ind_y)) / GROUP_OVERFLOW, memory_order_relaxed);\r"
"threadgroup_barrier(mem_flags::mem_threadgroup);\r"
"if (lid == 0){\r"
"for (uint i=0;i<8;i++)\r"
"{\r"
"int sq_save = atomic_load_explicit(val + 2*i, memory_order_relaxed);\r"
"int num_save = atomic_load_explicit(val + 2*i + 1, memory_order_relaxed);\r"
"float data = (float)num_save*GROUP_OVERFLOW + (float)sq_save;\r"
"sq_save  = fmod(data,GROUP_OVERFLOW);\r"
"num_save = data / GROUP_OVERFLOW;\r"
"atomic_fetch_add_explicit(feat_group + group*GLCM_GROUP + 2*i ,sq_save,memory_order_relaxed);\r"
"atomic_fetch_add_explicit(feat_group + group*GLCM_GROUP + 2*i + 1 ,num_save,memory_order_relaxed);\r"
"}\r"
"}\r"
"}\r"
"#define FETCH_IMAGE(x,y) (int)(image1.read(uint2(x,y)).r*255)\r"
"kernel void Group_FEATURE_atom(texture2d<float, access::read> image1 [[texture(0)]],\r"
"texture2d<float, access::read> image2 [[texture(1)]],\r"
"device atomic_int *resdata_ti [[buffer(0)]],\r"
"device atomic_int *resdata_si [[buffer(1)]],\r"
"device atomic_int *resdata_blur [[buffer(2)]],\r"
"uint2 gid [[thread_position_in_grid]],\r"
"ushort lid [[thread_index_in_threadgroup]],\r"
"uint2 threads_per_threadgroup  [[threads_per_threadgroup]],\r"
"uint simd_size [[threads_per_simdgroup]],\r"
"uint simd_lane_id [[thread_index_in_simdgroup]],\r"
"uint simd_group_id [[simdgroup_index_in_threadgroup]])\r"
"{\r"
"int x = gid.x;\r"
"int y = gid.y;\r"
"if (NOT_SKIP(x,y))\r"
"{\r"
"int diff1 = (int)(image1.read(gid).r*255) - int(image2.read(gid).r*255);\r"
"atomic_fetch_add_explicit(resdata_ti + lid  , diff1, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(resdata_ti + lid + BLOCKSIZE*BLOCKSIZE, (diff1*diff1) % GROUP_OVERFLOW_TI, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(resdata_ti + lid + BLOCKSIZE*BLOCKSIZE*2, (diff1*diff1) /  GROUP_OVERFLOW_TI, memory_order_relaxed);\r"
"int sum = (int)(image1.read(uint2(x-1,y)).r*255) + (int)(image1.read(uint2(x+1,y)).r*255) +\r"
"(int)(image1.read(uint2(x,y-1)).r*255) + (int)(image1.read(uint2(x,y+1)).r*255);\r"
"int cnt = EQUAL(x,0) + EQUAL(x,image1.get_width()-1) + EQUAL(y,0) + EQUAL(y,image1.get_height()-1);\r"
"int diff3 = cnt*(int)(image1.read(gid).r * 255) -sum;\r"
"atomic_fetch_add_explicit(resdata_blur + lid  , diff3, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(resdata_blur + lid + BLOCKSIZE*BLOCKSIZE, (diff3*diff3) % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(resdata_blur + lid + BLOCKSIZE*BLOCKSIZE*2, (diff3*diff3)/  GROUP_OVERFLOW, memory_order_relaxed);\r"
"}\r"
"if (NOT_SKIP_SI(x,y))\r"
"{\r"
"int sum_ver = FETCH_IMAGE(x-1,y-1) + 2*FETCH_IMAGE(x,y-1) + FETCH_IMAGE(x+1,y-1)\r"
"- FETCH_IMAGE(x-1,y+1) - 2*FETCH_IMAGE(x,y+1) - FETCH_IMAGE(x+1,y+1);\r"
"int sum_hor = FETCH_IMAGE(x-1,y-1) + 2*FETCH_IMAGE(x-1,y) + FETCH_IMAGE(x-1,y+1)\r"
"- FETCH_IMAGE(x+1,y-1) - 2*FETCH_IMAGE(x+1,y) - FETCH_IMAGE(x+1,y+1);\r"
"int diff2 = (int)(sqrt((float)(sum_ver*sum_ver + sum_hor*sum_hor)));\r"
"atomic_fetch_add_explicit(resdata_si + lid  , diff2, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(resdata_si + lid + BLOCKSIZE*BLOCKSIZE, (diff2*diff2) % GROUP_OVERFLOW, memory_order_relaxed);\r"
"atomic_fetch_add_explicit(resdata_si + lid + BLOCKSIZE*BLOCKSIZE*2, (diff2*diff2)/  GROUP_OVERFLOW, memory_order_relaxed);\r"
"}\r"
"}\r"
"constant float3 rgb2y  = float3(0.299f, 0.587f, 0.114f);\r"
"constant float3 rgb2cb = float3(-0.168736f, -0.331264f, 0.5f);\r"
"constant float3 rgb2cr = float3(0.5f, -0.418688f, -0.081312f);\r"
"kernel void rgb2yyuv(texture2d<float, access::read> inTexture [[texture(0)]],\r"
"texture2d<float, access::write> yTexture [[texture(1)]],\r"
"texture2d<float, access::write> uvTexture [[texture(2)]],\r"
"uint2 gid [[thread_position_in_grid]])\r"
"{\r"
"int x = gid.x << 1;\r"
"int y = gid.y << 1;\r"
"uint2 gid_tmp = uint2(x, y);\r"
"float3 rgb00 = inTexture.read(gid_tmp).zyx;\r"
"gid_tmp.x = x + 1;\r"
"float3 rgb01 = inTexture.read(gid_tmp).zyx;\r"
"gid_tmp.y = y + 1;\r"
"float3 rgb11 = inTexture.read(gid_tmp).zyx;\r"
"gid_tmp = uint2(x, y + 1);\r"
"float3 rgb10 = inTexture.read(gid_tmp).zyx;\r"
"float Y00 = dot(rgb00, rgb2y);\r"
"float Y01 = dot(rgb01, rgb2y);\r"
"float Y10 = dot(rgb10, rgb2y);\r"
"float Y11 = dot(rgb11, rgb2y);\r"
"float Cb  = dot(rgb00, rgb2cb) + 0.5f;\r"
"float Cr  = dot(rgb00, rgb2cr) + 0.5f;\r"
"yTexture.write((float4)Y00, uint2(x, y));\r"
"yTexture.write((float4)Y01, uint2(x + 1, y));\r"
"yTexture.write((float4)Y10, uint2(x, y + 1));\r"
"yTexture.write((float4)Y11, uint2(x + 1, y + 1));\r"
"float4 uv = float4(Cb, Cr, 1.f, 1.f);\r"
"uvTexture.write(uv, uint2(x/2, y/2));\r"
"}\r"
"kernel void boxfilter3x3(texture2d<float, access::read> yTexture [[texture(0)]],\r"
"texture2d<float, access::write> yyBlurTexture [[texture(1)]],\r"
"uint2 gid [[thread_position_in_grid]])\r"
"{\r"
"const int dx = gid.x << 1;\r"
"const int dy = gid.y << 1;\r"
"float4 Y0 = {yTexture.read(uint2(dx-1, dy-1)).x,  yTexture.read(uint2(dx, dy-1)).x,\r"
"yTexture.read(uint2(dx+1, dy-1)).x,  yTexture.read(uint2(dx+2, dy-1)).x};\r"
"float4 Y1 = {yTexture.read(uint2(dx-1, dy)).x,  yTexture.read(uint2(dx, dy)).x,\r"
"yTexture.read(uint2(dx+1, dy)).x,  yTexture.read(uint2(dx+2, dy)).x};\r"
"float4 Y2 = {yTexture.read(uint2(dx-1, dy+1)).x,  yTexture.read(uint2(dx, dy+1)).x,\r"
"yTexture.read(uint2(dx+1, dy+1)).x,  yTexture.read(uint2(dx+2, dy+1)).x};\r"
"float4 Y3 = {yTexture.read(uint2(dx-1, dy+2)).x,  yTexture.read(uint2(dx, dy+2)).x,\r"
"yTexture.read(uint2(dx+1, dy+2)).x,  yTexture.read(uint2(dx+2, dy+2)).x};\r"
"float4 sum = 0;\r"
"float4 summ = 0;\r"
"sum.x = Y0.x + Y0.y + Y0.z + Y1.x + Y1.y + Y1.z + Y2.x + Y2.y + Y2.z;\r"
"summ.x = Y0.x * Y0.x + Y0.y * Y0.y + Y0.z * Y0.z + Y1.x * Y1.x + Y1.y * Y1.y  + Y1.z * Y1.z  + Y2.x * Y2.x + Y2.y * Y2.y + Y2.z * Y2.z;\r"
"sum.y = Y0.w + Y0.y + Y0.z + Y1.w + Y1.y + Y1.z + Y2.w + Y2.y + Y2.z;\r"
"summ.y = Y0.w * Y0.w + Y0.y * Y0.y + Y0.z * Y0.z + Y1.w * Y1.w + Y1.y * Y1.y  + Y1.z * Y1.z  + Y2.w * Y2.w + Y2.y * Y2.y + Y2.z * Y2.z;\r"
"sum.z = Y3.x + Y3.y + Y3.z + Y1.x + Y1.y + Y1.z + Y2.x + Y2.y + Y2.z;\r"
"summ.z = Y3.x * Y3.x + Y3.y * Y3.y + Y3.z * Y3.z + Y1.x * Y1.x + Y1.y * Y1.y  + Y1.z * Y1.z  + Y2.x * Y2.x + Y2.y * Y2.y + Y2.z * Y2.z;\r"
"sum.w = Y3.x + Y3.y + Y3.z + Y1.x + Y1.y + Y1.z + Y2.x + Y2.y + Y2.z;\r"
"summ.w = Y3.w * Y3.w + Y3.y * Y3.y + Y3.z * Y3.z + Y1.w * Y1.w + Y1.y * Y1.y  + Y1.z * Y1.z  + Y2.w * Y2.w + Y2.y * Y2.y + Y2.z * Y2.z;\r"
"sum /= 9.0;\r"
"summ /= 9.0;\r"
"float4 yyBlur0 = float4(sum.x, summ.x, 1.f, 1.f);\r"
"float4 yyBlur1 = float4(sum.y, summ.y, 1.f, 1.f);\r"
"float4 yyBlur2 = float4(sum.z, summ.z, 1.f, 1.f);\r"
"float4 yyBlur3 = float4(sum.w, summ.w, 1.f, 1.f);\r"
"yyBlurTexture.write(yyBlur0, uint2(dx, dy));\r"
"yyBlurTexture.write(yyBlur1, uint2(dx+1, dy));\r"
"yyBlurTexture.write(yyBlur2, uint2(dx, dy+1));\r"
"yyBlurTexture.write(yyBlur3, uint2(dx+1, dy+1));\r"
"}\r"
"kernel void yuv2rgb_sharp(texture2d<float, access::read> yTexture [[texture(0)]],\r"
"texture2d<float, access::read> uvTexture [[texture(1)]],\r"
"texture2d<float, access::read> yyBlurTexture [[texture(2)]],\r"
"texture2d<float, access::write> outTexture [[texture(3)]],\r"
"constant float &enh_ratio [[buffer(0)]],\r"
"uint2 gid [[thread_position_in_grid]])\r"
"{\r"
"const int dx = gid.x << 1;\r"
"const int dy = gid.y << 1;\r"
"float2 xx = yyBlurTexture.read(uint2(dx, dy)).rg;\r"
"float2 xx1 = yyBlurTexture.read(uint2(dx + 1, dy)).rg;\r"
"float2 yy = yyBlurTexture.read(uint2(dx, dy+1)).rg;\r"
"float2 yy1 = yyBlurTexture.read(uint2(dx + 1, dy+1)).rg;\r"
"float2 x1 = {xx.r,xx1.r};\r"
"float2 x2 = {xx.g,xx1.g};\r"
"float2 y1 = {yy.r,yy1.r};\r"
"float2 y2 = {yy.g,yy1.g};\r"
"float2 Y0 = {yTexture.read(uint2(dx, dy)).x,  yTexture.read(uint2(dx + 1, dy)).x};\r"
"float2 Y1 = {yTexture.read(uint2(dx, dy+1)).x,  yTexture.read(uint2(dx + 1, dy+1)).x};\r"
"float2 sigma=x2-x1*x1;\r"
"float2 eps2={0.0001378,0.0001378};\r"
"float2 maxdiff={0.778,0.778};\r"
"float2 maxsharp2={0.001542,0.001542};\r"
"float2 diff=Y0-x1;\r"
"float2 diff2=diff*diff;\r"
"float2 maxdiff2=maxdiff*maxdiff;\r"
"float2 alpha={min(maxsharp2.x/(diff2.x+0.0000001),1.0),min(maxsharp2.y/(diff2.y+0.0000001),1.0)};\r"
"float2 residual=(sigma*maxdiff2)/((sigma+eps2)*(maxdiff2+diff2))*diff*alpha*enh_ratio;\r"
"float2 ysharp=Y0+residual;\r"
"Y0=ysharp;\r"
"float2 UV = uvTexture.read(uint2(dx >> 1, dy >> 1)).xy;\r"
"float2 U = {UV.x, UV.x};\r"
"float2 V = {UV.y, UV.y};\r"
"float2 R = Y0 + (float2)1.400f * V - (float2)0.7f;\r"
"float2 G = Y0 - (float2)0.343f * U - (float2)0.711f * V + (float2)0.526f;\r"
"float2 B = Y0 + (float2)1.765f * U - (float2)0.883f;\r"
"float4 out0 = {B.x, G.x, R.x, 1.f};\r"
"float4 out1 = {B.y, G.y, R.y, 1.f};\r"
"outTexture.write(out0, uint2(dx,   dy));\r"
"outTexture.write(out1, uint2(dx + 1, dy));\r"
"sigma=y2-y1*y1;\r"
"eps2={0.0001378,0.0001378};\r"
"maxdiff={0.778,0.778};\r"
"maxsharp2={0.001542,0.001542};\r"
"diff=Y1-y1;\r"
"diff2=diff*diff;\r"
"maxdiff2=maxdiff*maxdiff;\r"
"alpha={min(maxsharp2.x/(diff2.x+0.0000001),1.0),min(maxsharp2.y/(diff2.y+0.0000001),1.0)};\r"
"residual=(sigma*maxdiff2)/((sigma+eps2)*(maxdiff2+diff2))*diff*alpha*enh_ratio;\r"
"ysharp=Y1+residual;\r"
"Y1=ysharp;\r"
"R = Y1 + (float2)1.400f * V - (float2)0.7f;\r"
"G = Y1 - (float2)0.343f * U - (float2)0.711f * V + (float2)0.526f;\r"
"B = Y1 + (float2)1.765f * U - (float2)0.883f;\r"
"out0 = {B.x, G.x, R.x, 1.f};\r"
"out1 = {B.y, G.y, R.y, 1.f};\r"
"outTexture.write(out0, uint2(dx,   dy + 1));\r"
"outTexture.write(out1, uint2(dx + 1, dy + 1));\r"
"}\r"
"kernel void y_sharp(texture2d<float, access::read> yTexture [[texture(0)]],\r"
"texture2d<float, access::write> outTexture [[texture(1)]],\r"
"constant float &enh_ratio [[buffer(0)]],\r"
"uint2 gid [[thread_position_in_grid]])\r"
"{\r"
"const int dx = gid.x << 1;\r"
"const int dy = gid.y << 1;\r"
"float4 Y0 = {yTexture.read(uint2(dx-1, dy-1)).x,  yTexture.read(uint2(dx, dy-1)).x,\r"
"yTexture.read(uint2(dx+1, dy-1)).x,  yTexture.read(uint2(dx+2, dy-1)).x};\r"
"float4 Y1 = {yTexture.read(uint2(dx-1, dy)).x,  yTexture.read(uint2(dx, dy)).x,\r"
"yTexture.read(uint2(dx+1, dy)).x,  yTexture.read(uint2(dx+2, dy)).x};\r"
"float4 Y2 = {yTexture.read(uint2(dx-1, dy+1)).x,  yTexture.read(uint2(dx, dy+1)).x,\r"
"yTexture.read(uint2(dx+1, dy+1)).x,  yTexture.read(uint2(dx+2, dy+1)).x};\r"
"float4 Y3 = {yTexture.read(uint2(dx-1, dy+2)).x,  yTexture.read(uint2(dx, dy+2)).x,\r"
"yTexture.read(uint2(dx+1, dy+2)).x,  yTexture.read(uint2(dx+2, dy+2)).x};\r"
"float3 y00 = {Y0.x,Y0.y,Y0.z};\r"
"float3 y01 = {Y1.x,Y1.y,Y1.z};\r"
"float3 y02 = {Y2.x,Y2.y,Y2.z};\r"
"float x1=(y00.x+y00.y+y00.z+y01.x+y01.y+y01.z+y02.x+y02.y+y02.z)/9.0;\r"
"float x2=(y00.x*y00.x+y00.y*y00.y+y00.z*y00.z+y01.x*y01.x+y01.y*y01.y+y01.z*y01.z+y02.x*y02.x+y02.y*y02.y+y02.z*y02.z)/9.0;\r"
"float sigma=x2-x1*x1;\r"
"float eps2=0.0001378;\r"
"float maxdiff=0.778;\r"
"float maxsharp2=0.001542;\r"
"float y=y01.g;\r"
"float diff=y-x1;\r"
"float diff2=diff*diff;\r"
"float maxdiff2=maxdiff*maxdiff;\r"
"float alpha=min(maxsharp2/(diff2+0.0000001),1.0);\r"
"float residual=(sigma*maxdiff2)/((sigma+eps2)*(maxdiff2+diff2))*diff*alpha*enh_ratio;\r"
"float4 rgb(y+residual,1.0f,1.0f, 1.0f);\r"
"outTexture.write(rgb, uint2(dx-1,   dy-1));\r"
"y00 = {Y0.y,Y0.z,Y0.w};\r"
"y01 = {Y1.y,Y1.z,Y1.w};\r"
"y02 = {Y2.y,Y2.z,Y2.w};\r"
"x1=(y00.x+y00.y+y00.z+y01.x+y01.y+y01.z+y02.x+y02.y+y02.z)/9.0;\r"
"x2=(y00.x*y00.x+y00.y*y00.y+y00.z*y00.z+y01.x*y01.x+y01.y*y01.y+y01.z*y01.z+y02.x*y02.x+y02.y*y02.y+y02.z*y02.z)/9.0;\r"
"sigma=x2-x1*x1;\r"
"eps2=0.0001378;\r"
"maxdiff=0.778;\r"
"maxsharp2=0.001542;\r"
"y=y01.g;\r"
"diff=y-x1;\r"
"diff2=diff*diff;\r"
"maxdiff2=maxdiff*maxdiff;\r"
"alpha=min(maxsharp2/(diff2+0.0000001),1.0);\r"
"residual=(sigma*maxdiff2)/((sigma+eps2)*(maxdiff2+diff2))*diff*alpha*enh_ratio;\r"
"rgb.x=y+residual;\r"
"outTexture.write(rgb, uint2(dx,   dy-1));\r"
"y00 = {Y1.x,Y1.y,Y1.z};\r"
"y01 = {Y2.x,Y2.y,Y2.z};\r"
"y02 = {Y3.x,Y3.y,Y3.z};\r"
"x1=(y00.x+y00.y+y00.z+y01.x+y01.y+y01.z+y02.x+y02.y+y02.z)/9.0;\r"
"x2=(y00.x*y00.x+y00.y*y00.y+y00.z*y00.z+y01.x*y01.x+y01.y*y01.y+y01.z*y01.z+y02.x*y02.x+y02.y*y02.y+y02.z*y02.z)/9.0;\r"
"sigma=x2-x1*x1;\r"
"eps2=0.0001378;\r"
"maxdiff=0.778;\r"
"maxsharp2=0.001542;\r"
"y=y01.g;\r"
"diff=y-x1;\r"
"diff2=diff*diff;\r"
"maxdiff2=maxdiff*maxdiff;\r"
"alpha=min(maxsharp2/(diff2+0.0000001),1.0);\r"
"residual=(sigma*maxdiff2)/((sigma+eps2)*(maxdiff2+diff2))*diff*alpha*enh_ratio;\r"
"rgb.x=y+residual;\r"
"outTexture.write(rgb, uint2(dx-1,   dy));\r"
"y00 = {Y1.y,Y1.z,Y1.w};\r"
"y01 = {Y2.y,Y2.z,Y2.w};\r"
"y02 = {Y3.y,Y3.z,Y3.w};\r"
"x1=(y00.x+y00.y+y00.z+y01.x+y01.y+y01.z+y02.x+y02.y+y02.z)/9.0;\r"
"x2=(y00.x*y00.x+y00.y*y00.y+y00.z*y00.z+y01.x*y01.x+y01.y*y01.y+y01.z*y01.z+y02.x*y02.x+y02.y*y02.y+y02.z*y02.z)/9.0;\r"
"sigma=x2-x1*x1;\r"
"eps2=0.0001378;\r"
"maxdiff=0.778;\r"
"maxsharp2=0.001542;\r"
"y=y01.g;\r"
"diff=y-x1;\r"
"diff2=diff*diff;\r"
"maxdiff2=maxdiff*maxdiff;\r"
"alpha=min(maxsharp2/(diff2+0.0000001),1.0);\r"
"residual=(sigma*maxdiff2)/((sigma+eps2)*(maxdiff2+diff2))*diff*alpha*enh_ratio;\r"
"rgb.x=y+residual;\r"
"outTexture.write(rgb, uint2(dx,   dy));\r"
"}\r"
"kernel void y_copy(texture2d<float, access::read> yTexture [[texture(0)]],\r"
"texture2d<float, access::write> outTexture [[texture(1)]],\r"
"uint2 gid [[thread_position_in_grid]])\r"
"{\r"
"const int dx = gid.x << 1;\r"
"const int dy = gid.y << 1;\r"
"outTexture.write(yTexture.read(uint2(dx-1, dy-1)), uint2(dx-1, dy-1));\r"
"outTexture.write(yTexture.read(uint2(dx-1, dy)), uint2(dx-1, dy));\r"
"outTexture.write(yTexture.read(uint2(dx, dy-1)), uint2(dx, dy-1));\r"
"outTexture.write(yTexture.read(uint2(dx, dy)), uint2(dx, dy));\r"
"}\r"
";\r"
;
